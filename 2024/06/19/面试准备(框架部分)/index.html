<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试准备（框架部分） | Blog-无泪真伤</title><meta name="author" content="无泪真伤"><meta name="copyright" content="无泪真伤"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="面试准备（框架部分）Glide先上其他大牛的博客链接 面试官：简历上最好不要写Glide，不是问源码那么简单 - 掘金 (juejin.cn) Android | 《看完不忘系列》之Glide - 掘金 (juejin.cn) 基础流程开始自己的记录 需要明确的是看其他人的图片加载框架其实就是为了学习如果自己要搭建一个图片加载框架需要做的各个方面的工作 首先看最简单的用法 1234Glide.wi">
<meta property="og:type" content="article">
<meta property="og:title" content="面试准备（框架部分）">
<meta property="og:url" content="https://www.wuleizhenshang.love/2024/06/19/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87(%E6%A1%86%E6%9E%B6%E9%83%A8%E5%88%86)/index.html">
<meta property="og:site_name" content="Blog-无泪真伤">
<meta property="og:description" content="面试准备（框架部分）Glide先上其他大牛的博客链接 面试官：简历上最好不要写Glide，不是问源码那么简单 - 掘金 (juejin.cn) Android | 《看完不忘系列》之Glide - 掘金 (juejin.cn) 基础流程开始自己的记录 需要明确的是看其他人的图片加载框架其实就是为了学习如果自己要搭建一个图片加载框架需要做的各个方面的工作 首先看最简单的用法 1234Glide.wi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/66723b31d9c307b7e9cbf899.jpg">
<meta property="article:published_time" content="2024-06-19T04:33:46.000Z">
<meta property="article:modified_time" content="2024-06-19T01:58:22.169Z">
<meta property="article:author" content="无泪真伤">
<meta property="article:tag" content="其他">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/66723b31d9c307b7e9cbf899.jpg"><link rel="shortcut icon" href="/img/86634.jpg"><link rel="canonical" href="https://www.wuleizhenshang.love/2024/06/19/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87(%E6%A1%86%E6%9E%B6%E9%83%A8%E5%88%86)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 无泪真伤","link":"链接: ","source":"来源: Blog-无泪真伤","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试准备（框架部分）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-19 09:58:22'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/65582252c458853aeff7c6f5.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/66723b31d9c307b7e9cbf899.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog-无泪真伤"><span class="site-name">Blog-无泪真伤</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试准备（框架部分）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-19T04:33:46.000Z" title="发表于 2024-06-19 12:33:46">2024-06-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-19T01:58:22.169Z" title="更新于 2024-06-19 09:58:22">2024-06-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试准备（框架部分）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="面试准备（框架部分）"><a href="#面试准备（框架部分）" class="headerlink" title="面试准备（框架部分）"></a>面试准备（框架部分）</h1><h2 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h2><p><strong>先上其他大牛的博客链接</strong></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903986412126216">面试官：简历上最好不要写Glide，不是问源码那么简单 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6850037281349173261">Android | 《看完不忘系列》之Glide - 掘金 (juejin.cn)</a></p>
<h3 id="基础流程"><a href="#基础流程" class="headerlink" title="基础流程"></a>基础流程</h3><p><strong>开始自己的记录</strong></p>
<p><strong>需要明确的是看其他人的图片加载框架其实就是为了学习如果自己要搭建一个图片加载框架需要做的各个方面的工作</strong></p>
<p>首先看最简单的用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="built_in">this</span>).load(url).into(imageView);</span><br><span class="line"><span class="comment">//with（Context/Activity/Fragment）决定Glide加载图片的生命周期</span></span><br><span class="line"><span class="comment">//load（url）url包括网络图片、本地图片、应用资源、二进制流、Uri对象等等（重载）</span></span><br><span class="line"><span class="comment">//into（imageView）</span></span><br></pre></td></tr></table></figure>

<p>最简单的用法可以看作主干，其实就是三部曲</p>
<p>更进阶一点的用法这里贴出来，当然还有更多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩展功能</span></span><br><span class="line">.placeholder(R.drawable.loading)<span class="comment">//加载图片过程占位符，加载完成会替换占位符</span></span><br><span class="line">.error(R.drawable.error)<span class="comment">//加载图片错误占位符</span></span><br><span class="line">.asGif()/.asBitmap()只显示动态图/只显示静态图（不设置时，Glide会自动判断图片格式）</span><br><span class="line">.diskCacheStrategy(DiskCacheStrategy.NONE)<span class="comment">//禁用Glide缓存机制</span></span><br><span class="line">.override(<span class="number">100</span>, <span class="number">100</span>)<span class="comment">//指定图片大小（Glide会自动判断ImageView的大小，然后将对应的图片像素加载本地，节省内存开支）</span></span><br></pre></td></tr></table></figure>



<p><strong>下面先看三部曲部分</strong></p>
<ul>
<li><strong>with</strong></li>
</ul>
<p>with方法最后得到的一个对象是一个<strong>RequestManager对象</strong>，这个对象是用来管理和启动图片请求的对象。</p>
<p>with传入上下文context决定了图片请求的生命周期</p>
<ol>
<li><p>如果传入Application对象，那么拿到的就是应用级别的RequestManager对象，Application级别的RequestManager对象是一个全局单例，<strong>（并且需要注意到的是，如果在子线程中使用Glide，无论传入的Context对象是什么级别的，最终拿到的也是这个Application级别的RequestManager对象）</strong>，这里是通过<strong>RequestManagerRetriever</strong>去获取全局的RequestManager单例的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RequestManagerRetriever</span> <span class="keyword">implements</span> <span class="title class_">Handler</span>.Callback &#123;</span><br><span class="line">    <span class="keyword">volatile</span> RequestManager applicationManager;</span><br><span class="line">    </span><br><span class="line">    RequestManager <span class="title function_">getApplicationManager</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="comment">//双重检查锁，获取单例的RequestManager</span></span><br><span class="line">        <span class="keyword">if</span> (applicationManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (applicationManager == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">Glide</span> <span class="variable">glide</span> <span class="operator">=</span> Glide.get(context.getApplicationContext());</span><br><span class="line">                    applicationManager = factory.build(glide,<span class="keyword">new</span> <span class="title class_">ApplicationLifecycle</span>(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">EmptyRequestManagerTreeNode</span>(),context.getApplicationContext());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回应用级别的RequestManager单例</span></span><br><span class="line">        <span class="keyword">return</span> applicationManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果传入Activity对象，那么拿到的是页面级别的RequestManager对象，这时候Glide会通过tag在map中寻找当前的Activity是否创建过<strong>SupportRequestManagerFragment</strong>，如果创建过就直接返回这个对象的RequestManager对象，如果没有创建过SupportRequestManagerFragment，那么就会创建一个，并且通过<code> fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</code>将Fragment添加到Activity来感知Activity的生命周期变化（其中fm是FragmentManager），并返回新建的SupportRequestManagerFragment对象的RequestManager对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RequestManagerRetriever</span> <span class="keyword">implements</span> <span class="title class_">Handler</span>.Callback &#123;</span><br><span class="line">    RequestManager <span class="title function_">supportFragmentGet</span><span class="params">(Context context,FragmentManager fm,</span></span><br><span class="line"><span class="params">                                      Fragment parentHint,<span class="type">boolean</span> isParentVisible)</span> &#123;</span><br><span class="line">        <span class="comment">//获取空fragment，无则创建</span></span><br><span class="line">        <span class="type">SupportRequestManagerFragment</span> <span class="variable">current</span> <span class="operator">=</span></span><br><span class="line">            getSupportRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">        <span class="type">RequestManager</span> <span class="variable">requestManager</span> <span class="operator">=</span> current.getRequestManager();</span><br><span class="line">        <span class="keyword">if</span> (requestManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Glide</span> <span class="variable">glide</span> <span class="operator">=</span> Glide.get(context);</span><br><span class="line">            <span class="comment">//如果空fragment没有RequestManager，就创建一个</span></span><br><span class="line">            requestManager = factory.build(glide, current.getGlideLifecycle(), </span><br><span class="line">                                           current.getRequestManagerTreeNode(), context);</span><br><span class="line">            <span class="comment">//让空fragment持有RequestManager</span></span><br><span class="line">            current.setRequestManager(requestManager);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回页面级别的RequestManager</span></span><br><span class="line">        <span class="keyword">return</span> requestManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">class</span> <span class="title class_">RequestManagerRetriever</span> <span class="keyword">implements</span> <span class="title class_">Handler</span>.Callback &#123;</span><br><span class="line">       Map&lt;FragmentManager, SupportRequestManagerFragment&gt; pendingSupportRequestManagerFragments =</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       </span><br><span class="line">       SupportRequestManagerFragment <span class="title function_">getSupportRequestManagerFragment</span><span class="params">(</span></span><br><span class="line"><span class="params">           <span class="keyword">final</span> FragmentManager fm, Fragment parentHint, <span class="type">boolean</span> isParentVisible)</span> &#123;</span><br><span class="line">           <span class="comment">//通过tag找到Activity中的空fragment</span></span><br><span class="line">           <span class="type">SupportRequestManagerFragment</span> <span class="variable">current</span> <span class="operator">=</span></span><br><span class="line">               (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">           <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">//findFragmentByTag没找到空fragment，有可能是延迟问题？再从Map中找一下</span></span><br><span class="line">               current = pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">               <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//确实没有空fragment，就创建一个</span></span><br><span class="line">                   current = <span class="keyword">new</span> <span class="title class_">SupportRequestManagerFragment</span>();</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">                   <span class="comment">//缓存进Map</span></span><br><span class="line">                   pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">                   <span class="comment">//空fragment添加到Activity，使其能感知Activity的生命周期</span></span><br><span class="line">                   fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">                   <span class="comment">//...</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> current;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **load**</span><br><span class="line"></span><br><span class="line">load方法最后得到的是一个RequestBuilder对象，也就是图片请求构建器，with得到的RequestManager可以构建RequestBuilder对象</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RequestManager</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ComponentCallbacks2</span>, LifecycleListener, ModelTypes&lt;RequestBuilder&lt;Drawable&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入口</span></span><br><span class="line">    RequestBuilder&lt;Drawable&gt; <span class="title function_">load</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    RequestBuilder&lt;Drawable&gt; <span class="title function_">asDrawable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//需要加载的类型为Drawable</span></span><br><span class="line">        <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2,走到这里开始构建RequestBuilder，之后回到入口走了RequestBuilder的load(String)方法，接下来看这个方法</span></span><br><span class="line">    &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; <span class="title function_">as</span><span class="params">(Class&lt;ResourceType&gt; resourceClass)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个请求构建器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestBuilder</span>&lt;&gt;(glide, <span class="built_in">this</span>, resourceClass, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RequestBuilder</span>&lt;TranscodeType&gt; <span class="keyword">extends</span> <span class="title class_">BaseRequestOptions</span>&lt;RequestBuilder&lt;TranscodeType&gt;&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Cloneable</span>, ModelTypes&lt;RequestBuilder&lt;TranscodeType&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入口</span></span><br><span class="line">    RequestBuilder&lt;TranscodeType&gt; <span class="title function_">load</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1，这里就可以看到load其实就是进行了赋值，并最终得到的是RequestBuilder&lt;TranscodeType&gt;对象，然后用这个对象的into方法</span></span><br><span class="line">    RequestBuilder&lt;TranscodeType&gt; <span class="title function_">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> &#123;</span><br><span class="line">        <span class="comment">//只是简单地赋值</span></span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">        isModelSet = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>into</strong></li>
</ul>
<p>这里其实就是构建Target包装对象，构建Request发起请求，并且走三级缓存获取图像，网络请求由EnginJob发起，DecodeJob为具体请求，HttpUrlFecth最后执行并获取数据，最后SingleRuest回调到Target，Target加载图片到ImageView</p>
<ol>
<li>先要开始图片请求</li>
</ol>
<p>一开始是先根据传入的ImageView的参数设置一些请求参数，之后返回的是重载的into方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RequestBuilder</span>&lt;TranscodeType&gt; <span class="keyword">extends</span> <span class="title class_">BaseRequestOptions</span>&lt;RequestBuilder&lt;TranscodeType&gt;&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Cloneable</span>, ModelTypes&lt;RequestBuilder&lt;TranscodeType&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title function_">into</span><span class="params">(ImageView view)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        BaseRequestOptions&lt;?&gt; requestOptions = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (!requestOptions.isTransformationSet()</span><br><span class="line">            &amp;&amp; requestOptions.isTransformationAllowed()</span><br><span class="line">            &amp;&amp; view.getScaleType() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根据ImageView的ScaleType，来配置参数</span></span><br><span class="line">            <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">                <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">                    requestOptions = requestOptions.clone().optionalCenterCrop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">                    requestOptions = requestOptions.clone().optionalCenterInside();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> into(</span><br><span class="line">            <span class="comment">//前面提到，Target是展示图片的载体，这里他封装了ImageView</span></span><br><span class="line">            glideContext.buildImageViewTarget(view, transcodeClass),<span class="literal">null</span>,</span><br><span class="line">            requestOptions,Executors.mainThreadExecutor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在重载into方法中，就是要构建具体的<strong>Request</strong>请求了，就是先判断Target载体是否已经有请求，如果之前的请求正在允许就先启动异步请求，如果不存在就为Target绑定图片请求，之后通过前面获取到的RequestManager启动Request请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RequestBuilder</span>&lt;TranscodeType&gt; <span class="keyword">extends</span> <span class="title class_">BaseRequestOptions</span>&lt;RequestBuilder&lt;TranscodeType&gt;&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Cloneable</span>, ModelTypes&lt;RequestBuilder&lt;TranscodeType&gt;&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    &lt;Y <span class="keyword">extends</span> <span class="title class_">Target</span>&lt;TranscodeType&gt;&gt; Y <span class="title function_">into</span><span class="params">(Y target,RequestListener&lt;TranscodeType&gt; targetListener,</span></span><br><span class="line"><span class="params">                                             BaseRequestOptions&lt;?&gt; options,Executor callbackExecutor)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//创建图片请求</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line">        <span class="comment">//获取Target载体已有的请求</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">previous</span> <span class="operator">=</span> target.getRequest();</span><br><span class="line">        <span class="comment">//如果两个请求等效，并且xxx（先忽略）</span></span><br><span class="line">        <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">            &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">                <span class="comment">//启动异步请求</span></span><br><span class="line">                previous.begin();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        requestManager.clear(target);</span><br><span class="line">        <span class="comment">//图片载体绑定图片请求，即imageView setTag为request</span></span><br><span class="line">        target.setRequest(request);</span><br><span class="line">        <span class="comment">//启动异步请求</span></span><br><span class="line">        requestManager.track(target, request);</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code> requestManager.track(target, request);</code>是开启图片请求用的，下面是具体的启动过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RequestManager.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">track</span><span class="params">(Target&lt;?&gt; target,Request request)</span> &#123;</span><br><span class="line">    targetTracker.track(target);</span><br><span class="line">    requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RequestTracker.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">runRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    requests.add(request);</span><br><span class="line">    <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">        <span class="comment">//开启图片请求</span></span><br><span class="line">        request.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request.clear();</span><br><span class="line">        <span class="comment">//如果处于暂停状态，就把请求存起来，晚些处理</span></span><br><span class="line">        pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/15/17351bf3eb65acdb~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"></p>
<p>2. </p>
<p>之后需要关注的就是<code>request.begin()</code>方法了，这个方法里面其实就是先看是否明确了图片的尺寸，不然先去明确尺寸，最后都走到了<code>onSizeReady</code></p>
<p>在<code>onSizeReady</code>中就通过<code> engine.load()</code>（这里传了很多参数给load方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> <span class="keyword">implements</span> <span class="title class_">EngineJobListener</span>,MemoryCache.ResourceRemovedListener,</span><br><span class="line">EngineResource.ResourceListener &#123;</span><br><span class="line"></span><br><span class="line">    &lt;R&gt; LoadStatus <span class="title function_">load</span><span class="params">(</span></span><br><span class="line"><span class="params">        GlideContext glideContext,</span></span><br><span class="line"><span class="params">        //...</span></span><br><span class="line"><span class="params">        Executor callbackExecutor)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        EngineResource&lt;?&gt; memoryResource;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">//从内存加载</span></span><br><span class="line">            memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line">            <span class="keyword">if</span> (memoryResource == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果内存里没有缓存，则加载</span></span><br><span class="line">                <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">                    glideContext,</span><br><span class="line">                    model,</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    key,</span><br><span class="line">                    startTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;R&gt; LoadStatus <span class="title function_">waitForExistingOrStartNewJob</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        EngineJob&lt;R&gt; engineJob =engineJobFactory.build(...);</span><br><span class="line">        DecodeJob&lt;R&gt; decodeJob =decodeJobFactory.build(...);</span><br><span class="line">        jobs.put(key, engineJob);</span><br><span class="line">        <span class="comment">//添加回调，这个cb就是SingleRequest自己，todo1</span></span><br><span class="line">        engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">        <span class="comment">//engineJob开启decodeJob</span></span><br><span class="line">        engineJob.start(decodeJob);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoadStatus</span>(cb, engineJob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后如果内存中没有就要走到<code>waitForExistingOrStartNewJob</code>，最后是<code>engineJob.start(decodeJob);</code>，这里的<strong>EngineJob</strong>是负责最后的网络请求的，这里调用链是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DecodeJob.run -&gt; DecodeJob.runWrapped -&gt; DecodeJob.runGenerators -&gt;</span><br><span class="line"></span><br><span class="line">SourceGenerator.startNext -&gt; SourceGenerator.startNextLoad -&gt;</span><br><span class="line"></span><br><span class="line">MultiModelLoader#MultiFetcher.loadData -&gt;</span><br><span class="line"></span><br><span class="line">HttpUrlFetcher.loadData</span><br></pre></td></tr></table></figure>

<p>最后走到了<code>HttpUrlFetcher.loadData</code>，最后通过<code>    callback.onDataReady(result);</code>回调出去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HttpUrlFetcher</span> <span class="keyword">implements</span> <span class="title class_">DataFetcher</span>&lt;InputStream&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">loadData</span><span class="params">(Priority priority, DataCallback&lt;? <span class="built_in">super</span> InputStream&gt; callback)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取输入流，没有引入okhttp，则使用HttpURLConnection</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">result</span> <span class="operator">=</span> loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="literal">null</span>, glideUrl.getHeaders());</span><br><span class="line">            <span class="comment">//回调出去</span></span><br><span class="line">            callback.onDataReady(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            callback.onLoadFailed(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的callback是<strong>SingleRequest</strong>，当然result还需要做各种解码等等工作，最后看到<code>SingleRequest</code>，这里面最后走到了<code> target.onResourceReady(result, animation);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleRequest</span>&lt;R&gt; <span class="keyword">implements</span> <span class="title class_">Request</span>, SizeReadyCallback, ResourceCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onResourceReady</span><span class="params">(Resource&lt;?&gt; resource, DataSource dataSource)</span> &#123;</span><br><span class="line">        Resource&lt;?&gt; toRelease = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">received</span> <span class="operator">=</span> resource.get();</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="comment">//这里</span></span><br><span class="line">                onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (toRelease != <span class="literal">null</span>) &#123;</span><br><span class="line">                engine.release(toRelease);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, R result, DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//这里，回调给Target载体</span></span><br><span class="line">            target.onResourceReady(result, animation);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        notifyLoadSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的<code> target.onResourceReady(result, animation);</code>走到<code>DrawableImageViewTarget</code>，就是将图片设置出去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DrawableImageViewTarget</span> <span class="keyword">extends</span> <span class="title class_">ImageViewTarget</span>&lt;Drawable&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setResource</span><span class="params">(Drawable resource)</span> &#123;</span><br><span class="line">        <span class="comment">//ImageView设置图片</span></span><br><span class="line">        view.setImageDrawable(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>最后into的两个阶段的解析图就是如下</strong></p>
<p> <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/15/17351bf3f60f7634~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"></p>
<h3 id="三级缓存细节"><a href="#三级缓存细节" class="headerlink" title="三级缓存细节"></a>三级缓存细节</h3><p><strong>这里所说的三级缓存是内存缓存、硬盘缓存、网络</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200629211828127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0MTg5NDM=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>EngineResource的acquired变量记录使用的位置的数量，调用<code>acquire()</code>方法会让变量+1，调用<code>release()</code>方法会让变量-1</strong></p>
<ul>
<li><p><strong>内存缓存</strong></p>
<ol>
<li><p><strong>弱引用</strong></p>
<p>弱引用是由一个HashMap维护，key是缓存的key（这个key由图片url、width、heigjt等10来个参数组成）value是图片资源对象的弱引用类型<code>Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = new HashMap&lt;&gt;();</code></p>
<p>提高效率）弱引用使用的是HashMap，而LruCache采用的是LinkedHashMap，从访问效率而言，肯定是HashMap更高；（分压策略）减少LruCache中的trimToSize的概率，同一张图片不会同时出现在弱引用和LruCache中，正在引用的放到弱引用中，减少了LruCache中存放的数量</p>
</li>
<li><p><strong>LruCache</strong></p>
<p>Glide使用的内存缓存<code>LruCache</code>，不过并不是Android SDK中的**<code>LruCache</code>**，不过内部也是基于LinkHashMap(<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/linkedhashmap-source-code.html">LinkedHashMap 源码分析 | JavaGuide</a>）</p>
<p>可以先了解LinkHashMap，之后再了解Glide的LruCache的算法设计，这里的算法设计是<strong>最近最少使用算法</strong>，也就是需要移除的时候将最老的数据移除（达到缓存大小回收）</p>
<p>其中LinkHashMap的Entry也就是表对象如下，就是继承了HashMap，本质也是数组+链表的组合，就是重写了<code>createEntry</code>方法，创建的Entry变成了如下的结构，也就是所有的节点都能连在一起，是一个双向链表的形式，结构可以看下面的图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMapEntry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMapEntry</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// These fields comprise the doubly linked list used for iteration.</span></span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; before, after; <span class="comment">//双向链表</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        before.after = after;</span><br><span class="line">        after.before = before;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addBefore</span><span class="params">(LinkedHashMapEntry&lt;K,V&gt; existingEntry)</span> &#123;</span><br><span class="line">        after  = existingEntry;</span><br><span class="line">        before = existingEntry.before;</span><br><span class="line">        before.after = <span class="built_in">this</span>;</span><br><span class="line">        after.before = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么<strong>链表头节点header的before是最新访问的数据，header的after则是最旧的数据</strong>。这样在回收的时候就回收header的after即可，调用remove方法改变指针即可，要添加图片就在before前面添加即可，调用addBofore方法添加</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/3/16e3183d9e907230~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="LinkedHashMap"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addBefore</span><span class="params">(LinkedHashMapEntry&lt;K,V&gt; existingEntry)</span> &#123;</span><br><span class="line">        after  = existingEntry;</span><br><span class="line">        before = existingEntry.before;</span><br><span class="line">        before.after = <span class="built_in">this</span>;</span><br><span class="line">        after.before = <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        before.after = after;</span><br><span class="line">        after.before = before;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>LruCache有个trimToSize方法用来移除最老的数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//大小没有超出，不处理</span></span><br><span class="line">            <span class="keyword">if</span> (size &lt;= maxSize) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//超出大小，移除最老的数据</span></span><br><span class="line">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</span><br><span class="line">            <span class="keyword">if</span> (toEvict == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key = toEvict.getKey();</span><br><span class="line">            value = toEvict.getValue();</span><br><span class="line">            map.remove(key);</span><br><span class="line">            <span class="comment">//这个大小的计算，safeSizeOf 默认返回1；</span></span><br><span class="line">            size -= safeSizeOf(key, value);</span><br><span class="line">            evictionCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        entryRemoved(<span class="literal">true</span>, key, value, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>磁盘缓存</strong></p>
<p>DiskLruCache跟LruCache的思路差不多，一样是设置一个总大小，每次往磁盘写文件，总大小超过阈值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DiskLruCache 内部也是用LinkedHashMap</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries =</span><br><span class="line">      	<span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, Entry&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	    checkNotClosed();</span><br><span class="line">	    validateKey(key);</span><br><span class="line">	    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> lruEntries.get(key);</span><br><span class="line">	    <span class="keyword">if</span> (entry == <span class="literal">null</span> || entry.currentEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">	      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">            <span class="comment">//一个key可能对应多个value，hash冲突的情况</span></span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">	      <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> entry.getCleanFile(i);</span><br><span class="line">            <span class="comment">//通过 file.delete() 删除缓存文件，删除失败则抛异常</span></span><br><span class="line">	      <span class="keyword">if</span> (file.exists() &amp;&amp; !file.delete()) &#123;</span><br><span class="line">	        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;failed to delete &quot;</span> + file);</span><br><span class="line">	      &#125;</span><br><span class="line">	      size -= entry.lengths[i];</span><br><span class="line">	      entry.lengths[i] = <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    ...</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 DiskLruCache 同样是利用LinkHashMap的特点，只不过数组里面存的 Entry 有点变化，Editor 用于操作文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span>[] lengths;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> readable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Editor currentEditor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> sequenceNumber;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>网络部分</strong></p>
</li>
</ul>
<h3 id="线程池细节"><a href="#线程池细节" class="headerlink" title="线程池细节"></a>线程池细节</h3><h3 id="避免OOM和内存移除细节"><a href="#避免OOM和内存移除细节" class="headerlink" title="避免OOM和内存移除细节"></a>避免OOM和内存移除细节</h3><ul>
<li><p><strong>软引用</strong></p>
<p>强引用： 普通变量都属于强引用，比如 private Context context;<br>软应用： SoftReference，在发生OOM之前，垃圾回收器会回收SoftReference引用的对象。<br>弱引用： WeakReference，发生GC的时候，垃圾回收器会回收WeakReference中的对象。<br>虚引用： 随时会被回收，没有使用场景。</p>
<p>（强引用对象的回收时机依赖垃圾回收算法，我们常说的可达性分析算法，当Activity销毁的时候，Activity会跟GCRoot断开，至于GCRoot是谁？这里可以大胆猜想，Activity对象的创建是在ActivityThread中，ActivityThread要回调Activity的各个生命周期，肯定是持有Activity引用的，那么这个GCRoot可以认为就是ActivityThread，当Activity 执行onDestroy的时候，ActivityThread 就会断开跟这个Activity的联系，Activity到GCRoot不可达，所以会被垃圾回收器标记为可回收对象。）</p>
<p>存不足时软引用中的Bitmap被回收的时候，这个LruCache就形同虚设，相当于内存缓存失效了，必然出现效率问题</p>
</li>
<li><p><strong>onLowMemory</strong></p>
<p>当内存不足的时候，Activity、Fragment会调用onLowMemory方法，可以在这个方法里去清除缓存，Glide使用的就是这一种方式来防止OOM。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Glide</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLowMemory</span><span class="params">()</span> &#123;</span><br><span class="line">    clearMemory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearMemory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Engine asserts this anyway when removing resources, fail faster and consistently</span></span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    <span class="comment">// memory cache needs to be cleared before bitmap pool to clear re-pooled Bitmaps too. See #687.</span></span><br><span class="line">    memoryCache.clearMemory();</span><br><span class="line">    bitmapPool.clearMemory();</span><br><span class="line">    arrayPool.clearMemory();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从Bitmap 像素存储位置考虑</strong></p>
<p>占用内存由像素大小和宽高影响</p>
<p>Bitmap不同的格式，一个像素占用的大小不一样，如果Bitmap使用 RGB_565 格式，则1像素占用 2 byte，ARGB_8888 格式则占4 byte。<br>在选择图片加载框架的时候，可以将内存占用这一方面考虑进去，更少的内存占用意味着发生OOM的概率越低。 Glide内存开销是Picasso的一半，就是因为默认Bitmap格式不同。<strong>（Glide默认的bitmap格式为RGB_565，Picasso默认的bitmap格式为ARGB_8888）</strong></p>
<p>至于宽高，是指Bitmap的宽高，如果 BitmapFactory.Options 中指定 inJustDecodeBounds 为true，则为原图宽高，如果是false，则是缩放后的宽高。所以我们一般可以通过压缩来减小Bitmap像素占用内存。</p>
<p>8.0 的Bitmap创建就两个点：</p>
<ol>
<li>创建native层Bitmap，在native堆申请内存。</li>
<li>通过JNI创建java层Bitmap对象，这个对象在java堆中分配内存。</li>
</ol>
<p>7.0 像素内存的分配是这样的：</p>
<p>通过JNI调用java层创建一个数组<br>然后创建native层Bitmap，把数组的地址传进去。<br>由此说明，7.0 的Bitmap像素数据是放在java堆的。</p>
<p>当然，3.0 以下Bitmap像素内存据说也是放在native堆的，但是需要手动释放native层的Bitmap，也就是需要手动调用recycle方法，native层内存才会被回收。这个大家可以自己去看源码验证。</p>
<p>native层Bitmap 回收问题<br>Java层的Bitmap对象由垃圾回收器自动回收，而native层Bitmap印象中我们是不需要手动回收的，源码中如何处理的呢？</p>
<p>记得有个面试题是这样的：</p>
<p>说说final、finally、finalize 的关系</p>
<p>三者除了长得像，其实没有半毛钱关系，final、finally大家都用的比较多，而 finalize 用的少，或者没用过，finalize 是 Object 类的一个方法，垃圾回收器确认这个对象没有其它地方引用到它的时候，会调用这个对象的finalize方法，子类可以重写这个方法，做一些释放资源的操作。</p>
<p>在6.0以前，Bitmap 就是通过这个finalize 方法来释放native层对象的。</p>
</li>
<li><p><strong>内存泄露问题</strong></p>
<p>Glide在with中传入的是具有生命周期的作用域（非Application作用域），尽量避免使用Application作用域，因为Application作用域不会对页面绑定生命周期机制，就会回收不及时释放操作等，也别持有ImageView等等，最简单将ImageView用WeakReference修饰就完事了，但不完美，最完美就是上面Glide的生命周期方案了。</p>
</li>
</ul>
<h3 id="一些对比"><a href="#一些对比" class="headerlink" title="一些对比"></a>一些对比</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903974479331342">图片加载框架思考与理解 - 掘金 (juejin.cn)</a></p>
<p><strong>Glide和Picasso</strong></p>
<ol>
<li><p>with参数</p>
<p><img src="https://images2015.cnblogs.com/blog/1100100/201702/1100100-20170227103142501-178119769.jpg" alt="img"></p>
</li>
<li><p>图片质量不同</p>
<p>Glide默认的bitmap格式为RGB_565</p>
<p>Picasso默认的bitmap格式为ARGB_8888</p>
</li>
<li><p>加载Gif图不同</p>
<p>Glide的一个明显的优点就是它可以加载gif图片，用Picasso加载的gif图片是不会动的</p>
<p>因为Glide被设计成能和Activity&#x2F;Fragment的生命周期完美的相结合，因此gif动画将随着Activity&#x2F;Fragment的生命周期自动的开始和停止。</p>
<p>gif的缓存和一般的图片也是一样的，也是第一次加载的时候调整大小，然后缓存。</p>
</li>
<li><p>缓存策略和加载速度</p>
<p>Picasso的缓存是全尺寸的,而Glide的缓存根据ImageView的尺寸相同</p>
<p>将ImageView调整成不同的大小,不管大小如何,Picasso值缓存一个全尺寸的,Picasso则需要在显示前重新调整大小而导致一下延迟.</p>
<p>而Glide不同,它会为每种大小尺寸缓存一下,加载速度比Picasso更快,磁盘策略比Picasso更好,但需要更大的空间来缓存,Glide比Picasso更有利于减少OOM的发生</p>
</li>
</ol>
<p>**Glide和Fresco **</p>
<p>Fresco 之所以能跟Glide 正面交锋，必然有其独特之处，文中开头列出 Fresco 的优点是：“在5.0以下(最低2.3)系统，Fresco将图片放到一个特别的内存区域(Ashmem区)” 这个Ashmem区是一块匿名共享内存，Fresco 将Bitmap像素放到共享内存去了，共享内存是属于native堆内存。</p>
<p>Fresco 关键源码在 PlatformDecoderFactory 这个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlatformDecoderFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Provide the implementation of the PlatformDecoder for the current platform using the provided</span></span><br><span class="line"><span class="comment">   * PoolFactory</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> poolFactory The PoolFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> The PlatformDecoder implementation</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> PlatformDecoder <span class="title function_">buildPlatformDecoder</span><span class="params">(</span></span><br><span class="line"><span class="params">      PoolFactory poolFactory, <span class="type">boolean</span> gingerbreadDecoderEnabled)</span> &#123;</span><br><span class="line">    <span class="comment">//8.0 以上用 OreoDecoder 这个解码器</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">maxNumThreads</span> <span class="operator">=</span> poolFactory.getFlexByteArrayPoolMaxNumThreads();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OreoDecoder</span>(</span><br><span class="line">          poolFactory.getBitmapPool(), maxNumThreads, <span class="keyword">new</span> <span class="title class_">Pools</span>.SynchronizedPool&lt;&gt;(maxNumThreads));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">      <span class="comment">//大于5.0小于8.0用 ArtDecoder 解码器</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">maxNumThreads</span> <span class="operator">=</span> poolFactory.getFlexByteArrayPoolMaxNumThreads();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArtDecoder</span>(</span><br><span class="line">          poolFactory.getBitmapPool(), maxNumThreads, <span class="keyword">new</span> <span class="title class_">Pools</span>.SynchronizedPool&lt;&gt;(maxNumThreads));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (gingerbreadDecoderEnabled &amp;&amp; Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        <span class="comment">//小于4.4 用 GingerbreadPurgeableDecoder 解码器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GingerbreadPurgeableDecoder</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这个就是4.4到5.0 用的解码器了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KitKatPurgeableDecoder</span>(poolFactory.getFlexByteArrayPool());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.0 先不看了，看一下 4.4 以下是怎么得到Bitmap的，看下GingerbreadPurgeableDecoder这个类有个获取Bitmap的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GingerbreadPurgeableDecoder</span></span><br><span class="line"><span class="keyword">private</span> Bitmap <span class="title function_">decodeFileDescriptorAsPurgeable</span><span class="params">(</span></span><br><span class="line"><span class="params">      CloseableReference&lt;PooledByteBuffer&gt; bytesRef,</span></span><br><span class="line"><span class="params">      <span class="type">int</span> inputLength,</span></span><br><span class="line"><span class="params">      <span class="type">byte</span>[] suffix,</span></span><br><span class="line"><span class="params">      BitmapFactory.Options options)</span> &#123;</span><br><span class="line">    <span class="comment">//  MemoryFile ：匿名共享内存</span></span><br><span class="line">    <span class="type">MemoryFile</span> <span class="variable">memoryFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//将图片数据拷贝到匿名共享内存</span></span><br><span class="line">      memoryFile = copyToMemoryFile(bytesRef, inputLength, suffix);</span><br><span class="line">      <span class="type">FileDescriptor</span> <span class="variable">fd</span> <span class="operator">=</span> getMemoryFileDescriptor(memoryFile);</span><br><span class="line">      <span class="keyword">if</span> (mWebpBitmapFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建Bitmap，Fresco自己写了一套创建Bitmap方法</span></span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> mWebpBitmapFactory.decodeFileDescriptor(fd, <span class="literal">null</span>, options);</span><br><span class="line">        <span class="keyword">return</span> Preconditions.checkNotNull(bitmap, <span class="string">&quot;BitmapFactory returned null&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;WebpBitmapFactory is null&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>捋一捋，4.4以下，Fresco 使用匿名共享内存来保存Bitmap数据，首先将图片数据拷贝到匿名共享内存中，然后使用Fresco自己写的加载Bitmap的方法。</p>
<p>Fresco对不同Android版本使用不同的方式去加载Bitmap，至于4.4-5.0，5.0-8.0，8.0 以上，对应另外三个解码器，大家可以从PlatformDecoderFactory 这个类入手，自己去分析，思考为什么不同平台要分这么多个解码器，8.0 以下都用匿名共享内存不好吗？期待你在评论区跟大家分享~</p>
<h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p><img src="https://img-blog.csdnimg.cn/20190522191648150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p>
<p><a href="#OkHttp使用和工作原理">OkHttp使用和工作原理</a></p>
<p><a href="#OkHttp设计模式">设计模式</a></p>
<p><a href="#OkHttp源码解读">OkHttp源码解读</a></p>
<p><a id="OkHttp使用和工作原理"></a></p>
<ul>
<li><p><strong>使用和工作原理</strong></p>
<p>首先是OkHttpClient</p>
<p>（官方建议使用单例创建OkHttpClient，即一个进程中只创建一次即可，以后的每次交易都使用该实例发送交易。这是因为OkHttpClient拥有自己的连接池和线程池，这些连接池和线程池可以重复使用，这样做利于减少延迟和节省内存。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OkHttpClient的构造采用了建造者模式</span></span><br><span class="line">mOkHttpClient = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                            .addInterceptor(loggingInterceptor)</span><br><span class="line">                            .retryOnConnectionFailure(<span class="literal">true</span>)</span><br><span class="line">                            .connectTimeout(TIME_OUT, TimeUnit.SECONDS)</span><br><span class="line">                            .readTimeout(TIME_OUT, TimeUnit.SECONDS)</span><br><span class="line">                            .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Dispatcher dispatcher;<span class="comment">//调度器</span></span><br><span class="line">   <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">   Proxy proxy;<span class="comment">//代理</span></span><br><span class="line">   <span class="keyword">final</span> List&lt;Protocol&gt; protocols;<span class="comment">//协议</span></span><br><span class="line">   <span class="keyword">final</span> List&lt;ConnectionSpec&gt; connectionSpecs;<span class="comment">//传输层版本和连接协议</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors;<span class="comment">//拦截器</span></span><br><span class="line">   <span class="keyword">final</span> List&lt;Interceptor&gt; networkInterceptors;<span class="comment">//网络拦截器</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">final</span> EventListener.Factory eventListenerFactory;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">final</span> ProxySelector proxySelector;<span class="comment">//代理选择器</span></span><br><span class="line">   <span class="keyword">final</span> CookieJar cookieJar;<span class="comment">//cookie</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">   Cache cache;<span class="comment">//cache 缓存</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">   InternalCache internalCache;<span class="comment">//内部缓存</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">final</span> SocketFactory socketFactory;<span class="comment">//socket 工厂</span></span><br><span class="line">   <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">   SSLSocketFactory sslSocketFactory;<span class="comment">//安全套层socket工厂 用于https</span></span><br><span class="line">   <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">   CertificateChainCleaner certificateChainCleaner;<span class="comment">//验证确认响应书，适用HTTPS 请求连接的主机名</span></span><br><span class="line">   <span class="keyword">final</span> HostnameVerifier hostnameVerifier;<span class="comment">//主机名字确认</span></span><br><span class="line">   <span class="keyword">final</span> CertificatePinner certificatePinner;<span class="comment">//证书链</span></span><br><span class="line">   <span class="keyword">final</span> Authenticator proxyAuthenticator;<span class="comment">//代理身份验证</span></span><br><span class="line">   <span class="keyword">final</span> Authenticator authenticator;<span class="comment">//本地省份验证</span></span><br><span class="line">   <span class="keyword">final</span> ConnectionPool connectionPool;<span class="comment">//链接池 复用连接</span></span><br><span class="line">   <span class="keyword">final</span> Dns dns; <span class="comment">//域名</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">boolean</span> followSslRedirects;<span class="comment">//安全套接层重定向</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">boolean</span> followRedirects;<span class="comment">//本地重定向</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">boolean</span> retryOnConnectionFailure;<span class="comment">//重试连接失败</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> connectTimeout;<span class="comment">//连接超时</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> readTimeout;<span class="comment">//读取超时</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> writeTimeout;<span class="comment">//写入超时</span></span><br></pre></td></tr></table></figure>

<p>其次是Request</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">//Request中包含客户请求的参数：url、method、headers、requestBody和tag，也采用了建造者模式。</span></span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Call其实是RealCall，其中主要方法是①同步请求：client.newCall(request).execute；②异步请求：client.newCall(request).enqueue（常用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    Call <span class="title function_">newCall</span><span class="params">(Request request)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.newRealCall(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RealCall.java</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO 不能重复执行</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">      executed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//TODO 交给 dispatcher调度器 进行调度</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> <span class="title class_">AsyncCall</span>(responseCallback));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*这里synchronized (this) 确保每个call只能被执行一次不能重复执行，之后Dispatcher 调度器 将 Call 加入队列，并通过线程池执行 Call，在上面的OkHttpClient就已经初始化了Dispatcher*/</span></span><br></pre></td></tr></table></figure>

<p>下面就是Dispatcher了，具体结构原理在后面享学课堂部分写到了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher的属性和方法</span></span><br><span class="line"><span class="comment">//TODO 同时能进行的最大请求数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequests</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">   <span class="comment">//TODO 同时请求的相同HOST的最大个数 SCHEME :// HOST [ &quot;:&quot; PORT ] [ PATH [ &quot;?&quot; QUERY ]]</span></span><br><span class="line">   <span class="comment">//TODO 如 https://restapi.amap.com  restapi.amap.com - host</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequestsPerHost</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Ready async calls in the order they&#x27;ll be run.</span></span><br><span class="line"><span class="comment">    * TODO 双端队列，支持首尾两端 双向开口可进可出，方便移除</span></span><br><span class="line"><span class="comment">    * 异步等待队列</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet.</span></span><br><span class="line"><span class="comment">    * TODO 正在进行的异步队列</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 执行异步请求</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(AsyncCall call)</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 同时请求不能超过并发数(64,可配置调度器调整)</span></span><br><span class="line">        <span class="comment">//TODO okhttp会使用共享主机即 地址相同的会共享socket</span></span><br><span class="line">        <span class="comment">//TODO 同一个host最多允许5条线程通知执行请求</span></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp;</span><br><span class="line">                runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">            <span class="comment">//TODO 加入运行队列 并交给线程池执行</span></span><br><span class="line">            runningAsyncCalls.add(call);</span><br><span class="line">            <span class="comment">//TODO AsyncCall 是一个runnable，放到线程池中去执行，查看其execute实现</span></span><br><span class="line">            executorService().execute(call);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//TODO 加入等候队列</span></span><br><span class="line">            readyAsyncCalls.add(call);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*可见Dispatcher将Call加入队列中（若同时请求数未超过最大值，则加入运行队列，放到线程池中执行；否则加入等待队列），然后通过线程池执行call。*/</span></span><br></pre></td></tr></table></figure>

<p>executorService() 本质上是一个线程池执行方法，用于创建一个线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title function_">executorService</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (executorService == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//TODO 线程池的相关概念 需要理解</span></span><br><span class="line">           <span class="comment">//TODO 核心线程 最大线程 非核心线程闲置60秒回收 任务队列</span></span><br><span class="line">           executorService = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                   <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>,</span><br><span class="line">                   <span class="literal">false</span>));</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">/*使用的是SynchronousQueue作为运行队列，有请求进来就创建线程去执行，这才满足网络请求的要求，高并发并按顺序进行请求*/</span></span><br><span class="line">       <span class="keyword">return</span> executorService;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>加入线程池中的Call实际是AsyncCall，继承自NamedRunnable类，而NamedRunnable实现Runnable接口，线程池中执行execute()其实就是执行AsyncCall的execute()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AsyncCall</span> <span class="keyword">extends</span> <span class="title class_">NamedRunnable</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">signalledCallback</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//TODO 责任链模式</span></span><br><span class="line">       <span class="comment">//TODO 拦截器链  执行请求</span></span><br><span class="line">       <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> getResponseWithInterceptorChain();</span><br><span class="line">       <span class="comment">//回调结果</span></span><br><span class="line">       <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">         signalledCallback = <span class="literal">true</span>;</span><br><span class="line">         responseCallback.onFailure(RealCall.<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         signalledCallback = <span class="literal">true</span>;</span><br><span class="line">         responseCallback.onResponse(RealCall.<span class="built_in">this</span>, response);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">         <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">         Platform.get().log(INFO, <span class="string">&quot;Callback failure for &quot;</span> + toLoggableString(), e);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         eventListener.callFailed(RealCall.<span class="built_in">this</span>, e);</span><br><span class="line">         responseCallback.onFailure(RealCall.<span class="built_in">this</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//TODO 移除队列</span></span><br><span class="line">       client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>下面就是拦截器的部分了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 核心代码 开始真正的执行网络请求</span></span><br><span class="line">  Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="comment">//TODO 责任链</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//TODO 在配置okhttpClient 时设置的intercept 由用户自己设置</span></span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//TODO 负责处理失败后的重试与重定向</span></span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    <span class="comment">//TODO 负责把用户构造的请求转换为发送到服务器的请求 、把服务器返回的响应转换为用户友好的响应 处理 配置请求头等信息</span></span><br><span class="line">    <span class="comment">//TODO 从应用程序代码到网络代码的桥梁。首先，它根据用户请求构建网络请求。然后它继续呼叫网络。最后，它根据网络响应构建用户响应。</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));</span><br><span class="line">    <span class="comment">//TODO 处理 缓存配置 根据条件(存在响应缓存并被设置为不变的或者响应在有效期内)返回缓存响应</span></span><br><span class="line">    <span class="comment">//TODO 设置请求头(If-None-Match、If-Modified-Since等) 服务器可能返回304(未修改)</span></span><br><span class="line">    <span class="comment">//TODO 可配置用户自己设置的缓存拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));</span><br><span class="line">    <span class="comment">//TODO 连接服务器 负责和服务器建立连接 这里才是真正的请求网络</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      <span class="comment">//TODO 配置okhttpClient 时设置的networkInterceptors</span></span><br><span class="line">      <span class="comment">//TODO 返回观察单个网络请求和响应的不可变拦截器列表。</span></span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 执行流操作(写出请求体、获得响应数据) 负责向服务器发送请求数据、从服务器读取响应数据</span></span><br><span class="line">    <span class="comment">//TODO 进行http请求报文的封装与请求报文的解析</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 创建责任链</span></span><br><span class="line">    Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="built_in">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 执行责任链</span></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>后面是根据责任链的设计模式，按照责任链去递归执行拦截器，当责任链执行完毕，如果拦截器想要拿到最终的数据做其他的逻辑处理等，这样就不用在做其他的调用方法逻辑了，直接在当前的拦截器就可以拿到最终的数据。这也是okhttp设计的最优雅最核心的功能。周执行调度器完成方法，移除队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="type">boolean</span> promoteCalls)</span> &#123;</span><br><span class="line">        <span class="type">int</span> runningCallsCount;</span><br><span class="line">        Runnable idleCallback;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">//TODO calls 移除队列</span></span><br><span class="line">            <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>);</span><br><span class="line">            <span class="comment">//TODO 检查是否为异步请求，检查等候的队列 readyAsyncCalls，如果存在等候队列，则将等候队列加入执行队列</span></span><br><span class="line">            <span class="keyword">if</span> (promoteCalls) promoteCalls();</span><br><span class="line">            <span class="comment">//TODO 运行队列的数量</span></span><br><span class="line">            runningCallsCount = runningCallsCount();</span><br><span class="line">            idleCallback = <span class="built_in">this</span>.idleCallback;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//闲置调用</span></span><br><span class="line">        <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            idleCallback.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">promoteCalls</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 检查 运行队列 与 等待队列</span></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">        <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 将等待队列加入到运行队列中</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            <span class="type">AsyncCall</span> <span class="variable">call</span> <span class="operator">=</span> i.next();</span><br><span class="line">            <span class="comment">//TODO  相同host的请求没有达到最大，加入运行队列</span></span><br><span class="line">            <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">                i.remove();</span><br><span class="line">                runningAsyncCalls.add(call);</span><br><span class="line">                executorService().execute(call);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 同步执行请求 直接返回一个请求的结果</span></span><br><span class="line"><span class="comment">/*同步请求就直接交给调度器将Call加入执行队列，然后通过拦截器链通过责任链模式真正进行网络请求，之后完成后移除队列*/</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">      executed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    <span class="comment">//TODO 调用监听的开始方法</span></span><br><span class="line">    eventListener.callStart(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//TODO 交给调度器去执行</span></span><br><span class="line">      client.dispatcher().executed(<span class="built_in">this</span>);</span><br><span class="line">      <span class="comment">//TODO 获取请求的返回数据</span></span><br><span class="line">      <span class="type">Response</span> <span class="variable">result</span> <span class="operator">=</span> getResponseWithInterceptorChain();<span class="comment">//这里就是责任链的开始部分</span></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      eventListener.callFailed(<span class="built_in">this</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//TODO 执行调度器的完成方法 移除队列</span></span><br><span class="line">      client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​		</p>
<p>​		<strong>总结</strong></p>
<p>​	①OkhttpClient 实现了Call.Fctory,负责为Request 创建 Call；</p>
<p>​	②RealCall 为Call的具体实现，其enqueue() 异步请求接口通过Dispatcher()调度器利用ExcutorService实现，而最终进行网络请求时和同步的execute()接口一致，都是通过 getResponseWithInterceptorChain() 函数实现</p>
<p>​	③getResponseWithInterceptorChain() 中利用 Interceptor 链条，责任链模式 分层实现缓存、透明压缩、网络 IO 等功能；最终将响应数据返回给用户。</p>
<p><a  id="OkHttp设计模式"></a></p>
<ul>
<li><p><strong>设计模式</strong></p>
<ul>
<li><p>建造者模式</p>
<p>创建者模式又叫建造者模式，是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。创建者模式<strong>隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象</strong>。OkHttp中<strong>HttpClient、Request构造便是通过建造者模式</strong></p>
</li>
<li><p>简单工厂模式</p>
<p>okhttp 实现了Call.Factory接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    Call <span class="title function_">newCall</span><span class="params">(Request request)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Call接口</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.newRealCall(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>责任链模式</p>
<p>责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。<strong>看完只能说设计真的精妙</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Chain</span> &#123;</span><br><span class="line">        String <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        String <span class="title function_">proceed</span><span class="params">(String request)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BridgeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 BridgeInterceptor 拦截器之前代码&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">proceed</span> <span class="operator">=</span> chain.proceed(chain.request());</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 BridgeInterceptor 拦截器之后代码 得到最终数据：&quot;</span>+proceed);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryAndFollowInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 RetryAndFollowInterceptor 拦截器之前代码&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">proceed</span> <span class="operator">=</span> chain.proceed(chain.request());</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 RetryAndFollowInterceptor 拦截器之后代码 得到最终数据：&quot;</span> + proceed);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 CacheInterceptor 最后一个拦截器 返回最终数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span>.Chain &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Interceptor&gt; interceptors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String request;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RealInterceptorChain</span><span class="params">(List&lt;Interceptor&gt; interceptors, <span class="type">int</span> index, String request)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.interceptors = interceptors;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">proceed</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取下一个责任链</span></span><br><span class="line">        <span class="type">RealInterceptorChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, index+<span class="number">1</span>, request);</span><br><span class="line">        <span class="comment">// 执行当前的拦截器</span></span><br><span class="line">        <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> interceptor.interceptor(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试和结果</span></span><br><span class="line">List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>());</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> <span class="title class_">RetryAndFollowInterceptor</span>());</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">RealInterceptorChain</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, <span class="number">0</span>, <span class="string">&quot;request&quot;</span>);</span><br><span class="line"></span><br><span class="line">        request.proceed(<span class="string">&quot;request&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出的log</span></span><br><span class="line"><span class="comment">/*执行 BridgeInterceptor 拦截器之前代码</span></span><br><span class="line"><span class="comment">执行 RetryAndFollowInterceptor 拦截器之前代码</span></span><br><span class="line"><span class="comment">执行 CacheInterceptor 最后一个拦截器 返回最终数据</span></span><br><span class="line"><span class="comment">执行 RetryAndFollowInterceptor 拦截器之后代码 得到最终数据：success</span></span><br><span class="line"><span class="comment">执行 BridgeInterceptor 拦截器之后代码 得到最终数据：success</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><a id="OkHttp源码解读"></a></p>
<ul>
<li><p><strong>源码解读</strong></p>
<ul>
<li><p>ConnectionPool连接池</p>
<p>管理HTTP和SPDY连接的重用，减少网络延迟。连接池是将已经创建好的连接保存在一个缓冲池中，当有请求来时，直接使用已经创建好的连接。</p>
<p>在okhttp中，客户端与服务端的连接被抽象为一个个的Connection，实现类是RealConnection。而ConnectionPool就是专门用来管理Connection的类。ConnectionPool用来管理connections的复用，以减少网络的延迟。一些共享一个地址（Address）的HTTP requests可能也会共享一个Connection。ConnectionPool设置这样的策略：让一些connections保持打开状态，以备将来使用。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/songzi1228/article/details/93855680">OKHttp开源框架学习十：ConnectionPool连接池_okhttp connectionpool-CSDN博客</a></p>
</li>
<li><p>Route路由：对地址Adress的一个封装类</p>
</li>
<li><p>RouteSelector路由选择器:在OKhttp中其实其作用也就是返回一个可用的Route对象</p>
</li>
<li><p>Platform平台：用于针对不同平台适应性</p>
</li>
<li><p>Call请求（Request\Response）：代表实际的http请求，它是连接Request和response的桥梁。由于重写，重定向，跟进和重试，你简单的请求Call可能产生多个请求Request和响应Response。OkHttp会使用Call来模化满足请求的任务，然而中间的请求和响应是必要的（重定向处理和IP出错）<br>Call执行有两种方式：<br>Synchronous：线程会阻塞直到响应可读。<br>Asynchronous：在一个线程中入队请求，当你的响应可读时在另外一个线程获取回调。<br>线程中的请求取消、失败、未完成，写请求主体和读响应主体代码会遇到IOException</p>
</li>
<li><p>Dispatchar调度器：Dispatcher是okhttp3的任务调度核心类，负责管理同步和异步的请求，管理每一个请求任务的请求状态，并且其内部维护了一个线程池用于执行相应的请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatchar内部维护了三个队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//等待执行的异步队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//正在执行的异步队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//同步队列</span></span><br><span class="line">一个线程池</span><br><span class="line">  executorService = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"><span class="comment">/*Deque是一个双向队列接口，Deque接口具有丰富的抽象数据形式，它支持从队列两端点检索和插入元素</span></span><br><span class="line"><span class="comment">当需要执行的线程大于所能承受的最大范围时，就把未能及时执行的任务保存在readyAsyncCalls队列中。当线程池有空余线程可以执行时，会调用promoteCall()方法把等待队列readyAsyncCalls中的任务放到线程池执行，并把任务转移到runningAsyncCalls队列中*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Interceptor拦截器：拦截器是一个强大的机制，它可以监控，重写和重试Calls，自带5种拦截器，在享学课堂的OkHttp部分有写，<strong>下面的缓存相关部分是缓存拦截器内相关的原理</strong></p>
</li>
<li><p>缓存Cache</p>
<p>Cache来自OkHttpClient<br>Cache中采用了DiskLruCache，以Request的URL的md5为key，相应Response为value。此外Cache中还通过外观模式对外提供了InternalCache接口变量，用于调用Cache中的方法，也满足面向对象的接口隔离原则和依赖倒置原则等。<br>DiskLruCache和LruCache内部都是使用了LinkedHashMap去实现缓存算法的，只不过前者针对的是将缓存存在硬盘（&#x2F;sdcard&#x2F;Android&#x2F;data&#x2F;&#x2F;cache），而后者是直接将缓存存在内存；</p>
</li>
<li><p>缓存策略CacheStrategy</p>
<p>CacheStrategy的内部工厂类Factory中有一个getCandidate方法，会根据实际的请求生成对应的CacheStrategy类返回，是个典型的简单工厂模式。其内部维护一个request和response，通过指定request和response来告诉CacheInterceptor是使用缓存还是使用网络请求，亦或两者同时使用。</p>
</li>
<li><p>缓存框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 1.如果设置缓存并且当前request有缓存，则从缓存Cache中获取当前请求request的缓存response</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">cacheCandidate</span> <span class="operator">=</span> cache != <span class="literal">null</span></span><br><span class="line">      ? cache.get(chain.request())</span><br><span class="line">      : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// 2.传入的请求request和获取的缓存response通过缓存策略对象CacheStragy的工厂类get方法根据一些规则获取缓存策略CacheStrategy（这里的规则根据请求的request和缓存的Response的header头部信息生成的，比如是否有noCache标志位，是否是immutable不可变，缓存是否过期等等）</span></span><br><span class="line">  <span class="type">CacheStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">  <span class="comment">// 3.生成的CacheStrategy有2个变量，networkRequest和cacheRequest，如果networkRequest为Null表示不进行网络请求，如果cacheResponse为null，则表示没有有效缓存 </span></span><br><span class="line">  <span class="type">Request</span> <span class="variable">networkRequest</span> <span class="operator">=</span> strategy.networkRequest;</span><br><span class="line">  <span class="type">Response</span> <span class="variable">cacheResponse</span> <span class="operator">=</span> strategy.cacheResponse;</span><br><span class="line">  <span class="comment">// 4.缓存不可用，关闭</span></span><br><span class="line">  <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">    closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5.如果networkRequest和cacheResponse都为Null,则表示不请求网络且缓存为null，返回504，请求失败</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(<span class="number">504</span>)</span><br><span class="line">        .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 6.如果不请求网络，但存在缓存，则不请求网络，直接返回缓存，结束，不执行下一个拦截器</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 7.否则，请求网络，并调用下一个拦截器链，将请求转发到下一个拦截器</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">networkResponse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    networkResponse = chain.proceed(networkRequest);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//8.请求网络，并且网络请求返回HTTP_NOT_MODIFIED，说明缓存有效，则合并网络响应和缓存结果，同时更新缓存</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build();</span><br><span class="line">      networkResponse.body().close();</span><br><span class="line">      <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">      <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">      cache.trackConditionalCacheHit();</span><br><span class="line">      cache.update(cacheResponse, response);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      closeQuietly(cacheResponse.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//9.若没有缓存，则写入缓存</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> networkResponse.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">      <span class="type">CacheRequest</span> <span class="variable">cacheRequest</span> <span class="operator">=</span> cache.put(response);</span><br><span class="line">      <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具流流程如下：</p>
<p>①如果本地没有缓存，直接发送网络请求；cacheResponse &#x3D;&#x3D; null<br>如果当前请求是Https，而缓存没有TLS握手，则重新发起网络请求；<br>request.isHttps() &amp;&amp; cacheResponse.handshake() &#x3D;&#x3D; null<br>如果当前的缓存策略是不可缓存，直接发送网络请求；<br>!isCacheable(cacheResponse, request)<br>请求头no-cache或者请求头包含If-Modified-Since或者If-None-Match，则需要服务器验证本地缓存是不是还能继续使用，直接网络请求；<br>requestCaching.noCache() || hasConditions(request)<br>可缓存，并且ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis（意味着虽过期，但可用，只是会在响应头添加warning），则使用缓存；<br>缓存已经过期，添加请求头：If-Modified-Since或者If-None-Match，进行网络请求；</p>
</li>
<li><p>ConnectInterceptor（核心，连接池）</p>
<p>（下面有部分内容前面有过了）</p>
<p>okhttp的一大特点就是通过连接池来减小响应延迟。如果连接池中没有可用的连接，则会与服务器建立连接，并将socket的io封装到HttpStream（发送请求和接收response）中，HttpCodec（Stream）:数据交换的流,对请求的编码以及对响应数据的解码（Stream:基于Connection的逻辑Http请求&#x2F;响应对），RealConnecton（Collection）：Connection实现类，主要实现连接的建立等工作；Http中Stream和Collection关系：Http1（Http1.0）1:1一个连接只能被一个请求流使用Http2（Http1.1）1:n一个连接可被多个请求流同时使用，且keep-alive机制保证连接使用完不关闭，当下一次请求与连接的Host相同时，连接可以直接使用，不用再次创建StreamAllocation（流分配）:会通过ConnectPool获取或者创建一个RealConnection来得到一个连接到Server的Connection连接，同时会生成一个HttpCodec用于下一个CallServerInterceptor，以完成最终的请求；RouteDataBase：这是一个关于路由信息的白名单和黑名单类，处于黑名单的路由信息会被避免不必要的尝试；ConnectionPool:连接池，实现连接的复用；<br><img src="https://img-blog.csdnimg.cn/2019052219223447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p>
<p>具体源码不看了，直接看步骤</p>
<p>1.框架使用URL和配置好的OkHttpClient创建一个address。此地址指定我们将如何连接到网络服务器。<br>2.框架通过address从连接池中取回一个连接。<br>3.如果没有在池中找到连接，ok会选择一个route尝试连接。这通常意味着使用一个DNS请求， 以获取服务器的IP地址。如果需要，ok还会选择一个TLS版本和代理服务器。<br>4.如果获取到一个新的route，它会与服务器建立一个直接的socket连接、使用TLS安全通道（基于HTTP代理的HTTPS），或直接TLS连接。它的TLS握手是必要的。<br>5.开始发送HTTP请求并读取响应。<br>如果有连接出现问题，OkHttp将选择另一条route，然后再试一次。这样的好处是当服务器地址的一个子集不可达时，OkHttp能够自动恢复。而且当连接池过期或者TLS版本不受支持时，这种方式非常有用。<br>一旦响应已经被接收到，该连接将被返回到池中，以便它可以在将来的请求中被重用。连接在池中闲置一段时间后，它会被赶出。</p>
</li>
<li><p>CallServerInterceptor</p>
<p>CallServerInterceptor的intercept()方法里 负责发送请求和获取响应，实际上都是由HttpStream类去完成具体的工作。<br>一个socket连接用来发送HTTP&#x2F;1.1消息，这个类严格按照以下生命周期：<br>1、 writeRequestHeaders()发送request header<br>httpCodec.writeRequestHeaders(request);<br>2、打开一个sink来写request body，然后关闭sink</p>
<p>Sink requestBodyOut &#x3D; httpCodec.createRequestBody(request, request.body().contentLength());<br>3、readResponseHeaders()读取response头部</p>
<p>responseBuilder &#x3D; httpCodec.readResponseHeaders(true);<br>4、打开一个source来读取response body，然后关闭source</p>
</li>
</ul>
</li>
</ul>
<p><strong>使用方法</strong></p>
<p>调用流程</p>
<p>代码部分前面了</p>
<p>OkHttp请求过程解除最多的是OkHttpClient、Request、Call、Response，但是框架内部进行了大量的逻辑处理，所有逻辑处理大部分集中在拦截器中，但是进入拦截器之前还需要依靠分发器来调配请求任务</p>
<p>分发器：内部维护队列和线程池，完成请求调配</p>
<p>拦截器：完成整个请求过程（完成一次完整的http请求的过程，DNS解析-&gt;三次握手建立TCP连接(socket)-&gt;发送http报文）（当然这里还完成了许多的优化的功能，包括连接池等等）</p>
<p><strong>分发器Dispatcher</strong></p>
<p><strong>下面这部分就相当于是OkHttp进行网络请求的具体流程，源码分析就分析其中一些具体部分</strong></p>
<ul>
<li><p>构建OkHttpClient对象构造者模式可以使用自己的分发器对象</p>
</li>
<li><p>OkHttpClient的newCall方法传入Request对象得到一个Call对象（Call是一个接口，实现类是RealCall类，将OkHttpClient对象、Request对象都交给RealCall去处理，然后返回对象）</p>
</li>
<li><p>然后调用RealCall对象的同步和异步请求的方法发起请求</p>
</li>
<li><p>然后看到enqueue异步请求方法（进入这个方法一进来就synchronized(this)，加锁保证RealCall并限制只能进行同步请求或异步请求，不能同时进行，否则抛出异常，可以使用clone方法，克隆一个对象出来进行请求）（OkHttpClient还可以设置EventListener对象，可以监听请求的开始。。。）</p>
</li>
<li><p>然后enqueue内部就调用OkHttpClient的dispatcher方法去获取DisPatcher对象去执行enqueue方法，之后传入一个AsyncCall对象（可以看作请求任务），这个对象传入CallBack回调</p>
</li>
<li><p>进入分发器的enqueue方法，有RunningAsyncCalls（正在执行异步请求队列）、RunningSyncCalls（正在执行的同步请求队列）、ReadyAsyncCalls（等待异步请求队列）队列<strong>（ArrayDeque类型，内部循环数组，作者解释，如果把这个类型当做stack栈来使用，它比栈快，如果把它当做queue来使用，它比LinkedList快）</strong></p>
</li>
<li><p>接下来就是分发器分发任务的过程，对于异步请求有两种方式，进入等待队列，进入执行队列</p>
</li>
<li><p>进入Running队列的请求任务就会加入线程池执行，也是在enqueue方法中的，在加入执行队列代码下一行就是让ExecutorService对象（其实就是线程池）的execute执行这个Call对象任务（线程池需要接收Runnable，Call也就是AsyncCall其实就是Runnable）</p>
</li>
<li><p>接下来就是执行AsyncCall这个里面的execute方法（AsyncCall继承的类中的run执行了一个抽象方法execute），下面其实就是通过<strong>getResponseWithInterceptorChain方法去走拦截器，返回Response</strong>，这里异常机制，finally代码块一定执行，执行client.dispatcher().finished(this)，finish方法传入running队列，AsyncCall对象和true，然后从Running队列移除已经完成的Call对象，然后就循环根据下面提到的从Ready队列拿对象放到Running队列</p>
</li>
</ul>
<p>离并发任务分发</p>
<ul>
<li><p>异步请求 </p>
<ul>
<li><p>分发器怎么决定放入ready还是running队列？</p>
<p>是一个判断语句</p>
<p>第一个条件根据正在执行异步请求队列的个数决定的，分发器默认定义这个值为64，小于这个值直接加入Running队列，大于这个值就加入Ready队列（可以修改）</p>
<p>第二个条件是同一个域名的请求最大数不大于5个，默认值为5个</p>
</li>
<li><p>从Ready移动到Running的条件是什么？</p>
<p>任务结束判断，Running队列数量少于分发器规定的最大同时异步请求对象的数量，并且请求队列不为空，而且对于同一域名的请求数量少于定义的数量（多于的对象就找下一个），就移动到Running队列中</p>
</li>
<li><p>分发器线程池怎么定义的？</p>
<p>executorService其实就是线程池，new了一个ThreadPoolExecutor对象（这个就是最基本的线程池类，不是那几个特别的，可以看前面的部分，下面讲一下它构造这个对象传入的内容），这里传入的等待队列传入的类型是synchronousQueue（因为LinkedBlockingQueue和ArrayBlockingQueue不合适，如果使用ArrayBlockingQueue设定值为1，核心线程数为1，那么如果有一个线程一直在跑，又进来一个任务就会进入队列，再进来一个任务就又要入队，但是队列满了按照这个类型的等待队列就需要额外新建一个线程，但是会先跑任务3再跑任务2，就很有问题，因为我们需要线程进来就开始跑，并且按顺序来），那么如果达到线程池定义的最大线程数怎么办呢，就会需要使用线程池传入的拒绝策略的参数来进行处理</p>
<p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403062342157.png" alt="image-20240306234243536"></p>
</li>
</ul>
</li>
<li><p>同步请求</p>
<p>同样是先一个判断语句一个call只能用一次，然后执行分发器的同步请求方法（这里面就是直接把这个call放入running队列，直接执行），最后使用分发器的finished方法（将完成同步请求的call从队列remove）</p>
<p><strong>前面异步的具体流程直接看分发器的部分就可以了</strong></p>
</li>
</ul>
<p>线程池排队</p>
<p>OKHttp传入的工作队列类型决定了他的工作行为为无等待，最大并发的，这个就是具体的排队机制，这很符合OkHttp的使用场景，高并发的网络请求场景，但是并不会很容易OOM，因为前面分发器中定义的等待队列和</p>
<p>执行队列就是为了限制所有的异步请求的数量，避免了OOM</p>
<p><strong>拦截器</strong></p>
<p>责任链模式</p>
<p>（避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。）</p>
<p><strong>请求从上往下去执行，响应再从下往上去回传</strong></p>
<p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403071244326.png" alt="image-20240307124450739"></p>
<p>五大拦截器</p>
<ul>
<li><p>RetryAndFollowUpInterceptor（重试和重定向拦截器）</p>
<p>第一个接触到请求，最后接触到响应;负责判断是否需要重新发起整个请求</p>
</li>
<li><p>BridgeInterceptor（桥接拦截器）</p>
<p>补全请求（如补全请求头，gzip解压or设置cookie），并对响应进行额外处理</p>
</li>
<li><p>CacheInterceptor（缓存拦截器）</p>
<p>请求前查询缓存，获得响应并判断是否需要缓存（需要使用就需要手动去开启缓存，就是在构建OkHttpClient的时候在Builder.cache(new Cache(存储路径，最大长度))）</p>
<p>HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类可以分为强制缓存和对比缓存</p>
<ul>
<li><p>强制缓存</p>
<p><img src="https://img-blog.csdnimg.cn/20190712194525612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p>
<p>http1.1的head中Cache-Control字段标明失效规则，private客户端可以缓存；public客户端和代理服务器都可以缓存；max-age&#x3D;xxx:缓存的内容将在 xxx 秒后失效；no-cache:需要使用对比缓存来验证缓存数据；no-store:所有内容都不会缓存，强制缓存，对比缓存都不会触发</p>
</li>
<li><p>对比缓存</p>
<p><img src="https://img-blog.csdnimg.cn/20190712194541903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p>
<p>对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。</p>
<p>最重要的就是在header中的传递的两种标识，Last-Modified &#x2F; If-Modified-Since，Last-Modified：<br>服务器在响应请求时，告诉浏览器资源的最后修改时间；If-Modified-Since：再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。<br>服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。<br>若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</p>
<p>还有Etag &#x2F; If-None-Match（<strong>优先级高于Last-Modified &#x2F; If-Modified-Since</strong>），Etag：<br>服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定），If-None-Match：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</p>
</li>
</ul>
</li>
<li><p>ConnectInterceptor（链接拦截器）</p>
<p>与服务器完成TCP连接 （Socket）</p>
</li>
<li><p>CallServerInterceptor（请求服务拦截器）</p>
<p>与服务器通信;封装请求数据与解析响应数据(如:HTTP报文)</p>
</li>
</ul>
<p><strong>还可以自定义拦截器</strong></p>
<p>在Builder的addInterceptor和addNetworkInterceptor可以传入自定义的拦截器，这两者的区别体现在添加到list的顺序不同，添加拦截器是在RealCall中完成的，getResponseWithInterceptorChain中完成的，addInterceptor添加到拦截器会在list的最前面，也就是在重试和重定向拦截器的前面，而addNetworkInterceptor添加的拦截器在最后一个请求连接器的前面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());<span class="comment">//用户自定义拦截器</span></span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor); <span class="comment">//重试和重定向拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));<span class="comment">//负责添加交易请求头</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));<span class="comment">//缓存拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client)); <span class="comment">//网络连接拦截器</span></span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket)); <span class="comment">//负责发送网络请求和读取网络响应</span></span><br><span class="line"></span><br><span class="line">  Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">      interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>拦截器中的ConnectionPool（连接池）看前面的OkHttp部分有提到原理</p>
<p>网络代理</p>
<p>这是网络通信必备基础中的socket通信原则中的内容，socket通信原则中有SOCKS代理和HTTP普通代理与隧道代理</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li><p><strong>建造者模式</strong></p>
<p>创建者模式又叫建造者模式，是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。创建者模式<strong>隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象</strong>。OkHttp中<strong>HttpClient、Request构造便是通过建造者模式</strong></p>
</li>
<li><p><strong>简单工厂模式</strong></p>
<p>okhttp 实现了Call.Factory接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    Call <span class="title function_">newCall</span><span class="params">(Request request)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Call接口</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.newRealCall(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>责任链模式</strong></p>
<p>责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。<strong>看完只能说设计真的精妙，可以看下面这个博客一开始的代码就知道怎么写简单的责任链设计模式了</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41605937/article/details/133376446">行为型设计模式——责任链模式-CSDN博客</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Chain</span> &#123;</span><br><span class="line">        String <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        String <span class="title function_">proceed</span><span class="params">(String request)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BridgeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 BridgeInterceptor 拦截器之前代码&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">proceed</span> <span class="operator">=</span> chain.proceed(chain.request());</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 BridgeInterceptor 拦截器之后代码 得到最终数据：&quot;</span>+proceed);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryAndFollowInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 RetryAndFollowInterceptor 拦截器之前代码&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">proceed</span> <span class="operator">=</span> chain.proceed(chain.request());</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 RetryAndFollowInterceptor 拦截器之后代码 得到最终数据：&quot;</span> + proceed);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 CacheInterceptor 最后一个拦截器 返回最终数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span>.Chain &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Interceptor&gt; interceptors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String request;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RealInterceptorChain</span><span class="params">(List&lt;Interceptor&gt; interceptors, <span class="type">int</span> index, String request)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.interceptors = interceptors;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">proceed</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取下一个责任链</span></span><br><span class="line">        <span class="type">RealInterceptorChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, index+<span class="number">1</span>, request);</span><br><span class="line">        <span class="comment">// 执行当前的拦截器</span></span><br><span class="line">        <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> interceptor.interceptor(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试和结果</span></span><br><span class="line">List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>());</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> <span class="title class_">RetryAndFollowInterceptor</span>());</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">RealInterceptorChain</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, <span class="number">0</span>, <span class="string">&quot;request&quot;</span>);</span><br><span class="line"></span><br><span class="line">        request.proceed(<span class="string">&quot;request&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出的log</span></span><br><span class="line"><span class="comment">/*执行 BridgeInterceptor 拦截器之前代码</span></span><br><span class="line"><span class="comment">执行 RetryAndFollowInterceptor 拦截器之前代码</span></span><br><span class="line"><span class="comment">执行 CacheInterceptor 最后一个拦截器 返回最终数据</span></span><br><span class="line"><span class="comment">执行 RetryAndFollowInterceptor 拦截器之后代码 得到最终数据：success</span></span><br><span class="line"><span class="comment">执行 BridgeInterceptor 拦截器之后代码 得到最终数据：success</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7199431845367922745?searchId=20240618232451B3D0BB6A62FDCFF89F8E#heading-14">由浅入深，聊聊OkHttp的那些事(易懂，不繁琐) - 掘金 (juejin.cn)</a></p>
<p><strong>OkHttp中有五大拦截器</strong></p>
<ul>
<li><p><strong>RetryAndFollowUpInterceptor（重试和重定向拦截器）</strong></p>
<p>第一个接触到请求，最后接触到响应;</p>
<p>用于 <strong>请求失败</strong> 的 <strong>重试</strong> 工作以及 <strong>重定向</strong> 的后续请求工作，同时还会对 <strong>连接</strong> 做一些初始化工作。</p>
<ol>
<li>请求时如果遇到异常，则根据情况去尝试恢复，如果不能恢复，则抛出异常，跳过本次请求；如果请求成功，则在 <code>finally</code> 里释放资源；</li>
<li>如果请求是重试之后的请求，那么将重试前请求的响应体设置为null,并添加到当前响应体的 <code>priorResponse</code> 字段中；</li>
<li>根据当前的responseCode判断是否需要重试，若不需要，则返回 <code>response</code> ；若需要，则返回 <code>request</code> ，并在后续检查当前重试次数是否达到阈值；</li>
<li>重复上述步骤，直到步骤三成功。</li>
</ol>
<p>在第一步时，获取 <code>response</code> 时，需要调用 <code>realChain.proceed(request)</code> ，如果你还记得上述的责任链，所以这里触发了下面的拦截器执行，即 <code>BridgeInterceptor</code> 。</p>
</li>
<li><p><strong>BridgeInterceptor（桥接拦截器）</strong></p>
<p>补全请求（如补全请求头，gzip解压or设置cookie），并对响应进行额外处理</p>
<p>用于 <strong>客户端和服务器</strong> 之间的沟通 <strong>桥梁</strong> ，负责将用户构建的请求转换为服务器需要的请求。比如添加 <code>content-type</code>、<code>cookie</code> 等，再将服务器返回的 <code>response</code> 做一些处理，转换为客户端所需要的 <code>response</code>，比如移除 <code>Content-Encoding</code></p>
<ol>
<li>首先调用 <code>chain.request()</code> 获取原始请求数据，然后开始重新构建请求头，添加 <code>header</code> 以及 <code>cookie</code> 等信息；</li>
<li>将第一步构建好的新的 <code>request</code> 传入 <code>chain.proceed()</code> ,从而触发下一个拦截器的执行，并得到 服务器返回的 <code>response</code>。然后保存 <code>response</code> 携带的 <code>cookie</code>,并移除 <code>header</code> 中的 <code>Content-Encoding</code> 和 <code>Content-Length</code>,并同步修改 <code>body</code>。</li>
</ol>
</li>
<li><p><strong>CacheInterceptor（缓存拦截器）</strong></p>
<p>请求前查询缓存，获得响应并判断是否需要缓存（需要使用就需要手动去开启缓存，就是在构建OkHttpClient的时候在Builder.cache(new Cache(存储路径，最大长度))）（走的DiskLruCache磁盘缓存）</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9875cc9eba574c4ca20a5c75f2e2fa4c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
<p>下面是Http缓存的规则，上面的图是OkHttp缓存规则图，HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类可以分为强制缓存和对比缓存</p>
<ul>
<li><p>强制缓存</p>
<p><img src="https://img-blog.csdnimg.cn/20190712194525612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p>
<p>http1.1的head中Cache-Control字段标明失效规则，private客户端可以缓存；public客户端和代理服务器都可以缓存；max-age&#x3D;xxx:缓存的内容将在 xxx 秒后失效；no-cache:需要使用对比缓存来验证缓存数据；no-store:所有内容都不会缓存，强制缓存，对比缓存都不会触发</p>
</li>
<li><p>对比缓存</p>
<p><img src="https://img-blog.csdnimg.cn/20190712194541903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p>
<p>对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。</p>
<p>最重要的就是在header中的传递的两种标识，Last-Modified &#x2F; If-Modified-Since，Last-Modified：<br>服务器在响应请求时，告诉浏览器资源的最后修改时间；If-Modified-Since：再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。<br>服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。<br>若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</p>
<p>还有Etag &#x2F; If-None-Match（<strong>优先级高于Last-Modified &#x2F; If-Modified-Since</strong>），Etag：<br>服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定），If-None-Match：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</p>
</li>
</ul>
</li>
<li><p><strong>ConnectInterceptor（链接拦截器）</strong></p>
<p>与服务器完成TCP连接 （Socket）</p>
<p>先通过 <code>ExchangeFinder</code> 去 <code>RealConnecionPool</code> 中尝试寻找已经存在的连接，未找到则会重新创建一个 <code>RealConnection</code>(连接) 对象，并将其添加到连接池里，开始连接。然后根据找到或者新创建 <code>RealConnection</code> 对象，并根据当前请求协议创建不同的 <code>ExchangeCodec</code> 对象并返回，最后初始化一个 <code>Exchange</code> 交换器并返回，从而实现了 <code>Exchange</code> 的初始化过程。</p>
<p>在具体找寻 <code>RealConnection</code> 的过程中，一共尝试了5次，具体如下：</p>
<ol>
<li>尝试重连 <code>call</code> 中的 <code>connection</code>，此时不需要重新获取连接；</li>
<li>尝试从连接池中获取一个连接，不带路由与多路复用；</li>
<li>再次尝试从连接池中获取一个连接，带路由，不带多路复用；</li>
<li>手动创建一个新连接；</li>
<li>再次尝试从连接池中获取一个连接，带路由与多路复用；</li>
</ol>
<p>当 <code>Exchange</code> 初始化完成后，再复制该对象创建一个新的 <code>Exchange</code> ，并执行下一个责任链，从而完成连接的建立。</p>
</li>
<li><p><strong>CallServerInterceptor（请求服务拦截器）</strong></p>
<p>与服务器通信;封装请求数据与解析响应数据(如:HTTP报文)</p>
<p>先写入要发送的请求头，然后根据条件判断是否写入要发送的请求体。当请求结束后，解析服务器返回的响应头，构建一个新的 <code>response</code> 并返回；如果 <code>response.code</code> 为 <strong>100</strong>，则重新读取响应体并构建新的 <code>response</code>。因为这是最底层的拦截器，所以这里肯定不会再调用 <code>proceed()</code> 再往下执行。</p>
</li>
</ul>
<p><strong>还可以自定义拦截器</strong></p>
<p>在Builder的addInterceptor和addNetworkInterceptor可以传入自定义的拦截器，这两者的区别体现在添加到list的顺序不同，添加拦截器是在RealCall中完成的，getResponseWithInterceptorChain中完成的，addInterceptor添加到拦截器会在list的最前面，也就是在重试和重定向拦截器的前面，而addNetworkInterceptor添加的拦截器在最后一个请求连接器的前面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());<span class="comment">//用户自定义拦截器</span></span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor); <span class="comment">//重试和重定向拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));<span class="comment">//负责添加交易请求头</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));<span class="comment">//缓存拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client)); <span class="comment">//网络连接拦截器</span></span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket)); <span class="comment">//负责发送网络请求和读取网络响应</span></span><br><span class="line"></span><br><span class="line">  Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">      interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>拦截器中的ConnectionPool（连接池）看前面的OkHttp部分有提到原理</p>
<h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.wuleizhenshang.love">无泪真伤</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.wuleizhenshang.love/2024/06/19/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87(%E6%A1%86%E6%9E%B6%E9%83%A8%E5%88%86)/">https://www.wuleizhenshang.love/2024/06/19/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87(%E6%A1%86%E6%9E%B6%E9%83%A8%E5%88%86)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.wuleizhenshang.love" target="_blank">Blog-无泪真伤</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%B6%E4%BB%96/">其他</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/66723b31d9c307b7e9cbf899.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/16/%E5%89%91%E6%8C%87offer%E4%B8%AA%E4%BA%BA%E7%AE%97%E6%B3%95%E5%87%86%E5%A4%87/" title="剑指offer个人算法准备"><img class="cover" src="https://s2.loli.net/2024/09/16/dOZFEfXMl4j2VAs.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">剑指offer个人算法准备</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/19/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87(%E5%AE%89%E5%8D%93%E9%83%A8%E5%88%86)/" title="面试准备（安卓部分）"><img class="cover" src="https://pic.imgdb.cn/item/66725566d9c307b7e9f4c95d.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试准备（安卓部分）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/17/GitHub+Hexo+Git/" title="GitHub Pages+Hexo+Git快速搭建个人博客"><img class="cover" src="https://pic.imgdb.cn/item/65597baac458853aef754b7b.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-17</div><div class="title">GitHub Pages+Hexo+Git快速搭建个人博客</div></div></a></div><div><a href="/2024/06/19/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87(java%E9%83%A8%E5%88%86)/" title="面试准备(Java部分)"><img class="cover" src="https://pic.imgdb.cn/item/66723ae2d9c307b7e9cb8bc9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-19</div><div class="title">面试准备(Java部分)</div></div></a></div><div><a href="/2024/06/19/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87(%E5%AE%89%E5%8D%93%E9%83%A8%E5%88%86)/" title="面试准备（安卓部分）"><img class="cover" src="https://pic.imgdb.cn/item/66725566d9c307b7e9f4c95d.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-19</div><div class="title">面试准备（安卓部分）</div></div></a></div><div><a href="/2024/02/28/%E5%87%86%E5%A4%87/" title="小白个人Android面试准备"><img class="cover" src="https://pic.imgdb.cn/item/65df52089f345e8d030edde4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-28</div><div class="title">小白个人Android面试准备</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/65582252c458853aeff7c6f5.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">无泪真伤</div><div class="author-info__description">找寻自己所爱！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wuleizhenshang"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本人并非什么大佬！写博客纯属个人兴趣，记录一下个人学习经历而已，有错误请见谅！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%88%E6%A1%86%E6%9E%B6%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">面试准备（框架部分）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Glide"><span class="toc-number">1.1.</span> <span class="toc-text">Glide</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">基础流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E7%BB%86%E8%8A%82"><span class="toc-number">1.1.2.</span> <span class="toc-text">三级缓存细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%86%E8%8A%82"><span class="toc-number">1.1.3.</span> <span class="toc-text">线程池细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8DOOM%E5%92%8C%E5%86%85%E5%AD%98%E7%A7%BB%E9%99%A4%E7%BB%86%E8%8A%82"><span class="toc-number">1.1.4.</span> <span class="toc-text">避免OOM和内存移除细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.5.</span> <span class="toc-text">一些对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OkHttp"><span class="toc-number">1.2.</span> <span class="toc-text">OkHttp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">拦截器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Retrofit"><span class="toc-number">1.3.</span> <span class="toc-text">Retrofit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RxJava"><span class="toc-number">1.4.</span> <span class="toc-text">RxJava</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/05/%E8%87%AA%E5%AE%9A%E4%B9%89View/" title="自定义View"><img src="https://wushangblog.s3.bitiful.net/%E8%87%AA%E5%AE%9A%E4%B9%89View.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自定义View"/></a><div class="content"><a class="title" href="/2025/02/05/%E8%87%AA%E5%AE%9A%E4%B9%89View/" title="自定义View">自定义View</a><time datetime="2025-02-05T06:47:33.000Z" title="发表于 2025-02-05 14:47:33">2025-02-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/Leetcode%20CookBook%E7%AE%97%E6%B3%95/" title="Leetcode CookBook算法"><img src="https://pic1.imgdb.cn/item/67948944d0e0a243d4f7c0f9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode CookBook算法"/></a><div class="content"><a class="title" href="/2025/01/25/Leetcode%20CookBook%E7%AE%97%E6%B3%95/" title="Leetcode CookBook算法">Leetcode CookBook算法</a><time datetime="2025-01-25T06:47:33.000Z" title="发表于 2025-01-25 14:47:33">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/03/android%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/" title="Android知识秘籍"><img src="https://s2.loli.net/2025/01/03/gw4uYQMBloWir5K.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android知识秘籍"/></a><div class="content"><a class="title" href="/2025/01/03/android%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/" title="Android知识秘籍">Android知识秘籍</a><time datetime="2025-01-03T12:19:51.000Z" title="发表于 2025-01-03 20:19:51">2025-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/03/android%E6%8F%90%E9%97%AE200%E9%81%93/" title="Android提问问答"><img src="https://s2.loli.net/2025/01/03/tPiv5zLXgsfGWmn.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android提问问答"/></a><div class="content"><a class="title" href="/2025/01/03/android%E6%8F%90%E9%97%AE200%E9%81%93/" title="Android提问问答">Android提问问答</a><time datetime="2025-01-03T12:19:12.000Z" title="发表于 2025-01-03 20:19:12">2025-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/03/java%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/" title="Java知识秘籍"><img src="https://s2.loli.net/2025/01/03/K2M9njOwagHpfIs.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java知识秘籍"/></a><div class="content"><a class="title" href="/2025/01/03/java%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/" title="Java知识秘籍">Java知识秘籍</a><time datetime="2025-01-03T12:18:23.000Z" title="发表于 2025-01-03 20:18:23">2025-01-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By 无泪真伤</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog! --by Wuleizhenshang</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false#  open shake (抖動特效);
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>
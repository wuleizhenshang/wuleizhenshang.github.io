<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android知识秘籍 | Blog-无泪真伤</title><meta name="author" content="无泪真伤"><meta name="copyright" content="无泪真伤"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="总结自下面链接，转载请使用大佬的博客地址https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_29966203&#x2F;article&#x2F;details&#x2F;105455615?spm&#x3D;1001.2014.3001.5502 第一章 四大组件 介绍一下四大组件？ Activity  生命周期 参数传递 启动过程 启动模式 状态保存 &amp; 恢复   Service  启动方式 &amp; 生命周期 适用场景（S">
<meta property="og:type" content="article">
<meta property="og:title" content="Android知识秘籍">
<meta property="og:url" content="https://www.wuleizhenshang.love/2025/01/03/android%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/index.html">
<meta property="og:site_name" content="Blog-无泪真伤">
<meta property="og:description" content="总结自下面链接，转载请使用大佬的博客地址https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_29966203&#x2F;article&#x2F;details&#x2F;105455615?spm&#x3D;1001.2014.3001.5502 第一章 四大组件 介绍一下四大组件？ Activity  生命周期 参数传递 启动过程 启动模式 状态保存 &amp; 恢复   Service  启动方式 &amp; 生命周期 适用场景（S">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://smms.app/image/gw4uYQMBloWir5K">
<meta property="article:published_time" content="2025-01-03T12:19:51.000Z">
<meta property="article:modified_time" content="2025-01-03T12:22:52.190Z">
<meta property="article:author" content="无泪真伤">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://smms.app/image/gw4uYQMBloWir5K"><link rel="shortcut icon" href="/img/86634.jpg"><link rel="canonical" href="https://www.wuleizhenshang.love/2025/01/03/android%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 无泪真伤","link":"链接: ","source":"来源: Blog-无泪真伤","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android知识秘籍',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-03 20:22:52'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/65582252c458853aeff7c6f5.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://smms.app/image/gw4uYQMBloWir5K')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog-无泪真伤"><span class="site-name">Blog-无泪真伤</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Android知识秘籍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-03T12:19:51.000Z" title="发表于 2025-01-03 20:19:51">2025-01-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-03T12:22:52.190Z" title="更新于 2025-01-03 20:22:52">2025-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android%E9%9D%A2%E8%AF%95/">Android面试</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android%E9%9D%A2%E8%AF%95/Java%E7%9F%A5%E8%AF%86/">Java知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">66.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>245分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Android知识秘籍"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>总结自下面链接，转载请使用大佬的博客地址<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29966203/article/details/105455615?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_29966203/article/details/105455615?spm=1001.2014.3001.5502</a></strong></p>
<h1 id="第一章-四大组件"><a href="#第一章-四大组件" class="headerlink" title="第一章 四大组件"></a>第一章 四大组件</h1><ul>
<li>介绍一下四大组件？</li>
<li>Activity</li>
<li><ul>
<li>生命周期</li>
<li>参数传递</li>
<li>启动过程</li>
<li>启动模式</li>
<li>状态保存 &amp; 恢复</li>
</ul>
</li>
<li>Service</li>
<li><ul>
<li>启动方式 &amp; 生命周期</li>
<li>适用场景（Service 与 Thread 对比）</li>
<li>Service 分类 &amp; 使用</li>
<li>IntentService</li>
<li>Service和Activity 通信</li>
</ul>
</li>
<li>ContentProvider</li>
<li><ul>
<li>描述</li>
<li>使用</li>
</ul>
</li>
<li>BroadcastReceiver</li>
<li><ul>
<li>描述</li>
<li>分类</li>
<li>注册方式</li>
<li>使用方式：发送\接受\屏蔽 广播</li>
</ul>
</li>
<li>Context</li>
<li><ul>
<li>理解 &amp; 作用</li>
<li>分类</li>
<li>内存泄露</li>
</ul>
</li>
<li>Intent</li>
<li><ul>
<li>指定当前组件要完成的动作</li>
<li>传递数据</li>
</ul>
</li>
<li>Application</li>
</ul>
<h2 id="介绍一下四大组件？"><a href="#介绍一下四大组件？" class="headerlink" title="介绍一下四大组件？"></a>介绍一下四大组件？</h2><ul>
<li>Activity（活动）<br>Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种。它为用户提供一个窗口，上面可以显示一些控件用于监听并处理用户的事件。</li>
<li>Service（服务）<br>Service提供需在后台长期运行的服务，无用户界面。一个组件可以与一个Service进行绑定实现组件之间的交互。Service可以在后台执行很多任务，如处理网络事务，播放音乐，文件读写下载等等。</li>
<li>Content Provider（内容提供者）<br>Content Provider是Android官方推荐的不同应用程序间进行数据交互&amp;共享的方式。ContentProvider为存储和获取数据提供统一的接口，相当于数据的搬运工（中间者），真正的数据源为Sqlite&#x2F;文件&#x2F;XML&#x2F;网络等。</li>
<li>BroadcastReceiver（广播接收器）<br>BroadcastReceiver相当于一个全局监听器，用于接收应用间&#x2F;应用内发出的广播信息，并作出响应。</li>
</ul>
<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://mark.cuckooing.cn/pics/pic_7cd1595c.png" alt="pic_7cd1595c.png"><br><img src="https://mark.cuckooing.cn/pics/pic_0859beb3.png" alt="pic_0859beb3.png"><br>Activity生命周期包括四种状态、七种方法、两个异常:</p>
<ol>
<li>四种状态</li>
</ol>
<ul>
<li>Running状态：处于栈的最顶端，此时它处于可见并可和用户交互的激活状态。</li>
<li>Paused状态：当Activity被另一个透明或者Dialog样式的Activity覆盖时的状态。它仍然可见，但失去了焦点，故不可与用户交互。</li>
<li>Stopped状态：当Activity完全不可见，处于后台时，但仍保留着当前状态和成员信息</li>
<li>Killed状态：当前界面被销毁，等待被系统回收</li>
</ul>
<ol>
<li>七个方法</li>
</ol>
<ul>
<li>onCreate（）：在Activity创建时调用。一般用来做一些初始化操作，如初始化布局setContentLayout()</li>
<li>onStart（）：在Activity即将显示界面时调用，但用户无法操作。一般也用于做一些初始化操作，但对于Activity而言，onCreate只执行一次，但onStart可执行多次。</li>
<li>onResume（）：在Activity获取焦点开始与用户交互时调用，此时Activity处于运行状态，位于栈顶。一般用于数据恢复、开启动画等</li>
<li>onPause（）：在当前Activity被其他Activity覆盖部分或锁屏时调用，此时Activity处于暂停状态，仍然可见，但失去焦点，不能与用户交互。一般用于关闭动画，注销广播等。并应进行状态保存与数据存储，但不适合做耗时操作。（为了让新的Activity尽快切换到前台）</li>
<li>onStop（）：在Activity对用户完全不可见时调用，此时Activity处于停止状态。此时进程优先级较低，当系统内存不足时，容易被杀死。一般用于进行资源回收。</li>
<li>onDestory（）：在Activity销毁时调用，常用于释放资源，Activity处于销毁状态后，将被清出内存。</li>
<li>onRestart（）：在Activity从停止状态再次启动时调用。onRestart一般是应用位于后台重新切换为前台调用，可用于进行数据刷新。<br>其中onCreate() &amp; onDestory()、onStart() &amp; onStop()、onResume() &amp; onPause()成对出现。</li>
</ul>
<ol>
<li>两个异常</li>
</ol>
<ul>
<li>更高优先级的进程需要内存，但系统内存不足<br>处于暂停&#x2F;停止状态（低优先级）可能会被直接杀死onStop()-&gt;直接杀死进程（当前Activity）<br>手动重启当前Activity-&gt;onCreate()-&gt;onStart()-&gt;onResume()-&gt;运行</li>
<li>系统配置发生改变导致Activity意外销毁（如横竖屏切换、键盘事件等）<br>Running-&gt;onSaveInstanceState()-&gt;onPause()-&gt;onStop()-&gt;onDestroy()-&gt;自动重启-&gt;onCreate()-&gt;onStart()-&gt;onRestoreInstanceState()-&gt;onResume()-&gt;Running<br>在onSaveInstanceState（）保存Activity状态。适合保存一些非持久数据，如布局状态、成员变量的值等，持久数据适合在onPause（）与onStop（）中通过数据库、sharedpreference保存<br>在onRestoreInstanceState（）&#x2F;onCreate()恢复Activity状态。</li>
</ul>
<p>补充：Activity各种实际场景下生命周期的变换<br>（1）横竖屏切换、键盘事件等系统配置（自动重启）<br>-&gt;onPause-&gt;onSaveInstanceState-&gt;onStop-&gt;onDestroy-&gt;onCreate-&gt;onStart-&gt;onRestoreInstanceState-&gt;onResume<br>（2）横竖屏切换总结</p>
<ul>
<li>设置<br>a. 静态设置，即在Mainfest文件中配置screenOrientation属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制Activity为竖屏显示</span></span><br><span class="line">android:screenOrientation=<span class="string">&quot;portrait&quot;</span></span><br></pre></td></tr></table></figure>

<p>b. 动态设置，即调用Activity的setRequestedOrientation(@ActivityInfo.ScreenOrientation int requestedOrientation)方法设置screenOrientation属性值</p>
<ul>
<li>Activity生命周期<br>关于Android横竖屏切换Activity是否会销毁重建，这个由Activity的configChanges属性控制。</li>
</ul>
<p>a. Activity 不销毁重建<br>下方配置可以控制Activity在横竖屏切换时不销毁重建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:configChanges=<span class="string">&quot;orientation|keyboardHidden|screenSize&quot;</span></span><br></pre></td></tr></table></figure>

<p>配置了android:configChanges&#x3D;”orientation|keyboardHidden|screenSize”横竖屏切换时Activity不会销毁重建，而是会回调Activity的onConfigurationChanged方法。<br>b. Activity销毁重建</p>
<ul>
<li>不配置configChanges属性</li>
<li>设置android:configChanges&#x3D;“orientation”</li>
<li>设置android:configChanges&#x3D;“orientation|keyboardHidden”</li>
</ul>
<p>以上三种配置，横竖屏切换时Activity均会销毁重建，Activity的生命周期都会重新执行一次<br>onPause -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onResume<br>（3）锁屏&#x2F;息屏&#x2F;Home&#x2F;打开新Activity&#x2F;处于后台,并手动重启<br>-&gt;onPause-&gt;-&gt; onSaveInstanceState-&gt;onStop-&gt;onReStart-&gt;onStart-&gt;onResume<br>（4）Back键退出当前Activity<br>onPause-&gt;onStop-&gt;onDestroy<br>（5）Aactivity切换Bactivity<br>AActivity:-&gt;onPause()<br>BActivity:onCreate()-&gt;onStart()-&gt;onResume()<br>AActivity:onStop()<br>（6）Aactivity切换Bactivity（透明&#x2F;对话框）<br>AActivity:-&gt;onPause()<br>BActivity:onCreate()-&gt;onStart()-&gt;onResume()<br>面试题<br>1、弹出普通Dialog和一个自定义Dialog视图的Activity（android:theme&#x3D;”@style&#x2F;dialogstyle”）生命周期有什么区别？<br>（1）弹出普通Dialog：Activity周期不发生变化。因为Dialog依附于 Activity, Activity仍位于前台。<br>（2）弹出Dialog视图的Activity：<br>原Activity：onPause()<br>Dialog样式Activity:onCreate()-&gt;onStart()-&gt;onResume()</p>
<p>2、两个Activity 之间跳转时必然会执行的是哪几个方法？<br>当在A Activity里面激活B Activity的时候, A会调用onPause()方法,然后B调用onCreate() ,onStart(), onResume()。<br>这个时候B覆盖了A的窗体, A会调用onStop()方法。<br>如果B是个透明的窗口,或者是对话框的样式, 就不会调用A的onStop()方法。<br>如果B已经存在于Activity栈中，B会调用onReStart()-&gt;onStart()-&gt;onResume()<br>故一定会执行A的onPause()和B的onStart()与onResume()。</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ol>
<li>通过Intent传递</li>
</ol>
<ul>
<li>使用putExtra，可直接传递单一基本数据类型，或用Bundle封装多种数据类型再传递或者传递经Serializable&#x2F;Parcelable序列化对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递基本数据类型</span></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">   <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>,OtherActivity.class); </span><br><span class="line">   intent.putExtra(<span class="string">&quot;boolean_key&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">   intent.putExtra(<span class="string">&quot;string_key&quot;</span>, <span class="string">&quot;string_value&quot;</span>);</span><br><span class="line">   startActivity(intent);</span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line">   Intent intent=getIntent();</span><br><span class="line">   intent.getBooleanExtra(<span class="string">&quot;boolean_key&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">   intent.getStringExtra(<span class="string">&quot;string_key&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递多种数据类型（Bundle）</span></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">	<span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Intent</span>(CurrentActivity.<span class="built_in">this</span>,OtherActivity.class);</span><br><span class="line">	<span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">	bundle.putBoolean(<span class="string">&quot;boolean_key&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">	bundle.putString(<span class="string">&quot;string_key&quot;</span>, <span class="string">&quot;string_value&quot;</span>);</span><br><span class="line">	intent.putExtra(<span class="string">&quot;key&quot;</span>, bundle);<span class="comment">// 封装对象</span></span><br><span class="line">	startActivity(intent);<span class="comment">// 启动新的 Activity</span></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line">	<span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span>getIntent();</span><br><span class="line">	<span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span>intent.getBundleExtra(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">	bundle.getBoolean(<span class="string">&quot;boolean_key&quot;</span>);</span><br><span class="line">	bundle.getString(<span class="string">&quot;string_key&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递自定义对象</span></span><br><span class="line"><span class="comment">// 方式1：实现Serializable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(FirstActivity.<span class="built_in">this</span>, SecondActivity.class);</span><br><span class="line">intent.putExtra(<span class="string">&quot;person_data&quot;</span>, person);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) getIntent().getSerializableExtra(<span class="string">&quot;person_data&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：实现Parcelable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">describeContents</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		dest.writeString(name);</span><br><span class="line">		dest.writeInt(age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Person&gt; CREATOR=<span class="keyword">new</span> <span class="title class_">Parcelable</span>.Creator&lt;Person&gt;() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Person <span class="title function_">createFromParcel</span><span class="params">(Parcel source)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			Person person=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">			person.name=source.readString();</span><br><span class="line">			person.age=source.readInt();</span><br><span class="line">			<span class="keyword">return</span> person;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Person[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>[size];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) getIntent().getParcelableExtra(<span class="string">&quot;person_data&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用startActivityForResult+setResult获取新Activity关闭后返回的数据<br>FirstActivity.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FirstActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_first);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	onClick(View v)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(FirstActivity.<span class="built_in">this</span>,SecondActivity.class);</span><br><span class="line">		<span class="comment">// startActivityForResult(Intent intent, int requestCode)</span></span><br><span class="line">		<span class="comment">// intent:跳转页面 requestCode：自定义int类型数值，用于判断源Activity</span></span><br><span class="line">		startActivityForResult(intent,MyConstants.REQUEST_CODE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重写 onActivityResult(int requestCode,int resultCode,Intent data)</span></span><br><span class="line">	<span class="comment">// 处理从目的Activity 返回的数据</span></span><br><span class="line">	<span class="meta">@override</span> </span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode,Intent data)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">super</span>.onActivityResult(requestCode,resultCode,data);</span><br><span class="line">		<span class="keyword">if</span>(requestCode == MyConstants.REQUEST_CODE &amp;&amp; resultCode == MyConstants.RESULT_OK)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> data.getStringExtra(MyConstants.REQUEST_DATA);</span><br><span class="line">			Log.i(data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecondActivity.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_second);</span><br><span class="line">	&#125;</span><br><span class="line">		...</span><br><span class="line">	onClick(View v)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">		intent.putExtra(MyConstants.REQUEST_DATA,<span class="string">&quot;Data From SecondActivity&quot;</span>);</span><br><span class="line">		<span class="comment">// 在setResult后，要调用finish()销毁当前的Activity</span></span><br><span class="line">		<span class="comment">// 才能返回到原Activity，执行原Activity的onActivityResult()函数</span></span><br><span class="line">		setResult(MyConstants.RESULT_OK,intent);</span><br><span class="line">		finish();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过直接访问类的静态变量实现</li>
<li>在Application（单例模式）设置应用的全局变量，可在程序中通过getApplication随时调用</li>
<li>使用EventBus插件传输数据量较大的数据<br>订阅者</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用EventBus的接收方法的Activity，需要注册监听</span></span><br><span class="line">	EventBus.getDefault().register(<span class="built_in">this</span>);</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册onEvent()监听事件</span></span><br><span class="line"><span class="comment">     * 加入注解加入注解Subscribe并指定线程模型为主线程MAIN（默认为POSTING）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Subscribe</span>（threadMode = ThreadMode.MAIN）</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(MyEvent event)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        popOutToast(<span class="string">&quot;接收到Event：&quot;</span> + event.msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>发布者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(<span class="keyword">new</span> <span class="title class_">MyEvent</span>(<span class="string">&quot;Event From Publisher&quot;</span>));</span><br></pre></td></tr></table></figure>

<ol>
<li>借助外部存储，如SharedPreference、Sqlite或者File等</li>
</ol>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>Activity的启动过程，我们可以从Context的startActivity说起，其实现是ContextImpl的startActivity，然后内部会通过Instrumentation来尝试启动Activity，这是一个跨进程过程，它会调用AMS的startActivity方法<br>当AMS校验完activity的合法性后，将activity入栈，并创建新的应用进程ActivityThread，这个过程是在ActivityStack里完成的，ActivityStack是运行在Server进程里的。<br>此时Server进程会通过ApplicationThread回调到我们的进程通知app进程ActivityThread绑定Application并启动Activity，这也是一次跨进程过程，而ApplicationThread就是一个binder，回调逻辑是在binder线程池中完成的，所以需要通过Handler H向主线程ActivityThread发送操作消息<br>绑定Application发送的消息是BIND_APPLICATION，对应的方法是handleBindApplication，该方法中对进程进行了配置，并创建及初始化了Application。启动Activity发送的消息是LAUNCH_ACTIVITY，对应的方法handleLaunchActivity，在这个方法里完成了Activity的创建和启动，回调Activity相关的周期方法。接着，在activity的onResume中，activity的内容将开始渲染到window上，然后开始绘制直到我们看见。</p>
<h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><p>Activity的启动模式有四种：standard、singleTop、singleTask和singleInstance。我们可以通过在AndroidManifest.xml的activity标签下通过launchMode属性指定想要设置的启动模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">&quot;.MainActivity&quot;</span></span><br><span class="line">			  android:launchMode=<span class="string">&quot;singleTop&quot;</span>&gt;...</span><br></pre></td></tr></table></figure>

<ol>
<li>standard（标准模式）<br>该启动模式为默认模式。标准模式下，只要启动一次Activity，不管该实例是否存在，系统都会在当前任务栈中新建一个Activity实例并将该实例置于栈顶。<br>该模式用于正常打开一个新的页面。使用最多，最普通。</li>
<li>singleTop（栈顶复用模式）<br>栈顶复用模式下，如果要启动的Activity已经处于栈的顶部，那么此时系统不会创建新的实例，而是复用栈顶的实例，同时它的onNewIntent()方法会被执行，我们可以通过Intent进行传值。否则会创建一个新的实例。<br>SingleTop适用于接受推送通知的内容显示页面，防止每点击一次通知重新打开重复页面。</li>
<li>singleTask（栈内复用模式）<br>栈内复用模式下，首先会根据taskAffinity去寻找对应的任务栈：<br>1、如果不存在指定的任务栈，系统会新建对应的任务栈，并新建一个Activity实例压入栈中。<br>2、如果存在指定的任务栈，则会查找该任务栈中是否存在该Activity实例<br>a、如果不存在该实例，则会在该任务栈中新建一个Activity实例压入栈中。<br>b、如果存在该实例，则将任务栈中该Activity实例之上的所有Activity出栈并将所需Activity置于栈顶。<br>SingleTask这种启动模式最常使用的就是一个APP的首页，因为一般为一个APP的第一个页面，且长时间保留在栈中，所以最适合设置singleTask启动模式来复用。</li>
<li>singleInstance（单例模式）<br>单例模式拥有singleTask（栈内复用）所有特性外且该Activity实例单独占用一个任务栈，具有全局唯一性。该模式启动的activity在系统中是单例的。如果已存在，则将它所在的任务栈调度到前台，进行复用。<br>适用于与程序分开，具有独立功能的页面，如闹铃提醒，电话拨号等。</li>
</ol>
<blockquote>
<p>任务栈 &amp; 任务<br>[Android 任务栈][Android]<br>可简单理解，一个应用程序对应一个任务，任务以栈的方式存储一系列与用户交互的Activity</p>
</blockquote>
<h3 id="状态保存-恢复"><a href="#状态保存-恢复" class="headerlink" title="状态保存 &amp; 恢复"></a>状态保存 &amp; 恢复</h3><ul>
<li>需要保存&#x2F;恢复Activity状态的场景<br>当一些异常的场景导致某个activity变得”容易”被系统销毁（而不是被用户主动销毁（如点击BACK键））时，系统 会调用onSaveInstanceState方法来给用户提供一个存储现场的机会。<br>这些场景包括：锁屏、点击home键、其他app进入前台、启动新的activity、（当前activity可能被销毁）横竖屏切换、由于内存不足app被杀死（一定被销毁）等。<br>当该activity被系统销毁后重启回到前台时，系统会调用onRestoreInstanceState恢复Activity中数据。</li>
<li>如何保存&#x2F;恢复Activity状态<br>我们通常在系统调用onSaveInstanceState(Bundle savedInstanceState)中,我们可以在该方法中用一组存储在Bundle对象中的键值对集合保存该Activity当前状态&#x2F;需要恢复的数据。当我们重启该Activity时，上述的Bundle对象会作为实参传递给onCreate()与onRestoreInstanceState(Bundle savedInstanceState)方法, 我们可以从Bundle对象中取出保存的数据, 然后利用这些数据将activity恢复到被摧毁之前的状态.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSaveInstanceState</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        savedInstanceState.putString(<span class="string">&quot;MyString&quot;</span>, <span class="string">&quot;Welcome back to Android&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.onSaveInstanceState(savedInstanceState);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">        <span class="type">String</span> <span class="variable">myString</span> <span class="operator">=</span> savedInstanceState.getString(<span class="string">&quot;MyString&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="启动方式-生命周期"><a href="#启动方式-生命周期" class="headerlink" title="启动方式 &amp; 生命周期"></a>启动方式 &amp; 生命周期</h3><ol>
<li>Service 有2种启动方式</li>
</ol>
<ul>
<li>startService()方式启动服务，调用者与Service没有关联。只有当Service调用stopSelf()或调用者调用stopService()才能停止服务。</li>
<li>bindService()方式启动服务，调用者与Servie绑定，可以与Service进行交互。当所有调用者退出后，Service会自动停止。</li>
</ul>
<ol>
<li>Service 有5种生命周期方法</li>
</ol>
<table> 
 <thead> 
  <tr> 
   <th>回调</th> 
   <th>描述</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>onStartCommand()</td> 
   <td>其他组件(如活动)通过调用startService()来请求启动服务时，系统调用该方法。如果你实现该方法，你有责任在工作完成时通过stopSelf()或者stopService()方法来停止服务。</td> 
  </tr> 
  <tr> 
   <td>onBind()</td> 
   <td>当其他组件想要通过bindService()来绑定服务时，系统调用该方法。如果你实现该方法，你需要返回IBinder对象来提供一个接口，以便客户来与服务通信。你必须实现该方法，如果你不允许绑定，则直接返回null。</td> 
  </tr> 
  <tr> 
   <td>onUnbind()</td> 
   <td>当客户中断所有服务发布的特殊接口时，系统调用该方法。</td> 
  </tr> 
  <tr> 
   <td>onCreate()</td> 
   <td>当服务通过onStartCommand()和onBind()被第一次创建的时候，系统调用该方法。该调用要求执行一次性安装。</td> 
  </tr> 
  <tr> 
   <td>onDestroy()</td> 
   <td>当服务不再有用或者被销毁时，系统调用该方法。你的服务需要实现该方法来清理任何资源，如线程，已注册的监听器，接收器等。</td> 
  </tr> 
 </tbody> 
</table>

<ol>
<li>Service的生命周期根据启动方式分3种情况</li>
</ol>
<ul>
<li>只用startService启动服务：onCreate-&gt; onStartCommand-&gt; onDestory</li>
<li>只用bindService绑定服务：onCreate-&gt; onBind-&gt; onUnBind-&gt; onDestory</li>
<li>同时用startService启动服务与用bindService绑定服务：onCreate-&gt; onStartCommnad-&gt; onBind-&gt; onUnBind-&gt; onDestory<br><img src="https://mark.cuckooing.cn/pics/pic_8620baef.png" alt="pic_8620baef.png"></li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>服务启动方式</th> 
   <th>startService</th> 
   <th>bindService</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>方法参数</td> 
   <td>Intent：用于启动服务</td> 
   <td>Intent：用于启动服务<br>ServiceConnection：Activity 和 Service 建立连接时通信使用</td> 
  </tr> 
  <tr> 
   <td>服务周期</td> 
   <td>启动服务后服务将一直在后台运行，即使 Activity 销毁依然存在</td> 
   <td>假如没有先 startService，bindService后绑定的最后一个 Activity 销毁时，service也将销毁，且bindService后的Service 在系统 Running 任务管理器下是看不见的。但先startService,接着 bindService 时，系统 Running 任务管理器显示该服务，Service 解绑后，onDestroy并不会得到运行</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="适用场景（Service-与-Thread-对比）"><a href="#适用场景（Service-与-Thread-对比）" class="headerlink" title="适用场景（Service 与 Thread 对比）"></a>适用场景（Service 与 Thread 对比）</h3><p>Service和Thread均没有界面，在后台运行。</p>
<table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>Service</th> 
   <th>Thread</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>运行线程</td> 
   <td>主线程</td> 
   <td>工作线程</td> 
  </tr> 
  <tr> 
   <td>依赖</td> 
   <td>不依赖Activity，所有Activity都可以与该Service关联</td> 
   <td>依赖某个Activity，在某个Activity创建进程，其他Activity无法获取</td> 
  </tr> 
  <tr> 
   <td>优先级</td> 
   <td>提高进程的优先级，系统不容易回收进程</td> 
   <td>在activity中开启的子线程按照优先级回收，易回收</td> 
  </tr> 
  <tr> 
   <td>适用场景</td> 
   <td>长期在后台运行的操作</td> 
   <td>activity中需要处理的耗时操作</td> 
  </tr> 
 </tbody> 
</table>

<p>Android 系统进程管理是按照一定规则的：应用程序一旦打开，为了下一次快速启动，关闭（清空任务栈）后进程不会停止。会带来内存不足的问题。Android系统有一套内存清理机制，根据进程优先级回收系统内存。服务的作用就是提高进程的优先级，使系统不容易回收进程。因此对于需要在后台长期运行的操作，不要在activity中开启子线程，应该创建服务，在服务里开启子线程。<br>如：长期在后台运行的没有界面的组件。如天气预报、股票显示（后台连接服务器的逻辑，每隔一段时间获取最新的（天气、股票）信息）、mp3播放器（后台长期播放音乐）等。</p>
<h3 id="Service-分类-使用"><a href="#Service-分类-使用" class="headerlink" title="Service 分类 &amp; 使用"></a>Service 分类 &amp; 使用</h3><ol>
<li>不可交互的后台服务<br>不可交互的后台服务即是普通的Service，通过startService()方式开启。Service的生命周期很简单，分别为onCreate、onStartCommand、onDestroy这三个。<br>音乐播放器案例，继承Service类实现自定义Service，提供在后台播放音乐、暂停音乐、停止音乐的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;MyService&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MediaPlayer mediaPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> startId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Control</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        PLAY, PAUSE, STOP</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (mediaPlayer == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            mediaPlayer = MediaPlayer.create(<span class="built_in">this</span>, R.raw.music);</span><br><span class="line">            mediaPlayer.setLooping(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onCreate&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.startId = startId;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onStartCommand---startId: &quot;</span> + startId);</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> intent.getExtras();</span><br><span class="line">        <span class="keyword">if</span> (bundle != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="type">Control</span> <span class="variable">control</span> <span class="operator">=</span> (Control) bundle.getSerializable(<span class="string">&quot;Key&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (control != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">switch</span> (control) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">case</span> PLAY:</span><br><span class="line">                        play();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> PAUSE:</span><br><span class="line">                        pause();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> STOP:</span><br><span class="line">                        stop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onDestroy&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (mediaPlayer != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            mediaPlayer.stop();</span><br><span class="line">            mediaPlayer.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (!mediaPlayer.isPlaying()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            mediaPlayer.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pause</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (mediaPlayer != <span class="literal">null</span> &amp;&amp; mediaPlayer.isPlaying()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            mediaPlayer.pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (mediaPlayer != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            mediaPlayer.stop();</span><br><span class="line">        &#125;</span><br><span class="line">        stopSelf(startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onBind&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Not yet implemented&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①Service不运行在一个独立的进程中，它同样执行在UI线程中，因此，在Service中创建了子线程来完成耗时操作。<br>②当Service关闭后，如果在onDestory()方法中不关闭线程，你会发现我们的子线程进行的耗时操作是一直存在的，此时关闭该子线程的方法需要直接关闭该应用程序。因此，在onDestory()方法中要进行必要的清理工作。<br>（2）在清单文件中声明Service，为其添加label标签，便于在系统中识别Service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">          android:name=<span class="string">&quot;.MyService&quot;</span></span><br><span class="line">          android:label=<span class="string">&quot;@string/app_name&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>如果想配置成远程服务，加如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:process=<span class="string">&quot;remote&quot;</span></span><br></pre></td></tr></table></figure>

<p>（3）Activity中在布局中添加三个按钮，用于控制音乐播放、暂停与停止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playMusic</span><span class="params">(View view)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyService.class);</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        bundle.putSerializable(<span class="string">&quot;Key&quot;</span>, MyService.Control.PLAY);</span><br><span class="line">        intent.putExtras(bundle);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pauseMusic</span><span class="params">(View view)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyService.class);</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        bundle.putSerializable(<span class="string">&quot;Key&quot;</span>, MyService.Control.PAUSE);</span><br><span class="line">        intent.putExtras(bundle);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopMusic</span><span class="params">(View view)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyService.class);</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        bundle.putSerializable(<span class="string">&quot;Key&quot;</span>, MyService.Control.STOP);</span><br><span class="line">        intent.putExtras(bundle);</span><br><span class="line">        startService(intent);</span><br><span class="line">        <span class="comment">//或者是直接如下调用</span></span><br><span class="line">        <span class="comment">//Intent intent = new Intent(this, MyService.class);</span></span><br><span class="line">        <span class="comment">//stopService(intent);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>可交互的后台服务<br>可交互的后台服务是指前台页面可以调用后台服务的方法，通过bindService()方式开启。Service的生命周期很简单，分别为onCreate、onBind、onUnBind、onDestroy这四个。</li>
</ol>
<ul>
<li>创建服务类<br>和普通Service不同在于这里返回一个代理对象，返回给前台进行获取，即前台可以获取该代理对象执行后台服务的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//返回MyBinder对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBinder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要返回给前台的Binder类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyBinder</span> <span class="keyword">extends</span> <span class="title class_">Binder</span> <span class="keyword">implements</span> <span class="title class_">IService</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showTip</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;我是来此服务的提示&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>前台调用<br>通过以下方式绑定服务：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bindService(mIntent,con,BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>

<p>当建立绑定后，onServiceConnected中的service便是Service类中onBind的返回值。如此便可以调用后台服务类的方法，实现交互。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            BackService.<span class="type">MyBinder</span> <span class="variable">myBinder</span> <span class="operator">=</span> (BackService.MyBinder) service;</span><br><span class="line">            myBinder.showTip();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>可参考回调方式实现与Activity交互案例</p>
<ol>
<li>前台服务<br>所谓前台服务只不是通过一定的方式将服务所在的进程级别提升了。前台服务会一直有一个正在运行的图标在系统的状态栏显示，非常类似于通知的效果。<br>由于后台服务优先级相对比较低，当系统出现内存不足的情况下，它就有可能会被回收掉，所以前台服务就是来弥补这个缺点的，它可以一直保持运行状态而不被系统回收。<br>创建服务类<br>前台服务创建很简单，其实就在Service的基础上创建一个Notification，然后使用Service的startForeground()方法即可启动为前台服务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeService</span> <span class="keyword">extends</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        beginForeService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">beginForeService</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//创建通知</span></span><br><span class="line">        Notification.<span class="type">Builder</span> <span class="variable">mBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notification</span>.Builder(<span class="built_in">this</span>)</span><br><span class="line">                .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                .setContentText(<span class="string">&quot;2017-2-27&quot;</span>)</span><br><span class="line">                .setContentText(<span class="string">&quot;您有一条未读短信...&quot;</span>);</span><br><span class="line">        <span class="comment">//创建点跳转的Intent(这个跳转是跳转到通知详情页)</span></span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>,NotificationShow.class);</span><br><span class="line">        <span class="comment">//创建通知详情页的栈</span></span><br><span class="line">        <span class="type">TaskStackBuilder</span> <span class="variable">stackBulider</span> <span class="operator">=</span> TaskStackBuilder.create(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//为其添加父栈 当从通知详情页回退时，将退到添加的父栈中</span></span><br><span class="line">        stackBulider.addParentStack(NotificationShow.class);</span><br><span class="line">        <span class="type">PendingIntent</span> <span class="variable">pendingIntent</span> <span class="operator">=</span> stackBulider.getPendingIntent(<span class="number">0</span>,PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">        <span class="comment">//设置跳转Intent到通知中</span></span><br><span class="line">        mBuilder.setContentIntent(pendingIntent);</span><br><span class="line">        <span class="comment">//获取通知服务</span></span><br><span class="line">        <span class="type">NotificationManager</span> <span class="variable">nm</span> <span class="operator">=</span> (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">        <span class="comment">//构建通知</span></span><br><span class="line">        <span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> mBuilder.build();</span><br><span class="line">        <span class="comment">//显示通知</span></span><br><span class="line">        nm.notify(<span class="number">0</span>,notification);</span><br><span class="line">        <span class="comment">//启动前台服务</span></span><br><span class="line">        startForeground(<span class="number">0</span>,notification);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动前台服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startService(<span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, ForeService.class));</span><br></pre></td></tr></table></figure>

<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><ul>
<li>定义<br>由于Service默认运行在主线程中，所以如果直接在服务中处理耗时操作，容易出现ANR。此时可引用IntentService。<br>IntentService本质上是一个封装了HandlerThread+Service的异步框架，继承自Service。在使用完后会自动停止，适合需要在工作线程中按先后顺序，处理UI无关&#x2F;后台 的耗时任务的场景，如离线下载。</li>
</ul>
<blockquote>
<p>不适用于多个数据同时请求的场景，因为所有的任务都在同一个Thread loop里执行，故按照先后顺序。</p>
</blockquote>
<ul>
<li>使用<br>（1）定义IntentService子类，构造方法传入线程名称，复写onHandleIntent()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myIntentService</span> <span class="keyword">extends</span> <span class="title class_">IntentService</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">myIntentService</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 1. 调用父类的构造函数，传入工作线程的名字</span></span><br><span class="line">		<span class="built_in">super</span>(<span class="string">&quot;myIntentService&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onHandleIntent</span><span class="params">(Intent intent)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 2. 复写onHandleIntent()方法，根据intent请求处理 耗时操作</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">taskName</span> <span class="operator">=</span> intent.getExtras().getString(<span class="string">&quot;taskName&quot;</span>);</span><br><span class="line">		<span class="comment">// 从intent 中获取不同事务，根据不同事务进行处理</span></span><br><span class="line">		<span class="keyword">switch</span>(taskName)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;task1&quot;</span>:</span><br><span class="line">				Log.i(<span class="string">&quot;myIntentService&quot;</span>,<span class="string">&quot;do task1&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;task2&quot;</span>:</span><br><span class="line">				Log.i(<span class="string">&quot;myIntentService&quot;</span>,<span class="string">&quot;do task2&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">super</span>.onCreate();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent,<span class="type">int</span> flags,<span class="type">int</span> startId)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 复写onStartCommand方法，默认 = 将请求的Intent添加到工作队列中</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.onStartCommand(intent,flags,startId);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">super</span>.onDestroy();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// IntentService中，onBind()默认返回null</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在AndroidManifest.xml中注册服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=<span class="string">&quot;.myIntentService&quot;</span>&gt;</span><br><span class="line">            &lt;intent-filter &gt;</span><br><span class="line">                &lt;action android:name=<span class="string">&quot;cn.scu.finch&quot;</span>/&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/service&gt;</span><br></pre></td></tr></table></figure>

<p>（3）在Activity中开启服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同一服务只会开启1个工作线程,在onHandleIntent（）函数里，依次处理传入的Intent请求</span></span><br><span class="line">            <span class="comment">// 将请求通过Bundle对象传入到Intent，再传入到服务里</span></span><br><span class="line">            <span class="comment">// 请求1</span></span><br><span class="line">            <span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;cn.scu.finch&quot;</span>);	<span class="comment">// 通过意图过滤器找到服务</span></span><br><span class="line">            <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">            bundle.putString(<span class="string">&quot;taskName&quot;</span>, <span class="string">&quot;task1&quot;</span>);</span><br><span class="line">            i.putExtras(bundle);</span><br><span class="line">            startService(i);	<span class="comment">// 输出 do task1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求2</span></span><br><span class="line">            <span class="type">Intent</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;cn.scu.finch&quot;</span>);</span><br><span class="line">            <span class="type">Bundle</span> <span class="variable">bundle2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">            bundle2.putString(<span class="string">&quot;taskName&quot;</span>, <span class="string">&quot;task2&quot;</span>);</span><br><span class="line">            i2.putExtras(bundle2);</span><br><span class="line">            startService(i2);	<span class="comment">// 输出 do task2</span></span><br><span class="line">			<span class="comment">// 多次启动服务</span></span><br><span class="line">            startService(i);  <span class="comment">// 输出 do task1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果<br><img src="https://mark.cuckooing.cn/pics/pic_45332b57.png" alt="pic_45332b57.png"><br>一个服务只会创建一次onCreate，只会开启一个工作线程。在onHandleIntent中依次处理传入的Intent</p>
<ul>
<li>源码分析<br><img src="https://mark.cuckooing.cn/pics/pic_aa8c0cc4.png" alt="pic_aa8c0cc4.png"><br>IntentService本质上是一个封装了HandlerThread+Service的异步框架。若启动IntentService 多次，但只创建一个工作线程，因此 每个耗时操作 则 以队列的方式 在 IntentService的 onHandleIntent回调方法中依次执行，执行完自动结束。</li>
<li>onCreate<br>（1）IntentService 通过 HandlerThread 开启一个新的工作线程 ServiceThread<br>（2）创建1个内部 Handler：ServiceHandler，并将ServiceHandler 与 ServiceThread 绑定，接受这个工作线程的消息队列中的消息，重写onHandleIntent()依次处理这些消息（根据Intent 的不同执行不同操作）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="built_in">super</span>.onCreate();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 通过实例化HandlerThread新建线程 &amp; 启动；故 使用IntentService时，不需额外新建线程</span></span><br><span class="line">    <span class="comment">// HandlerThread继承自Thread，内部封装了 Looper</span></span><br><span class="line">    <span class="comment">// 创建HandlerThread类对象 = 创建Thread类对象 + 设置线程优先级 = 新开1个工作线程 + 设置线程优先级</span></span><br><span class="line">    <span class="type">HandlerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;IntentService[&quot;</span> + mName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2. 获得工作线程的 Looper &amp; 维护自己的工作队列</span></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 新建mServiceHandler &amp; 绑定上述获得Looper</span></span><br><span class="line">    <span class="comment">// 新建的Handler 属于工作线程 -&gt;&gt;分析1</span></span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> <span class="title class_">ServiceHandler</span>(mServiceLooper); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 分析1：ServiceHandler源码分析</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">         <span class="comment">// 构造函数，与新建工作线程的looper（&amp;MessegeQueue）绑定</span></span><br><span class="line">         <span class="keyword">public</span> <span class="title function_">ServiceHandler</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">         <span class="built_in">super</span>(looper);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// IntentService的handleMessage（）把从工作线程的Looper接收的消息交给onHandleIntent()处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// onHandleIntent 方法在工作线程中执行</span></span><br><span class="line">          <span class="comment">// onHandleIntent() = 抽象方法，使用时需重写 -&gt;&gt;分析2</span></span><br><span class="line">          onHandleIntent((Intent)msg.obj);</span><br><span class="line">          <span class="comment">// 执行完调用 stopSelf() 结束服务</span></span><br><span class="line">          stopSelf(msg.arg1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 分析2： onHandleIntent()源码分析</span></span><br><span class="line"><span class="comment">     * onHandleIntent() = 抽象方法，使用时需开发者重写</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">      <span class="meta">@WorkerThread</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">onHandleIntent</span><span class="params">(Intent intent)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>onStartCommand<br>IntentService将Intent传递给ServiceHandler &amp; 依次插入到工作队列 &amp; 逐个发送给onHandleIntent()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * onStartCommand（）源码分析</span></span><br><span class="line"><span class="comment">  * onHandleIntent() = 抽象方法，使用时需重写</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用onStart（）-&gt;&gt;分析1</span></span><br><span class="line">    onStart(intent, startId);</span><br><span class="line">    <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 分析1：onStart(intent, startId)</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(Intent intent, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 1. 获得ServiceHandler消息的引用</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 把 Intent参数 包装到 message 的 obj 发送消息中，</span></span><br><span class="line">    <span class="comment">//这里的Intent  = 启动服务时startService(Intent) 里传入的 Intent</span></span><br><span class="line">    msg.obj = intent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 发送消息，即 添加到消息队列里</span></span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>IntentService只会创建一个工作任务队列，因此多次启动 IntentService 时，每一个耗时操作（通过Intent逐一发送请求）会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，会按串行的方式顺序执行事件。<br>即 若一个任务正在IntentService中执行，此时你再发送1个新的任务请求，这个新的任务会一直等待直到前面一个任务执行完毕后才开始执行</p>
</blockquote>
<ul>
<li>IntentService &amp; Service 区别</li>
</ul>
<table> 
 <tbody> 
  <tr> 
   <td></td> 
   <td>IntentService</td> 
   <td>Service</td> 
  </tr> 
  <tr> 
   <td>运行线程</td> 
   <td>创建一个独立的工作线程处理异步任务（耗时操作）</td> 
   <td>主线程</td> 
  </tr> 
  <tr> 
   <td>结束服务操作</td> 
   <td>需手动调用stopService()</td> 
   <td>处理完所有intent请求后，系统自动关闭服务</td> 
  </tr> 
  <tr> 
   <td>联系</td> 
   <td colspan="2">IntentService继承自Service<br>IntentService为Service的onBind()默认实现：return null<br>IntentService为Service的onStartCommand()提供默认实现：将请求的intent添加到队列</td> 
  </tr> 
 </tbody> 
</table>

<ul>
<li>IntentService &amp; 其他线程 区别</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>作用</th> 
   <th>优先级</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>IntentService</td> 
   <td>后台线程，提供服务（继承自Service）</td> 
   <td>高</td> 
  </tr> 
  <tr> 
   <td>其他线程</td> 
   <td>工作线程，处理异步任务</td> 
   <td>低，容易被系统杀死</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="Service和Activity-通信"><a href="#Service和Activity-通信" class="headerlink" title="Service和Activity 通信"></a>Service和Activity 通信</h3><p>Service与Activity有2种方式进行通信：</p>
<ol>
<li>bindService + 回调函数<br>Activity调用bindService方法，绑定一个Service。通过实例化ServiceConnection接口内部类监听的方法获取Service中的Binder对象,并将该接口传给binderService方法。如果想实现主动通知Activity的，还可以在Service中添加回调方法。<br>（1）新建一个回调接口，通过回调接口实现当Service中进度发生变化主动通知Activity更新UI</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnProgressListener</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onProgress</span><span class="params">(<span class="type">int</span> progress)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）新建一个Service类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PROGRESS</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//进度条最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">progress</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//进度条进度值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnProgressListener onProgressListener;<span class="comment">//更新进度的回调接口</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnProgressListener</span><span class="params">(OnProgressListener onProgressListener)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     	<span class="comment">//注册回调接口的方法，供外部调用</span></span><br><span class="line">        <span class="built_in">this</span>.onProgressListener = onProgressListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getProgress</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//增加get()方法，供Activity调用,返回progress</span></span><br><span class="line">        <span class="keyword">return</span> progress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟下载任务，每秒钟更新一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startDownLoad</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">while</span>(progress &lt; MAX_PROGRESS)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    progress += <span class="number">5</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//进度发生变化通知调用方</span></span><br><span class="line">                    <span class="keyword">if</span>(onProgressListener != <span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        onProgressListener.onProgress(progress);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MsgBinder</span>();<span class="comment">//返回Binder对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgBinder</span> <span class="keyword">extends</span> <span class="title class_">Binder</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">public</span> MsgService <span class="title function_">getService</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> MsgService.<span class="built_in">this</span>;<span class="comment">//返回当前service对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）Activity中新建一个ServiceConnection对象，它是一个接口，Activity与Service绑定后，在onServiceConnected回调方法中返回服务对象。<br>onServiceConnected用于执行Activity与Service绑定后执行相关操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> MsgService msgService;</span><br><span class="line">    <span class="keyword">private</span> ProgressBar mProgressBar;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定Service</span></span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.example.communication.MSG_ACTION&quot;</span>);</span><br><span class="line">        bindService(intent, conn, Context.BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line">        mProgressBar = (ProgressBar) findViewById(R.id.progressBar1);</span><br><span class="line">        <span class="type">Button</span> <span class="variable">mButton</span> <span class="operator">=</span> (Button) findViewById(R.id.button1);</span><br><span class="line">        mButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//开始下载</span></span><br><span class="line">                msgService.startDownLoad();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServiceConnection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//返回一个MsgService对象</span></span><br><span class="line">            msgService = ((MsgService.MsgBinder)service).getService();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注册回调接口来接收下载进度的变化</span></span><br><span class="line">            msgService.setOnProgressListener(<span class="keyword">new</span> <span class="title class_">OnProgressListener</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProgress</span><span class="params">(<span class="type">int</span> progress)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    mProgressBar.setProgress(progress);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        unbindService(conn);</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>广播（推荐LocalBroadcastManager）<br>Activity调用registerReceive注册广播接收器，通过startService启动一个Service，之后Service调用sendBoardcast向Activity发送广播。Activity则通过onReceive方法接收Service发送的消息。</li>
</ol>
<h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>ContentProvider主要用于在不同的应用程序之间实现数据共享的功能。<br>ContentProvider&#x3D;中间者角色（搬运工），真正存储&amp;操作数据的数据源为原来存储数据的方式（数据库（sqlite）、文件、XML、网络等等）<br>ContentProvider一般为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据。<br>它的设计用意在于：<br>（1）对底层数据库的抽象<br>对数据进行封装，提供统一的接口。使用者不必关心这些数据来源于数据库、XML、Preferences或请求。当项目改变数据来源时,不会对使用代码产生影响。<br>（2）提供一种跨进程数据共享方式<br>数据在多个应用程序中共享，当一个应用程序改变共享数据时候，可用ContentResolver接口的notifyChange函数通知那些注册了监控该URI的ContentObserver对象，去通知其他应用程序共享数据被修改了，使得它们可以相应地执行一些处理。<br>（3）用安全的方式对数据进行封装<br>是ContentProvider为应用间的数据交互提供了一个安全的环境。它准许你把自己的应用数据根据需求开放给其他应用进行增、删、改、查。通过android:exported属性指示该服务是否能够被其他应用程序组件调用或跟它交互，通过permission属性对于需要开放的组件设置合理的权限，通过path-permission可开放部分uri进行共享。<br><img src="https://mark.cuckooing.cn/pics/pic_be05248f.png" alt="pic_be05248f.png"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>使用原理<br>内容提供者是一种跨应用访问数据库的方式。一个应用可以通过内容提供者将自己的私有数据暴露出来，其他应用通过内容解析者对数据进行增删改查等操作。</li>
<li>使用场景<br>由于ContentProvider是向其他应用暴露数据库接口，不能保证应用所定义的数据库的安全性。因此往往不用于自定义数据库。适用于获取系统数据库的接口，如短信数据库、联系人数据库。</li>
<li>实例</li>
</ol>
<ul>
<li>自定义Sqlite数据库<br>（1）创建数据库类 集成SQLiteOpenHelper</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBHelper</span> <span class="keyword">extends</span> <span class="title class_">SQLiteOpenHelper</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DATABASE_NAME</span> <span class="operator">=</span> <span class="string">&quot;finch.db&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER_TABLE_NAME</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JOB_TABLE_NAME</span> <span class="operator">=</span> <span class="string">&quot;job&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DATABASE_VERSION</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//数据库版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DBHelper</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>(context, DATABASE_NAME, <span class="literal">null</span>, DATABASE_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(SQLiteDatabase db)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个表格:用户表 和职业表</span></span><br><span class="line">        db.execSQL(<span class="string">&quot;CREATE TABLE IF NOT EXISTS &quot;</span> + USER_TABLE_NAME + <span class="string">&quot;(_id INTEGER PRIMARY KEY AUTOINCREMENT,&quot;</span> + <span class="string">&quot; name TEXT)&quot;</span>);</span><br><span class="line">        db.execSQL(<span class="string">&quot;CREATE TABLE IF NOT EXISTS &quot;</span> + JOB_TABLE_NAME + <span class="string">&quot;(_id INTEGER PRIMARY KEY AUTOINCREMENT,&quot;</span> + <span class="string">&quot; job TEXT)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="type">int</span> oldVersion, <span class="type">int</span> newVersion)</span>   &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）自定义ContentProvider 子类，继承自ContentProvider。并在清单文件中配置内容提供者<br>MyProvider.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProvider</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="type">DBHelper</span> <span class="variable">mDbHelper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 设置ContentProvider的唯一标识，与清单文件 android:authority对应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AUTHORITY</span> <span class="operator">=</span> <span class="string">&quot;cn.scu.myprovider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">User_Code</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">Job_Code</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UriMatcher类 路径匹配器:在ContentProvider 中注册URI</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher mMatcher;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mMatcher = <span class="keyword">new</span> <span class="title class_">UriMatcher</span>(UriMatcher.NO_MATCH);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        mMatcher.addURI(AUTOHORITY,<span class="string">&quot;user&quot;</span>, User_Code);</span><br><span class="line">        mMatcher.addURI(AUTOHORITY, <span class="string">&quot;job&quot;</span>, Job_Code);</span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user ，则返回注册码User_Code</span></span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/job ，则返回注册码Job_Code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下是ContentProvider的6个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        mContext = getContext();</span><br><span class="line">        <span class="comment">// 在ContentProvider创建时对数据库进行初始化</span></span><br><span class="line">        <span class="comment">// 运行在主线程，故不能做耗时操作,此处仅作展示</span></span><br><span class="line">        <span class="comment">// 因为实现对数据库的增删改查操作，因此操作数据必须获得SQLiteDatabase对象</span></span><br><span class="line">        mDbHelper = <span class="keyword">new</span> <span class="title class_">DBHelper</span>(getContext());</span><br><span class="line">        db = mDbHelper.getWritableDatabase();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化两个表的数据(先清空两个表,再各加入一个记录)</span></span><br><span class="line">        db.execSQL(<span class="string">&quot;delete from user&quot;</span>);</span><br><span class="line">        db.execSQL(<span class="string">&quot;insert into user values(1,&#x27;Carson&#x27;);&quot;</span>);</span><br><span class="line">        db.execSQL(<span class="string">&quot;insert into user values(2,&#x27;Kobe&#x27;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">        db.execSQL(<span class="string">&quot;delete from job&quot;</span>);</span><br><span class="line">        db.execSQL(<span class="string">&quot;insert into job values(1,&#x27;Android&#x27;);&quot;</span>);</span><br><span class="line">        db.execSQL(<span class="string">&quot;insert into job values(2,&#x27;iOS&#x27;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> getTableName(uri);</span><br><span class="line">        <span class="comment">// 向该表添加数据，返回值代表插入的行数 index</span></span><br><span class="line">        db.insert(table, <span class="literal">null</span>, values);</span><br><span class="line">        <span class="comment">// 当该URI的ContentProvider数据发生变化时，通知外界（即访问该ContentProvider数据的访问者）</span></span><br><span class="line">        mContext.getContentResolver().notifyChange(uri, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span><br><span class="line"><span class="params">                        String[] selectionArgs, String sortOrder)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> getTableName(uri);</span><br><span class="line">        <span class="comment">// 查询数据（即实现对数据库的查询操作）这里cursor不能关闭</span></span><br><span class="line">        <span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> db.query(table,projection,selection,selectionArgs,<span class="literal">null</span>,<span class="literal">null</span>,sortOrder,<span class="literal">null</span>);</span><br><span class="line">		<span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span><br><span class="line"><span class="params">                      String[] selectionArgs)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 更新操作，返回值代表影响的行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">updRows</span> <span class="operator">=</span> db.update(table, values, selection, selectionArgs);</span><br><span class="line">        <span class="keyword">return</span> updRows;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="comment">// 删除操作，返回值代表影响的行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">delRows</span> <span class="operator">=</span> db.delete(table, selection, selectionArgs);</span><br><span class="line">        <span class="keyword">return</span> delRows;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getTableName</span><span class="params">(Uri uri)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (mMatcher.match(uri)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">case</span> User_Code:</span><br><span class="line">                tableName = DBHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Job_Code:</span><br><span class="line">                tableName = DBHelper.JOB_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>AndroidManifest.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider android:name=<span class="string">&quot;MyProvider&quot;</span></span><br><span class="line">                android:authorities=<span class="string">&quot;cn.scu.myprovider&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>（3）由于第一个应用的私有数据库已通过ContentProvider暴露，因此第二个应用可以使用内容解析者对数据进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// 设置URI，对user表进行操作（与定义的路径一致）</span></span><br><span class="line">        <span class="type">Uri</span> <span class="variable">uri_user</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://cn.scu.myprovider/user&quot;</span>);</span><br><span class="line">        <span class="comment">// 插入表中数据 ContentValues</span></span><br><span class="line">        <span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">        values.put(<span class="string">&quot;_id&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        values.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Iverson&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取ContentResolver（直接通过上下文获取） &amp; 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        <span class="type">ContentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span>  getContentResolver();</span><br><span class="line">        resolver.insert(uri_user,values);</span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        <span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> resolver.query(uri_user, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     <span class="string">&quot;_id&quot;</span>,<span class="string">&quot;name&quot;</span>&#125;, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext())&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;query book:&quot;</span> + cursor.getInt(<span class="number">0</span>) +<span class="string">&quot; &quot;</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 将表中数据全部输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line">        <span class="comment">// 关闭游标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改URI,对JOB表操作,从而匹配不同的URI CODE,从而找到不同的数据资源</span></span><br><span class="line">        <span class="type">Uri</span> <span class="variable">uri_job</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://cn.scu.myprovider/job&quot;</span>);</span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        <span class="type">ContentValues</span> <span class="variable">values2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">        values2.put(<span class="string">&quot;_id&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        values2.put(<span class="string">&quot;job&quot;</span>, <span class="string">&quot;NBA Player&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        <span class="type">ContentResolver</span> <span class="variable">resolver2</span> <span class="operator">=</span>  getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver2.insert(uri_job,values2);</span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        <span class="type">Cursor</span> <span class="variable">cursor2</span> <span class="operator">=</span> resolver2.query(uri_job, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     <span class="string">&quot;_id&quot;</span>,<span class="string">&quot;job&quot;</span>&#125;, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor2.moveToNext())&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;query job:&quot;</span> + cursor2.getInt(<span class="number">0</span>) +<span class="string">&quot; &quot;</span>+ cursor2.getString(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 将表中数据全部输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        cursor2.close();</span><br><span class="line">        <span class="comment">// 关闭游标</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>系统短信数据库<br>系统短信目录位于com.android.provider.telephony内的mmssms.db（Provider 管理的私有数据库包括 com.android.provider.* 如applications、calendar、downloads等等）<br>权限 -rw-rw—- 对一般用户不可读不可写不可执行（完全私有）&#x3D;&gt; 通过ContentProvider 暴露接口。</li>
</ul>
<blockquote>
<p>linux 文件访问权限<br>Linux的文件访问权限分为 读、写、执行三种：<br>drwxr-xr-x意思如下：<br>第一位表示文件类型：<br>d是目录文件，l是链接文件，-是普通文件，p是管道。<br>后面分为三个三位来看，分别表示不同用户的权限：<br>第一个 rwx： root ：r 是可读，w 是可写，x 是可执行，rwx 意思是可读可写可执行。<br>第二个 r-x： 一般用户（用户组）：r-x 是可读可执行不可写。<br>第三个 r-x： 其他用户，r-x 是可读可执行不可写。<br>综合起来就是权限设置为：文件所有者（root）可读可写可执行，与文件所有者同属一个用户组的其他用户可读可执行，其它用户组可读可执行。<br><img src="https://mark.cuckooing.cn/pics/pic_f4397b07.png" alt="pic_f4397b07.png"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">(View v)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="comment">// 由于短信数据库 系统通过ContentProvider 将接口暴露出来，因此可以直接通过ContentResolver 操作数据（SmsProvider extends ContentProvider 系统上层应用源码）</span></span><br><span class="line">	<span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://sms/&quot;</span>);</span><br><span class="line">	<span class="comment">// 1. 往短信数据库里插入一条数据</span></span><br><span class="line">	<span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">	values.put(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;95555&quot;</span>);</span><br><span class="line">	values.put(<span class="string">&quot;body&quot;</span>,<span class="string">&quot;您的余额为 0.00 元&quot;</span>);</span><br><span class="line">	values.put(<span class="string">&quot;data&quot;</span>,System.currentTimeMillis());</span><br><span class="line">	getContentResolver().insert(uri,values);</span><br><span class="line">	<span class="comment">// 2. 查询短信数据内容</span></span><br><span class="line">	<span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> getContentResolver().query(uri,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     <span class="string">&quot;address&quot;</span>,<span class="string">&quot;data&quot;</span>,<span class="string">&quot;body&quot;</span>&#125;,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">	<span class="keyword">while</span> (cursor.moveToNext())&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;result:&quot;</span> + cursor.getString(<span class="number">0</span>) +<span class="string">&quot; &quot;</span>+ cursor.getString(<span class="number">1</span>) + <span class="string">&quot; &quot;</span> + cursor.getString(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得申请权限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.WRITE_SMS&quot;</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.READ_SMS&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><ul>
<li>BoardcastReceiver 简介<br>BroadcastReceiver是一个全局监听器，用于监听应用间&#x2F;应用内发出的广播消息，并作出响应。分为广播发送者和广播接受者。<br>系统在特定场景会发送广播，如电量低、插入耳机、状态改变等等。每个应用程序都会收到；应用程序也可以发送广播用来通知其他APP状态变化；<br>如果我们的应用程序想接收特定的广播并执行相关操作，便可注册一个BroadcastReceiver进行监听对应的广播，并在onReceive中执行操作。</li>
<li>BoardcaseReceiver 原理<br>Android中广播使用设计模式中观察者模式，基于消息的发布&#x2F;订阅事件模型。模型中有3个角色：消息订阅者（广播接受者）、消息发布者（广播发布者）、消息中心（AMS）<br><img src="https://mark.cuckooing.cn/pics/pic_cf531cef.png" alt="pic_cf531cef.png"></li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><table> 
 <thead> 
  <tr> 
   <th>类型</th> 
   <th>介绍</th> 
   <th>使用</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>普通广播</td> 
   <td>自定义广播为开发者自身定义的广播。</td> 
   <td>开发者定义广播的intent，并通过sendBroadcast（）方法发送。</td> 
  </tr> 
  <tr> 
   <td>系统广播</td> 
   <td>Android中内置了多个系统广播：包括手机的状态变化与基本操作（如开机、网络状态变化、电量状况、拍照等等），都会发出相应的广播。（每个广播都有特定的Intent - Filter（包括具体的action））。</td> 
   <td>当使用系统广播时，只需要在注册广播接收者时定义相关的action即可，并不需要手动发送广播，当系统有相关操作时会自动进行系统广播</td> 
  </tr> 
  <tr> 
   <td>有序广播</td> 
   <td>有序广播通过sendOrderedBroadcast发送，发送出去的广播根据广播接受者的优先级Priority按先后顺序接收。广播在发送过程中可被优先级较高的接受者拦截并修改再传给下一接受者。</td> 
   <td>sendOrderedBroadcast(intent);</td> 
  </tr> 
  <tr> 
   <td>无序广播</td> 
   <td>无序广播直接通过sendBroadcast发送，发送的广播不可被拦截也无法被修改。</td> 
   <td>sendBroadcast(intent);</td> 
  </tr> 
  <tr> 
   <td>全局广播</td> 
   <td>在应用间、应用与系统间、应用内部进行通信的一种方式。</td> 
   <td>默认BroadcastReceiver是跨应用广播</td> 
  </tr> 
  <tr> 
   <td>本地广播</td> 
   <td>本地广播仅能在自己应用内发送、接收广播。即发送的广播只能在自身app传播，且接收不到其他app发送的广播。故更加安全与高效。</td> 
   <td>（1）注册广播时将exported属性设置为false，使得非本App内部发出的此广播不被接收；（2）在广播发送和接收时，增设相应权限permission，用于权限验证；（3）发送广播时指定该广播接收器所在的包名，此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。（通过intent.setPackage(packageName)指定报名）（4）使用封装好的LocalBroadcastManager类</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h3><table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>静态注册</th> 
   <th>动态注册</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>使用</td> 
   <td>在AndroidManifest中通过标签声明，应用首次启动后，系统会自动实例化广播接收器实例并注册到广播系统中。</td> 
   <td>在代码中调用Context.registerReceiver()方法完成注册。</td> 
  </tr> 
  <tr> 
   <td>特点</td> 
   <td>广播常驻后台，不会随着其他组件的消亡而变化，当应用程序关闭后，如果有广播，应用程序仍会被系统调用。这样的话不仅占用内存，而且会增加应用的耗电量。</td> 
   <td>广播非常驻后台，生命周期灵活可控。注册和注销的过程需要开发者自己手动完成。为了避免内存泄漏，当广播不再使用时，开发者需要手动注销广播。</td> 
  </tr> 
  <tr> 
   <td>场景</td> 
   <td>适用于需要时刻监听广播的场景</td> 
   <td>需要特定时刻监听广播</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="使用方式：发送-接受-屏蔽-广播"><a href="#使用方式：发送-接受-屏蔽-广播" class="headerlink" title="使用方式：发送\接受\屏蔽 广播"></a>使用方式：发送\接受\屏蔽 广播</h3><ol>
<li>发送广播<br>开发者自定义intent广播并发送</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line"><span class="comment">// 广播通过 意图（Intent） 标识</span></span><br><span class="line"><span class="comment">// 对应BroadcastReceiver中intentFilter的action，只有action相同的广播接受者才能收到广播</span></span><br><span class="line">intent.setAction(BROADCAST_ACTION);</span><br><span class="line"><span class="comment">// 发送广播</span></span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<ol>
<li>接收广播</li>
</ol>
<ul>
<li>静态&#x2F;动态注册广播接收器<br>静态注册——在AndroidManifest.xml里通过标签声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此广播接收者类是mBroadcastReceiver</span></span><br><span class="line">&lt;receiver </span><br><span class="line">    android:name=<span class="string">&quot;.mBroadcastReceiver&quot;</span> &gt;</span><br><span class="line">	<span class="comment">//用于指定此广播接收器将接收的广播类型</span></span><br><span class="line">	<span class="comment">//本示例中给出的是用于接收网络状态改变时发出的广播</span></span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>

<p>通过过滤器匹配自定义广播：对于自定义广播接收者中注册时intentFilter的action与上述匹配，则会接收此广播（即进行回调onReceive()）。如下mBroadcastReceiver则会接收对应action广播</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此广播接收者类是mBroadcastReceiver</span></span><br><span class="line">&lt;receiver </span><br><span class="line">    android:name=<span class="string">&quot;.mBroadcastReceiver&quot;</span> &gt;</span><br><span class="line">    <span class="comment">//用于过滤器为 BROADCAST_ACTION 的广播</span></span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">&quot;BROADCAST_ACTION&quot;</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>

<p>动态注册——在代码中调用Context.registerReceiver（）方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择在Activity生命周期方法中的onResume()中注册</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      <span class="built_in">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 实例化BroadcastReceiver子类 &amp;  IntentFilter</span></span><br><span class="line">     <span class="type">mBroadcastReceiver</span> <span class="variable">mBroadcastReceiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mBroadcastReceiver</span>();</span><br><span class="line">     <span class="type">IntentFilter</span> <span class="variable">intentFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置接收广播的类型</span></span><br><span class="line">    intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 动态注册：调用Context的registerReceiver（）方法</span></span><br><span class="line">     registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册广播后，要在相应位置记得销毁广播</span></span><br><span class="line"><span class="comment">// 即在onPause() 中unregisterReceiver(mBroadcastReceiver)</span></span><br><span class="line"><span class="comment">// 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中</span></span><br><span class="line"><span class="comment">// 当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="built_in">super</span>.onPause();</span><br><span class="line">      <span class="comment">//销毁在onResume()方法中的广播，否则会导致内存泄露</span></span><br><span class="line">     unregisterReceiver(mBroadcastReceiver);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在onResume()注册、onPause()注销是因为onPause()在App死亡前一定会被执行，从而保证广播在App死亡前一定会被注销，从而防止内存泄露。</p>
<blockquote>
<p>不在onCreate() &amp; onDestory() 或 onStart() &amp; onStop()注册、注销是因为：<br>当系统因为内存不足（优先级更高的应用需要内存，请看上图红框）要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。<br>假设我们将广播的注销放在onStop()，onDestory()方法里的话，有可能在Activity被销毁后还未执行onStop()，onDestory()方法，即广播仍还未注销，从而导致内存泄露。<br>但是，onPause()一定会被执行，从而保证了广播在App死亡前一定会被注销，从而防止内存泄露。</p>
</blockquote>
<ul>
<li>自定义广播接收者BroadcastReceiver</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承BroadcastReceivre基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 复写onReceive()方法</span></span><br><span class="line">  <span class="comment">// 接收到广播后，则自动调用该方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">   <span class="comment">// 写入接收广播后的操作</span></span><br><span class="line">   <span class="comment">// 默认情况下，广播接收器运行在UI线程，因此onReceive()方法不能执行耗时操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>屏蔽广播</li>
</ol>
<ul>
<li>注册广播时将exported属性设置为false，使得非本App内部发出的此广播不被接收；</li>
<li>在广播发送和接收时，增设相应权限permission，用于权限验证，只用具有相应权限的广播发送者发送的广播才能被该BoardcastReceiver接收；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver</span><br><span class="line"><span class="comment">//此broadcastReceiver能否接收其他App的发出的广播</span></span><br><span class="line"><span class="comment">//默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false  </span></span><br><span class="line">	android:exported=[<span class="string">&quot;true&quot;</span> | <span class="string">&quot;false&quot;</span>]</span><br><span class="line"><span class="comment">//具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收；</span></span><br><span class="line">    android:permission=<span class="string">&quot;string&quot;</span>&gt;</span><br><span class="line"><span class="comment">//用于指定此广播接收器将接收的广播类型</span></span><br><span class="line"><span class="comment">//本示例中给出的是用于接收网络状态改变时发出的广播</span></span><br><span class="line"> &lt;intent-filter&gt;</span><br><span class="line">&lt;action android:name=<span class="string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>

<p>发送广播时指定权限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送广播，第二个参数标识接收消息的广播接收器需要BROADCAST_PERMISSION_DISC权限</span></span><br><span class="line"><span class="comment">// 权限为null，则说明广播监听者不需要任何权限便可监听</span></span><br><span class="line">sendBroadcast(intent,BROADCAST_PERMISSION_DISC);</span><br></pre></td></tr></table></figure>

<ul>
<li>发送广播时指定该广播接收器所在的包名，此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送广播时指定包名</span></span><br><span class="line">intent.setPackage(packageName)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用封装好的LocalBroadcastManager类（本地广播发送的广播只在自身app传播）<br>App应用内广播可理解为一种局部广播，广播的发送者和接收者都同属于一个App。相比于全局广播（普通广播），App应用内广播优势体现在：安全性高 &amp; 效率高（仅根据intent-filter过滤广播可能会造成隐私数据泄露等）<br>使用方式上与全局广播几乎相同，只是注册&#x2F;取消注册广播接收器和发送广播时将参数的context变成了LocalBroadcastManager的单一实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册应用内广播接收器</span></span><br><span class="line"><span class="comment">//步骤1：实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver </span></span><br><span class="line">mBroadcastReceiver = <span class="keyword">new</span> <span class="title class_">mBroadcastReceiver</span>(); </span><br><span class="line"><span class="type">IntentFilter</span> <span class="variable">intentFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤2：实例化LocalBroadcastManager的实例</span></span><br><span class="line">localBroadcastManager = LocalBroadcastManager.getInstance(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤3：设置接收广播的类型 </span></span><br><span class="line">intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤4：调用LocalBroadcastManager单一实例的registerReceiver（）方法进行动态注册 </span></span><br><span class="line">localBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消注册应用内广播接收器</span></span><br><span class="line">localBroadcastManager.unregisterReceiver(mBroadcastReceiver);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应用内广播</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction(BROADCAST_ACTION);</span><br><span class="line">localBroadcastManager.sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><h3 id="理解-作用"><a href="#理解-作用" class="headerlink" title="理解 &amp; 作用"></a>理解 &amp; 作用</h3><p>Android应用模型是基于组件的应用设计模式，组件的运行要有一个完整的Android工程环境，（与Java不同，不能单单靠new出来对象就能运行）Context是维持Android程序中各组件（Activity、Service等）能够正常工作的一个核心功能类。<br>Context：语境、上下文。提供了关于应用环境全局信息的接口。我们可以通过这个接口获取 应用程序的资源和类 以及 进行应用级别的操作。如：启动Activity，弹出对话框，启动服务，发送广播，加载资源等等。</p>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p>Context 继承关系<br>Context是一个抽象类，它的具体实现类是ContextImpl，ContextWrapper是包装类。Activity，Application，Service都是继承自ContextWrapper，其初始化的过程中都会创建一个具体的ContextImpl实例，由ContextImpl实现Context中的方法。<br>ContextThemeWrapper继承自ContextWrapper，相对于ContextWrapper添加了与主题相关的接口。Application与Service直接继承自ContextWrapper，Activity直接继承自ContextThemeWrapper。</p>
<blockquote>
<p>这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。<br>当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，所以Service直接继承于ContextWrapper，Application同理。</p>
</blockquote>
<p>因此对于一个应用程序，Context数量 &#x3D; Activity数量 + Service数量 + 1（Application数量）<br><img src="https://mark.cuckooing.cn/pics/pic_7ce331d4.png" alt="pic_7ce331d4.png"><br>Context 作用域<br><img src="https://mark.cuckooing.cn/pics/pic_e1e1798c.png" alt="pic_e1e1798c.png"><br>Appliation&#x2F;Service 不推荐使用的两种情况：</p>
<ol>
<li>如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?<br>这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。</li>
<li>在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。</li>
</ol>
<p>凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。<br>不同种类Context的区别</p>
<table> 
 <thead> 
  <tr> 
   <th>Context类型</th> 
   <th>Activity Context</th> 
   <th>Application（Service） Context</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>父类不同</td> 
   <td>ContextThemeWrapper（Activity相对于Application增加了UI界面的处理，如弹出Dialog）</td> 
   <td>ContextWrapper</td> 
  </tr> 
  <tr> 
   <td>数量不同</td> 
   <td>多个（Activity Context则随Activity启动而创建）</td> 
   <td>一个（Application Context随Application启动而创建）</td> 
  </tr> 
  <tr> 
   <td>生命周期不同</td> 
   <td>与Activity相关.故对于生命周期较长的对象应引用Application的Context防止内存泄露。</td> 
   <td>与Application相关，随应用程序销毁而销毁</td> 
  </tr> 
  <tr> 
   <td>作用域不同</td> 
   <td>Activity所持用的Context作用域最广，无所不能（继承自ContextThemeWrapper，在ContextWrapper基础上增加了主题操作）</td> 
   <td>不适用于UI相关的操作，如Start an Activity或Layout Inflate</td> 
  </tr> 
  <tr> 
   <td>获取方式不同</td> 
   <td>View.getContext()/Activity.this</td> 
   <td>Activity.getApplicationContext()</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><ol>
<li>引起内存泄露的原因<br>（1）错误的单例模式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个非线程安全的单例模式，instance作为静态对象，其生命周期要长于普通的对象，其中也包含Activity，假如Activity A去getInstance获得instance对象，传入this，常驻内存的Singleton保存了你传入的Activity A对象，并一直持有，即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不可能被GC掉，这样就导致了内存泄漏。<br>（2）View持有Activity引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Drawable mDrawable;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle saveInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(saveInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageView</span>(<span class="built_in">this</span>);</span><br><span class="line">        mDrawable = getResources().getDrawable(R.drawable.ic_launcher);</span><br><span class="line">        iv.setImageDrawable(mDrawable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个静态的Drawable对象，当ImageView设置这个Drawable时，ImageView保存了mDrawable的引用，而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，MainActivity被销毁时，也不能被GC掉，所以造成内存泄漏。</p>
<ol>
<li>正确使用Context<br>一般Context造成的内存泄漏，几乎都是当Context销毁的时候，却因为被引用导致销毁失败，而Application的Context对象可以理解为随着进程存在的，所以我们总结出使用Context的正确姿势：</li>
</ol>
<ul>
<li>当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。</li>
<li>不要让生命周期长于Activity的对象持有到Activity的引用。</li>
<li>尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。</li>
</ul>
<h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>Intent表示目的、意图。Android通过Intent协助应用间，或应用内部组件（Activity,Service和Broadcast Receiver）间交互与通讯。用户可以通过Intent向Android组件发出一个意图，Intent负责对这个意图的动作、附加数据等进行描述。Android根据Intent的描述找到对应的组件，将Intent传入并完成组件的调用。<br>Intent作用主要包括2个</p>
<h3 id="指定当前组件要完成的动作"><a href="#指定当前组件要完成的动作" class="headerlink" title="指定当前组件要完成的动作"></a>指定当前组件要完成的动作</h3><p>根据intent寻找目标组件的方式分成两类</p>
<ol>
<li>隐式意图<br>通过在指定需启动组件所需满足的条件<br>（1）在AndroidManifest.xml清单文件中配置启动目标组件的条件<br>通过 AndroidManifest.xml文件下的&lt;组件类型&gt;（如&lt; Activity &gt;&lt; Service &gt; &lt; BroadcastReceiver &gt;）标签下的&lt; intent -filter &gt; 声明 需 匹配的条件，声明条件含：动作（Action）、类型（Category）、数据（Data）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为使SecondActivity能继续响应该Intent</span></span><br><span class="line"><span class="comment">// 我们需在AndroidManifest.xml文件下的&lt;Activity&gt;标签下配置&lt;intent -filter&gt;的内容</span></span><br><span class="line">&lt;activity android:name=<span class="string">&quot;com.test.SecondActivity&quot;</span>&gt;</span><br><span class="line">&lt;intent-filter &gt;</span><br><span class="line">      &lt;action android:name=<span class="string">&quot;android.intent.action.ALL_APPS&quot;</span>/&gt;</span><br><span class="line">          &lt;category android:name=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span><br><span class="line">                &lt;category android:name=<span class="string">&quot;com.example.intent_test.MY_CATEGORY&quot;</span>/&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<p>（2）在Activity中发起意图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使FirstActivity启动SecondActivity（通过按钮）</span></span><br><span class="line">      mybutton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 1. 实例化1个隐式Intent对象</span></span><br><span class="line">		<span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">		<span class="comment">// 2. 指定action参数</span></span><br><span class="line">		intent.setAction(<span class="string">&quot;android.intent.action.ALL_APPS&quot;</span>);</span><br><span class="line">    	<span class="comment">// 3. 调用Intent中的addCategory（）来添加一个category</span></span><br><span class="line">    	<span class="comment">// 注：每个Intent中只能指定1个action，但却能指定多个category</span></span><br><span class="line">  		intent.addCategory(<span class="string">&quot;com.example.intent_test.MY_CATEGORY&quot;</span>);</span><br><span class="line">    	startActivity (intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>显式意图<br>通过明确指定组件名<br>明确指定组件名的方式：调用Intent的构造方法、Intent.setComponent（）、Intent.setClass（）<br>通过 AndroidManifest.xml文件下的&lt;组件类型 android:name&#x3D;“组件名”&gt;</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使FirstActivity启动SecondActivity（通过按钮）</span></span><br><span class="line">mybutton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 1. 实例化显式Intent &amp; 通过构造函数接收2个参数</span></span><br><span class="line">    <span class="comment">// new Intent(Context packageContext, Class&lt;?&gt; cls) ;</span></span><br><span class="line">    <span class="comment">// 参数1 = packageContext：启动活动的上下文，一般为当前Activity</span></span><br><span class="line">    <span class="comment">// 参数2 = cls：是指定要启动的目标活动</span></span><br><span class="line">      <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(FirstActivity.<span class="built_in">this</span>,SecondActivity.class);</span><br><span class="line">    <span class="comment">// 通过setClassName(String className) 指明类名</span></span><br><span class="line">   	<span class="comment">// intent.setClassName(&quot;com.test.SecondActivity&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 通过Activity类的startActivity（）执行该意图操作（接收一个Intent对象）</span></span><br><span class="line">    <span class="comment">// 将构建好的Intent对象传入该方法就可启动目标Activity</span></span><br><span class="line">      startActivity (intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Intent 构造方法<br>1、Intent() 空构造函数<br>2、Intent(Intent o) 拷贝构造函数<br>3、Intent(String action) 指定action类型的构造函数<br>4、Intent(String action, Uri uri) 指定Action类型和Uri的构造函数，URI主要是结合程序之间的数据共享ContentProvider<br>5、Intent(Context packageContext, Class<?> cls) 传入组件的构造函数，也就是上文提到的  
6、Intent(String action, Uri uri, Context packageContext, Class<?> cls) 前两种结合体</p>
</blockquote>
<p>通常开启自定义组件使用显式意图，开启系统应用时使用隐式意图。</p>
<ol>
<li>Intent 常见使用场景</li>
</ol>
<ul>
<li>启动页面（Context.startActivity() 、Activity.startActivityForResult()）<br>（1）启动系统Activity</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">显示网页</span><br><span class="line">   <span class="number">1.</span> <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;http://google.com&quot;</span>);  </span><br><span class="line">   <span class="number">2.</span> <span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW, uri);  </span><br><span class="line">   <span class="number">3.</span> startActivity(it);</span><br><span class="line"></span><br><span class="line">显示地图</span><br><span class="line">   <span class="number">1.</span> <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;geo:38.899533,-77.036476&quot;</span>);  </span><br><span class="line">   <span class="number">2.</span> <span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW, uri);   </span><br><span class="line">   <span class="number">3.</span> startActivity(it);   </span><br><span class="line"></span><br><span class="line">打电话</span><br><span class="line">   <span class="number">1.</span> <span class="comment">//叫出拨号程序 </span></span><br><span class="line">   <span class="number">2.</span> <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;tel:0800000123&quot;</span>);  </span><br><span class="line">   <span class="number">3.</span> <span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_DIAL, uri);  </span><br><span class="line">   <span class="number">4.</span> startActivity(it);  </span><br><span class="line">   </span><br><span class="line">   <span class="number">1.</span> <span class="comment">//直接打电话出去  </span></span><br><span class="line">   <span class="number">2.</span> <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;tel:0800000123&quot;</span>);  </span><br><span class="line">   <span class="number">3.</span> <span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_CALL, uri);  </span><br><span class="line">   <span class="number">4.</span> startActivity(it);  </span><br><span class="line">   <span class="number">5.</span> <span class="comment">//用這個，要在 AndroidManifest.xml 中，加上  </span></span><br><span class="line">   <span class="number">6.</span> <span class="comment">//&lt;uses-permission id=&quot;android.permission.CALL_PHONE&quot; /&gt; </span></span><br><span class="line"></span><br><span class="line">传送SMS/MMS</span><br><span class="line">   <span class="number">1.</span> <span class="comment">//调用短信程序 </span></span><br><span class="line">   <span class="number">2.</span> <span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW, uri);  </span><br><span class="line">   <span class="number">3.</span> it.putExtra(<span class="string">&quot;sms_body&quot;</span>, <span class="string">&quot;The SMS text&quot;</span>);   </span><br><span class="line">   <span class="number">4.</span> it.setType(<span class="string">&quot;vnd.android-dir/mms-sms&quot;</span>);  </span><br><span class="line">   <span class="number">5.</span> startActivity(it); </span><br><span class="line">   </span><br><span class="line">   <span class="number">1.</span> <span class="comment">//传送消息 </span></span><br><span class="line">   <span class="number">2.</span> <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;smsto://0800000123&quot;</span>);  </span><br><span class="line">   <span class="number">3.</span> <span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_SENDTO, uri);  </span><br><span class="line">   <span class="number">4.</span> it.putExtra(<span class="string">&quot;sms_body&quot;</span>, <span class="string">&quot;The SMS text&quot;</span>);  </span><br><span class="line">   <span class="number">5.</span> startActivity(it); </span><br><span class="line"></span><br><span class="line">传送 Email</span><br><span class="line">   <span class="number">1.</span> <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;mailto:xxx@abc.com&quot;</span>);  </span><br><span class="line">   <span class="number">2.</span> <span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_SENDTO, uri);  </span><br><span class="line">   <span class="number">3.</span> startActivity(it);</span><br></pre></td></tr></table></figure>

<p>（2）启动自定义Activity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Activity.Main.<span class="built_in">this</span>, Activity2.class);</span><br><span class="line">startActivity(it);</span><br></pre></td></tr></table></figure>

<ul>
<li>启动服务（ Context.startService() 、Context.bindService() ）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建启动服务的Intent对象</span></span><br><span class="line">	<span class="type">Intent</span> <span class="variable">startIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyService.class);</span><br><span class="line">	<span class="comment">//调用startService()方法-传入Intent对象,以此启动服务</span></span><br><span class="line">	startService(startIntent);</span><br></pre></td></tr></table></figure>

<ul>
<li>启动广播（ Context.sendBroadcast()、Context.sendOrderedBroadcast()）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">  <span class="comment">//接收到广播后自动调用该方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//写入接收广播后的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）监听系统广播</p>
<ul>
<li>静态注册</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver</span><br><span class="line">  <span class="comment">//此广播接收者类是mBroadcastReceiver</span></span><br><span class="line">  android:name=<span class="string">&quot;.mBroadcastReceiver&quot;</span> &gt;</span><br><span class="line">  <span class="comment">//用于接收网络状态改变时发出的广播</span></span><br><span class="line">  &lt;intent-filter&gt;</span><br><span class="line">      &lt;action android:name=<span class="string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span><br><span class="line">  &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态注册</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="built_in">super</span>.onResume();</span><br><span class="line">    <span class="type">mBroadcastReceiver</span> <span class="variable">mBroadcastReceiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mBroadcastReceiver</span>();</span><br><span class="line">    <span class="type">IntentFilter</span> <span class="variable">intentFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>();</span><br><span class="line">    <span class="comment">//设置接收广播的类型</span></span><br><span class="line">    intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);</span><br><span class="line">    registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）发送 &amp; 监听自定义广播<br>即开发者自身定义intent的广播（最常用）。发送广播使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line"><span class="comment">//对应BroadcastReceiver中intentFilter的action</span></span><br><span class="line">intent.setAction(BROADCAST_ACTION);</span><br><span class="line"><span class="comment">//发送广播</span></span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>若被注册了的广播接收者中注册时intentFilter的action与上述匹配，则会接收此广播（即进行回调onReceive()）。如下mBroadcastReceiver则会接收上述广播</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver </span><br><span class="line">    <span class="comment">//此广播接收者类是mBroadcastReceiver</span></span><br><span class="line">    android:name=<span class="string">&quot;.mBroadcastReceiver&quot;</span> &gt;</span><br><span class="line">    <span class="comment">//用于接收网络状态改变时发出的广播</span></span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">&quot;BROADCAST_ACTION&quot;</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>

<h3 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h3><p>Intent可传递的数据类型有3种</p>
<ul>
<li>java的8种基本数据类型（boolean byte char short int long float double）、String以及他们的数组形式；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目的：将FristActivity中的一个字符串传递到SecondActivity中，并在SecondActivity中将Intent对象中的数据（FristActivity传递过来的数据）取出</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 1. 数据传递</span></span><br><span class="line">	  <span class="comment">// a. 创建Intent对象（显示Intent）</span></span><br><span class="line">	  <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(FirstActivity.<span class="built_in">this</span>,SecondActivity.class);     </span><br><span class="line">	 </span><br><span class="line">	  <span class="comment">// b. 通过putExtra（）方法传递一个字符串到SecondActivity；</span></span><br><span class="line">	  <span class="comment">// putExtra（）方法接收两个参数：第一个是键，第二个是值（代表真正要传递的数据）</span></span><br><span class="line">	  intent.putExtra(<span class="string">&quot;string_key&quot;</span>,<span class="string">&quot;I come from FirstActivity&quot;</span>);</span><br><span class="line">	  intent.putExtra(<span class="string">&quot;boolean_key&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">	  <span class="comment">// c. 启动Activity</span></span><br><span class="line">	  startActivity(intent);</span><br><span class="line">	 </span><br><span class="line">	  <span class="comment">// 2. 数据取出（在被启动的Activity中）</span></span><br><span class="line">	  <span class="comment">// a. 获取用于启动SecondActivit的Intent</span></span><br><span class="line">	  <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line">	  <span class="comment">// b. 调用getStringExtra（），传入相应的键名，就可得到传来的数据</span></span><br><span class="line">	  <span class="comment">// 注意数据类型 与 传入时保持一致</span></span><br><span class="line">	  <span class="type">String</span> <span class="variable">string_data</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;string_key&quot;</span>);</span><br><span class="line">	  <span class="type">boolean</span> <span class="variable">boolean_data</span> <span class="operator">=</span> intent.getBooleanExtra(<span class="string">&quot;boolean_key&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>Bundle类，Bundle是一个以键值对的形式存储可传输数据的容器；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 数据传递</span></span><br><span class="line">	  <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(FirstActivity.<span class="built_in">this</span>,SecondActivity.class);     </span><br><span class="line">	  <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">	  bundle.putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;carson&quot;</span>);</span><br><span class="line">      bundle.putInt(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>);</span><br><span class="line">	  intent.putExtras(bundle);</span><br><span class="line">	  startActivity(intent);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 2. 数据取出（在被启动的Activity中）</span></span><br><span class="line">	  <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line">	  <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> intent.getExtras();</span><br><span class="line">	  <span class="comment">// c. 通过bundle获取数据传入相应的键名，就可得到传来的数据</span></span><br><span class="line">	  <span class="comment">// 注意数据类型 与 传入时保持一致</span></span><br><span class="line">	  <span class="type">String</span> <span class="variable">nameString</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">      <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> bundle.getInt(<span class="string">&quot;age&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>实现了Serializable和Parcelable接口的对象，这些对象实现了序列化。<br>Serializable</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MyActivity.<span class="built_in">this</span>,OthereActivity.class);</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putSerializable(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">intent.putExtras(bundle);</span><br></pre></td></tr></table></figure>

<p>Parcelable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MyActivity.<span class="built_in">this</span>,OthereActivity.class);</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putParcelable(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">intent.putExtras(bundle);</span><br></pre></td></tr></table></figure>

<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>Application代表应用程序，属于Android的一个系统组件。<br>Application特点</p>
<ol>
<li>单例模式<br>即每个App运行时，系统会自动创建并实例化Application对象，且应用程序中有且仅有一个Application对象。</li>
<li>全局实例<br>不同的组件可以获取Application且获取的是同一个Application。</li>
<li>与App应用程序同生共死。<br>Application的生命周期等于App的生命周期，与App同生共死。</li>
</ol>
<p>Application获取方式</p>
<ul>
<li>Context环境</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">application = (MyApplication)getApplicationContext();		<span class="comment">//方法1</span></span><br><span class="line">application = (MyApplication)getApplication();	<span class="comment">//方法2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>非Context环境——单例模式（饿汉式）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyApplication instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="built_in">super</span>.onCreate();</span><br><span class="line">    instance = <span class="keyword">new</span> <span class="title class_">MyApplication</span>();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 获取Application</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title function_">getMyApplication</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Application应用场景</p>
<table> 
 <thead> 
  <tr> 
   <th>应用场景</th> 
   <th>调用生命周期方法</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>初始化资源，WebView预加载，推送服务注册，第三方插件加载等</td> 
   <td>onCreate()</td> 
  </tr> 
  <tr> 
   <td>数据共享、数据缓存（设置全局共享变量、方法）</td> 
   <td>onCreate()</td> 
  </tr> 
  <tr> 
   <td>获取应用程序当前内存使用情况（及时释放资源，避免被系统杀死/提高应用程序性能）</td> 
   <td>onTrimMemory() &amp; onLowMemory</td> 
  </tr> 
  <tr> 
   <td>监听 应用程序 配置信息的改变</td> 
   <td>onConfigurationChanged()</td> 
  </tr> 
  <tr> 
   <td>监听应用程序内 所有Activity的生命周期</td> 
   <td>registerActivityLifecycleCallbacks() &amp; unregisterActivityLifecycleCallbacks()</td> 
  </tr> 
 </tbody> 
</table>



<h1 id="第二章-Fragment"><a href="#第二章-Fragment" class="headerlink" title="第二章 Fragment"></a>第二章 Fragment</h1><ul>
<li>理解 &amp; “第五组件”</li>
<li>生命周期</li>
<li>使用方式 &#x2F; Fragment加载到Activity的两种方式</li>
<li>切换方式</li>
<li>懒加载（结合 ViewPager）</li>
<li>Fragment 回退栈（结合replace）</li>
<li>Fragment 与 Activity 通信方式</li>
<li>遇见的坑</li>
</ul>
<h2 id="理解-“第五组件”"><a href="#理解-“第五组件”" class="headerlink" title="理解 &amp; “第五组件”"></a>理解 &amp; “第五组件”</h2><p>Fragment，碎片。作为Activity界面的一部分，可理解为模块化Activity。是为了解决屏幕适配问题及UI界面的灵活控制而设计的。<br>Fragment不能独立存在，必须嵌入到Activity中。<br>Fragment比Activity更节省内存，拥有自己的生命周期，并且可以接收并处理事件。<br>Fragment使用频率很高，完全不低于其余四大组件。可以被称为第五大组件。</p>
<h2 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h2><ol>
<li>Fragment 完整生命周期流程<br>Fragment依赖Activity的存在而存在，Activity的状态决定了Fragment可能接收到的回调函数，故在Activity生命周期中的方法一般与Fragment生命周期中的方法同步执行（且Activity通常先于Fragment执行）。<br><img src="https://mark.cuckooing.cn/pics/pic_463f209c.png" alt="pic_463f209c.png"><br>Fragment比Activity多了几个生命周期的回调方法<br>onAttach(Activity) 当Fragment与Activity发生关联的时候调用<br>onCreateView(LayoutInflater, ViewGroup, Bundle) 创建该Fragment的视图<br>onActivityCreated(Bundle) 当Activity的onCreated方法返回时调用<br>onDestroyView() 与onCreateView方法相对应，当该Fragment的视图被移除时调用<br>onDetach() 与onAttach方法相对应，当Fragment与Activity取消关联时调用</li>
<li>Fragment切换生命周期变化</li>
</ol>
<ul>
<li>通过add、hide、show切换Fragment<br>切换时不执行Fragment生命周期，调用onHiddenChanged方法</li>
<li>通过replace切换Fragment<br>切换时，Fragment都进行了销毁，重建的过程。相当于执行了一次生命周期</li>
<li>通过ViewPager切换Fragment<br>切换时不执行生命周期，调用setUserVisVleHint方法</li>
</ul>
<h2 id="使用方式-Fragment加载到Activity的两种方式"><a href="#使用方式-Fragment加载到Activity的两种方式" class="headerlink" title="使用方式 &#x2F; Fragment加载到Activity的两种方式"></a>使用方式 &#x2F; Fragment加载到Activity的两种方式</h2><p>Fragment加载到Activity分为动态加载与静态加载两种方式：</p>
<ul>
<li>静态加载<br>指在Activity布局文件中加载Fragment，使用指定属性name即可。<br>（1）创建一个类继承Fragment，重写onCreateView方法，来确定Fragment要显示的布局</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 参数1：布局文件的id</span></span><br><span class="line"><span class="comment">        * 参数2：容器</span></span><br><span class="line"><span class="comment">        * 参数3：是否将这个生成的View添加到这个容器中去</span></span><br><span class="line"><span class="comment">        * 作用是将布局文件封装在一个View对象中，并填充到此Fragment中</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">v</span> <span class="operator">=</span> inflater.inflate(R.layout.item_fragment, container, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在Activity中声明该类，与普通的View对象一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;com.usher.fragment.MainActivity&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;100dp&quot;</span></span><br><span class="line">        android:gravity=<span class="string">&quot;center&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;Good Boy&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;fragment</span><br><span class="line">        android:id=<span class="string">&quot;@+id/myfragment&quot;</span></span><br><span class="line">        android:name=<span class="string">&quot;com.usher.fragment.MyFragment&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态加载<br>指在Activity的java文件中加载Fragment，需要使用FragmentManager，通过FragmentManager获取FragmentTransaction动态添加Fragment。<br>Activity 布局文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;com.usher.fragment.MainActivity&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/bt_red&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;Red&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/bt_blue&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;Blue&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/myframelayout&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>MainActivity.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button bt_red;</span><br><span class="line">    <span class="keyword">private</span> Button bt_blue;</span><br><span class="line">    <span class="keyword">private</span> FragmentManager manager;</span><br><span class="line">    <span class="keyword">private</span> MyFragment fragment1;</span><br><span class="line">    <span class="keyword">private</span> MyFragment2 fragment2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        initView();</span><br><span class="line"></span><br><span class="line">        fragment1 = <span class="keyword">new</span> <span class="title class_">MyFragment</span>();</span><br><span class="line">        fragment2 = <span class="keyword">new</span> <span class="title class_">MyFragment2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化FragmentManager对象（Fragment 管理器）</span></span><br><span class="line">        manager = getSupportFragmentManager();</span><br><span class="line">        <span class="comment">//使用FragmentManager对象用来开启一个Fragment事务</span></span><br><span class="line">        <span class="type">FragmentTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> manager.beginTransaction();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//	默认显示fragment1</span></span><br><span class="line">        <span class="comment">// Activity 对应布局上FrameLayout 控件，作为Fragment的容器，Fragment通过FrameLayout显示在Acitivity里</span></span><br><span class="line">        transaction.add(R.id.myframelayout, fragment1).commit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对bt_red设置监听</span></span><br><span class="line">        bt_red.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="type">FragmentTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> manager.beginTransaction();</span><br><span class="line">                transaction.replace(R.id.myframelayout, fragment1).commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对bt_blue设置监听</span></span><br><span class="line">        bt_blue.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="type">FragmentTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> manager.beginTransaction();</span><br><span class="line">                transaction.replace(R.id.myframelayout, fragment2).commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initView</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        bt_red = (Button) findViewById(R.id.bt_red);</span><br><span class="line">        bt_blue = (Button) findViewById(R.id.bt_blue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切换方式"><a href="#切换方式" class="headerlink" title="切换方式"></a>切换方式</h2><p>FragmentTransaction对象，transaction的方法主要有以下几种：</p>
<table> 
 <thead> 
  <tr> 
   <th>方法</th> 
   <th>解释</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>add</td> 
   <td>向Activity中添加一个Fragment</td> 
  </tr> 
  <tr> 
   <td>remove</td> 
   <td>从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈，这个Fragment实例将会被销毁</td> 
  </tr> 
  <tr> 
   <td>replace</td> 
   <td>使用另一个Fragment替换当前的，实际上就是remove()然后add()的合体</td> 
  </tr> 
  <tr> 
   <td>hide</td> 
   <td>隐藏当前的Fragment，仅仅是设为不可见，并不会销毁</td> 
  </tr> 
  <tr> 
   <td>show</td> 
   <td>显示之前隐藏的Fragment</td> 
  </tr> 
  <tr> 
   <td>commit</td> 
   <td>提交事务，在add/replace/hide/show以后都要commit其效果才会在屏幕上显示出来</td> 
  </tr> 
 </tbody> 
</table>

<p>Fragment主要有3种界面切换方式：<br>MainActivity 布局文件（通过FrameLayout 显示fragment）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    android:background=<span class="string">&quot;#ffffff&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/main_frame_layout&quot;</span></span><br><span class="line">        android:background=<span class="string">&quot;#dddddd&quot;</span></span><br><span class="line">        android:layout_weight=<span class="string">&quot;1&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;0dp&quot;</span>&gt;</span><br><span class="line">    &lt;/FrameLayout&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;48dp&quot;</span>&gt;</span><br><span class="line">        &lt;Button</span><br><span class="line">            android:layout_weight=<span class="string">&quot;1&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;0dp&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:background=<span class="string">&quot;#ffffff&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;消息&quot;</span>/&gt;</span><br><span class="line">        &lt;Button</span><br><span class="line">            android:layout_weight=<span class="string">&quot;1&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;0dp&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:background=<span class="string">&quot;#ffffff&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;联系人&quot;</span>/&gt;</span><br><span class="line">        &lt;Button</span><br><span class="line">            android:layout_weight=<span class="string">&quot;1&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;0dp&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:background=<span class="string">&quot;#ffffff&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;动态&quot;</span>/&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>Fragment 实现逻辑代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> TextView tv;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyFragment</span><span class="params">(String fName)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.name = fName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> LayoutInflater.from(getActivity()).inflate(R.layout.fragment_my,container,<span class="literal">false</span>);</span><br><span class="line">        tv = (TextView) view.findViewById(R.id.fragment_tv);</span><br><span class="line">        tv.setText(name);</span><br><span class="line">        tv.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// 通过点击fragment 中的文字，改变文字内容</span></span><br><span class="line">                tv.setText(<span class="string">&quot;我变了-&quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MainActivity.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//三个fragment</span></span><br><span class="line">    <span class="keyword">private</span> MyFragment f1;</span><br><span class="line">    <span class="keyword">private</span> MyFragment f2;</span><br><span class="line">    <span class="keyword">private</span> MyFragment f3;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//底部三个按钮</span></span><br><span class="line">    <span class="keyword">private</span> Button foot1;</span><br><span class="line">    <span class="keyword">private</span> Button foot2;</span><br><span class="line">    <span class="keyword">private</span> Button foot3;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"> </span><br><span class="line">        foot1 = (Button) findViewById(R.id.btn1);</span><br><span class="line">        foot2 = (Button) findViewById(R.id.btn2);</span><br><span class="line">        foot3 = (Button) findViewById(R.id.btn3);</span><br><span class="line">        foot1.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">        foot2.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">        foot3.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//第一次初始化首页默认显示第一个fragment</span></span><br><span class="line">        initFragment1();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//显示第一个fragment</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFragment1</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//开启事务，fragment的控制是由事务来实现的</span></span><br><span class="line">        <span class="comment">//每处理一个事务都要开启一个新的事务，一个FragmentTransaction只能提交一次，否则会报错：java.lang.IllegalStateException: commit already called</span></span><br><span class="line">        <span class="type">FragmentTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> getSupportFragmentManager().beginTransaction();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//第一种方式（add），初始化fragment并添加到事务中，如果为null就new一个</span></span><br><span class="line">        <span class="keyword">if</span>(f1 == <span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            f1 = <span class="keyword">new</span> <span class="title class_">MyFragment</span>(<span class="string">&quot;消息&quot;</span>);</span><br><span class="line">            transaction.add(R.id.main_frame_layout, f1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//隐藏所有fragment</span></span><br><span class="line">        hideFragment(transaction);</span><br><span class="line">        <span class="comment">//显示需要显示的fragment</span></span><br><span class="line">        transaction.show(f1);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//第二种方式(replace)，初始化fragment</span></span><br><span class="line"><span class="comment">//        if(f1 == null)&#123;</span></span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">//            f1 = new MyFragment(&quot;消息&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        transaction.replace(R.id.main_frame_layout, f1);</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//显示第二个fragment</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFragment2</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">FragmentTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> getSupportFragmentManager().beginTransaction();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(f2 == <span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            f2 = <span class="keyword">new</span> <span class="title class_">MyFragment</span>(<span class="string">&quot;联系人&quot;</span>);</span><br><span class="line">            transaction.add(R.id.main_frame_layout,f2);</span><br><span class="line">        &#125;</span><br><span class="line">        hideFragment(transaction);</span><br><span class="line">        transaction.show(f2);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//        if(f2 == null) &#123;</span></span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">//            f2 = new MyFragment(&quot;联系人&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        transaction.replace(R.id.main_frame_layout, f2);</span></span><br><span class="line"> </span><br><span class="line">        transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//显示第三个fragment</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFragment3</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">FragmentTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> getSupportFragmentManager().beginTransaction();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(f3 == <span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            f3 = <span class="keyword">new</span> <span class="title class_">MyFragment</span>(<span class="string">&quot;动态&quot;</span>);</span><br><span class="line">            transaction.add(R.id.main_frame_layout,f3);</span><br><span class="line">        &#125;</span><br><span class="line">        hideFragment(transaction);</span><br><span class="line">        transaction.show(f3);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//        if(f3 == null) &#123;</span></span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">//            f3 = new MyFragment(&quot;动态&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        transaction.replace(R.id.main_frame_layout, f3);</span></span><br><span class="line"> </span><br><span class="line">        transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//隐藏所有的fragment</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">hideFragment</span><span class="params">(FragmentTransaction transaction)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span>(f1 != <span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            transaction.hide(f1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f2 != <span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            transaction.hide(f2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f3 != <span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            transaction.hide(f3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span>(v == foot1)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            initFragment1();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v == foot2)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            initFragment2();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v == foot3)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            initFragment3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式1：add&#x2F;show&#x2F;hide<br>初始化时通过add加入Fragment，hide&amp;show方式切换Fragment时将Fragment视图隐藏，所有的Fragment实例都会保存在内存，不会销毁与重建，不执行生命周期。<br>点击fragment文字改变后，切换到其他fragment并返回时，文字保持点击后改变的文字，而不是初始化的文字。即fragment没有重建，保持之前的fragment。</li>
</ul>
<p><img src="https://mark.cuckooing.cn/pics/pic_be0f0062.png" alt="pic_be0f0062.png"></p>
<ul>
<li>方式2：replace（+addToBackStack）<br>通过 replace 方法进行替换的时，Fragment 都是进行了销毁，重建的过程，相当于走了一整套的生命周期。<br>fragment1：onPause() -&gt; onStop -&gt; onDestroyView() -&gt; onDestroy() -&gt; onDetach()<br>fragment2：onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onActivityCreated() -&gt; on Start() -&gt; onResume()<br>点击fragment文字改变后，切换到其他fragment并返回时，文字恢复为初始化的文字。即fragment重新创建并初始化。<br><img src="https://mark.cuckooing.cn/pics/pic_e276ccf7.png" alt="pic_e276ccf7.png"></li>
<li>方式3：Fragment与ViewPager的搭配使用<br>通常情况下我们开发应用最常见的使用情况是TabLayout+ViewPager+Fragment的使用方式，下面通过一个实例展示：<br><img src="https://mark.cuckooing.cn/pics/pic_bd1bf224.png" alt="pic_bd1bf224.png"></li>
<li>步骤1：引入工具包</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.android.support:design:27.1.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.android.support:support-v4:27.1.1&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>步骤2：书写布局文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;.activities.TabLayoutActivity&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.TabLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/tl_tabs&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;40dp&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v4.view.ViewPager</span><br><span class="line">        android:id=<span class="string">&quot;@+id/vp_content&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤3：实现TabLayout+ViewPager+Fragment<br>使用流程：<br>1、创建存储多个Fragment实例的列表<br>2、创建PagerAdapter实例并关联到Viewpager中<br>3、将ViewPager关联到Tablayout中<br>4、根据需求改写Tablayout属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TabLayoutActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">MyFragment</span>.OnFragmentInteractionListener &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    TabLayout tabLayout;</span><br><span class="line">    ViewPager viewPager;</span><br><span class="line">    </span><br><span class="line">    List&lt;Fragment&gt; fragments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//步骤1：创建存储多个Fragment实例的列表</span></span><br><span class="line">    List&lt;String&gt; titles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_tab_layout);</span><br><span class="line"></span><br><span class="line">        tabLayout = findViewById(R.id.tl_tabs);</span><br><span class="line">        viewPager = findViewById(R.id.vp_content);</span><br><span class="line"></span><br><span class="line">        fragments.add(MyFragment.newInstance(<span class="string">&quot;11111&quot;</span>, <span class="string">&quot;11111&quot;</span>));</span><br><span class="line">        fragments.add(MyFragment.newInstance(<span class="string">&quot;22222&quot;</span>, <span class="string">&quot;22222&quot;</span>));</span><br><span class="line">        fragments.add(MyFragment.newInstance(<span class="string">&quot;33333&quot;</span>, <span class="string">&quot;33333&quot;</span>));</span><br><span class="line">        fragments.add(MyFragment.newInstance(<span class="string">&quot;44444&quot;</span>, <span class="string">&quot;44444&quot;</span>));</span><br><span class="line">        fragments.add(MyFragment.newInstance(<span class="string">&quot;55555&quot;</span>, <span class="string">&quot;55555&quot;</span>));</span><br><span class="line">        titles.add(<span class="string">&quot;fragment1&quot;</span>);</span><br><span class="line">        titles.add(<span class="string">&quot;fragment2&quot;</span>);</span><br><span class="line">        titles.add(<span class="string">&quot;fragment3&quot;</span>);</span><br><span class="line">        titles.add(<span class="string">&quot;fragment4&quot;</span>);</span><br><span class="line">        titles.add(<span class="string">&quot;fragment5&quot;</span>);</span><br><span class="line">        <span class="comment">//步骤2：创建PagerAdapter实例并关联到Viewpager中</span></span><br><span class="line">        viewPager.setAdapter(<span class="keyword">new</span> <span class="title class_">FragmentStatePagerAdapter</span>(getSupportFragmentManager()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Fragment <span class="title function_">getItem</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">return</span> fragments.get(position);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">return</span> fragments.size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyItem</span><span class="params">(ViewGroup container, <span class="type">int</span> position, Object object)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="built_in">super</span>.destroyItem(container, position, object);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> CharSequence <span class="title function_">getPageTitle</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> titles.get(position);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//步骤3：将ViewPager关联到Tablayout中</span></span><br><span class="line">        tabLayout.setupWithViewPager(viewPager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFragmentInteraction</span><span class="params">(Uri uri)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>FragmentStatePagerAdapter与FragmentPagerAdapter<br>FragmentStatePagerAdapter与FragmentPagerAdapter用法类似，区别在于，卸载不需要的Fragment时，各自的处理方法不同。</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>Adapter</th> 
   <th>FragmentStatePagerAdapter</th> 
   <th>FragmentPagerAdapter</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>切换方式</td> 
   <td>会销毁不需要的Fragment，事务提交后，FragmentManager中的Fragment会被彻底移除，销毁时可在onSaveInstanceState方法中保存信息</td> 
   <td>对于不再需要的Fragment会调用事务的detach方法而非remove方法，仅仅是销毁Fragment的视图，而实例对象仍然保留</td> 
  </tr> 
  <tr> 
   <td>适用场景</td> 
   <td>更节省内存，当page页面较多时适合使用</td> 
   <td>界面只是少量固定页面，FragmentPagerAdapter更安全</td> 
  </tr> 
 </tbody> 
</table>

<p>ViewPager + Fragment结合使用会出现内存泄漏吗 &amp; 如何解决？</p>
<ul>
<li>原因:<br>一般ViewPager + Fragment结合使用出现内存泄漏的原因可能用某个集合存储了Fragment的实例,导致当用户滑动ViewPager的时候，某一个Fragment即将面临销毁的时候，由于这个集合持有的它的引用，因此不能被回收掉,如果Fragment里面有大量的数据占据内存，有可能会导致OOM。</li>
<li>解决方法：<br>尽量不要使用集合来存储Fragment实例对象，除非你有良好的二次封装。再就是要做好每一页Fragment的数据缓存问题。</li>
</ul>
<h2 id="懒加载（结合-ViewPager）"><a href="#懒加载（结合-ViewPager）" class="headerlink" title="懒加载（结合 ViewPager）"></a>懒加载（结合 ViewPager）</h2><ul>
<li>ViewPager的缓存机制 —— 预加载<br>ViewPager为了让滑动的时候可以有很好的用户的体验，也就是防止出现卡顿现象，因此它有一个缓存机制。默认情况下，ViewPager会提前创建好当前Fragment旁的两个Fragment，举个例子说也就是如果你当前显示的是编号3的Fragment，那么其实编号2和4的Fragment也已经创建好了，也就是说这3个Fragment都已经执行完 onAttach() -&gt; onResume() 这之间的生命周期函数了。<br>也可以通过下述函数设置缓存的页面数目：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewPager.setOffscreenPageLimit(<span class="type">int</span> limit);</span><br></pre></td></tr></table></figure>

<p><img src="https://mark.cuckooing.cn/pics/pic_cda676d6.png" alt="pic_cda676d6.png"></p>
<ul>
<li>为什么要懒加载？<br>Android的View绘制流程是最消耗CPU时间片的操作，尤其是在ViewPager+Fragment的情况下，会对所有的Fragment进行预加载。如果在View绘建的同时还进行多个Fragment的数据加载，那用户体验简直是爆炸（不仅浪费流量，而且还造成不必要的卡顿）因此，需要对Fragment们进行懒加载策略。</li>
<li>什么是懒加载？<br>被动加载，当Fragment页面可见时，才从网络加载数据并显示出来。</li>
<li>如何懒加载？<br>实行懒加载必须满足的条件</li>
</ul>
<ol>
<li>View视图加载完毕，即onCreateView（）执行完成</li>
</ol>
<blockquote>
<p>（setUserVisibleHint函数是游离在Fragment生命周期之外的，它的执行有可能早于onCreate和onCreateView，然而既然要时间数据的加载，就必须要在onCreateView创建完视图过后才能使用，不然就会返回空指针崩溃）</p>
</blockquote>
<ol>
<li>当前Fragment可见，即setUserVisibleHint（）的参数为true</li>
<li>初次加载，即防止多次滑动重复加载</li>
</ol>
<p>故在Fragment全局变量中增加对应的三个标志参数并设置初始值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">mIsPrepare</span> <span class="operator">=</span> <span class="literal">false</span>;		<span class="comment">//是否加载完成 =&gt; onCreateView</span></span><br><span class="line"><span class="type">boolean</span> mIsVisible= <span class="literal">false</span>;		<span class="comment">//是否用户可见 =&gt; setUserVisibleHint</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">mIsFirstLoad</span> <span class="operator">=</span> <span class="literal">true</span>;	<span class="comment">//是否初次加载</span></span><br></pre></td></tr></table></figure>

<p>当然在onCreateView中确保了View已经准备好时，将mPrepare置为true，在setUserVisibleHint中确保了当前可见时，mIsVisible置为true，第一次加载完毕后则将mIsFirstLoad置为false，避免重复加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewCreated</span><span class="params">(View view, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="built_in">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">    mIsPrepare = <span class="literal">true</span>;</span><br><span class="line">    lazyLoad();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserVisibleHint</span><span class="params">(<span class="type">boolean</span> isVisibleToUser)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="built_in">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">    <span class="comment">//isVisibleToUser这个boolean值表示:该Fragment的UI 用户是否可见</span></span><br><span class="line">    <span class="keyword">if</span> (isVisibleToUser) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mIsVisible = <span class="literal">true</span>;</span><br><span class="line">        lazyLoad();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mIsVisible = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，贴上懒加载的lazyLoad()代码（只要标志位改变，就要进行lazyLoad()函数的操作）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">lazyLoad</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//这里进行三个条件的判断，如果有一个不满足，都将不进行加载</span></span><br><span class="line">    <span class="keyword">if</span> (!mIsPrepare || !mIsVisible||!mIsFirstLoad) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        loadData();</span><br><span class="line">        <span class="comment">//数据加载完毕,恢复标记,防止重复加载</span></span><br><span class="line">        mIsFirstLoad = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadData</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//这里进行网络请求和数据装载</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后，如果Fragment销毁的话，还应该将三个标志位进行默认值初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroyView</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onDestroyView();</span><br><span class="line">        mIsFirstLoad=<span class="literal">true</span>;</span><br><span class="line">        mIsPrepare=<span class="literal">false</span>;</span><br><span class="line">        mIsVisible = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>为什么在onDestroyView中进行而不是在onDestroy中进行呢？这又要提到之前Adapter的差异，onDestroy并不一定会调用。</p>
<h2 id="Fragment-回退栈（结合replace）"><a href="#Fragment-回退栈（结合replace）" class="headerlink" title="Fragment 回退栈（结合replace）"></a>Fragment 回退栈（结合replace）</h2><p>Fragment的回退栈是用来保存每一次Fragment事务发生的变化。在Fragment的时候，如果你不是手动开启回退栈，若用replace方式切换时，是直接销毁再重建；但如果将Fragment任务添加到回退栈，情况就会不一样了，它就有了类似Activity的栈管理方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fragment1.java</span></span><br><span class="line"><span class="comment">// Fragment1 中按钮事件，切换到fragment2，并将当前事务添加到了回退栈</span></span><br><span class="line"><span class="type">Fragment2</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fragment2</span>();</span><br><span class="line"><span class="type">FragmentManager</span> <span class="variable">fm</span> <span class="operator">=</span> getFragmentManager();</span><br><span class="line"><span class="type">FragmentTransaction</span> <span class="variable">tx</span> <span class="operator">=</span> fm.beginTransaction();</span><br><span class="line">tx.replace(R.id.fl, f2);</span><br><span class="line"><span class="comment">//将当前的事务添加到了回退栈</span></span><br><span class="line">tx.addToBackStack(<span class="literal">null</span>);</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure>

<p>Fragment的点击事件里写的是replace方法，相当于remove和add的合体，并且如果不添加事务到回退栈，前一个Fragment实例会被销毁。<br>这里很明显，我们调用tx.addToBackStack(null)将当前的事务添加到了回退栈，所以FragmentOne实例不会被销毁，但是视图层次依然会被销毁，即会调用onDestoryView和onCreateView（但不会调用onDestroy()和onCreate()）。<br>所以【请注意】，当之后我们从FragmentTwo返回到前一个页面的时候，视图层仍旧是重新按照代码绘制，这里仅仅是是实例没有销毁。</p>
<h2 id="Fragment-与-Activity-通信方式"><a href="#Fragment-与-Activity-通信方式" class="headerlink" title="Fragment 与 Activity 通信方式"></a>Fragment 与 Activity 通信方式</h2><ol>
<li>直接访问引用<br>如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法</li>
<li>Activity向Fragment通信——FindFragmentById<br>若Fragment存在，则可通过getSupportFragmentManager().findFragmentById直接获得Fragment，调用它的共有方法获得数据。否则可通过setArguments(bundle)&#x2F;getArguments方法传递bundle参数<br>MainActivity.java</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="type">MyFragment</span> <span class="variable">myFragment</span> <span class="operator">=</span> (MyFragment)getSupportFragmentManager().findFragmentById(R.id.my_fragment);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (articleFrag == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            myFragment = <span class="keyword">new</span> <span class="title class_">MyFragment</span>();</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">            bundle.putString(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Msg from Activity&quot;</span>);</span><br><span class="line">            myFragment.setArguments(args);</span><br><span class="line">            <span class="type">FragmentTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> getSupportFragmentManager().beginTransaction();</span><br><span class="line"></span><br><span class="line">            transaction.replace(R.id.fragment_container, newFragment);</span><br><span class="line">            <span class="comment">// Fragment的回退栈是用来保存每一次Fragment事务发生的变化 如果你将Fragment任务添加到回退栈，当用户点击后退按钮时，将看到上一次的保存的Fragment。</span></span><br><span class="line">            transaction.addToBackStack(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            transaction.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyFragment.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">View</span> <span class="variable">contentView</span> <span class="operator">=</span> inflater.inflate(R.layout.fragment, container, <span class="literal">false</span>);</span><br><span class="line">       ...</span><br><span class="line">        <span class="comment">// 步骤1:通过getArgments()获取从Activity传过来的全部值</span></span><br><span class="line">        bundle = <span class="built_in">this</span>.getArguments();</span><br><span class="line">        <span class="comment">// 步骤2:获取某一值</span></span><br><span class="line">        message = bundle.getString(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        <span class="keyword">return</span> contentView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>Fragment向Activity通信——回调函数<br>在Fragment内定义回调函数，并在Activity中实现回调接口，可实现Fragment向Activity传递数据<br>step1: 在Menuragment中创建一个接口以及接口对应的set方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MenuFragment.java文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnDataTransmissionListener</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataTransmission</span><span class="params">(String data)</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnDataTransmissionListener</span><span class="params">(OnDataTransmissionListener mListener)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.mListener = mListener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>step2: 在MenuFragment中的ListView条目点击事件中进行接口进行接口回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MenuFragment.java文件中</span></span><br><span class="line">lv.setOnItemClickListener(<span class="keyword">new</span> <span class="title class_">AdapterView</span>.OnItemClickListener() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view, <span class="type">int</span> position, <span class="type">long</span> id)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (mListener != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mListener.dataTransmission(mDatas.get(position));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>step3: 在MainActivity中根据menuFragment获取到接口的set方法，在这个方法中进行进行数据传递，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在MainActivity.java中</span></span><br><span class="line">menuFragment.setOnDataTransmissionListener(<span class="keyword">new</span> <span class="title class_">MenuFragment</span>.OnDataTransmissionListener() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataTransmission</span><span class="params">(String data)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mainFragment.setData(data);  <span class="comment">//注：对应的mainFragment此时应该要用final进行修饰</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>第三方开源框架：EventBus</li>
<li>Fragment之间通信——以宿主Activity为桥梁<br>综合上面两步，可得到Fragment之间的通信方式：<br>Fragment1通过getActivity获得宿主Activity，并通过Activity实例直接调用FindFragmentById获得Fragment2，并传递数据给Fragment2</li>
</ol>
<h2 id="遇见的坑"><a href="#遇见的坑" class="headerlink" title="遇见的坑"></a>遇见的坑</h2><ul>
<li>getActivity空指针<br>调用getActivity时，当前Fragment已经onDetach宿主Activity，导致空指针异常。常见页面重启（因内存不足&#x2F;按Home键&#x2F;横竖屏切换）或pop了Fragment后，由于Fragment的异步任务仍执行，且执行时调用了getActivity方法，会报空指针异常。<br>应该在Fragment的基类设置一个宿主Activity的全局变量，并在onAttach赋值，使用该全局变量代替getActivity。保证Fragment在被onDetach后，仍有Activity的引用。</li>
<li>内存泄露<br>用集合保存Fragment数组时，销毁Fragment会因为集合中仍存在Fragment的引用而无法销毁，引起内存泄露。常见于ViewPager的使用。</li>
<li>Can not perform this action after onSaveInstanceState异常<br>Activity在调用onSaveInstanceState()保存当前Activity的状态后，直到Activity状态恢复之前，若commit 一个FragmentTransaction，就会抛出该异常。因为onSaveInstanceState用于保存当前Activity的现场状态，若之后再调用FragmentTransaction.commit，则该事务没有被作为Activity的状态保存，导致意外的UI状态丢失。Android系统为了避免页面状态的丢失，抛出异常。<br>为了解决这个异常，应该谨慎地在Activity生命周期调用transaction的commit方法。确保在Activity状态恢复后才会调用。且避免在异步回调中处理transaction。使用commitAllowingStateLoss()虽然可以避免跑出异常，但是存在状态丢失的可能性。</li>
<li>Fragment界面重叠<br>当使用add方式添加Fragment并使用hide|show切换时，如果发生页面重启，可能会导致Fragment重叠。这是因为Activity使用onSaveInstanceState方法时，系统保存了Fragment状态。在重启时，FragmentManager会从栈底向栈顶的顺序一次性恢复Fragment，但没有保存Fragment的mHidden属性，使所有的Fragment都以show的形式恢复，导致页面发生重叠。<br>故应该在创建时，判断savedInstanceState不为空时，通过findFragmentByTag找到对应的Fragment，show需要显示的项目并hide隐藏的项目。</li>
</ul>
<h1 id="第三章-存储"><a href="#第三章-存储" class="headerlink" title="第三章 存储"></a>第三章 存储</h1><ul>
<li>数据持久化 &#x2F; 数据本地存储方式</li>
<li><ul>
<li>SharedPreferences</li>
<li>文件存储</li>
<li>SQLite</li>
</ul>
</li>
</ul>
<h2 id="数据持久化-数据本地存储方式"><a href="#数据持久化-数据本地存储方式" class="headerlink" title="数据持久化 &#x2F; 数据本地存储方式"></a>数据持久化 &#x2F; 数据本地存储方式</h2><p>Android本地存储方式有5种，分别是SharedPreferences存储、文件存储、SQLite存储、ContentProvider和网络存储方式。</p>
<table> 
 <thead> 
  <tr> 
   <th>存储方式</th> 
   <th>简介</th> 
   <th>特点</th> 
   <th>默认存储路径</th> 
   <th>项目应用</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>SharedPreferences</td> 
   <td>SharedPreferences是一种轻量级存储类，数据存储格式为键值对</td> 
   <td>保存一些简单的配置参数等轻量级数据</td> 
   <td>/data/data/packageName/shared_prefs/xxx.xml</td> 
   <td>登录界面保存上次登录成功的用户名和密码</td> 
  </tr> 
  <tr> 
   <td>文件存储</td> 
   <td>文件存储是通过I/O流从内部存储或SD卡（外存）中读写数据</td> 
   <td>内存中存储一些较小、安全性较高的数据<br>外存存储较大的文件或简单的文本/二进制数据</td> 
   <td>/data/data/packageName/files</td> 
   <td>项目所需图片、音频文件<br>较大的数据信息（.json/.xml）</td> 
  </tr> 
  <tr> 
   <td>SQLite</td> 
   <td>通过SQLite,一种轻型、嵌入式的ACID关系型数据库对数据存储，使用SQL语言<br>Android为此数据库提供了SQLiteDatabase类，封装了操作数据库的API</td> 
   <td>数据量不是很大且逻辑关系较为复杂的数据（结构性数据）</td> 
   <td>/data/data/packageName/databases</td> 
   <td>存储本地数据信息（结构性数据）</td> 
  </tr> 
  <tr> 
   <td>ContentProvider</td> 
   <td>作为Android四大组件之一，ContentProvider一般为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据<br>仅作为传输数据的媒介，数据源具有多样性</td> 
   <td>Android手机系统数据<br>跨进程数据</td> 
   <td>通过URI对象</td> 
   <td>获取手机短信、联系人等<br>进程间数据共享、交换</td> 
  </tr> 
  <tr> 
   <td>网络存储</td> 
   <td>与后台交互，将数据存储在后台数据库中</td> 
   <td>数据量大，逻辑关系复杂的数据交给后台处理</td> 
   <td>远程服务器</td> 
   <td>庞大的数据库<br>较大的音频、图片</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h3><ol>
<li>简介<br>SharedPreferences是Android平台上一个轻量级的存储类，主要是保存一些常用的配置比如窗口状态。是Android最简单数据存储方式。</li>
</ol>
<ul>
<li>只支持Java基本数据类型 &amp; String类型数据存储<br>如果要用 SharedPreferences 存取复杂的数据类型（类，图像等），就需要对这些数据进行编码。通常会将复杂类型的数据转换成Base64编码，然后将转换后的数据以字符串的形式保存在XML文件中。</li>
<li>数据存储类型为key-value对。</li>
<li>使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件 存放在&#x2F;data&#x2F;data&#x2F; &lt; package name &gt; &#x2F;shared_prefs目录下。</li>
<li>是一种轻量级存储类，常用于保存一些常用的配置比如窗口状态。之所以说SharedPreference是一种轻量级的存储方式，是因为它在创建的时候会把存储数据的整个xml文件全部加载进内存。</li>
<li>SharedPreferences读取数据都使用awaitLoadedLocked同步锁，故是线程安全的。</li>
<li>SharedPreferences一般采用单例模式</li>
</ul>
<ol>
<li>使用<br>存储数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个文件名为test、权限为private的xml文件的SharedPreferences对象</span></span><br><span class="line">    <span class="type">SharedPreferences</span> <span class="variable">sharedPreferences</span> <span class="operator">=</span> getSharedPreferences(<span class="string">&quot;test&quot;</span>, MODE_PRIVATE);</span><br><span class="line">    <span class="comment">//得到SharedPreferences.Editor对象，并保存key-value键值对数据到该对象中</span></span><br><span class="line">    SharedPreferences.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> sharedPreferences.edit();</span><br><span class="line">    editor.putString(<span class="string">&quot;username&quot;</span>, et_username.getText().toString().trim());</span><br><span class="line">    editor.putString(<span class="string">&quot;password&quot;</span>, et_password.getText().toString().trim());</span><br><span class="line">    <span class="comment">//apply提交数据，保存key-value对到文件中</span></span><br><span class="line">    editor.apply();</span><br><span class="line">    <span class="comment">// editor.commit();</span></span><br><span class="line">    <span class="comment">// apply没有返回值而commit返回boolean表明修改是否提交成功</span></span><br><span class="line">    <span class="comment">// apply是将修改数据原子提交到内存, 而后异步真正提交到硬件磁盘,</span></span><br><span class="line">    <span class="comment">// 而commit是在当前线程同步的提交到硬件磁盘，会阻塞调用它的线程。</span></span><br><span class="line">    <span class="comment">// 因此，推荐使用apply:在多个并发的提交commit的时候，他们会等待正在处理的commit保存到磁盘后在操作，从而降低了效率。而apply只是原子的提交到内容，后面有调用apply的函数的将会直接覆盖前面的内存数据，这样从一定程度上提高了很多效率。</span></span><br><span class="line">    <span class="built_in">super</span>.onStop();</span><br></pre></td></tr></table></figure>

<p>获取数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">et_username = (EditText) findViewById(R.id.et_username);</span><br><span class="line">    et_password = (EditText) findViewById(R.id.et_password);</span><br><span class="line">    <span class="type">SharedPreferences</span> <span class="variable">sharedPreferences</span> <span class="operator">=</span> <span class="built_in">this</span>.getSharedPreferences(<span class="string">&quot;test&quot;</span>, MODE_PRIVATE);</span><br><span class="line">    et_username.setText(sharedPreferences.getString(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">    et_password.setText(sharedPreferences.getString(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>

<ol>
<li>性能优化<br>SharedPreferences是Android平台上一个轻量级的存储类，主要是保存一些常用的配置比如窗口状态。本质是通过存放在&#x2F;data&#x2F;data&#x2F;&#x2F;shared_prefs目录下xml文件存放数据。由于创建时候会把整个xml文件全部加载进内存，故若SharedPreference文件比较大，会带来如下问题：</li>
</ol>
<ul>
<li>第一次从sp中获取值时，可能会阻塞主线程，使界面卡顿、掉帧。</li>
<li>解析sp时会产生大量临时对象，导致频繁GC，引起界面卡顿</li>
<li>这些存储的键值对会永远存储在内存中，不会释放，若存取较大的数据则十分消耗内存。<br>故优化建议如下：</li>
<li>不要存放大的数据，不相关的配置项不要放在一起。</li>
<li>频繁读取的key和不宜变动的key不要放在一起，影响读写速度。</li>
<li>不要多次apply和edit，尽量批量修改一次提交。多次apply会阻塞主线程（引起ANR）。</li>
</ul>
<blockquote>
<p>SP 调用 apply 方法，会创建一个等待锁mcr.writtenToDiskLatch.await()放到 QueuedWork 中，并将真正数据持久化封装成一个任务放到异步队列中执行，任务执行结束会释放锁。<br>Activity onStop 以及 Service 处理 onStop，onStartCommand 时，执行 QueuedWork.waitToFinish() 等待所有的等待锁释放。</p>
</blockquote>
<ul>
<li>尽量不要存放JSON和HTML。直接使用JSON配置文件。</li>
<li>不应使用SharedPreference进行跨进程通信（一般用ContentProvider。）</li>
</ul>
<h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><ol>
<li>内部存储（Internal Storage）</li>
</ol>
<ul>
<li>简介</li>
<li>位于&#x2F;data&#x2F;data&#x2F;&lt; package-name &gt;&#x2F;目录下的文件</li>
<li>依附于应用，位于和应用包名相同的目录下，只能被应用内部读写，且当应用卸载后，内部存储的文件也被删除。</li>
<li>内部存储控件有限，且存放系统本身和系统应用程序数据，包括SharedPreferences和SQLite数据库。</li>
<li>适用于存储体积小且安全性高的文件信息（内部存储一般用于系统存储APP专属文件）</li>
<li>存储路径 &amp; 获取方式</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>方法</th> 
   <th>路径</th> 
   <th>解释</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>getFilesDir()</td> 
   <td>/data/data/package-name/files</td> 
   <td>返回应用内部存放文件的目录的绝对路径。</td> 
  </tr> 
  <tr> 
   <td>getCacheDir()</td> 
   <td>/data/data/package-name/cache</td> 
   <td>返回应用内部存储的临时目录。系统内部存储即将耗尽的时候，可能会删除这个目录下的文件。</td> 
  </tr> 
  <tr> 
   <td>getDir(String name, int mode)</td> 
   <td>/data/data/package-name/name</td> 
   <td>可用于在应用内部存储根目录下创建或打开自定义的文件目录。name表示自定义的文件目录名。mode表示操作模式，用来控制该目录的读写权限，默认为MODE_PRIVATE，表示仅仅应用自身可以访问。</td> 
  </tr> 
 </tbody> 
</table>

<p>附：&#x2F;data&#x2F;user&#x2F;0&#x2F;packname&#x2F;目录（系统创建App专属文件）：<br><img src="https://mark.cuckooing.cn/pics/pic_6a2a6b26.png" alt="pic_6a2a6b26.png"><br>cache下存放缓存数据，databases下存放使用SQLite存储的数据，files下存放普通数据（log数据，json型数据等），shared_prefs下存放使用SharedPreference存放的数据。这些文件夹都是由系统创建的。</p>
<ul>
<li>存储方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeInternal</span><span class="params">(String fileName, String content)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 获取文件绝对路径</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">filePathName</span> <span class="operator">=</span> context.getFilesDir().getAbsolutePath()+<span class="string">&quot;/&quot;</span>+fileName;</span><br><span class="line">        <span class="comment">// 打开文件输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePathName);</span><br><span class="line">        <span class="comment">// 写数据到文件中</span></span><br><span class="line">        fileOutputStream.write(content.getBytes());</span><br><span class="line">        <span class="comment">// 关闭输出流</span></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>外部存储（External Storage）</li>
</ol>
<ul>
<li>简介</li>
<li>位于&#x2F;storage目录下的文件</li>
<li>4.4系统及以上的手机的外部存储分为机身存储（&#x2F;storage&#x2F;emulated&#x2F;） &amp; SD卡（&#x2F;storage&#x2F;sdcard&#x2F;）两部分。（SD卡属于USB存储设备的形式装载外部存储，可拆卸）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    files = getExternalFilesDirs(Environment.MEDIA_MOUNTED);</span><br><span class="line">    <span class="keyword">for</span>(File file:files)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Log.e(<span class="string">&quot;main&quot;</span>,file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有SD卡，打印路径有2条：</span></span><br><span class="line"><span class="comment">// /storage/emulated/0/Android/data/packname/files/mounted	机身存储的外部存储路径</span></span><br><span class="line"><span class="comment">// /storage/sdcard/0/Android/data/packname/files/mounted	SD卡存储的外部存储路径</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不依附于应用。外部存储的文件可以被全局访问，且用户卸载应用时，系统只卸载通过调用getExternalFilesDir()获取的目录里的文件（&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;packagename&#x2F;files）。</li>
<li>适用于存放希望被其他应用共享的及被用户访问的文件（外部存储一般用于开发人员存储APP专属文件）</li>
<li>存储路径 &amp; 获取方式</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>方法</th> 
   <th>路径</th> 
   <th>解释</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>Environment.getExternalStoragePublicDirectory(Environment.Type)<br>Environment.getExternalStorageDirectory(Environment.Type)</td> 
   <td>/storage/emulated/0</td> 
   <td>获取外部存储的公共文件路径</td> 
  </tr> 
  <tr> 
   <td>getExternalFilesDir(Environment.Type)</td> 
   <td>/storage/emulated/0/Android/data/package-name/files</td> 
   <td>获取某个应用在外部存储的私有文件路径</td> 
  </tr> 
  <tr> 
   <td>getExternalCacheDir()</td> 
   <td>/storage/emulated/0/Android/data/package-name/cache</td> 
   <td>获取某个应用在外部存储的cache路径</td> 
  </tr> 
 </tbody> 
</table>

<p>其中，Environment的Type参数有：</p>
<table> 
 <thead> 
  <tr> 
   <th>Environment的Type参数</th> 
   <th>对应模拟路径</th> 
   <th>解释说明</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>DIRECTORY_DCIM</td> 
   <td>/storage/emulated/0/DCIM</td> 
   <td>相册</td> 
  </tr> 
  <tr> 
   <td>DIRECTORY_DOCUMENTS</td> 
   <td>/storage/emulated/0/Documents</td> 
   <td>文件</td> 
  </tr> 
  <tr> 
   <td>DIRECTORY_DOWNLOADS</td> 
   <td>/storage/emulated/0/Download</td> 
   <td>下载文件</td> 
  </tr> 
  <tr> 
   <td>DIRECTORY_MUSIC</td> 
   <td>/storage/emulated/0/Music</td> 
   <td>音乐</td> 
  </tr> 
  <tr> 
   <td>DIRECTORY_PICTURES</td> 
   <td>/storage/emulated/0/Pictures</td> 
   <td>图片</td> 
  </tr> 
 </tbody> 
</table>

<ul>
<li>存储方式<br>（1）获取外部存储权限</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>（2）检测外部存储是否可用（外部存储可能不可用，比如用户将其挂载到了电脑或者移除了提供外部存储的SD卡）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExternalStorageWritable</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExternalStorageReadable</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state) ||</span><br><span class="line">        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）公共文件目录的获取<br>公共文件目录可以通过getExternalStoragePublicDirectory()方法获取，需要指定文件类型参数，以便外部统一处理。比如DIRECTORY_MUSIC或DIRECTORY_PICTURES。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> File <span class="title function_">getAlbumStorageDir</span><span class="params">(String albumName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Get the directory for the user&#x27;s public pictures directory.</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Environment.getExternalStoragePublicDirectory(</span><br><span class="line">            Environment.DIRECTORY_PICTURES), albumName);</span><br><span class="line">    <span class="keyword">if</span> (!file.mkdirs()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Log.e(LOG_TAG, <span class="string">&quot;Directory not created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用卸载时，系统不会删除这些文件。<br>（4）私有文件目录的获取<br>调用getExternalFilesDir()方法传入目录名字获取相应目录。当用户卸载应用时候，系统会删除这些文件。<br>比如，使用下面方法创建个人相册目录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> File <span class="title function_">getAlbumStorageDir</span><span class="params">(Context context, String albumName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Get the directory for the app&#x27;s private pictures directory.</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(context.getExternalFilesDir(</span><br><span class="line">            Environment.DIRECTORY_PICTURES), albumName);</span><br><span class="line">    <span class="keyword">if</span> (!file.mkdirs()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Log.e(LOG_TAG, <span class="string">&quot;Directory not created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法会在Environment.DIRECTORY_PICTURES目录下创建albumName值的目录，当然你也可以将第一个参数传为null，则会在你应用外部存储私有目录的根目录下创建。</p>
<ol>
<li>其他存储</li>
</ol>
<table> 
 <thead> 
  <tr> 
   <th>路径</th> 
   <th>系统文件</th> 
   <th>缓存文件</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>路径</td> 
   <td>/system</td> 
   <td>/cache</td> 
  </tr> 
  <tr> 
   <td>获取方式</td> 
   <td>Environment.getRootDirectory()</td> 
   <td>Environment.getDownloadCacheDirectory()</td> 
  </tr> 
 </tbody> 
</table>

<ol>
<li>案例：Android 保存网络图片到系统相册</li>
</ol>
<ul>
<li>确定存储路径<br>1、内部存储&#x2F;data&#x2F;data&#x2F;packageName&#x2F;（不采用）<br>一个应用对内部存储的所有访问都被限制在这个文件夹中，也就是说Android应用只能在该目录中读取，创建，修改文件。对该目录之外的其他内部存储中的目录都没有任何操作的权限。<br>因此，如果将图片保存在内部存储中，只能被应用自身读取，其他应用均无法读取。如果需要让系统图库，相册或其他应用能够找到保存的图片，必须将图片保存到外部存储中。<br>2、外部存储<br>（1）&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;packageName&#x2F;（不采用）<br>这个路径会随着应用的销毁而销毁，无法长期存储在内存中。因此，也不能将图片保存在这个目录中。<br>（2）&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;packageName&#x2F;image&#x2F;（采用）<br>除外部存储的&#x2F;Android目录之外的其他目录一般都是可以被其他应用访问的。目前，大多数应用都会在外部存储的根路径下建立一个类似包名的多层目录，以存储需要共享的文件。<br>获取外部存储路径：由于Android系统的碎片化问题，不同设备上外部存储的路径很可能会不同，因此，不能直接使用&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;作为外部存储的根路径。 Android SDK中 Environment类 提供了getExternalStorageDirectory()方法来获取外部存储的根路径。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Environment.getExternalStorageDirectory().getAbsolutePath();<span class="comment">// /storage/emulated/0</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dir</span> <span class="operator">=</span> Environment.getExternalStorageDirectory().getAbsolutePath() + <span class="string">&quot;/tencent/MicroMsg/WeiXin/&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取外部存储权限</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定外部存储状态<br>由于外部存储需要被挂载，也可以被卸载，在写入文件之前，需要先判断外部存储的状态是否正常。只有状态正常情况下才可以执行保存文件的操作。<br>挂载（mounting）是指由操作系统使一个存储设备（诸如硬盘、CD-ROM或共享资源）上的计算机文件和目录可供用户通过计算机的文件系统访问的一个过程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取内部存储状态</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> Environment.getExternalStorageState();</span><br><span class="line">	<span class="comment">//如果状态不是mounted，无法读写</span></span><br><span class="line">	<span class="keyword">if</span> (!state.equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定文件名<br>保存的图片文件名可以由应用根据自身需要自行确定，一般来说需要有一个命名规则，然后根据命名规则计算得到文件名。 常用：<br>（1）时间命名<br>根据保存图片的当前系统时间来对图片命名。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>, Locale.getDefault());</span><br><span class="line"><span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> simpleDate.format(now.getTime());</span><br></pre></td></tr></table></figure>

<p>（2）文件URL命名<br>每张网络图片都有一个对应的图片URL，可以根据图片的URL来对图片命名。</p>
<ul>
<li>保存到文件中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir + fileName + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        mBitmap.compress(Bitmap.CompressFormat.JPEG, <span class="number">100</span>, out);<span class="comment">//将Bitmap压缩到一个文件输出流</span></span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>发送广播，通知系统扫描保存后的文件<br>将Bitmap对象保存成外部存储中的一个jpg格式的文件。为了让其他应用能够知道图片文件被创建，必须通知MediaProvider服务将新建的文件添加到图片数据库中。<br>Android系统中常驻一个MediaProvider服务，对应的进程名为android.process.media，此服务用来管理本机上的媒体文件，提供媒体管理服务。在系统开机或者收到外部存储的挂载消息后，MediaProvider会调用MediaScanner，MediaScanner会扫描外部存储中的所有文件，根据文件类型的后缀将文件信息保存到对应的数据库中，供其他APP使用。<br>MediaScannerReceiver是一个广播接收者，当它接收到特定的广播请求后，就会去扫描指定的文件，并根据文件信息将其添加到数据库中。当图片文件被创建后，就可以发送广播给MediaScannerReceiver，通知其扫描新建的图片文件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存图片后发送广播通知更新系统图库（将图片保存在系统图库）</span></span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.fromFile(file);</span><br><span class="line">sendBroadcast(<span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, uri));</span><br></pre></td></tr></table></figure>

<ul>
<li>大图&#x2F;多图的异步保存<br>保存图片文件时，如果图片很大，或需要同时保存多张图片时，就需要较多的时间。为了避免阻塞UI线程，出现帧率下降或ANR，通常需要将图片保存操作放到线程中去执行。当图片保存完毕后通过sendMessage()方法通知UI线程保存结果。</li>
<li>完整代码<br>1、保存Bitmap到本地指定路径下<br>2、通过广播，通知系统相册图库刷新数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImgUtils</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//保存文件到指定路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">saveImageToGallery</span><span class="params">(Context context, Bitmap bmp)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 首先保存图片</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">storePath</span> <span class="operator">=</span> Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + <span class="string">&quot;dearxy&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">appDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(storePath);</span><br><span class="line">        <span class="keyword">if</span> (!appDir.exists()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            appDir.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(appDir, fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">            <span class="comment">//通过io流的方式来压缩保存图片</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> bmp.compress(Bitmap.CompressFormat.JPEG, <span class="number">60</span>, fos);</span><br><span class="line">            fos.flush();</span><br><span class="line">            fos.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把文件插入到系统图库</span></span><br><span class="line">            <span class="comment">//MediaStore.Images.Media.insertImage(context.getContentResolver(), file.getAbsolutePath(), fileName, null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//保存图片后发送广播通知更新数据库</span></span><br><span class="line">            <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.fromFile(file);</span><br><span class="line">            context.sendBroadcast(<span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, uri));</span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><ol>
<li>简介<br>一种轻量级Android 内置的数据库，是遵守ACID的关联式数据库管理系统。</li>
</ol>
<ul>
<li>存储结构型、关系型数据，可使用SQL语言，支持事务处理。</li>
<li>轻量级。占用资源非常低（可能只有几百K内存）。</li>
<li>位于 &#x2F;data&#x2F;data&#x2F;package-name&#x2F;databases&#x2F;database-name.db（内部存储，只能应用程序内部访问），Sqlite中每个数据库以单个文件形式存在，以B-Tree的形式存储在磁盘。</li>
<li>Sqlite共享锁和独享锁机制，保证线程安全。</li>
</ul>
<blockquote>
<p>一个共享锁允许多个数据库联接在同一时刻从这个数据库文件中读取信息。“共享”锁将不允许其他联接针对此数据库进行写操作。<br>一个临界锁允许其他所有已经取得共享锁的进程从数据库文件中继续读取数据。但是它会阻止新的共享锁的生成。也就说，临界锁将会防止因大量连续的读操作而无法获得写入的机会。</p>
</blockquote>
<ol>
<li>使用</li>
</ol>
<ul>
<li>创建一个类继承SQLiteOpenHelper，复写 onCreat()、onUpgrade()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseHelper</span> <span class="keyword">extends</span> <span class="title class_">SQLiteOpenHelper</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">Version</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * 在SQLiteOpenHelper的子类中，必须有该构造函数</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DatabaseHelper</span><span class="params">(Context context, String name, SQLiteDatabase.CursorFactory factory,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> version)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 参数说明</span></span><br><span class="line">        <span class="comment">// context：上下文对象 name：数据库名称 param：一个可选的游标工厂（通常是 Null） version：当前数据库的版本，值必须是整数并且是递增的状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须通过super调用父类的构造函数</span></span><br><span class="line">        <span class="built_in">super</span>(context, name, factory, version);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 复写onCreate（）</span></span><br><span class="line"><span class="comment">     * 调用时刻：当数据库第1次创建时调用</span></span><br><span class="line"><span class="comment">     * 作用：创建数据库 表 &amp; 初始化数据（getWritableDatabase() / getReadableDatabase() 第一次被调用时）</span></span><br><span class="line"><span class="comment">     * SQLite数据库创建支持的数据类型： 整型数据、字符串类型、日期类型、二进制</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(SQLiteDatabase db)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">              <span class="comment">// 创建数据库1张表</span></span><br><span class="line">              <span class="comment">// 通过execSQL（）执行SQL语句（此处创建了1个名为person的表）</span></span><br><span class="line">              <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;create table person(id integer primary key autoincrement,name varchar(64),address varchar(64))&quot;</span>; </span><br><span class="line">              db.execSQL(sql); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 复写onUpgrade（）</span></span><br><span class="line"><span class="comment">     * 调用时刻：当数据库升级时则自动调用（即 数据库版本 发生变化时）</span></span><br><span class="line"><span class="comment">     * 作用：更新数据库表结构</span></span><br><span class="line"><span class="comment">     * 注：创建SQLiteOpenHelper子类对象时,必须传入一个version参数，该参数 = 当前数据库版本, 若该版本高于之前版本, 就调用onUpgrade()</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="type">int</span> oldVersion, <span class="type">int</span> newVersion)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 参数说明： </span></span><br><span class="line">        <span class="comment">// db ： 数据库  oldVersion ： 旧版本数据库  newVersion ： 新版本数据库 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 SQL的ALTER语句，在person表中增加 sex 列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;alter table person add sex varchar(8)&quot;</span>;  </span><br><span class="line">        db.execSQL(sql);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建数据库</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：创建DatabaseHelper对象（注：此时还未创建数据库）</span></span><br><span class="line"> <span class="type">SQLiteOpenHelper</span> <span class="variable">dbHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseHelper</span>(SQLiteActivity.<span class="built_in">this</span>,<span class="string">&quot;test_carson&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：真正创建 / 打开数据库</span></span><br><span class="line"> <span class="type">SQLiteDatabase</span> <span class="variable">sqliteDatabase</span> <span class="operator">=</span> dbHelper.getWritableDatabase(); <span class="comment">// 创建 or 打开 可读/写的数据库</span></span><br><span class="line"> <span class="type">SQLiteDatabase</span> <span class="variable">sqliteDatabase</span> <span class="operator">=</span> dbHelper.getReadableDatabase(); <span class="comment">// 创建 or 打开 可读的数据库</span></span><br></pre></td></tr></table></figure>

<ul>
<li>操作数据库</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user (id,name) values (1,&#x27;carson&#x27;)&quot;</span>;</span><br><span class="line">        db.execSQL(sql) ；</span><br><span class="line">        <span class="comment">// 修改数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update [user] set name = &#x27;zhangsan&#x27; where id=&quot;</span><span class="number">1</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">        db.execSQL(sql);</span></span><br><span class="line"><span class="string">        // 删除数据</span></span><br><span class="line"><span class="string">        String sql = &quot;</span>delete from user where id=<span class="string">&quot;1&quot;</span>；</span><br><span class="line">        db.execSQL(sql);</span><br><span class="line">        <span class="comment">// 查询数据</span></span><br><span class="line">        <span class="comment">// db.query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy); </span></span><br><span class="line">        <span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> sqliteDatabase.query(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      <span class="string">&quot;id&quot;</span>,<span class="string">&quot;name&quot;</span> &#125;, <span class="string">&quot;id=?&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      <span class="string">&quot;1&quot;</span> &#125;, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span>(cursor.moveToFirst()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">           <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;name&quot;</span>)); </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 关闭数据库</span></span><br><span class="line">         db.close();</span><br></pre></td></tr></table></figure>



<h1 id="第四章-自定义组件、动画"><a href="#第四章-自定义组件、动画" class="headerlink" title="第四章 自定义组件、动画"></a>第四章 自定义组件、动画</h1><ul>
<li>自定义View</li>
<li><ul>
<li>Activity、PhoneWindow、DecorView、ViewRoot</li>
<li>View绘制流程</li>
<li>自定义View</li>
<li>View刷新&#x2F;重绘机制</li>
</ul>
</li>
<li>View的事件分发机制</li>
<li><ul>
<li>Touch事件的传递 &amp; 拦截机制</li>
<li>事件分发中的onTouch、onTouchEvent （和onClick） 有什么区别，又该如何使用？</li>
</ul>
</li>
<li>动画</li>
<li><ul>
<li>种类 &amp; 特点 &amp; 区别 &amp;原理</li>
<li>使用</li>
<li>源码</li>
<li>问题</li>
<li>估值器</li>
</ul>
</li>
<li>ListView &amp; RecycleView</li>
<li><ul>
<li>ListView 定义 &amp; 原理 &amp; 优化 &amp; 封装？</li>
<li>RecycleView 对比 &amp; 应用</li>
</ul>
</li>
<li>PopupWindow &amp; Dialog</li>
<li><ul>
<li>PopupWindow</li>
<li>Dialog</li>
<li>PopupWindow &amp; Dialog 区别</li>
</ul>
</li>
</ul>
<h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><h3 id="Activity、PhoneWindow、DecorView、ViewRoot"><a href="#Activity、PhoneWindow、DecorView、ViewRoot" class="headerlink" title="Activity、PhoneWindow、DecorView、ViewRoot"></a>Activity、PhoneWindow、DecorView、ViewRoot</h3><p>[Activity、PhoneWindow、DecorView、ViewRoot][Activity_PhoneWindow_DecorView_ViewRoot 1]</p>
<ol>
<li>Activity 控制器<br>Activity并不负责视图控制，它只是控制生命周期和处理事件。真正控制视图的是Window。一个Activity包含了一个Window，Window才是真正代表一个窗口。Activity就像一个控制器，统筹视图的添加与显示，以及通过其他回调方法，来与Window、以及View进行交互。</li>
<li>Window 承载器<br>Window是视图的承载器，承载视图View的显示。内部持有一个 DecorView，而这个DecorView才是 view 的根布局。<br>Window是一个抽象类，实际在Activity中持有的是其子类PhoneWindow。PhoneWindow中有个内部类DecorView，通过创建DecorView来加载Activity中设置的布局R.layout.activity_main。<br>Window 通过WindowManager将DecorView加载其中，并将DecorView交给ViewRoot，进行视图绘制以及其他交互。</li>
</ol>
<ul>
<li>WindowManager &amp; WindowManagerService<br>[带你彻底理解 Window 和 WindowManager][Window _ WindowManager]</li>
<li>Window 分类<br>Window 有三种类型，分别是应用 Window、子 Window 和系统 Window。应用类 Window 对应一个 Acitivity，子 Window 不能单独存在，需要依附在特定的父 Window 中，比如常见的一些 Dialog 就是一个子 Window。系统 Window是需要声明权限才能创建的 Window，比如 Toast 和系统状态栏都是系统 Window。<br>Window 是分层的，每个 Window 都有对应的 z-ordered，层级大的会覆盖在层级小的 Window 上面，这和 HTML 中的 z-index 概念是完全一致的。在三种 Window 中，应用 Window 层级范围是 1 ~ 99，子 Window 层级范围是 1000 ~ 1999，系统 Window 层级范围是 2000 ~ 2999</li>
<li>WindowManagerService<br>WindowManagerService 就是位于 Framework 层（Android Application层）的窗口管理服务，它的职责就是管理系统中的所有窗口。窗口的本质是什么呢？其实就是一块显示区域，在 Android 中就是绘制的画布：Surface，当一块 Surface 显示在屏幕上时，就是用户所看到的窗口了。WindowManagerService 添加一个窗口的过程，其实就是 WindowManagerService 为其分配一块 Surface 的过程，一块块的 Surface 在 WindowManagerService 的管理下有序的排列在屏幕上，Android 才得以呈现出多姿多彩的界面。于是根据对 Surface 的操作类型可以将 Android 的显示系统分为三个层次，如下图：<br><img src="https://mark.cuckooing.cn/pics/pic_990a32e5.png" alt="pic_990a32e5.png"><br>一般的开发过程中，我们操作的是 UI 框架层，对 Window 的操作通过 WindowManager 即可完成，而 WindowManagerService 作为系统级服务运行在一个单独的进程，所以 WindowManager 和 WindowManagerService 的交互是一个 IPC 过程。</li>
<li>WindowManager<br>在实际使用中无法直接访问 Window，我们对 Window 的操作是通过 WindowManager 来完成的，WindowManager 是一个接口，它继承自只有三个方法的 ViewManager 接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewManager</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeView</span><span class="params">(View view)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个方法其实就是 WindowManager 对外提供的主要功能，即添加 View、更新 View 和删除 View。WindowManager 最终都会通过一个 IPC 过程将操作移交给 WindowManagerService 这个位于 Framework 层的窗口管理服务来处理。</p>
<ol>
<li>DecorView 顶级View<br>DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点&#x2F;顶级视图。用于显示 &amp; 加载视图。它内部包含一个竖直方向的LinearLayout，在这个LinearLayout里面有两个部分：标题栏(根据Theme设置，有的布局没有)，下面的是内容栏。 具体情况和Android版本及主体有关，以其中一个布局为例，如下所示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:fitsSystemWindows=<span class="string">&quot;true&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span>&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        style=<span class="string">&quot;?android:attr/windowTitleBackgroundStyle&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;?android:attr/windowTitleSize&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=<span class="string">&quot;@android:id/title&quot;</span></span><br><span class="line">            style=<span class="string">&quot;?android:attr/windowTitleStyle&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:background=<span class="string">&quot;@null&quot;</span></span><br><span class="line">            android:fadingEdge=<span class="string">&quot;horizontal&quot;</span></span><br><span class="line">            android:gravity=<span class="string">&quot;center_vertical&quot;</span> /&gt;</span><br><span class="line">    &lt;/FrameLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">        android:id=<span class="string">&quot;@android:id/content&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;0dip&quot;</span></span><br><span class="line">        android:layout_weight=<span class="string">&quot;1&quot;</span></span><br><span class="line">        android:foreground=<span class="string">&quot;?android:attr/windowContentOverlay&quot;</span></span><br><span class="line">        android:foregroundGravity=<span class="string">&quot;fill_horizontal|top&quot;</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>在Activity中通过setContentView所设置的布局文件其实就是被加到内容栏之中的，成为其唯一子View，就是上面的id为content的FrameLayout中，在代码中可以通过content来得到对应加载的布局。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ViewGroup</span> <span class="variable">content</span> <span class="operator">=</span> (ViewGroup)findViewById(android.R.id.content);</span><br><span class="line"><span class="type">ViewGroup</span> <span class="variable">rootView</span> <span class="operator">=</span> (ViewGroup) content.getChildAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>ViewRoot 连接器<br>所有View的绘制以及事件分发等交互都是通过ViewRoot来执行或传递的。<br>ViewRoot对应ViewRootImpl类。它的作用包括：<br>（1）连接WindowManager 和 DecorView<br>（2）完成View的绘制流程<br>即ViewRoot可以与WMS交互通讯，调整窗口大小及分布；可以接收事件并向DecorView分发，Android的所有触屏事件、按键事件、界面刷新等事件都是通过ViewRoot进行分发的；可以完成View的三大绘制流程：测量、布局和绘制。</li>
<li>Activity &amp; PhoneWindow &amp; DecorView &amp; ViewRoot 联系<br><img src="https://mark.cuckooing.cn/pics/pic_c7408db6.png" alt="pic_c7408db6.png"><br>Activity就像个控制器，不负责视图部分。Window像个承载器，装着内部视图。DecorView就是个顶层视图，是所有View的最外层布局。ViewRoot像个连接器，负责沟通，通过硬件的感知来通知视图，进行用户之间的交互。</li>
<li>DecorView 的创建 &amp; 显示（View 绘制前准备）<br>工作流程<br><img src="https://mark.cuckooing.cn/pics/pic_e6d8310a.png" alt="pic_e6d8310a.png"><br>源码分析<br>总结：<br>（1） DecroView的创建</li>
</ol>
<ul>
<li>Activity 启动时过程（attach()方法中），系统创建Window抽象子类PhoneWindow类实例对象，并为PhoneWindow类对象设置WindowManager对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mWindow = <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(<span class="built_in">this</span>, window);</span><br><span class="line">mWindow.setWindowManager(...);</span><br></pre></td></tr></table></figure>

<ul>
<li>Activity 调用onCreate中通过setContentView(resId)中在PhoneWindow中创建一个DecroView类对象（初始布局根据系统主体样式），并为DecroView中content增加Activity中设置的布局文件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">installDecor();</span><br><span class="line">mLayoutInflater.inflate(layoutResID, mContentParent);</span><br></pre></td></tr></table></figure>

<p>（2）DecroView 的显示</p>
<ul>
<li>将DecroView对象添加到WindowManager</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wm.addView(mDecor, getWindow().getAttributes());</span><br></pre></td></tr></table></figure>

<ul>
<li>创建ViewRoot，WindowManager将DecroView对象交给ViewRoot。ViewRootImpl对象通过Handler向主线程发送了一条触发遍历操作的消息：performTraversals()；该方法用于执行View的绘制流程（measure、layout、draw）。并将DecroView设置为可见。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display);</span><br><span class="line">performTraversals(); </span><br><span class="line">mDecor.setVisibility(View.VISIBLE);</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li>DecroView 的创建<br>这部分内容主要讲DecorView是怎么一层层嵌套在Actvity，PhoneWindow中的，以及DecorView如何加载内部布局。<br>（1）创建Window抽象类的子类PhoneWindow类的实例对象，为PhoneWindow类对象设置WindowManager对象<br>Activity启动过程（由ActivityThread 中的 performLaunchActivity() 来完成整个启动过程，在这个方法内部会通过类加载器创建 Activity 的实例对象，并调用其 attach 方法为其关联运行过程中所依赖的一系列上下文环境变量）<br>Activity 的 Window 创建就发生在 attach 方法里，系统会创建 Activity 所属的 Window 对象并为其设置回调接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span><br><span class="line"><span class="params">    Instrumentation instr, IBinder token, <span class="type">int</span> ident,</span></span><br><span class="line"><span class="params">    Application application, Intent intent, ActivityInfo info,</span></span><br><span class="line"><span class="params">    CharSequence title, Activity parent, String id,</span></span><br><span class="line"><span class="params">    NonConfigurationInstances lastNonConfigurationInstances,</span></span><br><span class="line"><span class="params">    Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">    Window window)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        ..................................................................</span><br><span class="line">        <span class="comment">//1. 创建一个PhoneWindow对象</span></span><br><span class="line">        mWindow = <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(<span class="built_in">this</span>, window);</span><br><span class="line">        mWindow.setWindowControllerCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//2. 设置回调，向Activity分发点击或状态改变等事件</span></span><br><span class="line">        mWindow.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        mWindow.setOnWindowDismissedCallback(<span class="built_in">this</span>);</span><br><span class="line">        .................................................................</span><br><span class="line">        <span class="comment">//3. 给Window设置WindowManager对象</span></span><br><span class="line">        mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">        ....................................................................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）为PhoneWindow类对象创建1个DecroView类对象，并为DecroView类对象中的contnt增加Activity中设置的布局文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：Activity的setContentView()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="comment">// getWindow() 作用：获得Activity 的成员变量mWindow</span></span><br><span class="line">    	<span class="comment">// Window类实例的setContentView（） -&gt;&gt;分析1</span></span><br><span class="line">	    getWindow().setContentView(layoutResID);</span><br><span class="line">	    initWindowDecorActionBar();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：Window类实例的setContentView（）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">  		<span class="comment">// 1. 若mContentParent为空，创建一个DecroView（在PhoneWindow中嵌套添加DecroView）</span></span><br><span class="line">  		<span class="comment">// mContentParent即为内容栏（content）对应的DecorView = FrameLayout子类</span></span><br><span class="line">        <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            installDecor(); <span class="comment">// -&gt;&gt;分析2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        	<span class="comment">// 若不为空，则删除其中的View</span></span><br><span class="line">            mContentParent.removeAllViews();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 为mContentParent添加子View，即Activity中设置的布局文件</span></span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> getCallback();</span><br><span class="line">        <span class="keyword">if</span> (cb != <span class="literal">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            cb.onContentChanged();<span class="comment">//回调通知，内容改变</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析2：installDecor()</span></span><br><span class="line"><span class="comment">  * 作用：创建一个DecroView</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">installDecor</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="comment">// 1. 生成DecorView</span></span><br><span class="line">        mDecor = generateDecor();</span><br><span class="line">        ...</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    <span class="comment">// 2. 为DecorView设置布局格式 &amp; 返回mContentParent -&gt;&gt;分析3</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mContentParent = generateLayout(mDecor); </span><br><span class="line">        ...</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析3：generateLayout(mDecor)</span></span><br><span class="line"><span class="comment">  * 作用：为DecorView设置布局格式</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">protected</span> ViewGroup <span class="title function_">generateLayout</span><span class="params">(DecorView decor)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从主题文件中获取样式信息</span></span><br><span class="line">        <span class="type">TypedArray</span> <span class="variable">a</span> <span class="operator">=</span> getWindowStyle();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 根据主题样式，加载窗口布局</span></span><br><span class="line">        <span class="type">int</span> layoutResource;</span><br><span class="line">        <span class="type">int</span> <span class="variable">features</span> <span class="operator">=</span> getLocalFeatures();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 加载layoutResource</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">in</span> <span class="operator">=</span> mLayoutInflater.inflate(layoutResource, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 往DecorView中添加子View</span></span><br><span class="line">        <span class="comment">// 即文章开头介绍DecorView时提到的布局格式，那只是一个例子，根据主题样式不同，加载不同的布局。（上：titleBar 下：content）</span></span><br><span class="line">        decor.addView(in, <span class="keyword">new</span> <span class="title class_">ViewGroup</span>.LayoutParams(MATCH_PARENT, MATCH_PARENT)); </span><br><span class="line">        mContentRoot = (ViewGroup) in;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 这里获取的是mContentParent = 即为内容栏（content）对应的DecorView = FrameLayout子类</span></span><br><span class="line">        <span class="type">ViewGroup</span> <span class="variable">contentParent</span> <span class="operator">=</span> (ViewGroup)findViewById(ID_ANDROID_CONTENT); </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> contentParent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>DecroView 的显示<br>以上仅仅是将DecorView建立起来。通过setContentView()设置的界面，为什么在onResume()之后才对用户可见呢？<br>（1）将DecroView对象添加到WindowManager<br>（2）创建ViewRoot，WindowManager将DecroView对象交给ViewRoot。ViewRootImpl对象通过Handler向主线程发送了一条触发遍历操作的消息：performTraversals()；该方法用于执行View的绘制流程（measure、layout、draw）<br>这就要从ActivityThread开始说起。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里首先调用Activity.attach()，接着调用了Activity.onCreate()和Activity.onStart()生命周期，</span></span><br><span class="line">    <span class="comment">//但是由于只是初始化了mDecor，添加了布局文件，还没有把mDecor添加到负责UI显示的PhoneWindow中，所以这时候对用户来说，是不可见的</span></span><br><span class="line">    <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//这里面执行了Activity.onResume()</span></span><br><span class="line">    handleResumeActivity(r.token, <span class="literal">false</span>, r.isForward,</span><br><span class="line">                        !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                r.activity.mCalled = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//执行Activity.onPause()</span></span><br><span class="line">                mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看下handleResumeActivity(),在这其中，DecorView将会显示出来，同时重要的一个角色：ViewRoot也将登场。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">handleResumeActivity</span><span class="params">(IBinder token, <span class="type">boolean</span> clearHide, </span></span><br><span class="line"><span class="params">                                <span class="type">boolean</span> isForward, <span class="type">boolean</span> reallyResume)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个时候，Activity.onResume()已经调用了，但是现在界面还是不可见的</span></span><br><span class="line">    <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> performResumeActivity(token, clearHide);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> r.activity;</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="literal">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> r.window.getDecorView();</span><br><span class="line">            <span class="comment">//decor对用户不可见</span></span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            <span class="type">ViewManager</span> <span class="variable">wm</span> <span class="operator">=</span> a.getWindowManager();</span><br><span class="line">            WindowManager.<span class="type">LayoutParams</span> <span class="variable">l</span> <span class="operator">=</span> r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line"></span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//DecorView被添加进WindowManager了，但是这个时候，还是不可见的</span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">                    &amp;&amp; r.activity.mDecor != <span class="literal">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//在这里，执行了重要的操作,使得DecorView可见 -&gt;&gt; 分析1</span></span><br><span class="line">                <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    r.activity.makeVisible();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：Activity.makeVisible()</span></span><br><span class="line"><span class="comment">  * 当我们执行了Activity.makeVisible()方法之后，界面才对我们是可见的。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">makeVisible</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">   <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="type">ViewManager</span> <span class="variable">wm</span> <span class="operator">=</span> getWindowManager();</span><br><span class="line">            <span class="comment">// 1. 将DecorView添加到WindowManager -&gt;&gt;分析2</span></span><br><span class="line">            wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">            mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. DecorView可见</span></span><br><span class="line">        mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析2：wm.addView</span></span><br><span class="line"><span class="comment">  * 作用：WindowManager = 1个接口，由WindowManagerImpl类实现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">WindowManager</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">         </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WindowManagerGlobal</span> <span class="variable">mGlobal</span> <span class="operator">=</span> WindowManagerGlobal.getInstance();</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mGlobal.addView(view, params, mDisplay, mParentWindow); -&gt;&gt;分析<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析3：WindowManagerGlobal 的addView()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">             <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">wparams</span> <span class="operator">=</span> (WindowManager.LayoutParams)params;</span><br><span class="line"></span><br><span class="line">             ...</span><br><span class="line"></span><br><span class="line">             <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">             <span class="comment">// 1. 实例化一个ViewRootImpl对象</span></span><br><span class="line">             ViewRootImpl root;</span><br><span class="line">             root = <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display);</span><br><span class="line">             view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">             mViews.add(view);</span><br><span class="line">             mRoots.add(root);</span><br><span class="line">             mParams.add(wparams);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 2. WindowManager将DecorView实例对象交给ViewRootImpl 绘制View</span></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                  root.setView(view, wparams, panelParentView);</span><br><span class="line">                  <span class="comment">// -&gt;&gt; 分析4</span></span><br><span class="line"></span><br><span class="line">                	&#125;<span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析4：ViewRootImpl.setView（）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                requestLayout(); <span class="comment">// -&gt;&gt;分析5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析5：ViewRootImpl.requestLayout()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLayout</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        	<span class="comment">// 1. 检查是否在主线程</span></span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="literal">true</span>;<span class="comment">//mLayoutRequested 是否measure和layout布局。</span></span><br><span class="line">            <span class="comment">// 2. -&gt;&gt;分析6</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析6：ViewRootImpl.scheduleTraversals()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过mHandler.post（）发送一个runnable，在run()方法中去处理绘制流程</span></span><br><span class="line">            <span class="comment">// 与ActivityThread的Handler消息传递机制相似</span></span><br><span class="line">            <span class="comment">// -&gt;&gt;分析7</span></span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">            ``````</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析7：Runnable类的子类对象mTraversalRunnable</span></span><br><span class="line"><span class="comment">  * 作用：在run()方法中去处理绘制流程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">            doTraversal(); <span class="comment">// -&gt;&gt;分析8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">TraversalRunnable</span> <span class="variable">mTraversalRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraversalRunnable</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 分析8：doTraversal()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​     </span><br><span class="line">​            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">​    </span><br><span class="line">​            performTraversals(); </span><br><span class="line">​            <span class="comment">// 最终会调用performTraversals()，从而开始View绘制的3大流程：Measure、Layout、Draw</span></span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="comment">// 注：</span></span><br><span class="line">​    <span class="comment">//    a. 我们知道ViewRootImpl中W类是Binder的Native端，用于接收WmS处理操作</span></span><br><span class="line">​    <span class="comment">//    b. 因W类的接收方法是在线程池中的，故可通过Handler将事件处理切换到主线程中</span></span><br></pre></td></tr></table></figure>

<p>ViewRootImpl对象中接收的各种变化（如来自WmS的窗口属性变化、来自控件树的尺寸变化 &amp; 重绘请求等都引发performTraversals()的调用 &amp; 在其中完成处理。<br>而View的绘制则是在performTraversals()中执行，即View的绘制流程：measure、layout、draw</p>
<h3 id="View绘制流程"><a href="#View绘制流程" class="headerlink" title="View绘制流程"></a>View绘制流程</h3><p>View的绘制流程开始于：ViewRootImpl对象的performTraversals()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：ViewRootImpl.performTraversals()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">  		<span class="comment">// 1. 执行measure流程</span></span><br><span class="line">        <span class="comment">// 内部会调用performMeasure()</span></span><br><span class="line">        measureHierarchy(host, lp, res,desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 执行layout流程</span></span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行draw流程</span></span><br><span class="line">        performDraw();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的performTraversals()可知：View的绘制流程从顶级View（DecorView）的ViewGroup开始，一层一层从ViewGroup至子View遍历测绘，采用递归实现<br>即：自上而下遍历、由父视图到子视图、每一个 ViewGroup 负责测绘它所有的子视图，而最底层的 View 会负责测绘自身<br><img src="https://mark.cuckooing.cn/pics/pic_8693b15f.png" alt="pic_8693b15f.png"><br>绘制的流程 &#x3D; measure过程 + layout过程 + draw过程</p>
<ol>
<li>measure —— 测量View的宽 &#x2F; 高<br>（1）Android 尺寸值</li>
</ol>
<ul>
<li>ViewGroup.LayoutParams 布局参数<br>指定视图View 的高度（height） 和 宽度（width）等布局参数。可通过以下参数指定</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>参数</th> 
   <th>解释</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>具体值</td> 
   <td>dp / px</td> 
  </tr> 
  <tr> 
   <td>match_parent</td> 
   <td>强制性使子视图的大小扩展至与父视图大小相等（不含 padding )</td> 
  </tr> 
  <tr> 
   <td>wrap_content</td> 
   <td>自适应大小，强制性地使视图扩展以便显示其全部内容(含 padding )</td> 
  </tr> 
 </tbody> 
</table>

<ul>
<li>MeasureSpec 测量规格</li>
<li>描述<br>View大小的测量依据。<br>测量规格（MeasureSpec） &#x3D; 测量模式（mode） + 测量大小（size）</li>
<li>计算方法<br>子View的MeasureSpec值根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：getChildMeasureSpec（）</span></span><br><span class="line"><span class="comment">  * 作用：根据父视图的MeasureSpec &amp; 布局参数LayoutParams，计算单个子View的MeasureSpec</span></span><br><span class="line"><span class="comment">  * 注：子view的大小由父view的MeasureSpec值 和 子view的LayoutParams属性 共同决定</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildMeasureSpec</span><span class="params">(<span class="type">int</span> spec, <span class="type">int</span> padding, <span class="type">int</span> childDimension)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">         <span class="comment">//参数说明</span></span><br><span class="line">         * <span class="meta">@param</span> spec 父view的详细测量值(MeasureSpec) </span><br><span class="line">         * <span class="meta">@param</span> padding view当前尺寸的的内边距和外边距(padding,margin) </span><br><span class="line">         * <span class="meta">@param</span> childDimension 子视图的布局参数（宽/高）</span><br><span class="line"></span><br><span class="line">            <span class="comment">//父view的测量模式</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(spec);     </span><br><span class="line"></span><br><span class="line">            <span class="comment">//父view的大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(spec);     </span><br><span class="line">          </span><br><span class="line">            <span class="comment">//通过父view计算出的子view = 父大小-边距（父要求的大小，但子view不一定用这个值）   </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, specSize - padding);  </span><br><span class="line">          </span><br><span class="line">            <span class="comment">//子view想要的实际大小和模式（需要计算）  </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">resultSize</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">resultMode</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">          </span><br><span class="line">            <span class="comment">//通过父view的MeasureSpec和子view的LayoutParams确定子view的大小  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当父view的模式为EXACITY时，父view强加给子view确切的值</span></span><br><span class="line">           <span class="comment">//一般是父view设置为match_parent或者固定值的ViewGroup </span></span><br><span class="line">            <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">            <span class="keyword">case</span> MeasureSpec.EXACTLY:  </span><br><span class="line">                <span class="comment">// 当子view的LayoutParams&gt;0，即有确切的值  </span></span><br><span class="line">                <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                    <span class="comment">//子view大小为子自身所赋的值，模式大小为EXACTLY  </span></span><br><span class="line">                    resultSize = childDimension;  </span><br><span class="line">                    resultMode = MeasureSpec.EXACTLY;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当子view的LayoutParams为MATCH_PARENT时(-1)  </span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                    <span class="comment">//子view大小为父view大小，模式为EXACTLY  </span></span><br><span class="line">                    resultSize = size;  </span><br><span class="line">                    resultMode = MeasureSpec.EXACTLY;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当子view的LayoutParams为WRAP_CONTENT时(-2)      </span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                    <span class="comment">//子view决定自己的大小，但最大不能超过父view，模式为AT_MOST  </span></span><br><span class="line">                    resultSize = size;  </span><br><span class="line">                    resultMode = MeasureSpec.AT_MOST;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 当父view的模式为AT_MOST时，父view强加给子view一个最大的值。（一般是父view设置为wrap_content）  </span></span><br><span class="line">            <span class="keyword">case</span> MeasureSpec.AT_MOST:  </span><br><span class="line">                <span class="comment">// 道理同上  </span></span><br><span class="line">                <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                    resultSize = childDimension;  </span><br><span class="line">                    resultMode = MeasureSpec.EXACTLY;  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                    resultSize = size;  </span><br><span class="line">                    resultMode = MeasureSpec.AT_MOST;  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                    resultSize = size;  </span><br><span class="line">                    resultMode = MeasureSpec.AT_MOST;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 当父view的模式为UNSPECIFIED时，父容器不对view有任何限制，要多大给多大</span></span><br><span class="line">            <span class="comment">// 多见于ListView、GridView  </span></span><br><span class="line">            <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:  </span><br><span class="line">                <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                    <span class="comment">// 子view大小为子自身所赋的值  </span></span><br><span class="line">                    resultSize = childDimension;  </span><br><span class="line">                    resultMode = MeasureSpec.EXACTLY;  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                    <span class="comment">// 因为父view为UNSPECIFIED，所以MATCH_PARENT的话子类大小为0  </span></span><br><span class="line">                    resultSize = <span class="number">0</span>;  </span><br><span class="line">                    resultMode = MeasureSpec.UNSPECIFIED;  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                    <span class="comment">// 因为父view为UNSPECIFIED，所以WRAP_CONTENT的话子类大小为0  </span></span><br><span class="line">                    resultSize = <span class="number">0</span>;  </span><br><span class="line">                    resultMode = MeasureSpec.UNSPECIFIED;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mark.cuckooing.cn/pics/pic_5331172a.png" alt="pic_5331172a.png"></p>
<blockquote>
<p>规律总结：<br><img src="https://mark.cuckooing.cn/pics/pic_816662ee.png" alt="pic_816662ee.png"></p>
</blockquote>
<p>（2）measure流程<br><img src="https://mark.cuckooing.cn/pics/pic_1d3e794a.png" alt="pic_1d3e794a.png"></p>
<ul>
<li>单一View</li>
<li>ViewGroup<br>a. 遍历 测量所有子View的尺寸<br>b. 合并将所有子View的尺寸进行，最终得到ViewGroup父视图的测量值<br>自上而下、一层层地传递下去，直到完成整个View树的measure（）过程<br>（1）自定义ViewGroup<br>需要复写onMeasure()从而实现自定义子View测量逻辑<br>因为不同的ViewGroup子类（LinearLayout、RelativeLayout &#x2F; 自定义ViewGroup子类等）具备不同的布局特性，这导致他们子View的测量方法各有不同。因此，ViewGroup无法对onMeasure（）作统一实现。<br>根据自身的测量逻辑复写onMeasure（），分为4步</li>
<li>遍历所有子View：measureChildren（）</li>
<li>对子View 进行测量（根据父容器的measureSpec &amp; 布局参数layoutParams） 并 递归调用View.measure()：measureChild</li>
<li>合并所有子View的尺寸大小,最终得到ViewGroup父视图的测量值（自身实现）</li>
<li>存储测量后View宽&#x2F;高的值：调用setMeasuredDimension()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 定义存放测量后的View宽/高的变量</span></span><br><span class="line">        <span class="type">int</span> widthMeasure ;</span><br><span class="line">        <span class="type">int</span> heightMeasure ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 遍历所有子View &amp; 测量(measureChildren（）)</span></span><br><span class="line">        <span class="comment">// -&gt;&gt; 分析1</span></span><br><span class="line">        measureChildren(widthMeasureSpec, heightMeasureSpec)；</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 合并所有子View的尺寸大小，最终得到ViewGroup父视图的测量值</span></span><br><span class="line">         <span class="keyword">void</span> measureCarson&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">             ... <span class="comment">// 根据布局方式自身实现</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 存储测量后View宽/高的值：调用setMeasuredDimension()</span></span><br><span class="line">        setMeasuredDimension(widthMeasure,  heightMeasure);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从上可看出：</span></span><br><span class="line">  <span class="comment">// 复写onMeasure（）有三步，其中2步直接调用系统方法</span></span><br><span class="line">  <span class="comment">// 需自身实现的功能实际仅为步骤2：合并所有子View的尺寸大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：measureChildren()</span></span><br><span class="line"><span class="comment">  * 作用：遍历子View &amp; 调用measureChild()进行下一步测量</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">measureChildren</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 参数说明：父视图的测量规格（MeasureSpec）</span></span><br><span class="line"></span><br><span class="line">		        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mChildrenCount;</span><br><span class="line">		        <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 遍历所有子view</span></span><br><span class="line">		        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> children[i];</span><br><span class="line">		             <span class="comment">// 调用measureChild()进行下一步的测量 -&gt;&gt;分析1</span></span><br><span class="line">		            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		                measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">		            &#125;</span><br><span class="line">		        &#125;</span><br><span class="line">		    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析2：measureChild()</span></span><br><span class="line"><span class="comment">  * 作用：a. 计算单个子View的MeasureSpec</span></span><br><span class="line"><span class="comment">  *      b. 测量每个子View最后的宽 / 高：调用子View的measure()</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">measureChild</span><span class="params">(View child, <span class="type">int</span> parentWidthMeasureSpec,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> parentHeightMeasureSpec)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取子视图的布局参数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 根据父视图的MeasureSpec &amp; 布局参数LayoutParams，计算单个子View的MeasureSpec</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentWidthMeasureSpec,<span class="comment">// 获取 ChildView 的 widthMeasureSpec</span></span><br><span class="line">                mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentHeightMeasureSpec,<span class="comment">// 获取 ChildView 的 heightMeasureSpec</span></span><br><span class="line">                mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将计算好的子View的MeasureSpec值传入measure()，进行最后的测量</span></span><br><span class="line">        <span class="comment">// 下面的流程即类似单一View的过程，此处不作过多描述</span></span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回到调用原处</span></span><br></pre></td></tr></table></figure>

<p>（2）实例：LinearLayout extends ViewGroup</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据不同的布局属性进行不同的计算</span></span><br><span class="line">      <span class="comment">// 此处只选垂直方向的测量过程，即measureVertical()-&gt;&gt;分析1</span></span><br><span class="line">      <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">          measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">          measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 分析1：measureVertical()</span></span><br><span class="line"><span class="comment">    * 作用：测量LinearLayout垂直方向的测量尺寸</span></span><br><span class="line"><span class="comment">    **/</span> </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">measureVertical</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  其余测量逻辑</span></span><br><span class="line"><span class="comment">       **/</span></span><br><span class="line">          <span class="comment">// 获取垂直方向上的子View个数</span></span><br><span class="line">          <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 遍历子View获取其高度，并记录下子View中最高的高度数值</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">              <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 子View不可见，直接跳过该View的measure过程，getChildrenSkipCount()返回值恒为0</span></span><br><span class="line">              <span class="comment">// 注：若view的可见属性设置为VIEW.INVISIBLE，还是会计算该view大小</span></span><br><span class="line">              <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                 i += getChildrenSkipCount(child, i);</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 记录子View是否有weight属性设置，用于后面判断是否需要二次measure</span></span><br><span class="line">              totalWeight += lp.weight;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                  <span class="comment">// 如果LinearLayout的specMode为EXACTLY且子View设置了weight属性，在这里会跳过子View的measure过程</span></span><br><span class="line">                  <span class="comment">// 同时标记skippedMeasure属性为true，后面会根据该属性决定是否进行第二次measure</span></span><br><span class="line">                <span class="comment">// 若LinearLayout的子View设置了weight，会进行两次measure计算，比较耗时</span></span><br><span class="line">                  <span class="comment">// 这就是为什么LinearLayout的子View需要使用weight属性时候，最好替换成RelativeLayout布局</span></span><br><span class="line">                </span><br><span class="line">                  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">                  mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                  skippedMeasure = <span class="literal">true</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                  <span class="type">int</span> <span class="variable">oldHeight</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  步骤1：遍历所有子View &amp; 测量：measureChildren（）</span></span><br><span class="line"><span class="comment">       *  注：该方法内部，最终会调用measureChildren（），从而 遍历所有子View &amp; 测量</span></span><br><span class="line"><span class="comment">       **/</span></span><br><span class="line">            measureChildBeforeLayout(</span><br><span class="line"></span><br><span class="line">                   child, i, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec,</span><br><span class="line">                   totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>);</span><br><span class="line">                   ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  步骤2：合并所有子View的尺寸大小,最终得到ViewGroup父视图的测量值（自身实现）</span></span><br><span class="line"><span class="comment">       **/</span>        </span><br><span class="line">              <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeight</span> <span class="operator">=</span> child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 1. mTotalLength用于存储LinearLayout在竖直方向的高度</span></span><br><span class="line">              <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 2. 每测量一个子View的高度， mTotalLength就会增加</span></span><br><span class="line">              mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                     lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">      </span><br><span class="line">              <span class="comment">// 3. 记录LinearLayout占用的总高度</span></span><br><span class="line">              <span class="comment">// 即除了子View的高度，还有本身的padding属性值</span></span><br><span class="line">              mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">              <span class="type">int</span> <span class="variable">heightSize</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  步骤3：存储测量后View宽/高的值：调用setMeasuredDimension()  </span></span><br><span class="line"><span class="comment">       **/</span> </span><br><span class="line">       setMeasureDimension(resolveSizeAndState(maxWidth,width))</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>layout —— 计算视图（View）的位置，即计算View的四个顶点位置：Left、Top、Right 和 Bottom<br><img src="https://mark.cuckooing.cn/pics/pic_22bb8bca.png" alt="pic_22bb8bca.png"><br><img src="https://mark.cuckooing.cn/pics/pic_e00b9132.png" alt="pic_e00b9132.png"><br>基础：<br><img src="https://mark.cuckooing.cn/pics/pic_f9e31a21.png" alt="pic_f9e31a21.png"><br>View的位置由4个顶点决定的（如下A、B、C、D），4个顶点的位置描述分别由4个值决定：<br>（请记住：View的位置是相对于父控件而言的）<br>Top：子View上边界到父view上边界的距离<br>Left：子View左边界到父view左边界的距离<br>Bottom：子View下边距到父View上边界的距离<br>Right：子View右边界到父view左边界的距离</li>
</ol>
<ul>
<li>单一View</li>
<li>ViewGroup<br>a. 计算自身ViewGroup在父布局的位置：layout（）（&#x3D; setFrame()）<br>b. 遍历ViewGroup的所有子View在ViewGroup的位置（调用子View 的 layout（））：onLayout（）<br>自上而下、一层层地传递下去，直到完成整个View树的layout（）过程<br>（1）自定义ViewGroup<br>先计算自身在父容器中位置 setFrame()，再计算子View在父容器中相对位置onLayout()：<br>必须重写onLayout（）抽象方法，计算该ViewGroup包含所有的子View在父容器的位置。因：子View的确定位置与具体布局有关，所以onLayout（）在ViewGroup没有实现。<br>根据自身逻辑复写布局方法onLayout()：</li>
<li>循环遍历子View</li>
<li>计算当前子View相对于父容器（ViewGroup）的位置（根据具体布局）&amp; 递归调用View.layout()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算该ViewGroup包含所有的子View在父容器的位置（）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 参数说明</span></span><br><span class="line">     <span class="comment">// changed 当前View的大小和位置改变了 </span></span><br><span class="line">     <span class="comment">// left 左部位置</span></span><br><span class="line">     <span class="comment">// top 顶部位置</span></span><br><span class="line">     <span class="comment">// right 右部位置</span></span><br><span class="line">     <span class="comment">// bottom 底部位置</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1. 遍历子View：循环所有子View</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;getChildCount(); i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">              <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);   </span><br><span class="line"></span><br><span class="line">              <span class="comment">// 2. 计算当前子View的四个位置值</span></span><br><span class="line">                <span class="comment">// 2.1 位置的计算逻辑</span></span><br><span class="line">                ...<span class="comment">// 需自己实现，也是自定义View的关键</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.2 对计算后的位置值进行赋值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">mLeft</span>  <span class="operator">=</span> Left</span><br><span class="line">                <span class="type">int</span> <span class="variable">mTop</span>  <span class="operator">=</span> Top</span><br><span class="line">                <span class="type">int</span> <span class="variable">mRight</span> <span class="operator">=</span> Right</span><br><span class="line">                <span class="type">int</span> <span class="variable">mBottom</span> <span class="operator">=</span> Bottom</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 3. 根据上述4个位置的计算值，设置子View的4个顶点：调用子view的layout() &amp; 传递计算过的参数</span></span><br><span class="line">              <span class="comment">// 即确定了子View在父容器的位置（mLeft,mTop,mRight,mBottom）均是相对于父容器的位置</span></span><br><span class="line">              child.layout(mLeft, mTop, mRight, mBottom);</span><br><span class="line">              <span class="comment">// 该过程类似于单一View的layout过程中的layout（）和onLayout（），此处不作过多描述</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>（2）实例：LinearLayout extends ViewGroup</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：LinearLayout复写的onLayout（）</span></span><br><span class="line"><span class="comment">  * 注：复写的逻辑 和 LinearLayout measure过程的 onMeasure()类似</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据自身方向属性，而选择不同的处理方式</span></span><br><span class="line">      <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">          layoutVertical(l, t, r, b);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">          layoutHorizontal(l, t, r, b);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">// 由于垂直 / 水平方向类似，所以此处仅分析垂直方向（Vertical）的处理过程 -&gt;&gt;分析1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：layoutVertical(l, t, r, b)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">layoutVertical</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 子View的数量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 遍历子View</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                childTop += measureNullChild(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 计算子View的测量宽 / 高值（measure()过程中测量的结果）</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidth</span> <span class="operator">=</span> child.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeight</span> <span class="operator">=</span> child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 确定自身子View的位置</span></span><br><span class="line">                <span class="comment">// 即：递归调用子View的setChildFrame()，实际上是调用了子View的layout() -&gt;&gt;分析2</span></span><br><span class="line">                setChildFrame(child, childLeft, childTop + getLocationOffset(child),childWidth, childHeight);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// childTop逐渐增大，即后面的子元素会被放置在靠下的位置</span></span><br><span class="line">                <span class="comment">// 这符合垂直方向的LinearLayout的特性</span></span><br><span class="line">                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class="line"></span><br><span class="line">                i += getChildrenSkipCount(child, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析2：setChildFrame()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setChildFrame</span><span class="params">( View child, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> width, <span class="type">int</span> height)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// setChildFrame（）仅仅只是调用了子View的layout（）而已</span></span><br><span class="line">        child.layout(left, top, left + width, top + height);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 在子View的layout（）又通过调用setFrame（）确定View的四个顶点</span></span><br><span class="line">    <span class="comment">// 即确定了子View的位置</span></span><br><span class="line">    <span class="comment">// 如此不断循环确定所有子View的位置，最终确定ViewGroup的位置</span></span><br></pre></td></tr></table></figure>

<ol>
<li>draw —— 绘制View视图<br><img src="https://mark.cuckooing.cn/pics/pic_fdacae68.png" alt="pic_fdacae68.png"><br><img src="https://mark.cuckooing.cn/pics/pic_e19cb635.png" alt="pic_e19cb635.png"><br>（1）单一View</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：draw（）</span></span><br><span class="line"><span class="comment">  * 作用：根据给定的 Canvas 自动渲染 View（包括其所有子 View）。</span></span><br><span class="line"><span class="comment">  * 绘制过程：</span></span><br><span class="line"><span class="comment">  *   1. 绘制view背景</span></span><br><span class="line"><span class="comment">  *   2. 绘制view内容</span></span><br><span class="line"><span class="comment">  *   3. 绘制子View</span></span><br><span class="line"><span class="comment">  *   4. 绘制装饰（渐变框，滑动条等等）</span></span><br><span class="line"><span class="comment">  * 注：</span></span><br><span class="line"><span class="comment">  *    a. 在调用该方法之前必须要完成 layout 过程</span></span><br><span class="line"><span class="comment">  *    b. 所有的视图最终都是调用 View 的 draw （）绘制视图（ ViewGroup 没有复写此方法）</span></span><br><span class="line"><span class="comment">  *    c. 在自定义View时，不应该复写该方法，而是复写 onDraw(Canvas) 方法进行绘制</span></span><br><span class="line"><span class="comment">  *    d. 若自定义的视图确实要复写该方法，那么需先调用 super.draw(canvas)完成系统的绘制，然后再进行自定义的绘制</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    ...<span class="comment">// 仅贴出关键代码</span></span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> saveCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤1： 绘制本身View背景</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            drawBackground(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若有必要，则保存图层（还有一个复原图层）</span></span><br><span class="line">    <span class="comment">// 优化技巧：当不需绘制 Layer 时，“保存图层“和“复原图层“这两步会跳过</span></span><br><span class="line">    <span class="comment">// 因此在绘制时，节省 layer 可以提高绘制效率</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2：绘制本身View内容</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) </span><br><span class="line">            onDraw(canvas);</span><br><span class="line">        <span class="comment">// View 中：默认为空实现，需复写</span></span><br><span class="line">        <span class="comment">// ViewGroup中：需复写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤3：绘制子View</span></span><br><span class="line">    <span class="comment">// 由于单一View无子View，故View 中：默认为空实现</span></span><br><span class="line">    <span class="comment">// ViewGroup中：系统已经复写好对其子视图进行绘制我们不需要复写</span></span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 步骤4：绘制装饰，如滑动条、前景色等等</span></span><br><span class="line">        onDrawScrollBars(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）ViewGroup<br>dispatchDraw默认逻辑：</p>
<ul>
<li>ViewGroup绘制自身（含背景、内容）</li>
<li>循环遍历子View</li>
<li>绘制子View（递归 调用View.draw() 绘制背景、内容、装饰）</li>
<li>绘制装饰（滚动指示器、滚动条、前景）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：dispatchDraw（）</span></span><br><span class="line"><span class="comment">  * 作用：遍历子View &amp; 绘制子View</span></span><br><span class="line"><span class="comment">  * 注：</span></span><br><span class="line"><span class="comment">  *   a. ViewGroup中：由于系统为我们实现了该方法，故不需重写该方法</span></span><br><span class="line"><span class="comment">  *   b. View中默认为空实现（因为没有子View可以去绘制）</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">dispatchDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 1. 遍历子View</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childrenCount</span> <span class="operator">=</span> mChildrenCount;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                        transientChild.getAnimation() != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                  <span class="comment">// 2. 绘制子View视图 -&gt;&gt;分析1</span></span><br><span class="line">                    more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">                &#125;</span><br><span class="line">                ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：drawChild（）</span></span><br><span class="line"><span class="comment">  * 作用：绘制子View</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">drawChild</span><span class="params">(Canvas canvas, View child, <span class="type">long</span> drawingTime)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 最终还是调用了子 View 的 draw （）进行子View的绘制</span></span><br><span class="line">        <span class="keyword">return</span> child.draw(canvas, <span class="built_in">this</span>, drawingTime);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义View-1"><a href="#自定义View-1" class="headerlink" title="自定义View"></a>自定义View</h3><ol>
<li>注意点</li>
</ol>
<ul>
<li>支持特殊属性<br>（1）支持wrap_content<br>如果不在onMeasure（）中对wrap_content作特殊处理，那么wrap_content属性将失效<br>（2）支持padding &amp; margin<br>如果不支持，那么padding和margin（ViewGroup情况）的属性将失效<br>对于继承View的控件，padding是在draw()中处理<br>对于继承ViewGroup的控件，padding和margin会直接影响measure和layout过程</li>
<li>多线程直接使用post<br>View的内部本身提供了post系列的方法，完全可以替代Handler的作用，使用起来更加方便、直接。</li>
<li>避免内存泄露<br>主要针对View中含有线程或动画的情况：当View退出或不可见时，记得及时停止该View包含的线程和动画，否则会造成内存泄露问题。</li>
<li>处理好滑动冲突<br>当View带有滑动嵌套情况时，必须要处理好滑动冲突，否则会严重影响View的显示效果。<br>在onTouchEvent（）中处理</li>
</ul>
<ol>
<li>基本步骤<br>（1）创建自定义View类，复写相关方法（集成View类，具体绘制需要复写onDraw）<br>（2）在布局文件中添加自定义View类的组件<br>（3）Activity中setContentView（resId）显示</li>
<li>案例<br>（1）RefreshListView<br>（2）[含一键删除&amp;自定义样式的SuperEditText][SuperEditText]<br>（3）[简单好用的搜索框（含历史搜索记录）][Link 6]<br>（4）[时间轴][Link 7]<br>（5）[一个可爱 &amp; 小资风格的Android加载等待自定义View][_ _Android_View]</li>
</ol>
<h3 id="View刷新-重绘机制"><a href="#View刷新-重绘机制" class="headerlink" title="View刷新&#x2F;重绘机制"></a>View刷新&#x2F;重绘机制</h3><ol>
<li>时机</li>
</ol>
<ul>
<li>视图本身内部状态发生变化，比如显示属性由GONE到VISIBLE；</li>
<li>ViewGroup中添加或删除了视图导致需要重新为子视图分配位置</li>
<li>视图本身的大小发生变化，比如TextView中的文本内容变多变少了</li>
</ul>
<ol>
<li>方法</li>
</ol>
<ul>
<li>requestLayout<br>requestLayout()用于重新布局，该方法会递归调用父窗口的requestLayout()方法，直到触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为true，会触发onMesaure()与onLayout()方法重新设置位置，不一定 会触发onDraw()方法。</li>
<li>invalidate() &amp; postInvalidate()<br>invalidate()和postInvalidate()均用于View的重绘。该方法递归调用父View的invalidateChildInParent()方法，直到调用ViewRootImpl的invalidateChildInParent()方法，最终触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为false，不会 触发onMesaure()与onLayout()方法，会触发onDraw()方法。<br>invalidate()是在UI线程中使用，必须配合handler使用；postInvalidate可以在非UI线程中使用，不用使用handler。<br>invalidate主要给需要重绘的视图添加DIRTY标记，并通过不断回溯父视图做矩形运算求得真正需要绘制的区域，并最终保存在ViewRoot中的mDirty变量中，最后调用scheduleTraversals发起重绘请求，scheduleTraversals会发送一个异步消息，最终调用performTraversals()执行重绘（performTraversals（）遍历所有相关联的 View ，触发它们的 onDraw 方法进行绘制）<br>postInvalidate只是实现了一个消息机制，让用户能够在非UI线程使用，最终还是调用到invalidate()方法来触发重画，实现界面更新动作。</li>
</ul>
<ol>
<li>流程</li>
</ol>
<ul>
<li>View的界面刷新有三种方法invalidate（请求重绘）、requestLayout（重新布局）、requestFocus（请求焦点）</li>
<li>View界面刷新的所有方法均会递归调用父容器的相关方法，从View树向上层层找到最顶层的DecorView，通过DecorView的mParent，即ViewRootImpl执行scheduleTraversals()方法进行界面绘制。</li>
<li>调用到scheduleTraversals()时不会立即执行，而是将该操作保存到待执行队列中。并给底层的刷新信号注册监听。</li>
<li>当VSYNC信号到来时，会从待执行队列中取出对应的scheduleTraversals()操作，并将其加入到主线程的消息队列中。</li>
<li>主线程从消息队列中取出并调用performTraversals()执行三大流程: onMeasure()-onLayout()-onDraw()</li>
</ul>
<h2 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h2><h3 id="Touch事件的传递-拦截机制"><a href="#Touch事件的传递-拦截机制" class="headerlink" title="Touch事件的传递 &amp; 拦截机制"></a>Touch事件的传递 &amp; 拦截机制</h3><ol>
<li>事件分发 简介</li>
</ol>
<ul>
<li>本质<br>由于Android的View是树形结构，多个View会重叠在一起，View事件分发的本质就是解决将点击事情（Touch）产生的MotionEvent对象传递到哪一个具体的View然后消耗处理这个事件的整个过程。</li>
<li>分发对象<br>Android事件分发顺序：Activity（Window） -&gt; ViewGroup（容纳UI组件的容器，一组View的集合，如DecorView、Layout等） -&gt; View（所有UI的基类）</li>
<li>传递对象<br>事件（MotionEvent）<br>当用户触摸屏幕时（View或ViewGroup派生的控件），将产生点击事件（Touch事件）。Touch事件相关细节（发生触摸的位置、时间、历史记录、手势动作等）被封装成MotionEvent对象。<br>主要发生的Touch事件有如下四种：<br>MotionEvent.ACTION_DOWN：按下View（所有事件的开始）<br>MotionEvent.ACTION_MOVE：滑动View<br>MotionEvent.ACTION_UP：抬起View（与DOWN对应）</li>
<li>事件分发对应方法<br><img src="https://mark.cuckooing.cn/pics/pic_981ff3a8.png" alt="pic_981ff3a8.png"></li>
<li>事件分发 流程<br><img src="https://mark.cuckooing.cn/pics/pic_3792a52a.png" alt="pic_3792a52a.png"><br>当一个点击事件产生后，它的传递过程遵循如下顺序：Activity–&gt;Window–&gt;View。<br>（1）Activity 事件分发<br>即先将事件传递给Activity,Activity再传递给Window,最后Window再传递给DecorView,DecorView接收到事件后，就会按照事件分发机制去分发事件。即调用调用ViewGroup的dispatchTouchEvent。<br>（2）ViewGroup 事件分发<br>此时顶级ViewGroup的dispatchTouchEvent就会被调用，这个方法用于事件分发。如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前的事件，接着事件就会交给这个ViewGroup处理，即它的onTouch方法就会被调用来消耗事件并返回true；如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素View。<br>（3）View 事件分发<br>接着子元素的dispatchTouchEvent方法就会被调用，如果子元素是View，则它不会拦截事件，要么将事件消费，要么不处理直接回传。事件会按层级依此回传，最终会告诉Activity.dispatchTouchEvent。</li>
</ul>
<blockquote>
<p>在某个View拦截触摸事件：</p>
<ul>
<li>设置View 的 &lt;View android:clickable &#x3D; “false” 不可点击 android:focusable &#x3D; “false” 无法获取焦点 android:focusableInTouchMode &#x3D; “false” 不可通过触摸获取焦点&gt; 即使当前View不可获取点击事件，此时将事件回传给上一级父组件处理</li>
<li>设置View 的 onTouchEvent 返回值为false</li>
<li>设置View 的 父组件ViewGroup 的 onInterceptTouchEvent &#x2F; dispatchTouchEvent 返回值为 true</li>
</ul>
</blockquote>
<p>dispatchTouchEvent 代码描述</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击事件产生后，会直接调用dispatchTouchEvent（）方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//代表是否消耗事件</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">consume</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//如果onInterceptTouchEvent()返回true则代表当前View拦截了点击事件</span></span><br><span class="line">    <span class="comment">//则该点击事件则会交给当前View进行处理</span></span><br><span class="line">    <span class="comment">//即调用onTouchEvent (）方法去处理点击事件</span></span><br><span class="line">      consume = onTouchEvent (ev) ;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      <span class="comment">//如果onInterceptTouchEvent()返回false则代表当前View不拦截点击事件</span></span><br><span class="line">      <span class="comment">//则该点击事件则会继续传递给它的子元素</span></span><br><span class="line">      <span class="comment">//子元素的dispatchTouchEvent（）就会被调用，重复上述过程</span></span><br><span class="line">      <span class="comment">//直到点击事件被最终处理为止</span></span><br><span class="line">      consume = child.dispatchTouchEvent (ev) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> consume;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件分发 场景<br><img src="https://mark.cuckooing.cn/pics/pic_3846474f.png" alt="pic_3846474f.png"><br>原理分析：<br>类似侧滑菜单中若为一个列表，则对侧滑菜单SlideView的左右滑动事件可能会被列表的子元素ListViewItem消费，从而使左右滑动菜单显示&#x2F;隐藏菜单功能失效<br>解决：<br>对侧滑菜单组件的onInterceptTouchEvent方法进行重写，滑动时获取x,y方向上的偏移值。若x方向上的偏移值&gt;y方向上的偏移值 &amp; x方向偏移值大于一个阈值，则返回true拦截此次触摸事件，交给侧滑菜单处理（调用侧滑菜单SlideView的滑动事件onScroll），否则交给子元素处理（ListViewItem的onClick）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复写onInterceptEventTouch方法进行拦截处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlideView</span> <span class="keyword">extends</span> <span class="title class_">View</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_OFFSET_X</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">	<span class="comment">// 拦截处理</span></span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">switch</span>(ev.getAction())&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">				downX = ev.getX();	<span class="comment">// 触摸初始X值</span></span><br><span class="line">				downY = ev.getY();	<span class="comment">// 触摸初始Y值</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">				offsetX = Math.abs(ev.getX() - downX);	<span class="comment">// 手指在X方向偏移距离</span></span><br><span class="line">				offsetY = Math.abs(ev.getY() - downY);	<span class="comment">// 手指在Y方向偏移距离</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(offsetX &gt; offsetY &amp;&amp; offsetX &gt; MIN_OFFSET_X)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">					<span class="comment">// 如果X方向偏移值&gt;Y方向偏移值，且X偏移值大于阈值，则该触摸事件为滑动侧滑菜单</span></span><br><span class="line">					<span class="comment">// 拦截此次触摸事件，交给滑动菜单，进行菜单滑动</span></span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件分发中的onTouch、onTouchEvent-（和onClick）-有什么区别，又该如何使用？"><a href="#事件分发中的onTouch、onTouchEvent-（和onClick）-有什么区别，又该如何使用？" class="headerlink" title="事件分发中的onTouch、onTouchEvent （和onClick） 有什么区别，又该如何使用？"></a>事件分发中的onTouch、onTouchEvent （和onClick） 有什么区别，又该如何使用？</h3><p>这两个方法都在View.dispatchTouchEvent()中调用。<br>onTouch是View的onTouchListener中的方法。需要实现onTouchListener并且点击的View为enable时，View有touch事件便会调用。<br>onTouchEvent是复写的方法。屏幕有touch事件便会调用。<br>它们的区别在于<br>（1）onTouch优先级比onTouchEvent优先级高。当onTouch返回值为true，则表示事件已经被消费，便不会向onTouchEvent传递，也不会调用onClick（因为onClick是在onTouchEvent中执行的,onTouchEvent中performClick是onClick的入口方法）。只有当onTouch()的返回值为false。才会调用onTouchEvent()。<br>所以优先级为onTouch&gt;onTouchEvent&gt;onClick<br>（2）【为什么给ListView引入了一个滑动菜单的功能，ListView就不能滚动了？】<br>滑动菜单的功能是通过给ListView注册了一个touch事件来实现的。如果在onTouch方法里处理完了滑动逻辑后返回true，那么ListView本身的滚动事件就被屏蔽了，自然也就无法滑动(控件内置事件如滚动事件onScroll与点击事件onClick等等均基于onTouchEvent，优先级小于onTouch)，因此解决办法就是在onTouch方法里返回false。</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="种类-特点-区别-原理"><a href="#种类-特点-区别-原理" class="headerlink" title="种类 &amp; 特点 &amp; 区别 &amp;原理"></a>种类 &amp; 特点 &amp; 区别 &amp;原理</h3><table> 
 <tbody> 
  <tr> 
   <td></td> 
   <td colspan="2">视图动画</td> 
   <td>属性动画</td> 
  </tr> 
  <tr> 
   <td>类型</td> 
   <td>补间动画</td> 
   <td>逐帧动画</td> 
   <td>属性动画</td> 
  </tr> 
  <tr> 
   <td>作用对象</td> 
   <td colspan="2">视图控件（View）<br>如Android的TextView、Button等<br>不可作用于View组件的属性，如：颜色、背景等</td> 
   <td>任意Java对象<br>不仅局限于视图View对象</td> 
  </tr> 
  <tr> 
   <td>原理</td> 
   <td>通过确定开始的视图样式 &amp; 结束的视图样式，中间动画变化过程由系统补全来确定一个动画</td> 
   <td>将动画拆分为帧的形式，且定义每一帧均是一张图片，按顺序播放一组预先定义好的图片</td> 
   <td>在一定时间间隔内，通过不断对值进行更改，并不断传值给对象的属性，从而实现对象在该属性上的动画效果</td> 
  </tr> 
  <tr> 
   <td>特点</td> 
   <td colspan="2">作用对象局限：View &amp; 只能改变View的视觉效果而无法改变View的属性 &amp; 动画效果单一<br>适合视图简单、基本的动画效果（如Activity、Fragment的切换效果，或视图组（ViewGroup）中子元素出厂效果）</td> 
   <td>作用对象扩展：面向属性，作用对象可以是任何一个Object对象 &amp; 实际改变视图的属性 &amp; 动画效果丰富：包括四种基本变化意外的其他动画效果<br> 适合与属性相关，更为复杂的动画效果</td> 
  </tr> 
  <tr> 
   <td>使用</td> 
   <td>四种基本变换类型：<br>平移动画（Translate）<br>缩放动画（Scale）<br>旋转动画（Rotate）<br>透明度动画（Alpha）</td> 
   <td>使用时避免使用尺寸大的图片，否则会引起OOM</td> 
   <td>主要使用 ValueAnimator &amp; ObjectAnimator</td> 
  </tr> 
  <tr> 
   <td>区别</td> 
   <td colspan="3">是否改变动画本身的属性<br>视图动画仅仅对图像进行变化，视图的位置、相应区域等均在远地；而属性动画是通过过动态改变对象的属性从而达到动画效果</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ul>
<li>补间动画<br>[Android 补间动画：手把手教你使用 补间动画 ][Android _ _]<br>（1）在 res&#x2F;anim的文件夹里创建动画效果.xml文件<br>创建地址为：res&#x2F;anim&#x2F;view_animation.xml<br>（2）根据 不同动画效果（平移、缩放、旋转、透明度）的语法 设置 不同动画参数，从而实现动画效果</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>动画类型</th> 
   <th>标签</th> 
   <th>方法</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>公用</td> 
   <td>/</td> 
   <td>android:duration：动画持续时间<br>android:startOffset：动画延迟开始时间<br>android:repeatCount：动画重放次数<br>android:interpolator：插值器</td> 
  </tr> 
  <tr> 
   <td>平移</td> 
   <td>&lt; translate/ &gt;</td> 
   <td>android:fromXDelta：视图在水平方向x 移动的起始值<br>android:toXDelta：视图在水平方向x 移动的结束值<br>android:fromYDelta：视图在竖直方向y 移动的起始值<br>android:toYDelta：视图在竖直方向y 移动的结束值</td> 
  </tr> 
  <tr> 
   <td>缩放</td> 
   <td>&lt; scale/ &gt;</td> 
   <td>android:fromXScale：动画在水平方向X的起始缩放倍数<br>android:toXScale：动画在水平方向X的结束缩放倍数<br>android:fromYScale=“0.0”：动画开始前在竖直方向Y的起始缩放倍数<br>android:toYScale：动画在竖直方向Y的结束缩放倍数<br>android:pivotX：缩放轴点的x坐标<br>android:pivotY：缩放轴点的y坐标</td> 
  </tr> 
  <tr> 
   <td>旋转</td> 
   <td>&lt; rotate/ &gt;</td> 
   <td>android:fromDegrees=“0.0”：动画开始时 视图的旋转角度<br>android:toDegrees：动画结束时 视图的旋转角度<br>android:pivotX：旋转轴点的x坐标<br>android:pivotY：旋转轴点的y坐标</td> 
  </tr> 
  <tr> 
   <td>透明度</td> 
   <td>&lt; alpha/ &gt;</td> 
   <td>android:fromAlpha=“0.0”：动画开始时 视图的透明度<br>android:toAlpha：动画结束时 视图的透明度</td> 
  </tr> 
  <tr> 
   <td>组合</td> 
   <td>&lt; set/ &gt;</td> 
   <td>android:shareinterpolator：表示组合动画中的动画是否和集合共享同一个差值器</td> 
  </tr> 
 </tbody> 
</table>

<p>（3）在Java代码中创建Animation对象并播放动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span> <span class="variable">mButton</span> <span class="operator">=</span> (Button) findViewById(R.id.Button);</span><br><span class="line">        <span class="comment">// 步骤1:创建 需要设置动画的 视图View</span></span><br><span class="line">        <span class="type">Animation</span> <span class="variable">translateAnimation</span> <span class="operator">=</span> AnimationUtils.loadAnimation(<span class="built_in">this</span>, R.anim.view_animation);</span><br><span class="line">        <span class="comment">// 步骤2:创建 动画对象 并传入设置的动画效果xml文件</span></span><br><span class="line">        mButton.startAnimation(translateAnimation);</span><br><span class="line">        <span class="comment">// 步骤3:播放动画</span></span><br></pre></td></tr></table></figure>

<ul>
<li>逐帧动画<br>[Android 逐帧动画：关于 逐帧动画 的使用都在这里了！][Android _ _ 1]<br>（1）将动画资源（即每张图片资源）放到 drawable文件夹里<br>（2）从drawable文件夹获取动画资源 &amp; 载入并启动动画</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FrameActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Button btn_startFrame,btn_stopFrame;</span><br><span class="line">    <span class="keyword">private</span> ImageView iv;</span><br><span class="line">    <span class="keyword">private</span> AnimationDrawable animationDrawable;</span><br><span class="line"></span><br><span class="line">        iv = (ImageView) findViewById(R.id.iv);</span><br><span class="line">        btn_startFrame = (Button) findViewById(R.id.btn_startFrame);</span><br><span class="line">        btn_stopFrame = (Button) findViewById(R.id.btn_stopFrame);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;-- 开始动画 --&gt;</span><br><span class="line">        btn_startFrame.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                iv.setImageResource(R.drawable.knight_attack);</span><br><span class="line">                <span class="comment">// 1. 设置动画</span></span><br><span class="line">                animationDrawable = (AnimationDrawable) iv.getDrawable();</span><br><span class="line">                <span class="comment">// 2. 获取动画对象</span></span><br><span class="line">                animationDrawable.start();</span><br><span class="line">                <span class="comment">// 3. 启动动画</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//停止动画</span></span><br><span class="line">        btn_stopFrame.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                </span><br><span class="line">                iv.setImageResource(R.drawable.knight_attack);</span><br><span class="line">                <span class="comment">// 1. 设置动画</span></span><br><span class="line">                animationDrawable = (AnimationDrawable) iv.getDrawable();</span><br><span class="line">                <span class="comment">// 2. 获取动画对象</span></span><br><span class="line">                animationDrawable.stop();</span><br><span class="line">                <span class="comment">// 3. 暂停动画</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>属性动画<br>[Android 属性动画：这是一篇很详细的 属性动画 总结&amp;攻略][Android _ _ 2]<br><img src="https://mark.cuckooing.cn/pics/pic_3d3320e9.png" alt="pic_3d3320e9.png"></li>
</ul>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>[Android 动画原理分析][Android]</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>OOM：使用逐帧动画时避免使用尺寸大的图片，否则会引起OOM。</li>
<li>内存泄露：当我们把动画的repeatCount设置为无限循环时，如果在Activity退出时没有及时将动画停止，属性动画会导致Activity无法释放而导致内存泄漏，而补间动画却没有问题。因此，使用属性动画时切记在Activity执行 onStop 方法时顺便将动画停止。<br>在使用ValueAnimator或者ObjectAnimator时（ObjectAnimator继承ValueAnimator），如果没有及时做cancel取消动画，就可能造成内存泄露。ValueAnimator 有个AnimationHandler的单例，会持有属性动画对象自身的引用，属性动画对象持有view的引用，view持有activity引用，所以导致的内存泄露。<br>[分析：补间动画和属性动画内存泄露][Link 8]</li>
</ul>
<h3 id="估值器"><a href="#估值器" class="headerlink" title="估值器"></a>估值器</h3><p>插值器用于设置属性值从初始值过渡到结束值变化规律的一个接口。用于实现非线性运动，如匀速、加速、减速的动画效果。<br>估值器用于设置属性值从初始值过渡到结束值的变化具体数值的一个接口。用于决定值的变化规律，如匀速、加速、减速的变化趋势。用于辅助插值器实现非线性运动。</p>
<h2 id="ListView-RecycleView"><a href="#ListView-RecycleView" class="headerlink" title="ListView &amp; RecycleView"></a>ListView &amp; RecycleView</h2><h3 id="ListView-定义-原理-优化-封装？"><a href="#ListView-定义-原理-优化-封装？" class="headerlink" title="ListView 定义 &amp; 原理 &amp; 优化 &amp; 封装？"></a>ListView 定义 &amp; 原理 &amp; 优化 &amp; 封装？</h3><ul>
<li>ListView &amp; Adapter<br>列表 ListView 是 Android中的一种列表视图组件，继承自AdapterView抽象类。<br>适配器 Adapter 作为 View 和 数据 之间的桥梁&amp;中介，将数据映射到列表要展示的View中。<br>ListView 仅作为容器（列表），用于装载 &amp; 显示数据（即 列表项Item），而容器内的具体每一项的内容（列表项Item）则是由 适配器（Adapter）提供。<br><img src="https://mark.cuckooing.cn/pics/pic_3b6968da.png" alt="pic_3b6968da.png"></li>
<li>RecycleBin 缓存原理<br><img src="https://mark.cuckooing.cn/pics/pic_e6b12ef6.png" alt="pic_e6b12ef6.png"><br>为了节省空间和时间，ListView不会为每一个数据创建一个视图，而是采用了RecycleBin（Recycler组件），用于回收 &amp; 复用 View。<br>当屏幕需显示x个Item时，那么ListView会创建 x+1个视图。移出屏幕的View控件会缓存到RecycleBin当中，当有View进入屏幕后，ListView会从RecycleBin里面取出一个缓存View控件，将其作为convertView参数传递到Adapter的getView中，从而达到View的复用，不必每次都加载布局（LayoutInflater.inflate()）</li>
<li>ListView 优化</li>
<li>getView() 优化<br>convertView优化<br>主要优化加载布局的问题——减少getView方法每次调用LayoutInflater.inflate()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View <span class="title function_">getView</span><span class="params">(<span class="type">int</span> position, View convertView, ViewGroup parent)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	View view;</span><br><span class="line">	<span class="keyword">if</span>(convertView == <span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 没有缓存就加载布局</span></span><br><span class="line">		view = LayoutInfalter.from(getContext()).inflate(resourceID，<span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 有缓存直接使用缓存的convertView</span></span><br><span class="line">		view = convertView;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>viewHolder优化（Google推荐ListView优化方案）<br>主要优化加载控件问题——减少getView方法每次调用findViewById()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View <span class="title function_">getView</span><span class="params">(<span class="type">int</span> position, View convertView, ViewGroup parent)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     Log.d(<span class="string">&quot;MyAdapter&quot;</span>, <span class="string">&quot;Position:&quot;</span> + position + <span class="string">&quot;---&quot;</span></span><br><span class="line">             + String.valueOf(System.currentTimeMillis()));</span><br><span class="line">     ViewHolder holder;</span><br><span class="line">     <span class="keyword">if</span> (convertView == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="comment">// convertView为空时，viewHolder会将控件的实例放在ViewHolder中，然后用setTag方法将ViewHolder对象存储在View中</span></span><br><span class="line">         <span class="keyword">final</span> <span class="type">LayoutInflater</span> <span class="variable">inflater</span> <span class="operator">=</span> (LayoutInflater) mContext</span><br><span class="line">                 .getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">         convertView = inflater.inflate(R.layout.list_item_icon_text, <span class="literal">null</span>);</span><br><span class="line">         holder = <span class="keyword">new</span> <span class="title class_">ViewHolder</span>();</span><br><span class="line">         holder.icon = (ImageView) convertView.findViewById(R.id.icon);</span><br><span class="line">         holder.text = (TextView) convertView.findViewById(R.id.text);</span><br><span class="line">         convertView.setTag(holder);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="comment">// convertView不为空时，用getTag方法从View获取viewHolder对象</span></span><br><span class="line">         holder = (ViewHolder) convertView.getTag();</span><br><span class="line">     &#125;</span><br><span class="line">     holder.icon.setImageResource(R.drawable.icon);</span><br><span class="line">     holder.text.setText(mData[position]);</span><br><span class="line">     <span class="keyword">return</span> convertView;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     ImageView icon;</span><br><span class="line">     TextView text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>图片错乱<br>图片错乱：ContentView复用 + 异步加载网络图片</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View <span class="title function_">getView</span><span class="params">(<span class="type">int</span> position, View convertView, ViewGroup parent)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> urlList.get(position);</span><br><span class="line">		ViewHolder holder;</span><br><span class="line">		<span class="comment">// 1. 如果有可以复用的View ，则使用复用的View</span></span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            view = inflater.inflate(R.layout.item, <span class="literal">null</span>);</span><br><span class="line">            holder = <span class="keyword">new</span> <span class="title class_">ViewHolder</span>();</span><br><span class="line">            holder.image = (ImageView) view.findViewById(R.id.image);</span><br><span class="line">            view.setTag(holder);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			view = convertView;</span><br><span class="line">			holder = (ViewHolder)view.getTag();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 2. downloadBitmapFromNet开启多线程（如 AsyncTask）异步加载网络图片</span></span><br><span class="line">        <span class="type">BitmapDrawable</span> <span class="variable">drawable</span> <span class="operator">=</span> downloadBitmapFromNet(url);</span><br><span class="line">        <span class="comment">// 3. 若此时该View已经移出屏幕，新的View进入屏幕，并复用这块image</span></span><br><span class="line">        <span class="comment">// 此时的drawable因为异步耗时操作刚刚取到网络图片</span></span><br><span class="line">        <span class="comment">// 则会在该View上显示错误的图片，从而造成图片乱序</span></span><br><span class="line">        image.setImageDrawable(drawable);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	ImageView image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设屏幕上有7个条目，向上滑动。新的第8个条目进入界面就会回调getView()方法，而在getView()方法中会开启异步请求从网络上获取图片。由于网络操作耗时，刚进入的条目在图片下载完前会显示缓存中ImageView的图片（即第1个条目的图片），等到下载结束会变回网络图片。（因为第1个图片与第8个图片指向同一块ImageView实例）此时，若ListView快速滑动，移出屏幕的条目被进入的条目重新利用，若此时移出的条目发起的图片请求有了响应。则会造成不同位置显示图片错乱的现象。（显示第15个图片时，第8个图片得到响应，此时的image为第15个图片所复用，但显示的确是第8个图片）<br>解决方案：通过对ImageView设置tag（通常用图片的url）防止图片错位。<br>每次getView时（新的元素进入屏幕），对ImageView设置标签。当网络加载结束后，查询当前ImageView的标签，如果更改了，说明该ImageView被新的元素复用（因为移出屏幕的旧元素和进入屏幕的新元素指向的是同一块ImageView实例），则不显示加载的网络图片；否则仍为原来图片元素，显示加载的网络图片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View <span class="title function_">getView</span><span class="params">(<span class="type">int</span> position, View convertView, ViewGroup parent)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> urlList.get(position);</span><br><span class="line">		ViewHolder holder;</span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            view = inflater.inflate(R.layout.item, <span class="literal">null</span>);</span><br><span class="line">            holder = <span class="keyword">new</span> <span class="title class_">ViewHolder</span>();</span><br><span class="line">            holder.image = (ImageView) view.findViewById(R.id.image);</span><br><span class="line">            view.setTag(holder);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			view = convertView;</span><br><span class="line">			holder = (ViewHolder)view.getTag();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 给ImageView 设置Tag为当前加载图片的url</span></span><br><span class="line">		holder.image.setTag(url);</span><br><span class="line">        Glide.with(mContext).load(pic_url).into(<span class="keyword">new</span> <span class="title class_">SimpleTarget</span>&lt;GlideDrawable&gt;()&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResourceReady</span><span class="params">(GlideDrawable resource, GlideAnimation&lt;? <span class="built_in">super</span> GlideDrawable&gt; glideAnimation)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">				<span class="comment">// 异步加载图片完成后去取tag，判断是否是加载的图片的url</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">urlTag</span> <span class="operator">=</span> (String) holder.image.getTag();</span><br><span class="line">                <span class="keyword">if</span> (!TextUtils.isEmpty(urlTag) &amp;&amp; urlTag.equals(url)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                	<span class="comment">// 如果当前位置已经移除屏幕，则该holder.image的Tag被其他位置图片url覆盖，则不会满足上述条件，此时该位置的图片不会显示</span></span><br><span class="line">                	<span class="comment">// 若holder.image的Tag为当前url，则说明该image仍为当前元素所使用，没有被新的View复用。显示此次网络加载图片</span></span><br><span class="line">                    holder.image.setImageDrawable(resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	ImageView image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最优化方案的完整实现方案<br>（1）定义主xml布局：activity_main.xml</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:background=<span class="string">&quot;#FFFFFF&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span> &gt;</span><br><span class="line">    &lt;ListView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/listView1&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>（2）根据需要，定义ListView每行所实现的xml布局（item布局）：item.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">android:layout_width=<span class="string">&quot;match_parent&quot;</span> </span><br><span class="line">android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:layout_alignParentRight=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:id=<span class="string">&quot;@+id/ItemImage&quot;</span>/&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;按钮&quot;</span></span><br><span class="line">        android:id=<span class="string">&quot;@+id/ItemBottom&quot;</span></span><br><span class="line">        android:focusable=<span class="string">&quot;false&quot;</span></span><br><span class="line">        android:layout_toLeftOf=<span class="string">&quot;@+id/ItemImage&quot;</span> /&gt;</span><br><span class="line">    &lt;TextView android:id=<span class="string">&quot;@+id/ItemTitle&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;fill_parent&quot;</span></span><br><span class="line">        android:textSize=<span class="string">&quot;20sp&quot;</span>/&gt;</span><br><span class="line">    &lt;TextView android:id=<span class="string">&quot;@+id/ItemText&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;fill_parent&quot;</span></span><br><span class="line">        android:layout_below=<span class="string">&quot;@+id/ItemTitle&quot;</span>/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>

<p>（3）定义一个Adapter类继承BaseAdapter，重写里面的方法：MyAdapter.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdapter</span> <span class="keyword">extends</span> <span class="title class_">BaseAdapter</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> LayoutInflater mInflater;<span class="comment">//得到一个LayoutInfalter对象用来导入布局 </span></span><br><span class="line">    ArrayList&lt;HashMap&lt;String, Object&gt;&gt; listItem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAdapter</span><span class="params">(Context context,ArrayList&lt;HashMap&lt;String, Object&gt;&gt; listItem)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.mInflater = LayoutInflater.from(context);</span><br><span class="line">        <span class="built_in">this</span>.listItem = listItem;</span><br><span class="line">    &#125;<span class="comment">//声明构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> listItem.size();</span><br><span class="line">    &#125;<span class="comment">//这个方法返回了在适配器中所代表的数据集合的条目数</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getItem</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> listItem.get(position);</span><br><span class="line">    &#125;<span class="comment">//这个方法返回了数据集合中与指定索引position对应的数据项</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getItemId</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;<span class="comment">//这个方法返回了在列表中与指定索引对应的行id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用convertView+ViewHolder来重写getView()</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span></span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">public</span> ImageView img;</span><br><span class="line">        <span class="keyword">public</span> TextView title;</span><br><span class="line">        <span class="keyword">public</span> TextView text;</span><br><span class="line">        <span class="keyword">public</span> Button btn;</span><br><span class="line">    &#125;<span class="comment">//声明一个外部静态类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">getView</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> position, View convertView, <span class="keyword">final</span> ViewGroup parent)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        ViewHolder holder ;</span><br><span class="line">        <span class="keyword">if</span>(convertView == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            holder = <span class="keyword">new</span> <span class="title class_">ViewHolder</span>();</span><br><span class="line">            convertView = mInflater.inflate(R.layout.item, parent, <span class="literal">false</span>);</span><br><span class="line">            holder.img = (ImageView)convertView.findViewById(R.id.ItemImage);</span><br><span class="line">            holder.title = (TextView)convertView.findViewById(R.id.ItemTitle);</span><br><span class="line">            holder.text = (TextView)convertView.findViewById(R.id.ItemText);</span><br><span class="line">            holder.btn = (Button) convertView.findViewById(R.id.ItemBottom);</span><br><span class="line">            convertView.setTag(holder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            holder = (ViewHolder)convertView.getTag();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        holder.img.setImageResource((Integer) listItem.get(position).get(<span class="string">&quot;ItemImage&quot;</span>));</span><br><span class="line">        holder.title.setText((String) listItem.get(position).get(<span class="string">&quot;ItemTitle&quot;</span>));</span><br><span class="line">        holder.text.setText((String) listItem.get(position).get(<span class="string">&quot;ItemText&quot;</span>));</span><br><span class="line">        holder.btn.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                System.out.println(<span class="string">&quot;你点击了选项&quot;</span>+position);<span class="comment">//bottom会覆盖item的焦点，所以要在xml里面配置android:focusable=&quot;false&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> convertView;</span><br><span class="line">    &#125;<span class="comment">//这个方法返回了指定索引对应的数据项的视图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）在MainActivity中构造Adapter对象，设置适配器，将ListView绑定到适配器上：MainActivity.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> ListView lv;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        lv = (ListView) findViewById(R.id.listView1);</span><br><span class="line">        <span class="comment">/*定义一个以HashMap为内容的动态数组*/</span></span><br><span class="line">        ArrayList&lt;HashMap&lt;String, Object&gt;&gt; listItem = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HashMap&lt;String, Object&gt;&gt;();<span class="comment">/*在数组中存放数据*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;ItemImage&quot;</span>, R.mipmap.ic_launcher);<span class="comment">//加入图片</span></span><br><span class="line">            map.put(<span class="string">&quot;ItemTitle&quot;</span>, <span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;行&quot;</span>);</span><br><span class="line">            map.put(<span class="string">&quot;ItemText&quot;</span>, <span class="string">&quot;这是第&quot;</span> + i + <span class="string">&quot;行&quot;</span>);</span><br><span class="line">            listItem.add(map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">MyAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAdapter</span>(<span class="built_in">this</span>, listItem);</span><br><span class="line">        lv.setAdapter(adapter);<span class="comment">//为ListView绑定适配器</span></span><br><span class="line"></span><br><span class="line">        lv.setOnItemClickListener(<span class="keyword">new</span> <span class="title class_">AdapterView</span>.OnItemClickListener() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onItemClick</span><span class="params">(AdapterView&lt;?&gt; arg0, View arg1, <span class="type">int</span> arg2, <span class="type">long</span> arg3)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                System.out.println(<span class="string">&quot;你点击了第&quot;</span> + arg2 + <span class="string">&quot;行&quot;</span>);<span class="comment">//设置系统输出点击的行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ListView 性能优化</li>
<li>Bitmap优化<br>（1）用软引用存储图片信息<br>（2）图片压缩<br>（3）三级缓存</li>
<li>内存优化<br>（1）避免内存泄露，如使用Adapter传入context时注意context的生命周期（getApplicationContext）<br>（2）通过对View的复用减少内存<br>（3）分页机制</li>
<li>ListView 封装 —— 实现下拉刷新，上拉加载的具有分页机制的ListView<br>[黑马视频：RefreshListView —— 下拉刷新 &amp; 上拉加载][RefreshListView _ _ _]<br>设计思路：<br>（1）初始化头布局，动画：自定义头布局，初始隐藏头布局（mHeaderView.setTopPadding(-measuredHeight)）<br>（2）处理触摸事件，根据下滑偏移量的大小设置不同状态，并根据状态进行处理（修改头布局、数据请求等）：</li>
<li>ACTION_MOVE &amp;&amp; 列表头显示第一条数据(getFirstVisiblePosition &#x3D;&#x3D; 0)：<br>（a）if(offset &lt; measuredHeight &amp;&amp; currentState !&#x3D; PULL_TO_REFRESH) ：不完全显示 &#x3D;&gt; 下拉刷新，修改头布局<br>（b）if(offset &gt;&#x3D; measuredHeight &amp;&amp; currentState !&#x3D; RELEASE_REFRESH) ：完全显示 &#x3D;&gt; 释放刷新，修改头布局</li>
<li>ACTION_DOWN<br>（a）if(currentState &#x3D;&#x3D; RELEASE_REFRESH)<br>正在刷新，修改头布局，调用接口方法请求数据<br>（b）if(currentState &#x3D;&#x3D; PULL_TO_REFRESH)<br>恢复头布局<br>（3）设置监听器，监听列表中数据变化：</li>
<li>控件创建监听器回调接口，并调用接口方法</li>
<li>用户实现接口方法，监听刷新事件，进行网络请求</li>
</ul>
<p>ListView封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshListView</span> <span class="keyword">extends</span> <span class="title class_">ListView</span> <span class="keyword">implements</span> <span class="title class_">AbsListView</span>.OnScrollListener &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> View mHeaderView;           <span class="comment">// 头布局</span></span><br><span class="line">    <span class="keyword">private</span> ImageView mArrowView;       <span class="comment">// 箭头视图</span></span><br><span class="line">    <span class="keyword">private</span> TextView mTitleText;        <span class="comment">// 标题视图</span></span><br><span class="line">    <span class="keyword">private</span> ProgressBar pb;             <span class="comment">// 进度条</span></span><br><span class="line">    <span class="comment">// 头布局实现下拉刷新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> paddingTop;             <span class="comment">// 头部局的内边距（状态切换的依据）</span></span><br><span class="line">    <span class="type">int</span> headerViewMeasureHeight;        <span class="comment">// 头布局的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> downY;                <span class="comment">// 按下时的y坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> moveY;                <span class="comment">// 移动时的y坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentState</span> <span class="operator">=</span> <span class="number">0</span>;       <span class="comment">// 当前刷新模式，初始为下拉刷新模式</span></span><br><span class="line">    <span class="comment">// 定义默认刷新模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PULL_TO_REFRESH</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 下拉刷新模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RELEASE_REFRESH</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">// 释放刷新模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REFRESHING</span> <span class="operator">=</span> <span class="number">2</span>;         <span class="comment">// 正在刷新模式</span></span><br><span class="line"></span><br><span class="line">    RotateAnimation rotateUpAnim;       <span class="comment">// 向上旋转动画</span></span><br><span class="line">    RotateAnimation rotateDownAnim;     <span class="comment">// 向下旋转动画</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> View mFooterView;           <span class="comment">// 脚布局</span></span><br><span class="line">    <span class="keyword">private</span> TextView mFooterText;        <span class="comment">// 标题视图</span></span><br><span class="line">    <span class="comment">// 脚布局实现上拉加载</span></span><br><span class="line">    <span class="type">int</span> footerViewMeasureHeight;        <span class="comment">// 脚布局的高度</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLoadingMore</span> <span class="operator">=</span> <span class="literal">false</span>;      <span class="comment">// 正在加载状态，初始为false</span></span><br><span class="line"></span><br><span class="line">    OnRefreshListener mListener;         <span class="comment">// 列表数据监听</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshListView</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshListView</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化头布局，脚布局，动画</span></span><br><span class="line">    <span class="comment">// 滚动监听</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        initHeadView();</span><br><span class="line">        initFooterView();</span><br><span class="line">        initAnimation();</span><br><span class="line">        setOnScrollListener(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initHeadView</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 1. 添加自定义头部局</span></span><br><span class="line">        <span class="comment">// layout_header_list 为自定义头部布局文件</span></span><br><span class="line">        mHeaderView = View.inflate(getContext(), R.layout.layout_header_list,<span class="literal">null</span>);</span><br><span class="line">        mArrowView = mHeaderView.findViewById(R.id.iv_arrow);</span><br><span class="line">        mTitleText = (TextView)mHeaderView.findViewById(R.id.tv_title);</span><br><span class="line">        pb = (ProgressBar) mHeaderView.findViewById(R.id.pb);</span><br><span class="line">        <span class="comment">// 2. 默认隐藏头部局</span></span><br><span class="line">        <span class="comment">// 设置内边距，可以隐藏当前控件：paddingTop = -自身高度</span></span><br><span class="line">        mHeaderView.measure(<span class="number">0</span>,<span class="number">0</span>);   <span class="comment">// 按照设置的规则测量高度</span></span><br><span class="line">        <span class="comment">// int headerViewHeight = mHeaderView.getHeight(); // 控件显示在界面上高度</span></span><br><span class="line">        headerViewMeasureHeight = mHeaderView.getMeasuredHeight();    <span class="comment">// 获得测量得到控件真实高度</span></span><br><span class="line">        mHeaderView.setPadding(<span class="number">0</span>,-headerViewMeasureHeight,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// ListView.addHeadView(API)</span></span><br><span class="line">        addHeaderView(mHeaderView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initFooterView</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 7. 创建自定义脚布局</span></span><br><span class="line">        mFooterView = View.inflate(getContext(), R.layout.layout_footer_list,<span class="literal">null</span>);</span><br><span class="line">        mFooterText = mFooterView.findViewById(R.id.tv_footer);</span><br><span class="line">        mFooterView.measure(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        footerViewMeasureHeight = mFooterView.getMeasuredHeight();</span><br><span class="line">        <span class="comment">// 隐藏脚布局</span></span><br><span class="line">        mFooterView.setPadding(<span class="number">0</span>,-footerViewMeasureHeight,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent ev)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 3. 处理触摸事件，ListView下拉时，修改PaddingTop显示头部布局</span></span><br><span class="line">        <span class="comment">// 判断滑动距离，给Header设置paddingTop</span></span><br><span class="line">        <span class="keyword">switch</span>(ev.getAction())&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                downY = ev.getY();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                moveY = ev.getY();</span><br><span class="line">                <span class="type">float</span> <span class="variable">offset</span> <span class="operator">=</span> moveY - downY;     <span class="comment">// 向下移动的偏移量</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理：如果处于正在刷新的状态，则不处理头布局更新事件，调用父类方法（头布局不变，但仍可以滚动列表）</span></span><br><span class="line">                <span class="keyword">if</span>(currentState == REFRESHING)</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">super</span>.onTouchEvent(ev);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 显示头布局，则paddingTop = -自身高度 + 移动的偏移量</span></span><br><span class="line">                <span class="comment">// 只有偏移量 &gt; 0 &amp;&amp; 当前第一个可见条目的索引是0时，才下拉显示头部</span></span><br><span class="line">                <span class="comment">// ListView.getFirstVisiblePosition 返回值是当前可以看到的第一个item，在所有item中（包括看不到的）的位置</span></span><br><span class="line">                <span class="keyword">if</span>(offset &gt;<span class="number">0</span> &amp;&amp; getFirstVisiblePosition() == <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    paddingTop = (<span class="type">int</span>) (-headerViewMeasureHeight + offset);</span><br><span class="line">                    mHeaderView.setPadding(<span class="number">0</span>, paddingTop, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(paddingTop &gt;= <span class="number">0</span> &amp;&amp; currentState != RELEASE_REFRESH)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        <span class="comment">// 完全显示 =&gt; 切换成释放刷新模式</span></span><br><span class="line">                        currentState = RELEASE_REFRESH;</span><br><span class="line">                        updateHeader();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(paddingTop &lt; <span class="number">0</span> &amp;&amp; currentState != PULL_TO_REFRESH)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        <span class="comment">// 不完全显示 =&gt; 切换成下拉刷新模式</span></span><br><span class="line">                        currentState = PULL_TO_REFRESH;</span><br><span class="line">                        updateHeader();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// 当前事件被消费</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="comment">// 5. 松手之后根据当前的paddingTop决定是否执行刷新</span></span><br><span class="line">                <span class="keyword">if</span>(currentState == PULL_TO_REFRESH)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">// paddingTop &lt; 0 不完全显示，不刷新，恢复初始状态 =&gt; 隐藏头布局</span></span><br><span class="line">                    mHeaderView.setPadding(<span class="number">0</span>,-headerViewMeasureHeight,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (currentState == RELEASE_REFRESH)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">// paddingTop &gt;= 0 完全显示,切换状态为正在刷新</span></span><br><span class="line">                    mHeaderView.setPadding(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                    currentState = REFRESHING;</span><br><span class="line">                    updateHeader();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化动画</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initAnimation</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 向上转,围绕自身中心，逆时针180度 0 -&gt; -180</span></span><br><span class="line">        rotateUpAnim = <span class="keyword">new</span> <span class="title class_">RotateAnimation</span>(<span class="number">0f</span>,-<span class="number">180f</span>,</span><br><span class="line">                Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>,</span><br><span class="line">                Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>);</span><br><span class="line">        rotateUpAnim.setDuration(<span class="number">300</span>);</span><br><span class="line">        rotateUpAnim.setFillAfter(<span class="literal">true</span>);    <span class="comment">// 动画停留在结束位置</span></span><br><span class="line">        <span class="comment">// 向下转,围绕自身中心，逆时针180度 -180 -&gt; -360</span></span><br><span class="line">        rotateDownAnim = <span class="keyword">new</span> <span class="title class_">RotateAnimation</span>(-<span class="number">180f</span>,-<span class="number">360f</span>,</span><br><span class="line">                Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>,</span><br><span class="line">                Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>);</span><br><span class="line">        rotateDownAnim.setDuration(<span class="number">300</span>);</span><br><span class="line">        rotateDownAnim.setFillAfter(<span class="literal">true</span>);    <span class="comment">// 动画停留在结束位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 根据状态更新头布局内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateHeader</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">switch</span> (currentState)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">case</span> PULL_TO_REFRESH:</span><br><span class="line">                <span class="comment">// 切换为下拉刷新,执行动画 + 修改标题</span></span><br><span class="line">                mArrowView.startAnimation(rotateDownAnim);</span><br><span class="line">                mArrowView.setVisibility(View.VISIBLE);</span><br><span class="line">                pb.setVisibility(View.INVISIBLE);</span><br><span class="line">                mTitleText.setText(<span class="string">&quot;下拉刷新&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RELEASE_REFRESH:</span><br><span class="line">                <span class="comment">// 切换为释放刷新,执行动画 + 修改标题</span></span><br><span class="line">                mArrowView.startAnimation(rotateUpAnim);</span><br><span class="line">                mArrowView.setVisibility(View.VISIBLE);</span><br><span class="line">                pb.setVisibility(View.INVISIBLE);</span><br><span class="line">                mTitleText.setText(<span class="string">&quot;释放刷新&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REFRESHING:</span><br><span class="line">                <span class="comment">// 切换为正在刷新,暂停动画 + 修改标题</span></span><br><span class="line">                mArrowView.clearAnimation();</span><br><span class="line">                mArrowView.setVisibility(View.INVISIBLE);</span><br><span class="line">                pb.setVisibility(View.VISIBLE);</span><br><span class="line">                mTitleText.setText(<span class="string">&quot;正在刷新中……&quot;</span>);</span><br><span class="line">                <span class="comment">// 6. 设置监听器，（通过回调函数）通知用户执行网络操作刷新数据</span></span><br><span class="line">                <span class="keyword">if</span>(mListener != <span class="literal">null</span>)</span><br><span class="line">                    mListener.onRefresh();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRefreshComplete</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 用户通知刷新结束，恢复界面</span></span><br><span class="line">        currentState = PULL_TO_REFRESH;</span><br><span class="line">        updateHeader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnRefreshListener</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 安卓面向接口编程，使用回调函数</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span>;   <span class="comment">// 通知用户刷新</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onLoadMore</span><span class="params">()</span>;  <span class="comment">// 通知用户加载更多</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRefreshListener</span><span class="params">(OnRefreshListener listener)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 为列表设置监听器，监听数据的变化</span></span><br><span class="line">        <span class="built_in">this</span>.mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadMoreComplete</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 用户通知加载结束，恢复界面</span></span><br><span class="line">        mFooterView.setPadding(<span class="number">0</span>,-footerViewMeasureHeight,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        isLoadingMore = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 滚动监听</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onScrollStateChanged</span><span class="params">(AbsListView view, <span class="type">int</span> scrollState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 状态更新</span></span><br><span class="line"><span class="comment">//        public static int SCROLL_STATE_IDLE = 0; // 空闲</span></span><br><span class="line"><span class="comment">//        public static int SCROLL_STATE_TOUCH_SCROLL = 1;  // 触摸滑动</span></span><br><span class="line"><span class="comment">//        public static int SCROLL_STATE_FLING = 2; // 滑翔</span></span><br><span class="line">        <span class="comment">// 最新状态是空间状态 &amp;&amp; 当前界面显示的条目最后一项是最后一条数据 =&gt; 加载更多</span></span><br><span class="line">        <span class="comment">// 脚布局恢复</span></span><br><span class="line">        <span class="keyword">if</span>(isLoadingMore)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// 正在加载更多，避免重复加载更多数据</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(scrollState == SCROLL_STATE_IDLE &amp;&amp; getLastVisiblePosition() &gt;= (getCount() - <span class="number">1</span>))&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            isLoadingMore = <span class="literal">true</span>;</span><br><span class="line">            mFooterView.setPadding(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            setSelection(getCount());   <span class="comment">// 自动跳到最后一条数据</span></span><br><span class="line">            <span class="keyword">if</span>(mListener!=<span class="literal">null</span>)mListener.onLoadMore();  <span class="comment">// 通知用户加载数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onScroll</span><span class="params">(AbsListView view, <span class="type">int</span> firstVisibleItem, <span class="type">int</span> visibleItemCount, <span class="type">int</span> totalItemCount)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 滑动过程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MainActivity调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    RefreshListView listView;</span><br><span class="line">    MyAdapter adapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        listView = (RefreshListView) findViewById(R.id.listview);</span><br><span class="line">        adapter = <span class="keyword">new</span> <span class="title class_">MyAdapter</span>();</span><br><span class="line">        listView.setAdapter(adapter);</span><br><span class="line">        listView.setRefreshListener(<span class="keyword">new</span> <span class="title class_">RefreshListView</span>.OnRefreshListener()&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="comment">// 访问网络获取数据</span></span><br><span class="line">                refreshDataFromNet();</span><br><span class="line">                <span class="comment">// 获取结束，通知listView,调用onRefreshComplete</span></span><br><span class="line">                adapter.notifyDataSetChanged();</span><br><span class="line">                listView.onRefreshComplete();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadMore</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="comment">// 访问网络获取数据</span></span><br><span class="line">                loadDataFromNet();</span><br><span class="line">                <span class="comment">// 获取结束，通知listView,调用onRefreshComplete</span></span><br><span class="line">                adapter.notifyDataSetChanged();</span><br><span class="line">                listView.onLoadMoreComplete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RecycleView-对比-应用"><a href="#RecycleView-对比-应用" class="headerlink" title="RecycleView 对比 &amp; 应用"></a>RecycleView 对比 &amp; 应用</h3><ol>
<li>简介<br>用于代替ListView的滑动组件。相对于ListView功能更强大、支持定制样式更丰富、扩展性更高。</li>
<li>特点<br><img src="https://mark.cuckooing.cn/pics/pic_24b7d2f2.png" alt="pic_24b7d2f2.png"></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView = findView(R.id.id_recyclerview);</span><br><span class="line"><span class="comment">//设置布局管理器</span></span><br><span class="line">mRecyclerView.setLayoutManager(layout);</span><br><span class="line"><span class="comment">//设置adapter</span></span><br><span class="line">mRecyclerView.setAdapter(adapter)</span><br><span class="line"><span class="comment">//设置Item增加、移除动画</span></span><br><span class="line">mRecyclerView.setItemAnimator(<span class="keyword">new</span> <span class="title class_">DefaultItemAnimator</span>());</span><br><span class="line"><span class="comment">//添加分割线</span></span><br><span class="line">mRecyclerView.addItemDecoration(<span class="keyword">new</span> <span class="title class_">DividerItemDecoration</span>(</span><br><span class="line">                getActivity(), DividerItemDecoration.HORIZONTAL_LIST));</span><br></pre></td></tr></table></figure>

<ol>
<li>应用<br>RecyclerView 展示多种类型Item数据<br>（1）定义每个条目的bean</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> String goodsName;</span><br><span class="line">    <span class="keyword">private</span> String goodsImg;</span><br><span class="line">    <span class="keyword">private</span> String goodsDescription;</span><br><span class="line">    <span class="keyword">private</span> Integer goodsType;  <span class="comment">//1表示我的商品0表示别人的商品</span></span><br><span class="line">    <span class="keyword">private</span> String publisherName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Goods</span><span class="params">(String goodsName, String goodsImg, String goodsDescription, Integer goodsType,String publisherName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.goodsName = goodsName;</span><br><span class="line">        <span class="built_in">this</span>.goodsImg = goodsImg;</span><br><span class="line">        <span class="built_in">this</span>.goodsDescription = goodsDescription;</span><br><span class="line">        <span class="built_in">this</span>.goodsType = goodsType;</span><br><span class="line">        <span class="built_in">this</span>.publisherName = publisherName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGoodsName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> goodsName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGoodsName</span><span class="params">(String goodsName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.goodsName = goodsName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGoodsImg</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> goodsImg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGoodsImg</span><span class="params">(String goodsImg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.goodsImg = goodsImg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGoodsDescription</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> goodsDescription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGoodsDescription</span><span class="params">(String goodsDescription)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.goodsDescription = goodsDescription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getGoodsType</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> goodsType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGoodsType</span><span class="params">(Integer goodsType)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.goodsType = goodsType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPublisherName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> publisherName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPublisherName</span><span class="params">(String publisherName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.publisherName = publisherName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）定义各样式（ViewHolder）统一的委托接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDelegateAdapter</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找委托时调用的方法，根据商品的类型选择样式</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isForViewType</span><span class="params">(Goods goods)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于委托Adapter的onCreateViewHolder方法</span></span><br><span class="line">    RecyclerView.ViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="type">int</span> viewType)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于委托Adapter的onBindViewHolder方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="type">int</span> position, Goods goods)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）不同样式实现自己的Adapter，创建&#x2F;复用 RecyclerView.ViewHolder<br>GoodsOfMineDelegateAdapter.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsOfMineDelegateAdapter</span> <span class="keyword">implements</span> <span class="title class_">IDelegateAdapter</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isForViewType</span><span class="params">(Goods goods)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span>(goods.getGoodsType()==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RecyclerView.ViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//缓存池没有ViewHolder，则创建一个ViewHolder</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> LayoutInflater.from(parent.getContext()).inflate(R.layout.item_goods_of_mine,parent,<span class="literal">false</span>);</span><br><span class="line">        <span class="type">GoodsOfMineViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GoodsOfMineViewHolder</span>(view);</span><br><span class="line">        <span class="keyword">return</span> viewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="type">int</span> position, Goods goods)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//缓存池已有ViewHolder，直接拿出来进行复用</span></span><br><span class="line">        <span class="type">GoodsOfMineViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> (GoodsOfMineViewHolder) holder;</span><br><span class="line">        viewHolder.goodsName.setText(goods.getGoodsName());</span><br><span class="line">        viewHolder.goodsDescription.setText(goods.getGoodsDescription());</span><br><span class="line">        Glide.with(holder.itemView.getContext()).load(goods.getGoodsImg()).into(viewHolder.goodsImg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GoodsOfMineViewHolder</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ViewHolder&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        TextView goodsName;</span><br><span class="line">        ImageView goodsImg;</span><br><span class="line">        TextView goodsDescription;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">GoodsOfMineViewHolder</span><span class="params">(View view)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="built_in">super</span>(view);</span><br><span class="line">            goodsName = (TextView) view.findViewById(R.id.name_goods_of_mine);</span><br><span class="line">            goodsImg = (ImageView) view.findViewById(R.id.img_goods_of_mine);</span><br><span class="line">            goodsDescription = (TextView) view.findViewById(R.id.description_goods_of_mine);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GoodsOfOthersDelegateAdapter.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsOfOthersDelegateAdapter</span> <span class="keyword">implements</span> <span class="title class_">IDelegateAdapter</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isForViewType</span><span class="params">(Goods goods)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span>(goods.getGoodsType()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RecyclerView.ViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//缓存池没有ViewHolder，则创建一个ViewHolder</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> LayoutInflater.from(parent.getContext()).inflate(R.layout.item_goods_of_others,parent,<span class="literal">false</span>);</span><br><span class="line">        <span class="type">GoodsOfMineViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GoodsOfMineViewHolder</span>(view);</span><br><span class="line">        <span class="keyword">return</span> viewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="type">int</span> position, Goods goods)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//缓存池已有ViewHolder，直接拿出来进行复用</span></span><br><span class="line">        <span class="type">GoodsOfMineViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> (GoodsOfMineViewHolder) holder;</span><br><span class="line">        viewHolder.goodsName.setText(goods.getGoodsName());</span><br><span class="line">        viewHolder.goodsDescription.setText(goods.getGoodsDescription());</span><br><span class="line">        viewHolder.goodsPublisher.setText(goods.getPublisherName());</span><br><span class="line">        Glide.with(holder.itemView.getContext()).load(goods.getGoodsImg()).into(viewHolder.goodsImg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GoodsOfMineViewHolder</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ViewHolder&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        TextView goodsName;</span><br><span class="line">        ImageView goodsImg;</span><br><span class="line">        TextView goodsDescription;</span><br><span class="line">        TextView goodsPublisher;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">GoodsOfMineViewHolder</span><span class="params">(View view)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="built_in">super</span>(view);</span><br><span class="line">            goodsName = (TextView) view.findViewById(R.id.name_goods_of_others);</span><br><span class="line">            goodsImg = (ImageView) view.findViewById(R.id.img_goods_of_others);</span><br><span class="line">            goodsPublisher = (TextView) view.findViewById(R.id.publisher_goods_of_others);</span><br><span class="line">            goodsDescription = (TextView) view.findViewById(R.id.description_goods_of_others);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）实现RecyclerViewAdapter 继承 RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodsAdapter</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.Adapter&lt;RecyclerView.ViewHolder&gt;&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Goods&gt; goodslist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;IDelegateAdapter&gt; delegateAdapters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">currentType</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataItems</span><span class="params">(List&lt;Goods&gt; goodslist)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.goodslist = goodslist;</span><br><span class="line">        notifyDataSetChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDelegate</span><span class="params">(IDelegateAdapter delegateAdapter)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        delegateAdapters.add(delegateAdapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemViewType</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="comment">// 根据不同位置，通过委托对条目的类别进行判断</span></span><br><span class="line">        <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> goodslist.get(position);</span><br><span class="line">        <span class="keyword">for</span>(IDelegateAdapter delegateAdapter : delegateAdapters)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span>(delegateAdapter.isForViewType(goods))</span><br><span class="line">                currentType = goods.getGoodsType();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RecyclerView.ViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 缓冲池没有相应的ViewHolder，根据 getItemViewType得到的viewType设置相应的布局</span></span><br><span class="line">        <span class="comment">// 找到对应的委托Adapter</span></span><br><span class="line">        <span class="type">IDelegateAdapter</span> <span class="variable">delegateAdapter</span> <span class="operator">=</span> delegateAdapters.get(viewType);</span><br><span class="line">        <span class="comment">// 把onCreateViewHolder交给委托Adapter去处理</span></span><br><span class="line">        RecyclerView.<span class="type">ViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> delegateAdapter.onCreateViewHolder(parent, viewType);</span><br><span class="line">        <span class="keyword">return</span> viewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// RecyclerView 缓冲池有对应的ViewHolder，则复用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">viewType</span> <span class="operator">=</span> holder.getItemViewType();</span><br><span class="line">        <span class="comment">// 找到对应的委托Adapter</span></span><br><span class="line">        <span class="type">IDelegateAdapter</span> <span class="variable">delegateAdapter</span> <span class="operator">=</span> delegateAdapters.get(viewType);</span><br><span class="line">        <span class="comment">// 把onCreateViewHolder交给委托Adapter去处理</span></span><br><span class="line">        delegateAdapter.onBindViewHolder(holder,position,goodslist.get(position));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> goodslist.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）RecyclerViewActivity中创建适配器，RecyclerView，绑定。并为RecyclerView设置布局管理器<br>activity_recycler_view.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;com.sdu.chy.chytest.recyclerViewTest.RecyclerViewActivity&quot;</span>&gt;</span><br><span class="line">    &lt;android.support.v7.widget.RecyclerView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/chy_recycleView&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span>/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>RecyclerView.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initViews</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        recyclerView = (RecyclerView)findViewById(R.id.chy_recycleView);</span><br><span class="line">        recyclerView.setLayoutManager(<span class="keyword">new</span> <span class="title class_">LinearLayoutManager</span>(<span class="built_in">this</span>));	<span class="comment">// 线性布局管理器</span></span><br><span class="line">        <span class="comment">// recyclerView.setLayoutManager(new GridLayoutManager(this,3));</span></span><br><span class="line"></span><br><span class="line">        goodsAdapter = <span class="keyword">new</span> <span class="title class_">GoodsAdapter</span>();</span><br><span class="line">        goodsAdapter.setDataItems(goodsList);</span><br><span class="line">        goodsAdapter.addDelegate(<span class="keyword">new</span> <span class="title class_">GoodsOfMineDelegateAdapter</span>());</span><br><span class="line">        goodsAdapter.addDelegate(<span class="keyword">new</span> <span class="title class_">GoodsOfOthersDelegateAdapter</span>());</span><br><span class="line"></span><br><span class="line">        recyclerView.setAdapter(goodsAdapter);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于固定块数的样式。比如硅谷商城界面，分为6块：横幅、频道、活动、秒杀、推荐和热卖。则getItemCount()中return 6（固定），此时getItemViewType(position)则会从0遍历到5，根据各个位置的布局，填充相应的样式（ViewHolder）即可。源码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6种类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BANNER</span> <span class="operator">=</span> <span class="number">0</span>;	  <span class="comment">// 横幅</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CHANNEL</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 频道</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ACT</span> <span class="operator">=</span> <span class="number">2</span>;	  <span class="comment">// 活动</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SECKILL</span> <span class="operator">=</span> <span class="number">3</span>;  <span class="comment">// 秒杀</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RECOMMEND</span> <span class="operator">=</span> <span class="number">4</span>;<span class="comment">// 推荐</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HOT</span> <span class="operator">=</span> <span class="number">5</span>;	  <span class="comment">// 热卖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">currentType</span> <span class="operator">=</span> BANNER;	  <span class="comment">// 当前种类</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据位置得到类型-系统调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> position</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemViewType</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">case</span> BANNER:</span><br><span class="line">                currentType = BANNER;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHANNEL:</span><br><span class="line">                currentType = CHANNEL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ACT:</span><br><span class="line">                currentType = ACT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SECKILL:</span><br><span class="line">                currentType = SECKILL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RECOMMEND:</span><br><span class="line">                currentType = RECOMMEND;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOT:</span><br><span class="line">                currentType = HOT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回总条数（布局分为6块）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RecyclerView.ViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (viewType == BANNER) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BannerViewHolder</span>(mLayoutInflater.inflate(R.layout.banner_viewpager, <span class="literal">null</span>), mContext, resultBean);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewType == CHANNEL) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChannelViewHolder</span>(mLayoutInflater.inflate(R.layout.channel_item, <span class="literal">null</span>), mContext);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewType == ACT) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActViewHolder</span>(mLayoutInflater.inflate(R.layout.act_item, <span class="literal">null</span>), mContext);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewType == SECKILL) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SeckillViewHolder</span>(mLayoutInflater.inflate(R.layout.seckill_item, <span class="literal">null</span>), mContext);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewType == RECOMMEND) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RecommendViewHolder</span>(mLayoutInflater.inflate(R.layout.recommend_item, <span class="literal">null</span>), mContext);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewType == HOT) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HotViewHolder</span>(mLayoutInflater.inflate(R.layout.hot_item, <span class="literal">null</span>), mContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="PopupWindow-Dialog"><a href="#PopupWindow-Dialog" class="headerlink" title="PopupWindow &amp; Dialog"></a>PopupWindow &amp; Dialog</h2><h3 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a>PopupWindow</h3><p><img src="https://mark.cuckooing.cn/pics/pic_5bcf6655.png" alt="pic_5bcf6655.png"><br>定义popupWindow类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择照片的PopupWindow</span></span><br><span class="line"><span class="comment"> * Created by chenlijin on 2016/4/12.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectPicPopupWindow</span> <span class="keyword">extends</span> <span class="title class_">PopupWindow</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnTouchListener, View.OnKeyListener &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> View rootView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SelectPicPopupWindow</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mContext = context;</span><br><span class="line">        <span class="type">LayoutInflater</span> <span class="variable">inflater</span> <span class="operator">=</span> LayoutInflater.from(context);</span><br><span class="line">        rootView = inflater.inflate(R.layout.popupwindow_selectpic, <span class="literal">null</span>);</span><br><span class="line">        setContentView(rootView);</span><br><span class="line">        ButterKnife.bind(<span class="built_in">this</span>, rootView);</span><br><span class="line">        <span class="comment">//设置高度和宽度。</span></span><br><span class="line">        <span class="built_in">this</span>.setHeight(ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">        <span class="built_in">this</span>.setWidth(ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">        <span class="built_in">this</span>.setFocusable(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置动画效果</span></span><br><span class="line">        <span class="built_in">this</span>.setAnimationStyle(R.style.mypopwindow_anim_style);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当单击Back键或者其他地方使其消失、需要设置这个属性。</span></span><br><span class="line">        rootView.setOnTouchListener(<span class="built_in">this</span>);</span><br><span class="line">        rootView.setOnKeyListener(<span class="built_in">this</span>);</span><br><span class="line">        rootView.setFocusable(<span class="literal">true</span>);</span><br><span class="line">        rootView.setFocusableInTouchMode(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化一个ColorDrawable颜色为半透明</span></span><br><span class="line">        <span class="type">ColorDrawable</span> <span class="variable">dw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColorDrawable</span>(<span class="number">0xb0000000</span>);</span><br><span class="line">        <span class="comment">//设置SelectPicPopupWindow弹出窗体的背景</span></span><br><span class="line">        <span class="built_in">this</span>.setBackgroundDrawable(dw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//点击外部popup消失</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouch</span><span class="params">(View v, MotionEvent event)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> rootView.findViewById(R.id.linearlayout_window).getTop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">        <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (y &lt; height) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                dismiss();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点back键消失</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onKey</span><span class="params">(View v, <span class="type">int</span> keyCode, KeyEvent event)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; <span class="built_in">this</span>.isShowing()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="built_in">this</span>.dismiss();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClick(&#123;</span></span><br><span class="line"><span class="meta">   </span></span><br><span class="line"><span class="meta">     </span></span><br><span class="line"><span class="meta">     R.id.button_take_photo, R.id.button_select_pic, R.id.button_cancal&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">switch</span> (view.getId()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">case</span> R.id.button_take_photo:</span><br><span class="line">                listener.onClickTakePhoto();</span><br><span class="line">                <span class="built_in">this</span>.dismiss();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.button_select_pic:</span><br><span class="line">                listener.onClickSelectPic();</span><br><span class="line">                <span class="built_in">this</span>.dismiss();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.button_cancal:</span><br><span class="line">                <span class="built_in">this</span>.dismiss();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnWindowItemClickListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnWindowItemClickListener</span><span class="params">(OnWindowItemClickListener listener)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.listener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnWindowItemClickListener</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onClickTakePhoto</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onClickSelectPic</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义Style</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">&quot;MyPopup&quot;</span> parent=<span class="string">&quot;android:style/Theme.Dialog&quot;</span>&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:windowFrame&quot;</span>&gt;<span class="meta">@null</span>&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:windowNoTitle&quot;</span>&gt;<span class="literal">true</span>&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:windowBackground&quot;</span>&gt;<span class="meta">@color</span>/popup&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:windowIsFloating&quot;</span>&gt;<span class="literal">true</span>&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:windowContentOverlay&quot;</span>&gt;<span class="meta">@null</span>&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>定义进入和退出的动画:<br>进入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;set xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br><span class="line">    &lt;translate </span><br><span class="line">        android:duration=<span class="string">&quot;200&quot;</span></span><br><span class="line">        android:fromYDelta=<span class="string">&quot;100.0%&quot;</span></span><br><span class="line">        android:toYDelta=<span class="string">&quot;0.0&quot;</span>/&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure>

<p>退出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;set xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br><span class="line">    &lt;translate </span><br><span class="line">        android:duration=<span class="string">&quot;200&quot;</span></span><br><span class="line">        android:fromYDelta=<span class="string">&quot;0.0&quot;</span></span><br><span class="line">        android:toYDelta=<span class="string">&quot;100.0%&quot;</span>/&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure>

<p>动画的style</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">&quot;mypopwindow_anim_style&quot;</span>&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:windowEnterAnimation&quot;</span>&gt;<span class="meta">@anim</span>/popup_in&lt;/item&gt;</span><br><span class="line">        &lt;!-- 指定显示的动画xml --&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:windowExitAnimation&quot;</span>&gt;<span class="meta">@anim</span>/popup_out&lt;/item&gt;</span><br><span class="line">        &lt;!-- 指定消失的动画xml --&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>在指定的位置显示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示窗口  </span></span><br><span class="line">window.showAtLocation(MainActivity.<span class="built_in">this</span>.findViewById(R.id.main), Gravity.BOTTOM|Gravity.CENTER_HORIZONT</span><br></pre></td></tr></table></figure>

<h3 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h3><p><img src="https://mark.cuckooing.cn/pics/pic_3b8ce2fe.png" alt="pic_3b8ce2fe.png"><br>定义style</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--自定义布局的dialog--&gt;</span><br><span class="line">    &lt;style name=<span class="string">&quot;MyDialog&quot;</span> parent=<span class="string">&quot;android:style/Theme.Dialog&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 背景颜色及透明程度 --&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:windowBackground&quot;</span>&gt;<span class="meta">@android</span>:color/transparent&lt;/item&gt;</span><br><span class="line">        &lt;!-- 是否有标题 --&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:windowNoTitle&quot;</span>&gt;<span class="literal">true</span>&lt;/item&gt;</span><br><span class="line">        &lt;!-- 是否浮现在activity之上,会造成macth_parent失效--&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:windowIsFloating&quot;</span>&gt;<span class="literal">false</span>&lt;/item&gt;</span><br><span class="line">        &lt;!-- 是否模糊 --&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:backgroundDimEnabled&quot;</span>&gt;<span class="literal">true</span>&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:windowFrame&quot;</span>&gt;<span class="meta">@null</span>&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>动画: 和popupwindow一致<br>自定义Dialog:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择图片对话框</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectPicDialog</span> <span class="keyword">extends</span> <span class="title class_">Dialog</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SelectPicDialog</span><span class="params">(Context context, <span class="type">int</span> themeResId)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>(context, themeResId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.dialog_select_pic);</span><br><span class="line">        ButterKnife.bind(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClick(&#123;</span></span><br><span class="line"><span class="meta">   </span></span><br><span class="line"><span class="meta">     </span></span><br><span class="line"><span class="meta">     R.id.linearlayout_out,R.id.textview_take_photo, R.id.textview_select_photo, R.id.textview_cancal&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">switch</span> (view.getId()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">case</span> R.id.textview_take_photo:</span><br><span class="line">                <span class="keyword">if</span>(listener!=<span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    listener.onClickTakePhoto();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.cancel();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.textview_select_photo:</span><br><span class="line">                <span class="keyword">if</span>(listener!=<span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    listener.onClickSelectPic();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.cancel();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.linearlayout_out:</span><br><span class="line">            <span class="keyword">case</span> R.id.textview_cancal:</span><br><span class="line">                <span class="built_in">this</span>.cancel();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnWindowItemClickListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnWindowItemClickListener</span><span class="params">(OnWindowItemClickListener listener)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.listener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnWindowItemClickListener</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onClickTakePhoto</span><span class="params">()</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onClickSelectPic</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Activity中调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SelectPicDialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SelectPicDialog</span>(mContext,R.style.MyDialog);</span><br><span class="line">        <span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> dialog.getWindow();</span><br><span class="line">        window.setGravity(Gravity.BOTTOM);  <span class="comment">//此处可以设置dialog显示的位置</span></span><br><span class="line">        window.setWindowAnimations(R.style.mypopwindow_anim_style);  <span class="comment">//添加动画</span></span><br><span class="line">        dialog.show();</span><br><span class="line">        dialog.setOnWindowItemClickListener(<span class="keyword">new</span> <span class="title class_">SelectPicDialog</span>.OnWindowItemClickListener()&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClickTakePhoto</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                startActivityForResult(createCameraIntent(), CREATE_CAMERA);   <span class="comment">//选择拍照</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClickSelectPic</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                startActivityForResult(createPickIntent(), CREATE_PICK);   <span class="comment">//选择启用系统的选择图片</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="PopupWindow-Dialog-区别"><a href="#PopupWindow-Dialog-区别" class="headerlink" title="PopupWindow &amp; Dialog 区别"></a>PopupWindow &amp; Dialog 区别</h3><ul>
<li>Popupwindow在显示之前一定要设置宽高，Dialog无此限制。</li>
<li>Popupwindow默认不会响应物理键盘的back，除非显示设置了popup.setFocusable(true);而在点击back的时候，Dialog会消失。</li>
<li>Popupwindow不会给页面其他的部分添加蒙层，而Dialog会。</li>
<li>Popupwindow没有标题，Dialog默认有标题，可以通过dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);取消标题</li>
<li>二者显示的时候都要设置Gravity。如果不设置，Dialog默认是Gravity.CENTER。</li>
<li>二者都有默认的背景，都可以通过setBackgroundDrawable(new ColorDrawable(android.R.color.transparent));去掉。</li>
</ul>
<p>其中最本质的差别就是：AlertDialog是非阻塞式对话框：AlertDialog弹出时，后台还可以做事情；而PopupWindow是阻塞式对话框：PopupWindow弹出时，程序会等待，在PopupWindow退出前，程序一直等待，只有当我们调用了dismiss方法的后，PopupWindow退出，程序才会向下执行。这两种区别的表现是：AlertDialog弹出时，背景是黑色的，但是当我们点击背景，AlertDialog会消失，证明程序不仅响应AlertDialog的操作，还响应其他操作，其他程序没有被阻塞，这说明了AlertDialog是非阻塞式对话框；PopupWindow弹出时，背景没有什么变化，但是当我们点击背景的时候，程序没有响应，只允许我们操作PopupWindow，其他操作被阻塞。</p>
<h1 id="第五章-网络-之-计算机网络"><a href="#第五章-网络-之-计算机网络" class="headerlink" title="第五章 网络 之 计算机网络"></a>第五章 网络 之 计算机网络</h1><ul>
<li>计算机体系结构</li>
<li><ul>
<li>计算机网络概念、组成与功能</li>
<li>计算机网络分层结构（各层功能）</li>
<li><ul>
<li>ISO&#x2F;OSI 7层模型（权威）</li>
<li>TCP&#x2F;IP 4层模型（实用）</li>
<li>5层模型（折中）</li>
</ul>
</li>
</ul>
</li>
<li>一. 物理层</li>
<li>二. 数据链路层</li>
<li><ul>
<li>基本功能</li>
<li><ul>
<li>封装成帧</li>
<li>透明传输</li>
<li>差错检测</li>
</ul>
</li>
<li>相关概念</li>
<li><ul>
<li>局域网</li>
<li>以太网</li>
<li>MAC地址</li>
<li>交换机</li>
</ul>
</li>
</ul>
</li>
<li>三. 网络层</li>
<li><ul>
<li>异构网络互联（互联网）</li>
<li>路由选择 &amp; 分组转发</li>
<li><ul>
<li>路由表</li>
<li><ul>
<li>为什么不用目的主机号制作路由表 &#x2F; 为什么不直接用MAC地址&#x2F;寻址？</li>
<li>内部结构 &#x2F; 工作原理</li>
</ul>
</li>
<li>分组转发算法</li>
</ul>
</li>
<li>IPv4 &amp; IPv6</li>
<li><ul>
<li>IP数据报格式</li>
<li>IP地址编址方式</li>
<li><ul>
<li>第一阶段 1981：分类IP地址（2级结构）</li>
<li>第二阶段 1985：子网划分（3级结构）</li>
<li>第三阶段 1987：CIDR（无分类 &#x2F; 网络前缀）</li>
<li>第四阶段 1994：NAT（地址转换）</li>
</ul>
</li>
</ul>
</li>
<li>相关协议</li>
<li><ul>
<li>ARP 地址解析协议（Adress Resolution Protocol）</li>
<li>DHCP 动态主机设置协议（Dynamic Host Configuration Protocol）</li>
<li>ICMP 网络控制报文协议（Internet Control Message Protocol）</li>
<li>VPN 虚拟专用网</li>
</ul>
</li>
<li>路由协议</li>
<li><ul>
<li>内部网关协议IGP（RIP、OSPF）</li>
<li>外部网关协议EGP（BGP）</li>
</ul>
</li>
<li>网络层设备：路由器</li>
</ul>
</li>
<li>四. 传输层</li>
<li><ul>
<li>传输层寻址 &amp;&amp; 端口</li>
<li>TCP &amp;&amp; UDP</li>
<li><ul>
<li>TCP&#x2F;UDP 特点</li>
<li>首部格式</li>
<li>三次握手 &amp; 四次挥手</li>
<li>TCP可靠传输</li>
<li><ul>
<li>超时重传</li>
<li>滑动窗口</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>五. 应用层</li>
<li><ul>
<li>网络应用模型</li>
<li><ul>
<li>C&#x2F;S（客户端&#x2F;服务器）方式</li>
<li>P2P（peer to peer 对等）方式</li>
</ul>
</li>
<li>相关协议</li>
<li><ul>
<li>DNS系统</li>
<li>FTP</li>
<li>电子邮件（SMTP、POP3、IMAP）</li>
<li>WWW（HTTP）</li>
<li>Telent</li>
</ul>
</li>
</ul>
</li>
<li>面试</li>
<li><ul>
<li>MAC &#x2F; IP地址 &amp; 作用？</li>
<li>描述一次网络请求的流程&#x2F;浏览器访问一个url网址所经历的过程？</li>
<li>什么是DNS？作用是什么？工作机制？</li>
</ul>
</li>
</ul>
<p>[文都考研——计算机网络强化班][Link 30]</p>
<h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>计算机网络体系结构：计算机网络各层次与协议的集合<br>（1）层次：每个层次的功能是明确的，独立的，对等的。<br>（2）协议：为数据交换而制定的规则，约定，标准。包含：</p>
<ul>
<li>语义：解释比特流每一部分的意义。</li>
<li>语法：用户数据与控制信息的结构与格式，以及数据出现的顺序的意义。</li>
<li>时序：事件实现顺序的详细说明。</li>
</ul>
<h3 id="计算机网络概念、组成与功能"><a href="#计算机网络概念、组成与功能" class="headerlink" title="计算机网络概念、组成与功能"></a>计算机网络概念、组成与功能</h3><ul>
<li>概念<br>计算机网络就是利用通信设备和线路将地理位置不同、功能独立的多个计算机系统互连起来，以功能完善的网络软件（即网络通信协议、信息交换方式、网络操作系统等）实现网络中资源共享和信息传递的系统。</li>
<li>组成<br>资源子网：负责数据处理的主计算机与终端，由主机终端负责。<br>通信子网：负责数据通信处理的通信处理机与通信线路，由路由器，交换机负责。</li>
</ul>
<h3 id="计算机网络分层结构（各层功能）"><a href="#计算机网络分层结构（各层功能）" class="headerlink" title="计算机网络分层结构（各层功能）"></a>计算机网络分层结构（各层功能）</h3><p><img src="https://mark.cuckooing.cn/pics/pic_c63dd286.png" alt="pic_c63dd286.png"></p>
<h4 id="ISO-OSI-7层模型（权威）"><a href="#ISO-OSI-7层模型（权威）" class="headerlink" title="ISO&#x2F;OSI 7层模型（权威）"></a>ISO&#x2F;OSI 7层模型（权威）</h4><ul>
<li>物理层<br>利用传输介质为通信的网络结点之间建立、管理和释放物理连接；实现比特流的透明传输，位数据链路层提供数据传输服务；物理层的数据传输单元是比特。</li>
<li>数据链路层<br>在物理层提供的服务基础上，数据链路层在通信实体间简历数据链路连接；传输以”帧”为单位的数据包；采用差错控制与流量控制方法，使有差错的物理线路编程无差错的数据链路。</li>
<li>网络层<br>通过路由选择算法为分组通过通信子网选择最适当的路径；为数据在结点之间传输创建逻辑链路。</li>
<li>传输层（承上（资源子网）启下（通信子网））<br>向用户提供可靠端到端（end to end）通信；处理数据包错误、数据包次序以及其他一些关键传输问题；屏蔽了下层数据通信的细节，是计算机通信体系结构中关键的一层。</li>
<li>会话层<br>建立及管理会话（数据交换）。负责维护两个结点之间的传输链接，以便确保点到点传输不终端。</li>
<li>表示层<br>用于处理在两个通信系统中交换信息的表示方式，包括数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li>
<li>应用层<br>为应用程序提供了网络服务；应用层需要识别并保证通信对方的可用性，使得协同工作的应用程序之间的同步。建立传输错误纠正与保证数据完整性的控制机制。<br><img src="https://mark.cuckooing.cn/pics/pic_dc7a3899.png" alt="pic_dc7a3899.png"></li>
</ul>
<h4 id="TCP-IP-4层模型（实用）"><a href="#TCP-IP-4层模型（实用）" class="headerlink" title="TCP&#x2F;IP 4层模型（实用）"></a>TCP&#x2F;IP 4层模型（实用）</h4><p>TCP&#x2F;IP协议独立于特定的计算机硬件与操作系统，屏蔽网络层以下的传输。拥有统一的网络地址分配方案，使整个TCP&#x2F;IP设备在网络中都有唯一的地址。</p>
<ul>
<li>网络接口层：负责通过网络发送和接收IP数据报</li>
<li>网络层：IP协议是无连接的，提供”尽力而为”服务的网络层协议</li>
<li>传输层：在互联网中源主机与目的主机的对等实体间建立用于会话的端-端链接。包括TCP、UDP</li>
<li>应用层：包括Telnet、FTP、SMTP、P0P3、IMAP、DNS、HTTP等<br><img src="https://mark.cuckooing.cn/pics/pic_04ae8d32.png" alt="pic_04ae8d32.png"><br><img src="https://mark.cuckooing.cn/pics/pic_65caa861.png" alt="pic_65caa861.png"></li>
</ul>
<h4 id="5层模型（折中）"><a href="#5层模型（折中）" class="headerlink" title="5层模型（折中）"></a>5层模型（折中）</h4><p>包含：物理层、数据链路层、网络层、传输层、应用层</p>
<h2 id="一-物理层"><a href="#一-物理层" class="headerlink" title="一. 物理层"></a>一. 物理层</h2><h2 id="二-数据链路层"><a href="#二-数据链路层" class="headerlink" title="二. 数据链路层"></a>二. 数据链路层</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。<br><img src="https://mark.cuckooing.cn/pics/pic_04d3d228.png" alt="pic_04d3d228.png"></p>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>透明表示一个实际存在的事物看起来好像不存在一样。<br>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。<br><img src="https://mark.cuckooing.cn/pics/pic_46d60303.png" alt="pic_46d60303.png"></p>
<h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h4><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p>
<blockquote>
<p>广播信道：一对多通信，一个结点发送数据能够被广播信道上所有结点接收到。所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA&#x2F;CD 协议。</p>
</blockquote>
<p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。<br>可以按照网络拓扑结构对局域网进行分类：<br><img src="https://mark.cuckooing.cn/pics/pic_da0b3ed2.png" alt="pic_da0b3ed2.png"></p>
<h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><p>以太网是一种星型拓扑结构局域网。<br>早期使用集线器进行连接，目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。<br>以太网&#x2F;MAC帧格式：<br>类型 ：标记上层使用的协议；<br>数据 ：长度在 46-1500 之间，如果太小则需要填充；<br>FCS ：帧检验序列，使用的是 CRC 检验方法；<br><img src="https://mark.cuckooing.cn/pics/pic_f0f57147.png" alt="pic_f0f57147.png"></p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>MAC 地址又称物理&#x2F;硬件地址，是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。<br>MAC地址前三字节（高位24位）由IEEE的注册管理机构RA负责向厂家分配。<br>MAC地址后三字节（地位24位）由厂家自行指派，称为扩展标识符，必须保证生产出的网络适配器没有重复地址。</p>
<h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>交换机又称交换式集线器，实质上是一个多接口网桥，工作在数据链路层。根据MAC帧的目的地址对收到的帧进行转发。实现数据链路层上局域网的互连。（互连不同数据链路层协议、不同传输介质与不同传输速率的网络）<br>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。<br>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。<br>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。<br><img src="https://mark.cuckooing.cn/pics/pic_2d6ea0f6.png" alt="pic_2d6ea0f6.png"></p>
<h2 id="三-网络层"><a href="#三-网络层" class="headerlink" title="三. 网络层"></a>三. 网络层</h2><p>网络层主要任务：</p>
<ul>
<li>通过路由选择算法，为分组通过通信子网选择最适当的路径；</li>
<li>网络层使用数据链路层的服务，实现路由选择、拥塞控制与网络互连等基本功能，向传输层的端到端传输连接提供服务。</li>
</ul>
<h3 id="异构网络互联（互联网）"><a href="#异构网络互联（互联网）" class="headerlink" title="异构网络互联（互联网）"></a>异构网络互联（互联网）</h3><p>互联网是使用IP协议，通过路由器（网关）将各种物理网络互连起来的虚拟互连网络。<br>互连起来的各种物理网络的异构性是客观存在的，利用IP协议可以使这些性能各异的网络从用户看起来好像是一个统一的网络（屏蔽物理网络的异构性）。<br>从网络层看IP数据报：</p>
<ul>
<li>网络地址不变（源IP地址、目的IP地址）</li>
<li>链路层地址变化（源MAC地址、目的MAC地址）<br><img src="https://mark.cuckooing.cn/pics/pic_e38e3674.png" alt="pic_e38e3674.png"><br><img src="https://mark.cuckooing.cn/pics/pic_bb41a8d0.png" alt="pic_bb41a8d0.png"></li>
</ul>
<h3 id="路由选择-分组转发"><a href="#路由选择-分组转发" class="headerlink" title="路由选择 &amp; 分组转发"></a>路由选择 &amp; 分组转发</h3><ul>
<li>分组转发<br>转发就是路由器根据路由&#x2F;转发表将用户的IP数据报从合适的端口转发出去。</li>
<li>路由选择<br>按照分布式算法根据从各相邻的路由器得到关于网络拓扑的变化情况，动态地改变所选择地路由。路由表是根据李由选择算法得出地。</li>
</ul>
<h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><h5 id="为什么不用目的主机号制作路由表-为什么不直接用MAC地址-寻址？"><a href="#为什么不用目的主机号制作路由表-为什么不直接用MAC地址-寻址？" class="headerlink" title="为什么不用目的主机号制作路由表 &#x2F; 为什么不直接用MAC地址&#x2F;寻址？"></a>为什么不用目的主机号制作路由表 &#x2F; 为什么不直接用MAC地址&#x2F;寻址？</h5><p>（1）根据目的主机的MAC地址制作路由表，使得路由表过于庞大。<br>（2）由于物理网络的异构性使不同链路主机的地址不统一，需要转化。</p>
<blockquote>
<p>有四个A类网络通过三个路由器连接在一起。每一个网络上都可能有成千上万个主机。可以想象，若按目的主机号来制作路由表，则所得出路由表就会过于庞大。但若按主机所在网络地址来制作路由表，那么每一个路由器中的路由表就只包含4个项目。可以使路由表简化。</p>
</blockquote>
<h5 id="内部结构-工作原理"><a href="#内部结构-工作原理" class="headerlink" title="内部结构 &#x2F; 工作原理"></a>内部结构 &#x2F; 工作原理</h5><p><img src="https://mark.cuckooing.cn/pics/pic_24fb0d7f.png" alt="pic_24fb0d7f.png"><br>在路由表中，对每一条路由，包含（目的网络地址，下一跳地址）</p>
<blockquote>
<p>路由表项主要字段：目的网络、子网掩码、下一跳路由、经由接口</p>
</blockquote>
<p>根据目的网络地址就能确定下一跳路由器，因此IP数据报最终一定可以找到目的主机所在目的网络上的路由器（可能经过多次间接交付）。只有到达最后一个路由器时，才试图向目的主机进行直接交付。<br>注：<br>IP数据报首部中没有地方用来指明”下一跳路由器的IP地址”<br>当路由器收到待转发的数据报，不是将下一跳路由器的IP地址填入IP数据报，而是送交下层的网络接口软件。网络接口软件使用ARP负责将下一跳路由器的IP地址转换成硬件地址，并将此硬件地址放在链路层MAC帧首部，然后根据这个硬件地址找到下一跳路由器。<br>因此IP数据报在网络层IP（逻辑）地址不变，MAC（物理）地址不断变化。</p>
<h4 id="分组转发算法"><a href="#分组转发算法" class="headerlink" title="分组转发算法"></a>分组转发算法</h4><p>（1）从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N；<br>（2）若网络N与此路由器直接相连，则把数据报直接交付目的主机D；否则是间接交付，执行（3）；<br>（3）若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则执行（4）；<br>（4）若路由表中有到大网络N的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行（5）；<br>（5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由；否则，执行（6）；<br>默认路由：若匹配路由表中其他项都不匹配，则走默认路由指明的路由。<br>（6）报告转发分组出错。<br>若路由表项皆不匹配且无默认路由，主机发出错的ICMP包。<br><img src="https://mark.cuckooing.cn/pics/pic_c6eddbb9.png" alt="pic_c6eddbb9.png"></p>
<h3 id="IPv4-IPv6"><a href="#IPv4-IPv6" class="headerlink" title="IPv4 &amp; IPv6"></a>IPv4 &amp; IPv6</h3><h4 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h4><p><img src="https://mark.cuckooing.cn/pics/pic_81a4b1c1.png" alt="pic_81a4b1c1.png"><br>一个IP数据报由首部和数据两部分组成。首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。</p>
<ul>
<li>IP数据报的分片与重组<br>IP数据报作为网络层数据必然要通过帧来传输。一个数据报可能要通过多个不同的物理网络。每一个路由器都要将接收到的帧进行拆包和处理，然后封装成另外一个帧。每一种物理网络都规定了各自帧的数据域最大字节长度的最大传输单元。其中帧的格式与长度取决于物理网络所采用的协议。<br>分片、重组的基本方法——标识、标志和片偏移<br>在IP数据报的报头，与一个数据报的分片、组装相关的域有标识域、标志域和片偏移域</li>
</ul>
<h4 id="IP地址编址方式"><a href="#IP地址编址方式" class="headerlink" title="IP地址编址方式"></a>IP地址编址方式</h4><ul>
<li>IPv4地址<br>TCP&#x2F;IP协议的网络层使用的地址标识符叫做IP地址。IPv4中IP地址是一个32位的二进制地址，采用点分十进制。网络中的每一个主机或路由器至少有一个IP地址（连接到多个物理网络时，可以用有多个处于不同网络的IP地址）。在Internet中每个设备的IP地址全网唯一。</li>
<li>编址方式</li>
</ul>
<h5 id="第一阶段-1981：分类IP地址（2级结构）"><a href="#第一阶段-1981：分类IP地址（2级结构）" class="headerlink" title="第一阶段 1981：分类IP地址（2级结构）"></a>第一阶段 1981：分类IP地址（2级结构）</h5><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。<br>IP 地址 ::&#x3D; {&lt; 网络号 &gt;, &lt; 主机号 &gt;}<br><img src="https://mark.cuckooing.cn/pics/pic_2a709174.png" alt="pic_2a709174.png"></p>
<table> 
 <thead> 
  <tr> 
   <th>类别</th> 
   <th>地址范围</th> 
   <th>使用</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>A类</td> 
   <td>0.0.0.0到127.255.255.255</td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>B类</td> 
   <td>128.0.0.0到191.255.255.255</td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>C类</td> 
   <td>192.0.0.0到223.255.255.255</td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>D类</td> 
   <td>224.0.0.0到239.255.255.255</td> 
   <td>多用于组播，它并不指向特定的网络，多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机（如直播）</td> 
  </tr> 
  <tr> 
   <td>E类</td> 
   <td>240.0.0.0到247.255.255.255</td> 
   <td>保留为今后使用</td> 
  </tr> 
 </tbody> 
</table>

<p>（1）IP地址是一种分等级的地址结构。好处在于：网络号由IP地址管理机构在分配IP地址时分配；主机号由得到该网络号的单位自行分配。且路由器仅根据目的主机所连接的网络号转发分组，减少路由表表项。<br>（2）IP地址标志一个主机（或路由器）和一条链路的接口。一个路由器应当连接到两个或多个网络上（将IP数据报从一个网络转发到另一个网络），因此一个路由器的每个接口都有一个不同网络号的IP地址。<br>（3）用转发器或网桥（链路层）连接起来的若干局域网仍为一个网络，因此这些局域网都具有相同的网络号。<br>（4）同一局域网上主机域路由器IP地址网络号必须相同（才能通过路由器转发数据 &#x3D;&gt; 上网）</p>
<h5 id="第二阶段-1985：子网划分（3级结构）"><a href="#第二阶段-1985：子网划分（3级结构）" class="headerlink" title="第二阶段 1985：子网划分（3级结构）"></a>第二阶段 1985：子网划分（3级结构）</h5><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。使一个大的网络（如A、B类网络划分成几个较小的网络）<br>注意，外部网络看不到子网的存在（划分子网属于单位内部的事 &#x3D;&gt; 单位内部对分类得到地址（）进一步进行划分）<br>IP 地址 ::&#x3D; {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}<br><img src="https://mark.cuckooing.cn/pics/pic_14e6bc09.png" alt="pic_14e6bc09.png"></p>
<ul>
<li>子网掩码<br>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。<br><img src="https://mark.cuckooing.cn/pics/pic_896803e9.png" alt="pic_896803e9.png"><br>网络地址 &#x3D; （IP地址） AND （子网地址）<br>划分子网的基本思路：根据子网中主机的个数最大值（保证为子网中所有主机分配IP地址） &#x3D;&gt; 子网域位数</li>
</ul>
<blockquote>
<p>划分子网实例（重点）：<br>某企业分配到一个C类IP地址201.222.5.0。假设需要6个子网，每个子网20台主机，给出网络规划。<br>（1）确定子网域位数，从主机借位：2^3-2&#x3D;8-2 &gt;&#x3D; 6，从主机位借3位。<br>C类默认掩码255.255.255.0，即1111 1111.1111 1111.1111 1111.0000 0000<br>借3位后子网掩码 1111 1111.1111 1111.1111 1111.1110 0000 &#x3D; 255.255.255.224<br>此时主机号5位，每个子网可以分配2^5 &#x3D; 32 &gt; 20台主机，满足要求。<br>分配的每个子网：000（X）、001、010、011、100、101、110、111（X）</p>
</blockquote>
<ul>
<li>划分子网情况下路由器转发分组算法<br>路由表的每一项：{目的网络地址、子网掩码、下一跳（下一跳地址、接口）}<br>（1）从分组的首部提取目的IP地址D；<br>（2）先用与该路由器直接相连的网络的子网掩码与D进行与运算，看结果是否与相应的网络<br>地址相匹配。若匹配，则进行直接交付。<br>否则就是间接交付，马上执行（3）；<br>（3）若路由表中有一条到目的主机D的特定路由，则将分组转发给其指明的下一跳路由器。<br>否则执行（4）；<br>（4）对路由表中每一行的子网掩码和D进行与运算，若结果与该行的目的网络地址匹配，则将<br>分组传给该行指明的下一跳路由器。<br>否则执行（5）；<br>（5）若路由表中有一个默认路由，则将分组传给路由表中指明的默认路由器。<br>否则执行（6）；<br>（6）报告转发分组出错。</li>
</ul>
<h5 id="第三阶段-1987：CIDR（无分类-网络前缀）"><a href="#第三阶段-1987：CIDR（无分类-网络前缀）" class="headerlink" title="第三阶段 1987：CIDR（无分类 &#x2F; 网络前缀）"></a>第三阶段 1987：CIDR（无分类 &#x2F; 网络前缀）</h5><ul>
<li>无分类编址<br>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化，用于代替分类地址中的网络号和子网号，使IP地址从三级编址回到了两级编址。<br>IP 地址 ::&#x3D; {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}<br>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7&#x2F;20 表示前 20 位为网络前缀。</li>
<li>路由聚合、构成超网<br>网络前缀相同的连续IP地址 称为一个CIDR地址块。<br>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。如&#x2F;20地址块的掩码是20个连续的1。<br>一个 CIDR 地址块中有很多地址，一个 CIDR 地址块表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。<br>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</li>
</ul>
<blockquote>
<p>目的地址D &#x3D; 206.0.71.130 &#x3D; 206.0.0100 0111.1000 0010<br>路由表中项目 ： 206.0.68.0&#x2F;22（ISP） 与目的地址匹配长度 &#x3D; 22<br>206.0.71.128&#x2F;25（四系） 与目的地址匹配长度 &#x3D; 25<br>根据最长匹配原则，查找路由表中第二项</p>
</blockquote>
<p><img src="https://mark.cuckooing.cn/pics/pic_d8737b30.png" alt="pic_d8737b30.png"></p>
<h5 id="第四阶段-1994：NAT（地址转换）"><a href="#第四阶段-1994：NAT（地址转换）" class="headerlink" title="第四阶段 1994：NAT（地址转换）"></a>第四阶段 1994：NAT（地址转换）</h5><p>需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球地址IP。所有使用本地地址的主机在和外界通信时都要在NAT路由器上将本地地址转化成IP地址才能和因特网连接。</p>
<ul>
<li>专用&#x2F;私有地址（RFC1918定义一系列私有地址）为只用于机构内部的网络或主机IP。Internet中的路由器不转发目的地址为私有地址的IP数据报<br>10.0.0.0 ~ 10.255.255.255（CIDR：10.0&#x2F;8）<br>172.16.0.0 ~ 172.31.255.255（CIDR：172.16&#x2F;12）<br>192.168.0.0 ~ 192.168.255.255（CIDR：192.168&#x2F;16）</li>
<li>公有地址：全网唯一IP地址，向ISP&#x2F;注册中心申请，由因特网分配。</li>
</ul>
<p>通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。</p>
<ul>
<li>工作原理<br>借助于NAT，私有（保留）地址的”内部”网络通过路由器发送数据包时，私有地址被转换成合法的IP地址，一个局域网只需使用少量IP地址（甚至是1个）即可实现私有地址网络内所有计算机与Internet的通信需求。<br>（1）内部主机ClientA用本地地址192.168.1.2和因特网主机202.20.65.4通信所发送数据报必须经过NAT路由器<br>（2）NAT路由器将数据报源地址192.168.1.2转换成全球地址202.20.65.2，目的地址保持不变，然后发送到因特网。<br>（3）NAT路由器收到因特网主机发回的数据报时，知道数据报中源地址是202.20.65.4，目的地址是202.20.65.2<br>（4）根据NAT转换表，NAT路由器将目的地址202.20.65.2转换为192.168.1.2，并转发给最终的内部主机ClientA<br><img src="https://mark.cuckooing.cn/pics/pic_0fe9f33c.png" alt="pic_0fe9f33c.png"></li>
<li>IPv6<br>从计算机本身发展以及从因特网规模和网络传输速率来看，IPv4已不适用。最主要的问题就是32位的IP地址不够用。因此采用具有更大地址控件的新版本IP协议IPv6解决这个问题。（无类别编址CIDR、网络转换协议NAT也可解决地址耗尽问题）<br>IPv6的地址长度为128位，是IPv4地址长度的4倍，首部长度位固定40字节。于是IPv4点分十进制格式不再适用，采用十六进制表示。</li>
</ul>
<h3 id="相关协议"><a href="#相关协议" class="headerlink" title="相关协议"></a>相关协议</h3><h4 id="ARP-地址解析协议（Adress-Resolution-Protocol）"><a href="#ARP-地址解析协议（Adress-Resolution-Protocol）" class="headerlink" title="ARP 地址解析协议（Adress Resolution Protocol）"></a>ARP 地址解析协议（Adress Resolution Protocol）</h4><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。在实际网络的链路上传送数据帧时，最终使用硬件地址。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。<br>ARP 实现由 IP 地址得到 MAC 地址。RARP实现由MAC地址得到IP地址。<br>实现（同一个局域网上路由器&#x2F;主机）IP地址和MAC地址转换。</p>
<blockquote>
<p>如果目的主机和源主机不在同一个局域网，应该通过ARP找到一个位于本局域网上某个路由器的硬件地址，通过分组发送给这个路由器，让这个路由器将分组转发给下一个网络。此时目的主机不变，源主机为该路由器的硬件地址，剩下工作交给下一个网络链路层处理。</p>
</blockquote>
<p><img src="https://mark.cuckooing.cn/pics/pic_8480a5c7.png" alt="pic_8480a5c7.png"><br>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。<br>如果主机 A 知道主机 B 的 IP 地址。查找ARP 高速缓存中有没有该 IP 地址到 MAC 地址的映射<br>（1）如果有，查找出对应的MAC地址，并将该硬件地址写入MAC帧，就可以通过局域网将该MAC帧发送到此硬件地址。<br>（2）如果没有，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会通过单播的方式发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。<br><img src="https://mark.cuckooing.cn/pics/pic_e3ea020d.png" alt="pic_e3ea020d.png"></p>
<h4 id="DHCP-动态主机设置协议（Dynamic-Host-Configuration-Protocol）"><a href="#DHCP-动态主机设置协议（Dynamic-Host-Configuration-Protocol）" class="headerlink" title="DHCP 动态主机设置协议（Dynamic Host Configuration Protocol）"></a>DHCP 动态主机设置协议（Dynamic Host Configuration Protocol）</h4><p>动态主机配置协议DHCP提供即插即用连网机制。允许一台计算机加入新的网络和获取IP地址而不用手工参与。</p>
<ul>
<li>DHCP使用客户服务器方式，使用UDP传输数据<br>（1）需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文（DHCPDISCOVER），这时主机就称为DHCP客户<br>（2）本地网络上所有主机都能收到此广播报文，但只有DHCP服务器才能回答此广播报文。<br>（3）DHCP服务器先在其数据库中查找该计算机的配置，若找到，则返回找到的信息。若找不到则从IP 地址池（address pool）中取出一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCPOFFER）<br>（4）DHCP客户 会检查得到的IP信息是否完整并发送广播DHCPREQUEST通知DHCP服务器已获得IP地址<br>（5）DHCP服务端发送广播DHCPACK确认客户的请求，表示分配成功<br><img src="https://mark.cuckooing.cn/pics/pic_0d21b8ad.png" alt="pic_0d21b8ad.png"><br>DHCP服务器分配给DHCP客户的IP地址是临时的，因此DHCP客户只能在一段有限的时间使用这个分配到的IP地址。这段有限的时间称为租用期。</li>
</ul>
<h4 id="ICMP-网络控制报文协议（Internet-Control-Message-Protocol）"><a href="#ICMP-网络控制报文协议（Internet-Control-Message-Protocol）" class="headerlink" title="ICMP 网络控制报文协议（Internet Control Message Protocol）"></a>ICMP 网络控制报文协议（Internet Control Message Protocol）</h4><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。ICMP允许主机活路由器报告差错情况和提供异常情况的报告。它作为IP数据报的数据，加上数据报的首部，封装在 IP 数据报中，不属于高层协议。<br><img src="https://mark.cuckooing.cn/pics/pic_c8d57687.png" alt="pic_c8d57687.png"><br>ICMP 报文分为差错报告报文和询问报文。<br><img src="https://mark.cuckooing.cn/pics/pic_e76364e5.png" alt="pic_e76364e5.png"><br>（1）Ping<br>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。<br>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。<br>（2）Traceroute<br>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<h4 id="VPN-虚拟专用网"><a href="#VPN-虚拟专用网" class="headerlink" title="VPN 虚拟专用网"></a>VPN 虚拟专用网</h4><p>VPN 可以使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p>
<ul>
<li>专用地址<br>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。<br>有三个专用地址块：<br>10.0.0.0 ~ 10.255.255.255<br>172.16.0.0 ~ 172.31.255.255<br>192.168.0.0 ~ 192.168.255.255</li>
<li>VPN 机制<br>VPN通过在公用网络上建立专用网络，进行加密通讯。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN可通过服务器、硬件、软件等多种方式实现。<br>例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。<br>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。<br><img src="https://mark.cuckooing.cn/pics/pic_a571bdf9.png" alt="pic_a571bdf9.png"></li>
</ul>
<h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。<br>自治系统（AS）：一个自治系统(AS)是一个有权自主地决定在本系统中应采用何种路由协议的小型单位。这个网络单位可以是一个简单的网络也可以是一个由一个或多个普通的网络管理员来控制的网络群体，它是一个单独的可管理的网络单元（例如一所大学，一个企业或者一个公司个体）。一个自治系统有时也被称为是一个路由选择域（routing domain）。</p>
<h4 id="内部网关协议IGP（RIP、OSPF）"><a href="#内部网关协议IGP（RIP、OSPF）" class="headerlink" title="内部网关协议IGP（RIP、OSPF）"></a>内部网关协议IGP（RIP、OSPF）</h4><ul>
<li>RIP<br>RIP 是一种基于距离向量的路由选择协议，要求网络中每一个路由器都要维护从自己到其他每一个目的网络的距离记录。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。<br>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表全部信息，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。<br>RIP认为一个好的路由就是通过的路由器数目少，即距离短。<br>距离向量算法：<br>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；<br>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<br>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；<br>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。<br>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。<br>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。且有”坏消息传播慢”这一问题。</li>
<li>ODPF<br>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。<br>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。<br>OSPF 具有以下特点：<br>（1）向本自治系统中的所有路由器发送信息，这种方法是洪泛法。<br>（2）发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。<br>（3）只有当链路状态发生变化时，路由器才会发送信息。<br>（4）所有路由器都具有全网的拓扑结构图，并且是一致的（链路状态数据库的同步）。相比于 RIP，OSPF 的更新过程收敛的很快。</li>
</ul>
<h4 id="外部网关协议EGP（BGP）"><a href="#外部网关协议EGP（BGP）" class="headerlink" title="外部网关协议EGP（BGP）"></a>外部网关协议EGP（BGP）</h4><ul>
<li>BGP<br>BGP（Border Gateway Protocol，边界网关协议）<br>AS 之间的路由选择很困难，主要是由于：<br>（1）互联网规模很大；<br>（2）各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；<br>（3）AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。<br>BGP 只能寻找一条比较好的路由，而不是最佳路由。<br>每个 AS 都必须配置至少一个 BGP 发言人，两个BGP发言人都是通过一个共享网络连接在一起的，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息（使用TCP连接能提供可靠服务，保证数据可达）<br><img src="https://mark.cuckooing.cn/pics/pic_2a95bc35.png" alt="pic_2a95bc35.png"></li>
</ul>
<h3 id="网络层设备：路由器"><a href="#网络层设备：路由器" class="headerlink" title="网络层设备：路由器"></a>网络层设备：路由器</h3><p>路由器的组成与功能<br>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是路由选择和转发分组。</p>
<ul>
<li>转发<br>转发就是路由器根据路由&#x2F;转发表将用户的IP数据报从合适的端口转发出去。</li>
<li>路由选择<br>按照分布式算法根据从各相邻的路由器得到关于网络拓扑的变化情况，动态地改变所选择地路由。路由表是根据李由选择算法得出地。<br><img src="https://mark.cuckooing.cn/pics/pic_9ae23306.png" alt="pic_9ae23306.png"></li>
</ul>
<h2 id="四-传输层"><a href="#四-传输层" class="headerlink" title="四. 传输层"></a>四. 传输层</h2><p>传输层的目标是向应用层应用程序进程之间的通信，提供有效、可靠、保证质量的服务；<br>传输层在网络分层结构中起着承上启下的作用，通过执行传输层协议，屏蔽通信子网（信息传输）在技术、设计上的差异和服务质量的不足，向资源子网（信息处理）提供一个标准的、完善的通信服务；</p>
<blockquote>
<p>传输层提供端到端（主机的应用进程之间）的通信<br>网络层提供点到点（主机之间）的通信</p>
</blockquote>
<h3 id="传输层寻址-端口"><a href="#传输层寻址-端口" class="headerlink" title="传输层寻址 &amp;&amp; 端口"></a>传输层寻址 &amp;&amp; 端口</h3><p>端口用一个16位端口号进行标志，只具有本地意义，即端口号只是为了标志本计算机应用层中的各个进程，作为通信的终点。</p>
<h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP &amp;&amp; UDP"></a>TCP &amp;&amp; UDP</h3><h4 id="TCP-UDP-特点"><a href="#TCP-UDP-特点" class="headerlink" title="TCP&#x2F;UDP 特点"></a>TCP&#x2F;UDP 特点</h4><ul>
<li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li>
</ul>
<h4 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h4><ul>
<li>UDP 首部格式<br><img src="https://mark.cuckooing.cn/pics/pic_c901ca7e.png" alt="pic_c901ca7e.png"><br>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</li>
<li>TCP 首部格式<br><img src="https://mark.cuckooing.cn/pics/pic_18cce72b.png" alt="pic_18cce72b.png"><br>序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。<br>确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。<br>数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。<br>确认 ACK ：当 ACK&#x3D;1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。<br>同步 SYN ：在连接建立时用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN&#x3D;1，ACK&#x3D;1。<br>终止 FIN ：用来释放一个连接，当 FIN&#x3D;1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。<br>窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li>
</ul>
<h4 id="三次握手-四次挥手"><a href="#三次握手-四次挥手" class="headerlink" title="三次握手 &amp; 四次挥手"></a>三次握手 &amp; 四次挥手</h4><p>[第五章 网络 之 TCP&#x2F;IP][_ _ TCP_IP]</p>
<h4 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h4><h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。<br>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。<br>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。<br><img src="https://mark.cuckooing.cn/pics/pic_1424f829.png" alt="pic_1424f829.png"></p>
<h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。<br>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。<br><img src="https://mark.cuckooing.cn/pics/pic_c7ae4e9d.png" alt="pic_c7ae4e9d.png"><br>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。<br>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。<br>为了便于讨论，做如下假设：<br>接收方有足够大的接收缓存，因此不会发生流量控制；<br>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。<br><img src="https://mark.cuckooing.cn/pics/pic_e1fceacb.png" alt="pic_e1fceacb.png"></p>
<ul>
<li>慢开始与拥塞避免<br>发送的最初执行慢开始，令 cwnd &#x3D; 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …<br>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;&#x3D; ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。<br>如果出现了超时，则令 ssthresh &#x3D; cwnd &#x2F; 2，然后重新执行慢开始。</li>
<li>快重传与快恢复<br>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。<br>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。<br>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh &#x3D; cwnd &#x2F; 2 ，cwnd &#x3D; ssthresh，注意到此时直接进入拥塞避免。<br>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。<br><img src="https://mark.cuckooing.cn/pics/pic_7f47351d.png" alt="pic_7f47351d.png"></li>
</ul>
<h2 id="五-应用层"><a href="#五-应用层" class="headerlink" title="五. 应用层"></a>五. 应用层</h2><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><p>在网络应用层运行的应用程序之间通信方式可划分成两大类：</p>
<h4 id="C-S（客户端-服务器）方式"><a href="#C-S（客户端-服务器）方式" class="headerlink" title="C&#x2F;S（客户端&#x2F;服务器）方式"></a>C&#x2F;S（客户端&#x2F;服务器）方式</h4><p>客户client和服务器server都是指通信中所设计的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务的请求方，服务器是服务的提供方。</p>
<h4 id="P2P（peer-to-peer-对等）方式"><a href="#P2P（peer-to-peer-对等）方式" class="headerlink" title="P2P（peer to peer 对等）方式"></a>P2P（peer to peer 对等）方式</h4><p>对等连接是指两个主机在通信时并不区分哪一个是服务请求方，提供方。只要两个主机运行了对等连接软件，它们就可以进行平等的、对等连接通信。双方都可以下载对方已经存储在硬盘中的共享文档。</p>
<h3 id="相关协议-1"><a href="#相关协议-1" class="headerlink" title="相关协议"></a>相关协议</h3><h4 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h4><p>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用UDP端口53。<br>因特网采用层次结构的命名树作为主机的名字，并使用分布式域名系统DNS。<br>名字到IP地址的解析是由若干个域名服务器完成。域名服务器在专设的结点上运行，运行该程序的机器称为域名服务器。<br>DNS基于UDP协议实现：DNS的一个客户向本地域名服务器发送域名解析请求（UDP报文），其中包含待解析的域名，本地域名服务器在查找域名后，返回应答报文，其中包含对应的IP地址。</p>
<ul>
<li>层次域名空间</li>
<li>域名<br>因特网采用了层次树状结构的命名方法，任何一个连接在因特网上的主机活路由器，都有一个唯一的层次结构的名称，即域名。<br>域名的结构由标号序列组成，各标号分别代表不同层次的域名，每个层次只需要负责该层次级别的独立功能（层次之间相互独立），各标号之间用点隔开：<br><img src="https://mark.cuckooing.cn/pics/pic_48050285.png" alt="pic_48050285.png"></li>
<li>因特网的域名空间<br><img src="https://mark.cuckooing.cn/pics/pic_fa09395f.png" alt="pic_fa09395f.png"></li>
<li>域名服务器<br>树状结构的DNS域名服务器<br><img src="https://mark.cuckooing.cn/pics/pic_54d9e05b.png" alt="pic_54d9e05b.png"><br>域名服务器四种类型<br>（1）根域名服务器：13个（A~M）。在使用迭代查询时，根域名服务器把下一步应当查找的顶级域名服务器的IP地址告诉本地域名服务器。<br>（2）顶级域名服务器：负责顶级域名和所有国家域名。<br>（3）权威DNS服务器：在因特网上具有公共可访问主机（如Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。<br>当一个权威域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的DNS客户，下一步应该查找哪一个权威域名服务器。多数大学、企业实现和维护他们自己的权威DNS服务器。<br>（4）本地域名服务器：当一个主机发出DNS查询请求时，这个查询报文就发送给本地域名服务器。</li>
<li>域名解析过程<br>主机向本地域名服务器的查询一般采用递归查询。如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文。<br>本地域名服务器向根&#x2F;顶级&#x2F;权威域名服务器的查询通常是采用迭代查询。当根域名服务器收到本地域名服务器查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个域名服务器进行查询，然后让本地域名服务器进行后续查询。<br><img src="https://mark.cuckooing.cn/pics/pic_1c6af33a.png" alt="pic_1c6af33a.png"></li>
</ul>
<h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><p>文件传送协议FTP只提供文件传送的一些基本的服务，它使用TCP可靠的运输服务。FTP的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。<br>FTP使用客户服务器方式。一个FTP服务器进程可同时为多个客户进程提供服务。FTP的服务器进程由两大部分组成：一个主进程，负责接收新的请求；另外有若干个从属进程，负责处理单个请求。<br>FTP 两个连接</p>
<ul>
<li>控制连接（20端口）<br>当用户主机与远程主机开始一个FTP会话前，FTP的客户机端（用户）在21端口发起一个用于控制的与服务器（远程主机）的TCP连接。<br>控制连接在整个会话期间一直保持打开，FTP客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用于传送文件。</li>
<li>数据连接（21端口）<br>当FTP服务器端从该连接上收到一个文件传输的命令后，就发起20端口到客户机的数据连接。数据连接用于传输文件。FTP在该数据连接上准确地传送一个文件并关闭连接。</li>
</ul>
<h4 id="电子邮件（SMTP、POP3、IMAP）"><a href="#电子邮件（SMTP、POP3、IMAP）" class="headerlink" title="电子邮件（SMTP、POP3、IMAP）"></a>电子邮件（SMTP、POP3、IMAP）</h4><p>电子邮件系统的组成结构<br><img src="https://mark.cuckooing.cn/pics/pic_1c68b11a.png" alt="pic_1c68b11a.png"><br>（1）用户代理（UA）<br>用户与电子邮件系统的接口，是电子邮件客户端软件。用户代理的功能：撰写、显示、处理和通信。<br>（2）邮件服务器（MS）<br>发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）。邮件服务器按照客户&#x2F;服务器方式工作。邮件服务器需要使用发送和读取两个不同协议。</p>
<ul>
<li>发送邮件协议：SMTP<br>使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件，也用来将邮件从发送方的用户代理传送到发送方的邮件服务器。限制邮件报文主体部分只能采用简单的7位ASCII码表示。<br>为发送非ASCII文本的内容，发送方的用户代理可在报文中使用附加的首部行，即多用途因特网邮件扩展（MIME）<br>MIME 在其邮件首部说明了邮件数据类型（如文本、声音、图像、视频等），使用MIME可在邮件中同时传送多种类型的数据。</li>
<li>读取邮件协议：POP3<br>POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件。</li>
<li>读取邮件服务器：IMAP<br>IMAP全称是Internet Mail Access Protocol，即交互式邮件存取协议，它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。</li>
<li>POP3与IMAP区别<br>POP3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。<br>而IMAP提供webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。<br><img src="https://mark.cuckooing.cn/pics/pic_494a404e.png" alt="pic_494a404e.png"><br>总之，IMAP 整体上为用户带来更为便捷和可靠的体验。POP3 更易丢失邮件或多次下载相同的邮件，但 IMAP 通过邮件客户端与webmail 之间的双向同步功能很好地避免了这些问题。</li>
</ul>
<h4 id="WWW（HTTP）"><a href="#WWW（HTTP）" class="headerlink" title="WWW（HTTP）"></a>WWW（HTTP）</h4><ul>
<li>万维网<br>万维网以客户服务器方式工作。<br>浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，这个计算机也称为万维网服务器。<br>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所需要的万维网文档。在一个客户程序主窗口上显示出的万维网文档称为页面（page）。<br>万维网使用统一资源定位符URL来标志万维网上的各种文档，使每一个文档在整个因特网的范围具有唯一的标识符URL。</li>
<li>HTTP<br>Web的应用层协议是超文本传输协议HTTP。定义了HTTP报文的格式以及客户端服务器如何进行报文交换。<br><img src="https://mark.cuckooing.cn/pics/pic_baa7a88c.png" alt="pic_baa7a88c.png"><br>用户点击鼠标后发生的事件<br><img src="https://mark.cuckooing.cn/pics/pic_43cb1c87.png" alt="pic_43cb1c87.png"></li>
</ul>
<h4 id="Telent"><a href="#Telent" class="headerlink" title="Telent"></a>Telent</h4><p>Telnet协议是TCP&#x2F;IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。</p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><h3 id="MAC-IP地址-作用？"><a href="#MAC-IP地址-作用？" class="headerlink" title="MAC &#x2F; IP地址 &amp; 作用？"></a>MAC &#x2F; IP地址 &amp; 作用？</h3><ul>
<li>mac地址 &amp; ip地址？</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>mac地址</th> 
   <th>ip地址</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>定义</td> 
   <td>物理/硬件地址，由网络设备制造商生产时写在硬件内部</td> 
   <td>网络地址</td> 
  </tr> 
  <tr> 
   <td>格式</td> 
   <td>08:00:20:0A:8C:6D<br>长度为48位（6个字节），通常表示为12个16进制数，每2个16进制数之间用冒号隔开</td> 
   <td>192.168.0.1<br>长度为32位。用点分隔开的4个8八位组构成</td> 
  </tr> 
  <tr> 
   <td>组成</td> 
   <td>前6位16进制数08:00:20代表网络硬件制造商的编号，它由IEEE分配，而后3位16进制数0A:8C:6D代表该制造商所制造的某个网络产品（如网卡）的系列号</td> 
   <td>IP地址由网络地址和主机地址两部分组成，分配给这两部分的位数随地址类（A类、B类、C类等）的不同而不同。网络地址用于路由选择，而主机地址用于在网络或子网内部寻找一个单独的主机</td> 
  </tr> 
  <tr> 
   <td>所属层</td> 
   <td>数据链路层</td> 
   <td>网络层</td> 
  </tr> 
  <tr> 
   <td>说明</td> 
   <td>每个网络制造商必须确保它所制造的每个以太网设备都具有相同的前三个字节以及不同的后三个字节。这样就可保证世界上每个以太网设备都具有唯一的MAC地址。MAC地址与网络无关。</td> 
   <td>IP地址只是逻辑上的标识，用于路由器将数据从源地址传送到目的地址。会根据网络而变化，也可以被用户任意修改</td> 
  </tr> 
 </tbody> 
</table>

<ul>
<li>MAC地址的作用？</li>
<li>既然每个以太网设备在出厂时都有一个唯一的MAC地址了，那为什么还需要为每台主机再分配一个IP地址呢？&#x3D;&gt; IP地址作用？<br>（1）IP地址的分配是根据网络的拓朴结构，而不是根据谁制造了网络设置。若将高效的路由选择方案建立在设备制造商的基础上而不是网络所处的拓朴位置基础上，这种方案是不可行的。<br>（2）当存在一个附加层的地址寻址时，设备更易于移动和维修。例如，如果一个以太网卡坏了，可以被更换，而无须取得一个新的IP地址。如果一个IP主机从一个网络移到另一个网络，可以给它一个新的IP地址，而无须换一个新的网卡。</li>
<li>为什么每台主机都分配唯一的IP地址了，为什么还要在网络设备（如网卡，集线器，路由器等）生产时内嵌一个唯一的MAC地址呢？&#x3D;&gt; mac地址作用？<br>这是由组网方式决定的，如今比较流行的接入Internet的方式（也是未来发展的方向）是把主机通过局域网组织在一起，然后再通过交换机和 Internet相连接。这样一来就出现了如何区分具体用户，防止盗用的问题。由于IP只是逻辑上标识，任何人都随意修改，因此不能用来标识用户；而 MAC地址则不然，它是固化在网卡里面的。<br>基于MAC地址的这种特点，局域网采用了用MAC地址来标识具体用户的方法。</li>
<li>因此计算机的通信，需要 MAC地址 与 IP地址 结合 传送数据包<br>无论是局域网，还是广域网中的计算机之间的通信，最终都表现为将数据包从某种形式的链路上的初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的移动都是由ARP（Address Resolution Protocol：地址解析协议）负责将IP地址映射到MAC地址上来完成的（交换机内部通过”表”将MAC地址与IP地址一一对应实现绑定）。<br>假设网络上要将一个数据包（名为PAC）由临沭的一台主机（名称为A，IP地址为IP_A，MAC地址为MAC_A）发送到北京的一台主机（名称为B，IP地址为IP_B，MAC地址为MAC_B）。这两台主机之间不可能是直接连接起来的，因而数据包在传递时必然要经过许多中间节点（如路由器，服务器等等），我们假定在传输过程中要经过C1、C2、C3（其MAC地址分别为M1，M2，M3）三个节点。<br>A在将PAC发出之前，先发送一个 ARP（Address Resolution Protocol：地址解析协议）请求，找到其要到达IP_B所必须经历的第一个中间节点C1的MAC地址M1，然后在其数据包中封装（Encapsulation）这些地址： IP_A、IP_B，MAC_A和M1。当PAC传到C1后，再由ARP根据其目的IP地址IP_B，找到其要经历的第二个中间节点C2的MAC地址 M2，然后再将带有M2的数据包传送到C2。如此类推，直到最后找到带有IP地址为IP_B的B主机的地址MAC_B，最终传送给主机B。在传输过程中， IP_A、IP_B和MAC_A不变，而中间节点的MAC地址通过ARP在不断改变（M1，M2，M3），直至目的地址MAC_B。<br>具体的通信方式：接收过程，当有发给本地局域网内一台主机的数据包时，交换机接收下来，然后把数据包中的IP地址按照“表”中的对应关系映射成MAC地址，转发到对应的MAC地址的主机上，这样一来，即使某台主机盗用了这个IP地址，但由于他没有这个MAC地址，因此也不会收到数据包。</li>
</ul>
<h3 id="描述一次网络请求的流程-浏览器访问一个url网址所经历的过程？"><a href="#描述一次网络请求的流程-浏览器访问一个url网址所经历的过程？" class="headerlink" title="描述一次网络请求的流程&#x2F;浏览器访问一个url网址所经历的过程？"></a>描述一次网络请求的流程&#x2F;浏览器访问一个url网址所经历的过程？</h3><ol>
<li>域名解析（DNS查找）</li>
<li>建立TCP连接（TCP的三次握手和四次挥手）</li>
<li>建立TCP连接后客户端向服务端发起HTTP请求（HTTP请求报文：请求行、请求头、空行、消息体）</li>
<li>服务器接受并处理请求，并返回HTTP响应消息，HTTP响应报文的消息体为服务端返回给客户端的HTML文本内容（或其他格式数据）（HTTP响应报文：状态行、响应头、空行、消息体）</li>
<li>浏览器解析HTML代码，同时请求HTML代码中的静态资源（如js、css、图片等）<br>遇到js&#x2F;css&#x2F;image等静态资源时，向服务器端发起一个HTTP请求，如果服务器端返回304状态码（告诉浏览器服务器端没有修改该资源），那么浏览器会直接读取本地的该资源的缓存文件。否则开启新线程向服务器端去请求下载。（这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源。）</li>
<li>最后浏览器使用请求到的静态资源和HTML代码对页面进行渲染并呈现给用户</li>
</ol>
<h3 id="什么是DNS？作用是什么？工作机制？"><a href="#什么是DNS？作用是什么？工作机制？" class="headerlink" title="什么是DNS？作用是什么？工作机制？"></a>什么是DNS？作用是什么？工作机制？</h3><p>DNS（Domain Name System）域名系统，用于进行域名解析的服务器，即进行域名与IP地址转换。<br>DNS查询过程<br>以查询 zh.wikipedia.org 为例：</p>
<ul>
<li>输入域名”zh.wikipedia.org”，操作系统会先检查自己的本地hosts文件是否有这个网址映射关系。如果hosts没有这个域名的映射，则查询本地DNS解析器缓存。如果hosts与本地DNS服务器缓存都没有相应的网址映射关系，首先会找TCP&#x2F;IP参数中设置的首选DNS服务器。</li>
<li>客户端发送查询报文”query zh.wikipedia.org”至DNS服务器，DNS服务器首先检查自身缓存，如果存在记录则直接返回结果。</li>
<li>如果记录老化或不存在，则：</li>
</ul>
<ol>
<li>DNS服务器向根域名服务器发送查询报文”query zh.wikipedia.org”，根域名服务器返回顶级域.org 的权威域名服务器地址。</li>
<li>DNS服务器向 .org 域的权威域名服务器发送查询报文”query zh.wikipedia.org”，得到二级域.wikipedia.org 的权威域名服务器地址。</li>
<li>DNS服务器向 .wikipedia.org 域的权威域名服务器发送查询报文”query zh.wikipedia.org”，得到主机 zh 的A记录，存入自身缓存并返回给客户端。<br>从上图可以知道，客户端到本地DNS服务器是属于递归查询（只发送一次请求，得到一次准确结果（消耗资源）），而DNS服务器之间的交互查询就是迭代查询（发送多次请求，得到参考结果）<br><img src="https://mark.cuckooing.cn/pics/pic_099b6424.png" alt="pic_099b6424.png"></li>
</ol>
<h1 id="第五章-网络-之-TCP-IP"><a href="#第五章-网络-之-TCP-IP" class="headerlink" title="第五章 网络 之 TCP&#x2F;IP"></a>第五章 网络 之 TCP&#x2F;IP</h1><ul>
<li>TCP</li>
<li><ul>
<li>什么是TCP协议？UDP协议？它们的区别？</li>
<li>说一下TCP&#x2F;IP三次握手，四次挥手的具体细节？</li>
</ul>
</li>
<li>HTTP</li>
<li><ul>
<li>描述一下HTTP协议？</li>
<li>HTTP请求&#x2F;响应报文？</li>
<li><ul>
<li>HTTP方法？（请求报文）</li>
<li><ul>
<li>面试：POST与GET区别？</li>
</ul>
</li>
<li>HTTP状态码？（响应报文）</li>
<li>HTTP首部？（请求 &amp; 响应首部常用字段）</li>
</ul>
</li>
<li>HTTP 缓存机制？</li>
<li>浏览器缓存机制：cookie&#x2F;session</li>
<li>HTTP1.0 &amp; HTTP1.x &amp; HTTP2.0区别是什么？</li>
</ul>
</li>
<li>HTTPS</li>
<li><ul>
<li>描述一下HTTPS？</li>
<li>HTTPS 工作原理 &#x2F; 连接 &amp; 通信过程？</li>
<li>HTTPS与HTTP区别？</li>
<li>对称加密 &amp; 非对称加密？</li>
</ul>
</li>
<li>Socket</li>
<li><ul>
<li>描述一下Socket?</li>
<li>Socket 通信模型 &#x2F; 原理 &#x2F; 连接过程？</li>
<li>Socket 使用？</li>
<li>描述一下WebSocket？</li>
<li>Socket &amp; WebSocket &amp; HTTP 对比？</li>
</ul>
</li>
<li>数据传输格式</li>
<li><ul>
<li>序列化</li>
<li>JSON、XML 解析方式</li>
</ul>
</li>
<li>Andorid 网络基础</li>
<li><ul>
<li>HttpClient &amp; HttpURLConnection][HttpClient _ HttpURLConnection</li>
</ul>
</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="什么是TCP协议？UDP协议？它们的区别？"><a href="#什么是TCP协议？UDP协议？它们的区别？" class="headerlink" title="什么是TCP协议？UDP协议？它们的区别？"></a>什么是TCP协议？UDP协议？它们的区别？</h3><p>TCP&#x2F;UDP协议为传输层协议，传输层用于向用户提供可靠的端到端（每个进程都用一个端口号唯一标识）的通信，通过提供流量控制和差错控制保证报文的正确传输。<br>传输单位是报文段或用户数据报。<br>主要协议包括TCP协议和UDP协议。</p>
<table> 
 <thead> 
  <tr> 
   <th>协议</th> 
   <th>TCP协议</th> 
   <th>UDP协议</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>简介</td> 
   <td>面向连接的、可靠的传输层协议。传输的数据无差错、不丢失、不重复、按序到达（有流量控制、拥塞控制、提供全双工通信）</td> 
   <td>无连接的、不可靠的传输层协议。尽最大努力交付，不保证可靠性</td> 
  </tr> 
  <tr> 
   <td>连接</td> 
   <td>面向连接（发送数据前三次握手建立连接，发送结束四次挥手释放连接）</td> 
   <td>无连接的</td> 
  </tr> 
  <tr> 
   <td>传输数据</td> 
   <td>面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）</td> 
   <td>面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）</td> 
  </tr> 
  <tr> 
   <td>交互</td> 
   <td>点对点（一对一）</td> 
   <td>一对一，一对多，多对多</td> 
  </tr> 
  <tr> 
   <td>大小</td> 
   <td>TCP首部（开销20字节，包括源端口号、目的端口号等以及确认ACK、同步SYN、终止FIN等用于连接建立与数据传输）+TCP数据部分</td> 
   <td>UDP首部开销8字节（包括源端口号、目的端口号等）+UDP数据部分</td> 
  </tr> 
  <tr> 
   <td>适用情景</td> 
   <td>TCP用于在传输层有必要实现可靠传输的情景</td> 
   <td>UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信：1.包总量较少的通信（DNS、SNMP等）2.视频、音频等多媒体通信（即时通信）3.限定于LAN等特定网络中的应用通信4.广播通信（广播、多播）</td> 
  </tr> 
  <tr> 
   <td>传输</td> 
   <td>可靠传输：<br>（1）传输信道无差错，保证传输数据正确；<br>（2）不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据；<br>可靠性原理：<br>（1）使用三次握手建立TCP连接，四次握手释放TCP连接，保证建立的传输信道是可靠的。<br>（2）使用连续ARQ协议（超时自动重传：如果一个已经发送的报文段在超时时间内没没有收到确认，那么就重传这个报文段）来保证数据传输的正确性，<br>（3）使用滑动窗口协议来保证接收方能够及时处理所接收到的数据，进行流量控制<br>（4）使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞</td> 
   <td>不可靠传输：<br>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务<br>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。<br>即使是出现网络拥堵的情况，UDP也无法进行流量控制等避免网络拥塞行为。<br>此外传输途中出现丢包，UDP也不负责重发（发送后不管其是否会到达接收方）。甚至当包的到达顺序出现乱序也没有纠正的功能。<br>如果需要以上的细节控制，不得不交由采用UDP的应用程序去处理。</td> 
  </tr> 
  <tr> 
   <td>协议</td> 
   <td>FTP、HTTP、POP3、TELNET…</td> 
   <td>SMTP（网络管理）、DNS（域名转换）、TFTP（文件传输）、NFS（远程文件服务器）、DHCP…</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="说一下TCP-IP三次握手，四次挥手的具体细节？"><a href="#说一下TCP-IP三次握手，四次挥手的具体细节？" class="headerlink" title="说一下TCP&#x2F;IP三次握手，四次挥手的具体细节？"></a>说一下TCP&#x2F;IP三次握手，四次挥手的具体细节？</h3><ol>
<li>报文段标识符</li>
</ol>
<ul>
<li>确认ACK ：TCP协议规定只有ACK&#x3D;1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</li>
<li>同步SYN：在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN&#x3D;1和ACK&#x3D;1，因此SYN置1就表示这是一个连接请求或连接接受报文。</li>
<li>终止FIN：用来释放一个连接。当 FIN &#x3D; 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</li>
<li>序号seq：用于对字节流进行编号。例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li>
<li>确认号ack：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li>
</ul>
<ol>
<li>三次握手<br>最初两端的TCP进程都处于CLOSED关闭状态，Client（A）主动打开连接，而Server（B）处于LISTEN（监听状态），等待A的连接请求并被动打开连接（由客户端执行connect触发）。</li>
</ol>
<ul>
<li>第一次握手：由Client发出请求连接数据包： SYN&#x3D;1 ACK&#x3D;0 seq&#x3D;x（TCP规定SYN&#x3D;1时不能携带数据，但要消耗一个序号，因此声明自己的序号是 seq&#x3D;x）此时Client进入SYN-SENT（同步已发送）状态，等待Server确认；</li>
<li>第二次握手：Server收到请求报文后，如果统一建立连接，则向A发送连接确认报文，即 SYN&#x3D;1 ACK&#x3D;1 seq&#x3D;y，ack&#x3D;x+1，此时Server进入SYN-RCVD（同步收到）状态；</li>
<li>第三次握手：Client收到Server的确认（SYN+ACK）后，向Server发出确认报文段，即 ACK&#x3D;1，seq&#x3D;x+1， ack&#x3D;y+1，TCP连接已经建立，Client进入ESTABLISHED（已建立连接）状态；<br>Server收到Client的确认后，也进入ESTABLISHED状态，完成三次握手；此时Client和Server可以开始传输数据。<br><img src="https://mark.cuckooing.cn/pics/pic_e33bdd5b.png" alt="pic_e33bdd5b.png"><br>（理解版）<br>我们假设A和B是通信的双方。我理解的握手实际上就是通信，发一次信息就是进行一次握手。则对于三次握手：<br>第一次握手： A给B打电话说，你可以听到我说话吗？<br>第二次握手： B收到了A的信息，然后对A说： 我可以听得到你说话啊，你能听得到我说话吗？<br>第三次握手： A收到了B的信息，然后说可以的，我要给你发信息啦！<br>在三次握手之后，A和B都能确定这么一件事： 我说的话，你能听到； 你说的话，我也能听到。 这样，就可以开始正常通信了。<br>如果两次，那么B无法确定B的信息A是否能收到，所以如果B先说话，可能后面的A都收不到，会出现问题 。<br>如果四次，那么就造成了浪费，因为在三次结束之后，就已经可以保证A可以给B发信息，A可以收到B的信息； B可以给A发信息，B可以收到A的信息。</li>
</ul>
<ol>
<li>四次挥手<br>数据传输结束后，通信的双方都可释放连接，A和B都处于ESTABLISHED状态。当Client没有数据再需要发送给服务端时，就需要释放客户端的连接，整个过程为：</li>
</ol>
<ul>
<li>第一次挥手：当Client发起终止连接请求的时候，会发送一个（FIN为1,seq&#x3D;u）的没有数据的报文，这时Client停止发送数据（但仍可以接受数据） ，进入FIN_WAIT1（终止等待1）状态，等待Server确认</li>
<li>第二次挥手：Server收到连接释放报文后会给Client一个确认报文段（ACK&#x3D;1,ack&#x3D;u+1,seq&#x3D;v）， 进入CLOSE-WAIT（关闭等待）状态<br>Client收到Server的确认后进入FIN_WAIT2状态，等待Server请求释放连接，Server仍可向Client发送数据。</li>
<li>第三次挥手：Server数据发送完成后，向Client发起请求连接释放报文（FIN&#x3D;1,ACK&#x3D;1,seq&#x3D;w,ack &#x3D; u+1）,Server进入LAST-ACK（最后确认）状态，等待Client确认</li>
<li>第四次挥手：Client收到连接释放报文段后，回复一个确认报文段（ACK&#x3D;1,seq&#x3D;u+1,ack&#x3D;w+1），进入 TIME_WAIT（时间等待） 状态，Server收到后进入CLOSED（连接关闭）状态。经过等待2MSL 时间（最大报文生存时间），Client进入CLOSED状态。<br><img src="https://mark.cuckooing.cn/pics/pic_db69222d.png" alt="pic_db69222d.png"><br>（理解版）<br>A:“喂，我不说了 (FIN)。”A-&gt;FIN_WAIT1<br>B:“我知道了(ACK)。等下，上一句还没说完。Balabala……（传输数据）”B-&gt;CLOSE_WAIT | A-&gt;FIN_WAIT2<br>B:”好了，说完了，我也不说了（FIN）。”B-&gt;LAST_ACK<br>A:”我知道了（ACK）。”A-&gt;TIME_WAIT | B-&gt;CLOSED<br>A等待2MSL,保证B收到了消息,否则重说一次”我知道了”,A-&gt;CLOSED<br>这样，通过四次挥手，可以把该说的话都说完，并且A和B都知道自己没话说了，对方也没花说了，然后就挂掉电话（断开链接）了 。</li>
</ul>
<ol>
<li>面试问题</li>
</ol>
<ul>
<li>为什么需要握手？<br>这里就引出了 TCP 与 UDP 的一个基本区别， TCP 是可靠通信协议， 而 UDP 是不可靠通信协议。<br>TCP 的可靠性含义： 接收方收到的数据是完整， 有序， 无差错的。<br>UDP 不可靠性含义： 接收方接收到的数据可能存在部分丢失， 顺序也不一定能保证。<br>UDP 和 TCP 协议都是基于同样的互联网基础设施， 且都基于 IP 协议实现， 互联网基础设施中对于数据包的发送过程是会发生丢包现象的， 为什么 TCP 就可以实现可靠传输， 而 UDP 不行？</li>
<li>为什么需要三次握手？<br>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。<br>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</li>
<li>为什么需要四次挥手？<br>为了让服务器发送还未传送完毕的数据。只有传送完毕后，服务器会发送FIN连接释放报文。<br>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET（服务端数据未传输完毕），FIN报文仅仅表示Client没有需要发送的数据，但是仍能接受数据，Server的数据未必全部发送出去，需要等待Server的数据发送完毕后发送FIN报文给Client才能表示同意关闭连接。<br>所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</li>
</ul>
<blockquote>
<p>建立连接时候ACK和SYN可以放在一个报文里发送给客户端。<br>连接关闭时ACK和FIN一般分开发送。</p>
</blockquote>
<ul>
<li>为什么A在TIME-WAIT状态必须等待2MSL的时间？<br>MSL最长报文段寿命Maximum Segment Lifetime，MSL&#x3D;2<br>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</li>
<li>保证A发送的最后一个ACK报文段能够到达B。<br>如果 B 没收到 A 发送来的确认报文（A发送的最后一个ACK报文段可能丢失），那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>防止“防止本次已失效的连接请求报文段出现在新的连接中。<br>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<ol>
<li>整体通信流程<br><img src="https://mark.cuckooing.cn/pics/pic_485aa4d3.png" alt="pic_485aa4d3.png"></li>
</ol>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="描述一下HTTP协议？"><a href="#描述一下HTTP协议？" class="headerlink" title="描述一下HTTP协议？"></a>描述一下HTTP协议？</h3><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从万维网（WWW）Web服务器 传输超文本到 本地客户浏览器 的传输协议。<br>在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。<br>HTTP协议特点：</p>
<ul>
<li>基于TCP&#x2F;IP通信协议传递数据（HTML、图片文件，查询结果等）</li>
<li>属于应用层协议</li>
<li>采用客户端-服务端（请求-响应 C&#x2F;S）工作方式，具体工作流程如下：<br><img src="https://mark.cuckooing.cn/pics/pic_4010b822.png" alt="pic_4010b822.png"></li>
</ul>
<h3 id="HTTP请求-响应报文？"><a href="#HTTP请求-响应报文？" class="headerlink" title="HTTP请求&#x2F;响应报文？"></a>HTTP请求&#x2F;响应报文？</h3><p>HTTP在应用层通过报文交互数据，分为请求报文和响应报文，分别用于发送请求&amp;响应请求。</p>
<ul>
<li>请求报文<br><img src="https://mark.cuckooing.cn/pics/pic_b056b10c.png" alt="pic_b056b10c.png"><br>如<br><img src="https://mark.cuckooing.cn/pics/pic_7e5e8585.png" alt="pic_7e5e8585.png"></li>
<li>响应报文<br><img src="https://mark.cuckooing.cn/pics/pic_6d165f29.png" alt="pic_6d165f29.png"><br>如<br><img src="https://mark.cuckooing.cn/pics/pic_9e3ac5ac.png" alt="pic_9e3ac5ac.png"></li>
</ul>
<h4 id="HTTP方法？（请求报文）"><a href="#HTTP方法？（请求报文）" class="headerlink" title="HTTP方法？（请求报文）"></a>HTTP方法？（请求报文）</h4><p>客户端发送的 请求报文 第一行为请求行，包含了方法字段。</p>
<table> 
 <thead> 
  <tr> 
   <th>请求方法</th> 
   <th>用法</th> 
   <th>说明</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>OPTIONS</td> 
   <td>返回服务器针对特定资源所支持的HTTP请求方法</td> 
   <td>返回：Allow: GET,POST,HEAD等</td> 
  </tr> 
  <tr> 
   <td>HEAD</td> 
   <td>获取报文首部</td> 
   <td>与GET方法类似，但不返回报文实体主体部分。用于确认URL的有效性以及资源更新日期时间等</td> 
  </tr> 
  <tr> 
   <td>GET</td> 
   <td>获取资源</td> 
   <td>当前网络请求中，绝大部分使用GET方法</td> 
  </tr> 
  <tr> 
   <td>POST</td> 
   <td>传输实体主体</td> 
   <td>向指定资源传输数据（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改</td> 
  </tr> 
  <tr> 
   <td>PUT</td> 
   <td>上传文件</td> 
   <td>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法<br> PUT /new.html HTTP/1.1</td> 
  </tr> 
  <tr> 
   <td>DELETE</td> 
   <td>删除文件</td> 
   <td>与 PUT 功能相反，并且同样不带验证机制<br>DELETE /file.html HTTP/1.1</td> 
  </tr> 
  <tr> 
   <td>TRACE</td> 
   <td>追踪路径</td> 
   <td>回显服务器收到的请求，主要用于测试或诊断。</td> 
  </tr> 
 </tbody> 
</table>

<h5 id="面试：POST与GET区别？"><a href="#面试：POST与GET区别？" class="headerlink" title="面试：POST与GET区别？"></a>面试：POST与GET区别？</h5><table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>GET提交</th> 
   <th>POST提交</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>作用</td> 
   <td>获取资源</td> 
   <td>传输实体数据</td> 
  </tr> 
  <tr> 
   <td>参数位置</td> 
   <td>附在URL之后（将数据放在HTTP请求行），以？代表URL结尾，多个参数用&amp;连接。例如：login.action?name=chy&amp;password=123</td> 
   <td>提交的数据放在HTTP报文的请求体中</td> 
  </tr> 
  <tr> 
   <td>参数长度</td> 
   <td>提交的数据大小有限制（因为浏览器对URL的长度有限制）</td> 
   <td>提交的数据没有限制（GET提交的数据会在地址栏中显示，而POST提交，地址不会改变）</td> 
  </tr> 
  <tr> 
   <td>参数形式</td> 
   <td>键值对形式（作为查询字符串）</td> 
   <td>表单形式，因此必须将Content-type设置为：application/x-www-form- urlencoded</td> 
  </tr> 
  <tr> 
   <td>参数类型</td> 
   <td>只允许ASCII字符</td> 
   <td>任何类型</td> 
  </tr> 
  <tr> 
   <td>安全性</td> 
   <td>安全性低<br>请求参数直接在URL上可见<br>报文可缓存在浏览器内</td> 
   <td>安全性高<br>请求参数在HTTP请求数据中<br>浏览器无缓存</td> 
  </tr> 
  <tr> 
   <td>应用场景</td> 
   <td>传递小量、不敏感的数据。用于从指定资源请求数据</td> 
   <td>传递大量、敏感数据。用于向指定资源提交数据</td> 
  </tr> 
  <tr> 
   <td>实例</td> 
   <td>GET /bookes/?name=chy&amp;password=123 HTTP/1.1<br> Host: www.wrox.com<br>User-Agent: Mozilla/5.0 Gecko/20050225<br>Connection: Keep-Alive</td> 
   <td>POST / HTTP/1.1<br>Host: www.wrox.com<br>User-Agent: Mozilla/5.0 Gecko/20050225<br>Content-type: application/x-www-form- urlencoded<br>Connection: Keep-Alive<br>name=chy&amp;password=123</td> 
  </tr> 
 </tbody> 
</table>

<h4 id="HTTP状态码？（响应报文）"><a href="#HTTP状态码？（响应报文）" class="headerlink" title="HTTP状态码？（响应报文）"></a>HTTP状态码？（响应报文）</h4><p>服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<table> 
 <thead> 
  <tr> 
   <th>状态码</th> 
   <th>类别</th> 
   <th>含义</th> 
   <th>常见类型</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>1xx</td> 
   <td>Informational（信息性状态码）</td> 
   <td>接收的请求正在处理</td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>2xx</td> 
   <td>Success（成功状态码）</td> 
   <td>请求正常处理完毕</td> 
   <td>200：OK</td> 
  </tr> 
  <tr> 
   <td>3xx</td> 
   <td>Redirection（重定向状态码）</td> 
   <td>需要进行附加操作以完成请求</td> 
   <td>304 Not Modified ：如果请求报文首部包含例如：If-None-Match，If-Modified-Since等HTTP缓存相关数据<br>当服务器数据未修改时，则返回304告知客户可以使用缓存数据</td> 
  </tr> 
  <tr> 
   <td>4xx</td> 
   <td>Client Error（客户端错误状态码）</td> 
   <td>服务器无法处理请求</td> 
   <td>400 Bad Request：请求报文出现语法错误<br>403 Forbidden：请求被拒绝<br>404 Not Found：没有找到服务器</td> 
  </tr> 
  <tr> 
   <td>5xx</td> 
   <td>Server Error（服务器错误状态码）</td> 
   <td>服务器处理请求出错</td> 
   <td>500 Internal Server Error：服务器正在执行请求时内部发生错误</td> 
  </tr> 
 </tbody> 
</table>

<h4 id="HTTP首部？（请求-响应首部常用字段）"><a href="#HTTP首部？（请求-响应首部常用字段）" class="headerlink" title="HTTP首部？（请求 &amp; 响应首部常用字段）"></a>HTTP首部？（请求 &amp; 响应首部常用字段）</h4><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>
<ul>
<li>请求 &amp; 响应报文 的 通用首部字段</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>首部字段名</th> 
   <th>用法</th> 
   <th>说明</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>Cache-Control</td> 
   <td>指定请求和响应遵循的缓存机制</td> 
   <td>取值一般为no-cache或max-age=XX（XX为整数，表示资源缓存有效期（秒））</td> 
  </tr> 
  <tr> 
   <td>Content-Type</td> 
   <td>请求体/响应体类型</td> 
   <td>text/plain：数据以纯文本形式（text/json/xml/html）进行编码，其中不含任何控件或格式字符<br>application/json(x-www-form-urlencoded)：数据被编码为名称/值对。是标准的编码格式，如消息主体是序列化后的JSON字符串<br>multipart/form-data：数据被编码为一条消息，页上的每个控件对应消息中的一个部分，如文件上传</td> 
  </tr> 
  <tr> 
   <td>Content-Length</td> 
   <td>请求体/响应体长度</td> 
   <td>单位字节</td> 
  </tr> 
  <tr> 
   <td>Content-Encoding</td> 
   <td>请求体/响应体编码格式</td> 
   <td>如gzip,deflate</td> 
  </tr> 
  <tr> 
   <td>Accept</td> 
   <td>说明接收的类型。可以多个值，用,分开</td> 
   <td>Accept:text/plain,text/html</td> 
  </tr> 
  <tr> 
   <td>Accept-Encoding</td> 
   <td>告诉对方我方接受的Content-Encoding</td> 
   <td>如gzip,deflate</td> 
  </tr> 
  <tr> 
   <td>ETag</td> 
   <td>当前资源的标识</td> 
   <td>与Last-Modified、If-None-Match、If-Modified-Since配合，用于缓存控制</td> 
  </tr> 
 </tbody> 
</table>

<ul>
<li>请求报文 的 请求首部字段<br><img src="https://mark.cuckooing.cn/pics/pic_17653efe.png" alt="pic_17653efe.png"></li>
<li>响应报文 的 响应首部字段<br><img src="https://mark.cuckooing.cn/pics/pic_d5953417.png" alt="pic_d5953417.png"></li>
<li>实体首部字段</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>首部字段名</th> 
   <th>用法</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>Allow</td> 
   <td>资源可支持的HTTP方法</td> 
  </tr> 
  <tr> 
   <td>Content-Encoding</td> 
   <td>实体主体使用的编码方式</td> 
  </tr> 
  <tr> 
   <td>Content-Language</td> 
   <td>实体主体的自然语言</td> 
  </tr> 
  <tr> 
   <td>Content-Length</td> 
   <td>实体主体的大小</td> 
  </tr> 
  <tr> 
   <td>Content-Type</td> 
   <td>实体主体的媒体类型</td> 
  </tr> 
  <tr> 
   <td>Expires</td> 
   <td>实体主体过期的日期时间</td> 
  </tr> 
  <tr> 
   <td>Last-Modified</td> 
   <td>资源的最后修改日期时间</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="HTTP-缓存机制？"><a href="#HTTP-缓存机制？" class="headerlink" title="HTTP 缓存机制？"></a>HTTP 缓存机制？</h3><ul>
<li>浏览器第一次请求<br><img src="https://mark.cuckooing.cn/pics/pic_3dacfdf1.png" alt="pic_3dacfdf1.png"><br>在浏览器第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回相应的数据（主体body）和缓存规则（响应头Header）后，浏览器将数据和缓存规则存储至缓存数据库中。<br>HTTP缓存规则包括：Expires、Cache-Control（强制缓存规则），Etag、Last-Modified（对比缓存规则）<br><img src="https://mark.cuckooing.cn/pics/pic_7a1da264.png" alt="pic_7a1da264.png"></li>
<li>浏览器第二次请求<br><img src="https://mark.cuckooing.cn/pics/pic_8011ec01.png" alt="pic_8011ec01.png"><br>浏览器第二次请求数据时，会根据是否需要向服务器发起请求分为 强制缓存 &amp; 对比缓存</li>
</ul>
<ol>
<li>首先执行强制缓存，服务器响应浏览器一个缓存时间（Expires&#x2F;Cache-Control）</li>
</ol>
<ul>
<li>Expires：服务器返回的到期时间。</li>
<li>Cache-Control：</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>Cache-Control类型</th> 
   <th>描述</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>private</td> 
   <td>客户端可缓存</td> 
  </tr> 
  <tr> 
   <td>public</td> 
   <td>客户端和代理服务器均可缓存</td> 
  </tr> 
  <tr> 
   <td>max-age = xxx</td> 
   <td>缓存内容在xxx秒后失效</td> 
  </tr> 
  <tr> 
   <td>no-cache</td> 
   <td>需要使用对比缓存来验证缓存数据</td> 
  </tr> 
  <tr> 
   <td>no-store</td> 
   <td>所有内容均不会缓存，不出发强制缓存与对比缓存</td> 
  </tr> 
 </tbody> 
</table>

<ol>
<li>如果强制缓存命中（在缓存时间内），则直接使用缓存，不需与服务器发生交互，不再执行对比缓存规则。</li>
<li>若超出缓存时间，则执行比较缓存策略。<br><img src="https://mark.cuckooing.cn/pics/pic_421d34e0.png" alt="pic_421d34e0.png"></li>
<li>再执行比较缓存策略，浏览器将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验</li>
</ol>
<ul>
<li>Last-Modified&#x2F;If-Modified-Since：<br>Last-Modified 为服务器相应请求时，告诉浏览器资源的最后修改时间。当浏览器再次请求服务器时，将在请求中添加参数 If-Modified-Since（值为上次响应里面的Last-Modified值），服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。<br>若资源的最后修改时间 大于 If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间 小于或等于 If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</li>
<li>Etag&#x2F;If-None-Match：<br>Etag 为服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对。<br>若不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</li>
</ul>
<blockquote>
<p>为什么比较校验要访问服务器？<br>服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。因此报文大小和请求时间打打减少</p>
</blockquote>
<p><img src="https://mark.cuckooing.cn/pics/pic_40eb0c47.png" alt="pic_40eb0c47.png"></p>
<h3 id="浏览器缓存机制：cookie-session"><a href="#浏览器缓存机制：cookie-session" class="headerlink" title="浏览器缓存机制：cookie&#x2F;session"></a>浏览器缓存机制：cookie&#x2F;session</h3><p>cookie &amp; session均是解决HTTP无状态协议的一种记录客户状态的机制。<br>cookie——客户端的通行证<br>Cookie 是服务器发送到用户浏览器并保存在本地浏览器的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。<br>创建过程：</p>
<ol>
<li>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</li>
<li>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</li>
</ol>
<p>session——服务端的客户档案<br>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。<br>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。<br>使用 Session 维护用户登录状态的过程如下：</p>
<ol>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；<br>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ol>
<p>cookie 与 session 区别</p>
<table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>cookie</th> 
   <th>session</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>存放位置</td> 
   <td>客户端</td> 
   <td>服务端</td> 
  </tr> 
  <tr> 
   <td>存储数据</td> 
   <td>只能存储 ASCII 码字符串</td> 
   <td>可以存储任何类型数据（考虑存储数据的复杂性）</td> 
  </tr> 
  <tr> 
   <td>安全性</td> 
   <td>低（存储在浏览器中，对用户可见，容易被恶意查看、修改）</td> 
   <td>高（session存储在服务器上，不存在敏感信息泄露的风险）</td> 
  </tr> 
  <tr> 
   <td>开销</td> 
   <td>较小</td> 
   <td>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="HTTP1-0-HTTP1-x-HTTP2-0区别是什么？"><a href="#HTTP1-0-HTTP1-x-HTTP2-0区别是什么？" class="headerlink" title="HTTP1.0 &amp; HTTP1.x &amp; HTTP2.0区别是什么？"></a>HTTP1.0 &amp; HTTP1.x &amp; HTTP2.0区别是什么？</h3><table> 
 <thead> 
  <tr> 
   <th>协议</th> 
   <th>HTTP1.0</th> 
   <th>HTTP1.X</th> 
   <th>HTTP2.0</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>特点</td> 
   <td>无状态、无连接<br>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</td> 
   <td>1. 持久连接：通过请求管道化实现，多个http 请求可以复用一个TCP连接，服务器端按照FIFO原则来处理不同的Request（实现"并行"传输）<br>2. 缓存处理：cache-control<br>3. 一个服务器能够创建多个Web站点：Host<br>4. 断点续传、身份认证、状态管理等</td> 
   <td>1. 二进制分帧：在应用层和传输层之间增加一个二进制分帧，在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量<br>2. 实现多路复用：多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。即HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流，实现真正的并行传输<br>3. 头部压缩<br>4. 服务器推送：是一种在客户端请求之前发送数据的机制。</td> 
  </tr> 
  <tr> 
   <td>痛点</td> 
   <td>连接无法复用：每次请求都要经历三次握手和慢启动<br>队头阻塞：由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，那么下一个请求就不发送，同样的后面的请求也给阻塞了</td> 
   <td>请求管道化并没有真正地实现"并行"，且在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞</td> 
   <td></td> 
  </tr> 
 </tbody> 
</table>

<p>图1为短连接（http 1.0），图2为持久连接（多路复用 http 2.0），图3为持久连接（管道化http 1.1）<br><img src="https://mark.cuckooing.cn/pics/pic_4aeaf7cb.png" alt="pic_4aeaf7cb.png"></p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="描述一下HTTPS？"><a href="#描述一下HTTPS？" class="headerlink" title="描述一下HTTPS？"></a>描述一下HTTPS？</h3><ul>
<li>HTTP传输数据的安全性问题</li>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
<li>HTTPS简介<br>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）不是新协议，是以安全为目标的HTTP通道，可理解为HTTP的加强版。实现原理是让 HTTP 先和 SSL（Secure Sockets Layer 安全套接字层，TLS（传输层安全）是更为安全的升级版 SSL）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了SSL&#x2F;TLS建立信道，加密数据包。<br>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。<br><img src="https://mark.cuckooing.cn/pics/pic_c035681e.png" alt="pic_c035681e.png"><br>HTTPS特点：</li>
<li>内容加密：采用混合加密技术，中间者无法直接查看明文内容。<br>混合加密：结合对称加密和非对称加密技术。使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。所以网络上传输的数据是被对称加密过的密文和用非对称加密后的密钥。即使被黑客截取。由于没有私钥，所以无法获取加密明文的密钥，也无法获取明文数据。</li>
<li>身份认证：确保浏览器访问的网站是经过CA（数字证书认证机构）验证的可信任网站。</li>
<li>数据完整性：SSL 提供报文摘要功能来进行完整性保护。</li>
</ul>
<blockquote>
<p>报文摘要：用于对发送的报文生成一个非常小的摘要信息。这个摘要信息保证原报文的完整性，即原报文只要有一位被改变，则摘要信息就会不匹配。</p>
</blockquote>
<h3 id="HTTPS-工作原理-连接-通信过程？"><a href="#HTTPS-工作原理-连接-通信过程？" class="headerlink" title="HTTPS 工作原理 &#x2F; 连接 &amp; 通信过程？"></a>HTTPS 工作原理 &#x2F; 连接 &amp; 通信过程？</h3><ul>
<li>对称加密<br>使用一个密钥加密，使用相同的密钥才能解密。计算量小，加密解密速度快，但在传输加密数据时需传输密钥，密钥容易泄露，安全性低。</li>
<li>非对称加密<br>有一个公钥，一个私钥。公钥加密只能私钥解密，私钥加密只能公钥解密。计算量大，加密解密速度慢，在传输数据时只需传输公钥和公钥加密的数据，即时被截取，由于没有私钥所以无法获取明文数据，安全性高。</li>
<li>HTTPS工作原理（SSL&#x2F;TLS认证+加密过程）<br>发送方将对称加密的密钥通过非对称加密的公钥进行加密，接收方使用私钥进行解密得到对称加密的密钥，再通过对称加密交换数据。Https协议通过对称加密（传输快，传输交换数据）和非对称加密（安全，传输密钥）结合处理实现的。</li>
</ul>
<ol>
<li>浏览器发起往服务器的443端口发起请求”<a target="_blank" rel="noopener" href="https://www.baidu.com"(及之后的对称加密算法)./">https://www.baidu.com&quot;（及之后的对称加密算法）。</a></li>
<li>服务器中有公钥和私钥，收到请求，会将公钥和服务器身份认证信息通过SSL数字证书返回给浏览器（证书包含公钥和身份认证信息）；</li>
</ol>
<blockquote>
<p>服务端，都有公钥、私钥和证书:<br>证书用来对通信方进行身份认证的。一般证书包含公钥以及身份认证信息。这里的证书可以是向某个权威机构申请的，也可以是自制的。区别在于自己办法的证书需要客户端验证通过，才可以继续访问；而使用受信任的公司申请的证书则不会弹出提示页面。<br>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。<br>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。<br>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
</blockquote>
<ol>
<li>浏览器进入数字证书认证环节，这一部分是浏览器内置的TLS完成的：<br>（1）证书可信度认证：首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会警告用户该证书不是由权威机构颁发，是不可信任的（浏览器显示https警告）。如果查到了对应的机构，则取出该机构颁发的证书公钥。<br>（2）服务端身份认证：用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会警告用户。如果网址一致会检查证书有效期，证书过期了也会警告用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。<br>（3）浏览器生成一个随机数R，并使用证书公钥对R进行加密。（R就是之后数据传输的对称密钥）</li>
<li>浏览器将加密的R传送给服务器。</li>
<li>服务器用自己的私钥解密得到R。</li>
<li>服务器以R为密钥使用了对称加密算法加密网页内容并传输给浏览器。</li>
<li>浏览器以R为密钥使用对应的对称解密算法获取网页内容。<br><img src="https://mark.cuckooing.cn/pics/pic_7c65a083.png" alt="pic_7c65a083.png"></li>
</ol>
<ul>
<li>HTTPS中那里使用对称加密？哪里使用非对称加密<br>前5步其实就是HTTPS的握手过程，这个过程主要是认证服务端证书的合法性。<br>因为非对称加密计算量较大，整个通信过程只会用到一次非对称加密算法（主要是用来保护传输客户端生成的用于对称加密的随机数私钥）。后续内容的加解密都是通过一开始约定好的对称加密算法进行的。<br>握手过程采用了一次非对称加密，对对称密钥加密。使得浏览器与服务器双方知道传输数据过程对称加密算法的规则。<br>数据传输过程采用多次对称加密，对传输数据加密。浏览器和服务器用握手过程获得的对称加密规则加密&#x2F;解密传输数据。</li>
</ul>
<h3 id="HTTPS与HTTP区别？"><a href="#HTTPS与HTTP区别？" class="headerlink" title="HTTPS与HTTP区别？"></a>HTTPS与HTTP区别？</h3><table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>HTTP</th> 
   <th>HTTPS</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>定义</td> 
   <td>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议</td> 
   <td>HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性</td> 
  </tr> 
  <tr> 
   <td>成本</td> 
   <td>成本低</td> 
   <td>服务器的运营人员需要向CA申请证书，SSL的专业证书需要购买，功能越强大，费用越高</td> 
  </tr> 
  <tr> 
   <td>安全性</td> 
   <td>安全性较低</td> 
   <td>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，防止数据在传输过程中被窃取，确保数据的完整性</td> 
  </tr> 
  <tr> 
   <td>端口</td> 
   <td>80</td> 
   <td>443</td> 
  </tr> 
  <tr> 
   <td>效率</td> 
   <td>效率较高</td> 
   <td>因为需要进行加密解密等过程，因此速度会更慢</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="对称加密-非对称加密？"><a href="#对称加密-非对称加密？" class="headerlink" title="对称加密 &amp; 非对称加密？"></a>对称加密 &amp; 非对称加密？</h3><table> 
 <thead> 
  <tr> 
   <th>加密算法</th> 
   <th>对称加密</th> 
   <th>非对称加密</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>原理</td> 
   <td>加密算法是公开的，靠的是密钥来加密数据。使用一个密钥加密，使用相同的密钥才能解密</td> 
   <td>加密算法是公开的，有一个公钥，一个私钥（公钥和私钥不是随机的，由加密算法生成）；公钥加密只能私钥解密，私钥加密只能公钥解密，加密解密需要不同密钥</td> 
  </tr> 
  <tr> 
   <td>常用算法</td> 
   <td>DES,3DES,AES</td> 
   <td>RSA</td> 
  </tr> 
  <tr> 
   <td>优点</td> 
   <td>计算量小，加密和解密速度较快，适合加密较大数据</td> 
   <td>可以传输公钥（服务器—&gt;客户端）和公钥加密的数据（客户端-&gt;服务器），数据传输安全</td> 
  </tr> 
  <tr> 
   <td>缺点</td> 
   <td>在传输加密数据之前需要传递密钥，密钥传输容易泄露；一个用户需要对应一个密钥，服务器管理密钥比较麻烦</td> 
   <td>计算量大，加密和解密速度慢</td> 
  </tr> 
 </tbody> 
</table>

<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h3 id="描述一下Socket"><a href="#描述一下Socket" class="headerlink" title="描述一下Socket?"></a>描述一下Socket?</h3><p>Socket 即 套接字，是通信的基石，是应用层 与 TCP&#x2F;IP 协议族通信的中间软件抽象层，本质为一个封装了 TCP &#x2F; IP协议族 的编程接口（属于传输层）。网络上的两个进程端口通过Socket实现一个双向的通信连接从而进行数据交换。<br><img src="https://mark.cuckooing.cn/pics/pic_f444a31b.png" alt="pic_f444a31b.png"></p>
<ul>
<li>表示<br>Socket是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用协议、（本地主机IP地址，本地进程的协议端口）、（远地主机IP地址，远地进程协议端口）。<br>Socket一般成对出现，一对套接字（其中一个运行在服务端一个运行在客户端）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Socket =&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     (IP地址<span class="number">1</span>:PORT端口号)，(IP地址<span class="number">2</span>:PORT端口号)&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>适用场景：即时通讯，替代轮询<br>网站上的即时通讯是很常见的，比如网页的QQ，聊天系统等。按照以往的技术能力通常是采用轮询、Comet技术解决。<br>HTTP协议是非持久化的，单向的网络协议，在建立连接后只允许浏览器向服务器发出请求后，服务器才能返回相应的数据。当需要即时通讯时，通过轮询在特定的时间间隔（如1秒），由浏览器向服务器发送Request请求，然后将最新的数据返回给浏览器。这样的方法最明显的缺点就是需要不断的发送请求，而且通常HTTP request的Header是非常长的，为了传输一个很小的数据 需要付出巨大的代价，是很不合算的，占用了很多的宽带。<br>缺点：会导致过多不必要的请求，浪费流量和服务器资源，每一次请求、应答，都浪费了一定流量在相同的头部信息上<br>然而WebSocket的出现可以弥补这一缺点。在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握手的动作，然后单独建立一条TCP的通信通道进行数据的传送。</li>
</ul>
<h3 id="Socket-通信模型-原理-连接过程？"><a href="#Socket-通信模型-原理-连接过程？" class="headerlink" title="Socket 通信模型 &#x2F; 原理 &#x2F; 连接过程？"></a>Socket 通信模型 &#x2F; 原理 &#x2F; 连接过程？</h3><p>ServerSocket：服务器端类<br>Socket：客户端类<br>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。<br><img src="https://mark.cuckooing.cn/pics/pic_91e6667f.png" alt="pic_91e6667f.png"><br>（1）连接过程</p>
<ul>
<li>服务端监听<br>服务端创建 ServerSocket 实例，绑定监听的端口；调用accept()方法，进入等待状态，等待客户请求</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">30000</span>);</span><br><span class="line"><span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端请求<br>客户端创建 Socket 实例，指明需要连接的服务端IP地址和端口号（即指明需要连接服务端套接字），并向服务端Socket提出连接请求</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;192.168.1.88&quot;</span>,<span class="number">30000</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>连接确认<br>当 服务端Socket 监听到 客户端Socket 的连接请求后，为该连接创建一个服务端Socket。此时连接就建立好了。</li>
</ul>
<p>（2）通信过程</p>
<ul>
<li>连接建立后，服务端&#x2F;客户端通过入流InputStream读取接收到的数据；通过OutputStream向对方发送信息。</li>
<li>调用close()方法关闭相应资源</li>
</ul>
<h3 id="Socket-使用？"><a href="#Socket-使用？" class="headerlink" title="Socket 使用？"></a>Socket 使用？</h3><p>（1）使用 ServerSocket 创建服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//1. 创建一个服务器端Socket，即ServerSocket对象，指定绑定的端口，并监听此端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">12345</span>);</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> address.getHostAddress();</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2. 调用accept()等待客户端连接</span></span><br><span class="line">        System.out.println(<span class="string">&quot;~~~服务端已就绪，等待客户端接入~，服务端ip地址: &quot;</span> + ip);</span><br><span class="line">        socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">//3. 连接建立后，通过输入流InputStream读取接收到的数据</span></span><br><span class="line">        InputStream is=<span class="literal">null</span>;</span><br><span class="line">        InputStreamReader isr=<span class="literal">null</span>;</span><br><span class="line">        BufferedReader br=<span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//4. 通过输出流OutputStream向客户端发送响应信息</span></span><br><span class="line">        OutputStream os=<span class="literal">null</span>;</span><br><span class="line">        PrintWriter pw=<span class="literal">null</span>;</span><br><span class="line">        is = socket.getInputStream();     <span class="comment">//获取输入流</span></span><br><span class="line">        isr = <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((info=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        	<span class="comment">//循环读取客户端的信息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端发送过来的信息&quot;</span> + info);</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownInput();<span class="comment">//关闭输入流</span></span><br><span class="line">        <span class="comment">//5. 调用close()方法关闭相关资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）使用 Socket 创建客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="type">Button</span> <span class="variable">btn_accept</span> <span class="operator">=</span> (Button) findViewById(R.id.btn_accept);</span><br><span class="line">        btn_accept.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    acceptServer();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">acceptServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//1. 创建客户端Socket，指定服务器ip地址和端口</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;172.16.2.54&quot;</span>, <span class="number">12345</span>);</span><br><span class="line">        <span class="comment">//2. 连接建立后，通过输出流OutputStream向服务器发送请求信息</span></span><br><span class="line">        <span class="comment">//3. 通过输入流InputStream获取服务器响应的信息</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();<span class="comment">//字节输出流</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(os);<span class="comment">//将输出流包装为打印流</span></span><br><span class="line">        <span class="comment">// 获取客户端的IP地址</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> address.getHostAddress();</span><br><span class="line">        pw.write(<span class="string">&quot;客户端：~&quot;</span> + ip + <span class="string">&quot;~ 接入服务器！！&quot;</span>);</span><br><span class="line">        pw.flush();</span><br><span class="line">        socket.shutdownOutput();<span class="comment">//关闭输出流</span></span><br><span class="line">        <span class="comment">//4. 调用close()方法关闭套接字</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="描述一下WebSocket？"><a href="#描述一下WebSocket？" class="headerlink" title="描述一下WebSocket？"></a>描述一下WebSocket？</h3><p>WebSocket是HTML5一种新的协议。它借鉴了Socket这种思想，为web应用程序客户端和服务端之间（注意是客户端服务端）提供了一种全双工通信机制(full-duplex)。同时，它又是一种新的应用层协议。一开始的握手需要借助HTTP请求完成。<br>WebSocket同HTTP一样也是应用层的协议，但是它是一种双向通信协议，是建立在TCP之上的。连接过程需要进行握手：</p>
<ol>
<li><p>浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行。</p>
</li>
<li><p>TCP连接成功后，需要进行浏览器与服务器的一次握手（开始前的HTTP握手）：</p>
<ul>
<li>浏览器通过HTTP协议向服务器传送WebSocket支持的版本号等信息。</li>
<li>服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据。</li>
</ul>
</li>
<li><p>当收到了连接成功的消息后，通过TCP通道进行传输通信。并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p>
</li>
</ol>
<p>现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。<br>HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。<br><img src="https://mark.cuckooing.cn/pics/pic_05928cf4.png" alt="pic_05928cf4.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">WebSocketTest</span><span class="params">()</span></span><br><span class="line">         &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;WebSocket&quot;</span> in window)	<span class="comment">// 浏览器支持WebSocket</span></span><br><span class="line">            &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">               <span class="comment">// 打开一个 web socket</span></span><br><span class="line">               <span class="comment">// Websocket 使用 ws 或 wss 的统一资源标志符，类似于 HTTPS，其中 wss 表示在 TLS 之上的 Websocket。如：</span></span><br><span class="line">               <span class="comment">// ws://example.com/wsapi	Websocket与HTTP使用相同的TCP端口：80端口</span></span><br><span class="line">			   <span class="comment">// wss://secure.example.com/ 运行TLS上时，默认使用443端口</span></span><br><span class="line">               <span class="type">var</span> <span class="variable">ws</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:9998/echo&quot;</span>);</span><br><span class="line">                </span><br><span class="line">               ws.onopen = function()</span><br><span class="line">               &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                  ws.send(<span class="string">&quot;发送数据&quot;</span>);</span><br><span class="line">               &#125;;</span><br><span class="line">                </span><br><span class="line">               ws.onmessage = function (evt) </span><br><span class="line">               &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">                  <span class="type">var</span> <span class="variable">received_msg</span> <span class="operator">=</span> evt.data;</span><br><span class="line">               &#125;;</span><br><span class="line">                </span><br><span class="line">               ws.onclose = function()</span><br><span class="line">               &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 连接关闭</span></span><br><span class="line">               &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Socket-WebSocket-HTTP-对比？"><a href="#Socket-WebSocket-HTTP-对比？" class="headerlink" title="Socket &amp; WebSocket &amp; HTTP 对比？"></a>Socket &amp; WebSocket &amp; HTTP 对比？</h3><table> 
 <tbody> 
  <tr> 
   <td></td> 
   <td>Socket</td> 
   <td>WebSocket</td> 
   <td>HTTP</td> 
  </tr> 
  <tr></tr> 
  <tr> 
   <td>定义</td> 
   <td>封装了 TCP / IP协议族 的编程接口（API）</td> 
   <td>借鉴了Socket这种思想，为web服务器和浏览器之间提供了一种全双工通信机制的数据传输协议</td> 
   <td>利用TCP在Web服务器和浏览器之间数据传输的协议</td> 
  </tr> 
  <tr></tr> 
  <tr> 
   <td>工作层</td> 
   <td>传输层</td> 
   <td colspan="2">应用层</td> 
  </tr> 
  <tr></tr> 
  <tr> 
   <td>数据传输</td> 
   <td colspan="2">全双工通信机制（双向）<br> 即建立网络连接后，通信双方都能主动向对方发送或接受数据，直到双方连接断开。即服务器可主动发送消息给客户端，实现信息的主动推送；而不需要由客户端向服务器发送请求</td> 
   <td>请求-响应（单向）<br>客户端向服务端发送请求后，服务端才能向客户端返回数据</td> 
  </tr> 
  <tr></tr> 
  <tr> 
   <td>持久性</td> 
   <td colspan="2">持久化<br>（Socket 的 TCP 长连接的通讯模式：一旦 Socket 连接建立后，后续数据都以帧序列的形式传输。在客户端或服务端断开Socket 连接前，不需要客户端和服务端重新发起连接请求。）</td> 
   <td>非持久化</td> 
  </tr> 
  <tr></tr> 
  <tr> 
   <td>连接建立 &amp; 数据传输</td> 
   <td>1. 创建ServerSocket对象，绑定监听的端口<br>2. 调用accept()方法监听客户端的请求<br>3. 连接建立后，通过输入流InputStream、OutputStream进行数据交互</td> 
   <td>TCP连接建立后，借助HTTP协议进行WebSocket三次握手，之后数据传输使用WebSocket协议</td> 
   <td>TCP连接建立后，客户端发送请求报文，服务端返回响应报文</td> 
  </tr> 
  <tr></tr> 
 </tbody> 
</table>

<h2 id="数据传输格式"><a href="#数据传输格式" class="headerlink" title="数据传输格式"></a>数据传输格式</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化：把java对象转化为二进制字节码写入IO流中。<br>反序列化：将IO流中的二进制字节恢复成java对象。<br>序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。<br>应用场景：</p>
<ul>
<li>所有可在网络上传输的对象都必须是可序列化的。</li>
<li>所有需要保存到磁盘的java对象都必须是可序列化的。</li>
</ul>
<p>通常建议：程序创建的每个JavaBean类都实现Serializeable接口</p>
<h3 id="JSON、XML-解析方式"><a href="#JSON、XML-解析方式" class="headerlink" title="JSON、XML 解析方式"></a>JSON、XML 解析方式</h3><ul>
<li>Json<br>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。</li>
<li>代码格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;中国&quot;</span>,</span><br><span class="line">    <span class="string">&quot;province&quot;</span>: [&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;黑龙江&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cities&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;city&quot;</span>: [<span class="string">&quot;哈尔滨&quot;</span>, <span class="string">&quot;大庆&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;广东&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cities&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;city&quot;</span>: [<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>, <span class="string">&quot;珠海&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解析方式</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>解析方式</th> 
   <th>JSONObject</th> 
   <th>FastJson</th> 
   <th>Gson</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>介绍</td> 
   <td>原生</td> 
   <td>阿里巴巴FastJson是一个Json处理工具包</td> 
   <td>GSON是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库</td> 
  </tr> 
  <tr> 
   <td>序列化</td> 
   <td>String jsonStr = jsonObject.toString();<br>String jsonStr = jsonArray.toString();</td> 
   <td>String jsonString = JSON.toJSONString(person);</td> 
   <td>String gsonString = gson.toJson(object);</td> 
  </tr> 
  <tr> 
   <td>反序列化</td> 
   <td>JSONObject jsonObject = new JSONObject(jsonStr);<br>JSONArray jsonArray = new JSONArray(jsonStr);</td> 
   <td>person =JSON.parseObject(jsonString,Person.class);<br>List persons2 = JSON.parseArray(jsonString,Person.class);</td> 
   <td>T t = gson.fromJson(gsonString, cls);</td> 
  </tr> 
  <tr> 
   <td>特点</td> 
   <td></td> 
   <td>性能好，速度快</td> 
   <td>功能全面</td> 
  </tr> 
 </tbody> 
</table>

<ul>
<li>XML</li>
<li>代码格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;country&gt;</span><br><span class="line">    &lt;name&gt;中国&lt;/name&gt;</span><br><span class="line">    &lt;province&gt;</span><br><span class="line">        &lt;name&gt;黑龙江&lt;/name&gt;</span><br><span class="line">        &lt;cities&gt;</span><br><span class="line">            &lt;city&gt;哈尔滨&lt;/city&gt;</span><br><span class="line">            &lt;city&gt;大庆&lt;/city&gt;</span><br><span class="line">        &lt;/cities&gt;</span><br><span class="line">    &lt;/province&gt;</span><br><span class="line">     &lt;province&gt;</span><br><span class="line">        &lt;name&gt;广东&lt;/name&gt;</span><br><span class="line">        &lt;cities&gt;</span><br><span class="line">            &lt;city&gt;广州&lt;/city&gt;</span><br><span class="line">            &lt;city&gt;深圳&lt;/city&gt;</span><br><span class="line">            &lt;city&gt;珠海&lt;/city&gt;</span><br><span class="line">        &lt;/cities&gt;</span><br><span class="line">    &lt;/province&gt;</span><br><span class="line">&lt;/country&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>解析方式</li>
</ul>
<ol>
<li>Dom</li>
<li>Sax</li>
<li>Pull</li>
</ol>
<h2 id="Andorid-网络基础"><a href="#Andorid-网络基础" class="headerlink" title="Andorid 网络基础"></a>Andorid 网络基础</h2><h3 id="HttpClient-HttpURLConnection"><a href="#HttpClient-HttpURLConnection" class="headerlink" title="HttpClient &amp; HttpURLConnection"></a>HttpClient &amp; HttpURLConnection</h3><p>Android主要提供了两种方式进行网络请求：HttpClient与HttpUrlConnection。</p>
<table> 
 <tbody> 
  <tr> 
   <td></td> 
   <td>HttpClient</td> 
   <td>HttpUrlConnection</td> 
  </tr> 
  <tr> 
   <td>相同</td> 
   <td colspan="2">都支持https协议，以流的形式进行上传和下载、配置超时事件、IPV6、以及连接池等功能。</td> 
  </tr> 
  <tr> 
   <td>不同</td> 
   <td>拥有众多API，实现较稳定，bug数量少。但难以扩展，维护成本高。Android6.0后被移除。</td> 
   <td>提供简单、轻量级API，易于扩展。但Android2.2前有个重大bug。2.3后修改了bug并且提供了压缩和缓存机制，有效提升了网络性能。</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="常见网络框架总结"><a href="#常见网络框架总结" class="headerlink" title="常见网络框架总结"></a>常见网络框架总结</h3><ul>
<li>Volley<br>Volley是Google推出的网络通信框架，适合数据量小但通信频繁的网络操作。但不适合大文件下载。<br>特点是：（1）可进行Post、Get网络请求与图像异步处理请求（2）对网络请求进行排序与优先级处理（3）对网络请求进行缓存（4）多级别取消请求（5）与Activity生命周期联动<br>它的工作原理是先将请求加入缓存队列，并通过cacheDispatcher查询本地是否缓存本次请求结果，如果命中，则从缓存中解析结果并返回主线程；如果没有命中则将请求添加到网络队列，并通过networkDispatcher发送网络请求，获得并解析响应结果，将结果写入缓存并返回主线程。</li>
<li>OkHttp<br>OkHttp是Square团队开发的支持Http2&#x2F;SPDY的网络通信框架，即支持共享同一个Socket处理同一个服务器的所有请求，若SPDY不可用，则通过连接池来减少请求延时。支持重连机制、缓存响应数据及GZIP减少数据流量。<br>OkHttp核心设计模式是拦截器责任链模式，采用责任链的模式来使每个功能分开，每个拦截器自行完成自己的任务，并且将不属于自己的任务交给下一个，简化了各自的责任和逻辑，实现了网络请求。这样设计的好处在于使每个责任链可以分层实现缓存、压缩、网络IO和请求等功能，并且可以对响应的数据做其他的逻辑处理。<br>OkHttp适用于数据量大的重量级网络请求。</li>
<li>Retrofit<br>Retrofit是基于RESTful风格推出的网络请求框架封装，是基于OKHttp的网络请求框架的二次封装。其底层是通过OKHttp进行网络请求，而Retrofit仅负责网络请求接口的封装，从而简化了用户网络请求的参数配置，还能与Rxjava结合。<br>Retrofit采用了大量设计模式封装OkHttp，它的核心工作原理是将Http请求抽象为Java接口，在接口中用注解描述和配置网络请求参数。Retrofit使用动态代理的方式，动态地将网络请求接口的注解解析成HTTP请求。最终通过OKHttp执行Http请求。<br>Retrofit在任何场景下都优先选择，尤其是后台Api遵循RESTful风格且项目中使用RxJava的场景。</li>
</ul>
<h1 id="第五章-网络-之-Android网络知识-框架"><a href="#第五章-网络-之-Android网络知识-框架" class="headerlink" title="第五章 网络 之 Android网络知识&amp;框架"></a>第五章 网络 之 Android网络知识&amp;框架</h1><ul>
<li>（一）HttpClient和HttpURLConnection的区别</li>
<li>（二）Volley，OkHttp，Retrofit（三大常用Android网络框架）之间的区别和核心原理和使用场景</li>
<li>（三）网络请求缓存处理，okhttp如何处理网络缓存的？</li>
</ul>
<h2 id="（一）HttpClient和HttpURLConnection的区别"><a href="#（一）HttpClient和HttpURLConnection的区别" class="headerlink" title="（一）HttpClient和HttpURLConnection的区别"></a>（一）HttpClient和HttpURLConnection的区别</h2><p>Android主要提供了两种方式进行网络请求：HttpClient与HttpUrlConnection。这两种方式都支持https协议，以流的形式进行上传和下载、配置超时事件、IPV6、以及连接池等功能。<br>HttpClient拥有众多API，实现较稳定，bug数量少。但难以扩展，维护成本高。Android6.0后被移除。<br>HttpUrlConnection提供简单、轻量级API，易于扩展。但Android2.2前有个重大bug。2.3后修改了bug并且提供了压缩和缓存机制，有效提升了网络性能。</p>
<h2 id="（二）Volley，OkHttp，Retrofit（三大常用Android网络框架）之间的区别和核心原理和使用场景"><a href="#（二）Volley，OkHttp，Retrofit（三大常用Android网络框架）之间的区别和核心原理和使用场景" class="headerlink" title="（二）Volley，OkHttp，Retrofit（三大常用Android网络框架）之间的区别和核心原理和使用场景"></a>（二）Volley，OkHttp，Retrofit（三大常用Android网络框架）之间的区别和核心原理和使用场景</h2><p>1、Volley是Google推出的网络通信框架，适合数据量小但通信频繁的网络操作。但不适合大文件下载。<br>特点是：（1）可进行Post、Get网络请求与图像异步处理请求（2）对网络请求进行排序与优先级处理（3）对网络请求进行缓存（4）多级别取消请求（5）与Activity生命周期联动<br>它的工作原理是先将请求加入缓存队列，并通过cacheDispatcher查询本地是否缓存本次请求结果，如果命中，则从缓存中解析结果并返回主线程；如果没有命中则将请求添加到网络队列，并通过networkDispatcher发送网络请求，获得并解析响应结果，将结果写入缓存并返回主线程。<br>2、OkHttp是Square团队开发的支持Http2&#x2F;SPDY的网络通信框架，即支持共享同一个Socket处理同一个服务器的所有请求，若SPDY不可用，则通过连接池来减少请求延时。支持重连机制、缓存响应数据及GZIP减少数据流量。<br>OkHttp核心设计模式是拦截器责任链模式，采用责任链的模式来使每个功能分开，每个拦截器自行完成自己的任务，并且将不属于自己的任务交给下一个，简化了各自的责任和逻辑，实现了网络请求。这样设计的好处在于使每个责任链可以分层实现缓存、压缩、网络IO和请求等功能，并且可以对响应的数据做其他的逻辑处理。<br>OkHttp适用于数据量大的重量级网络请求。<br>3、Retrofit是基于RESTful风格推出的网络请求框架封装，是基于OKHttp的网络请求框架的二次封装。其底层是通过OKHttp进行网络请求，而Retrofit仅负责网络请求接口的封装，从而简化了用户网络请求的参数配置，还能与Rxjava结合。<br>Retrofit采用了大量设计模式封装OkHttp，它的核心工作原理是将Http请求抽象为Java接口，在接口中用注解描述和配置网络请求参数。Retrofit使用动态代理的方式，动态地将网络请求接口的注解解析成HTTP请求。最终通过OKHttp执行Http请求。<br>Retrofit在任何场景下都优先选择，尤其是后台Api遵循RESTful风格且项目中使用RxJava的场景。</p>
<h2 id="（三）网络请求缓存处理，okhttp如何处理网络缓存的？"><a href="#（三）网络请求缓存处理，okhttp如何处理网络缓存的？" class="headerlink" title="（三）网络请求缓存处理，okhttp如何处理网络缓存的？"></a>（三）网络请求缓存处理，okhttp如何处理网络缓存的？</h2><p>Http网络请求缓存处理：<br>强制缓存：当用户端第一次请求数据是，服务端返回了缓存的过期时间（Expires与Cache-Control），没有过期即可以继续使用缓存；如果过期则不使用缓存，无需再请求服务端。<br>对比缓存：当用户端第一次请求数据时，服务端会将缓存标识（Etag&#x2F;If-None-Match与Last-Modified&#x2F;If-Modified-Since）与数据一起返回给用户端，用户端将两者都备份到缓存中 ，再次请求数据时，用户端将上次备份的缓存<br>标识发送给服务端，服务端根据缓存标识进行判断缓存是否过期，假如返回304，则表示缓存可用，从缓存中读取数据；假如返回200，标识缓存不可用，请求服务端，并使用最新返回的数据。</p>
<h1 id="第六章-图片"><a href="#第六章-图片" class="headerlink" title="第六章 图片"></a>第六章 图片</h1><ul>
<li>Bitmap</li>
<li><ul>
<li>Bitmap 简介</li>
<li>Bitmap 导致OOM 原因 &amp; 性能优化</li>
<li>Bitmap 压缩策略</li>
</ul>
</li>
<li>大图加载：从网络加载一个10M的图片，说下注意事项？</li>
<li>说一下三级缓存的原理？</li>
<li>LruCache &amp; DiskLruCache原理？</li>
<li>如果让你设计一个图片加载库，你会如何设计？</li>
</ul>
<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><h3 id="Bitmap-简介"><a href="#Bitmap-简介" class="headerlink" title="Bitmap 简介"></a>Bitmap 简介</h3><ol>
<li>基本信息</li>
</ol>
<ul>
<li>简介<br>Bitmap位图包括像素以及长、宽、颜色等描述信息。长宽和像素位数是用来描述图片的，可以通过这些信息计算出图片的像素占用内存的大小。<br>位图可以理解为一个画架，把图放到上面然后可以对图片做一些列的处理。<br>位图文件图像显示效果好，但是非压缩格式，需要占用较大的存储空间。</li>
<li>Config 图片像素类型</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>图片像素类型</th> 
   <th>解释</th> 
   <th>适用场景</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>ARGB_8888</td> 
   <td>四个通道都是8位，每个像素占用4个字节，图片质量是最高的，但是占用的内存也是最大的</td> 
   <td>既要设置透明度，对图片质量要求又高，就用ARGB_8888</td> 
  </tr> 
  <tr> 
   <td>ARGB_4444</td> 
   <td>四个通道都是4位，每个像素占用2个字节，图片的失真比较严重</td> 
   <td>ARGB_4444失真严重，基本不用</td> 
  </tr> 
  <tr> 
   <td>RGB_565</td> 
   <td>没有A通道，每个像素占用2个字节，图片失真小，但是没有透明度</td> 
   <td>不需要设置透明度，RGB_565是个不错的选择</td> 
  </tr> 
  <tr> 
   <td>ALPHA_8</td> 
   <td>只有A通道，每个像素占用1个字节大大小，只有透明度，没有颜色值</td> 
   <td>ALPHA_8使用场景特殊，比如设置遮盖效果等</td> 
  </tr> 
 </tbody> 
</table>

<ul>
<li>CompressFormat 图片压缩格式</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>图片压缩格式</th> 
   <th>解释</th> 
   <th>文件格式</th> 
   <th>优点</th> 
   <th>缺点</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>JPEG</td> 
   <td>一种有损压缩（JPEG2000既可以有损也可以无损）</td> 
   <td>.jpg 或者 .jpeg</td> 
   <td>采用了直接色，有丰富的色彩，适合存储照片和生动图像效果</td> 
   <td>有损，不适合用来存储logo、线框类图</td> 
  </tr> 
  <tr> 
   <td>PNG</td> 
   <td>一种无损压缩</td> 
   <td>.png</td> 
   <td>支持透明、无损，主要用于小图标，透明背景等</td> 
   <td>若色彩复杂，则图片生成后文件很大</td> 
  </tr> 
 </tbody> 
</table>

<ol>
<li>加载<br>BitmapFactory提供了四类方法：decodeFile、decodeResource、decodeStream、decodeByteArray</li>
</ol>
<ul>
<li>从文件中读取</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/sdcard/Download/sample.png&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeStream(in);</span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">bm</span> <span class="operator">=</span> BitmapFactory.decodeFile(sd_path); <span class="comment">// 间接调用 BitmapFactory.decodeStream</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从资源中读取</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeResource(getContext().getResources(), R.drawable.sample); <span class="comment">// 间接调用 BitmapFactory.decodeStream</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从字节序列中读取</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InputStream转换成byte[]</span></span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">bm</span> <span class="operator">=</span> BitmapFactory.decodeByteArray(myByte,<span class="number">0</span>,myByte.length);</span><br></pre></td></tr></table></figure>

<ul>
<li>巨图加载：BitmapRegionDecoder，可以按照区域进行加载</li>
</ul>
<ol>
<li>存储</li>
</ol>
<p>根据android sdk版本有所不同。</p>
<ul>
<li>2.3以前<br>图片像素存储在native内存中。缺点是虚拟机无法自动进行垃圾回收，必须手动使用recycle，很容易导致内存泄露。也不方便调试等；</li>
<li>3.0以后<br>图片像素存储在Java堆中，垃圾回收能够自动进行，内存占用也能方便的展示在monitor中；</li>
<li>4.0以后<br>传输方式发生变化，大数据会通过ashmem（匿名共享内存）来传递（不占用Java内存），小数据通过直接拷贝的方式（在内存中操作），放宽了图片大小的限制；</li>
<li>6.0以后<br>加强了ashmen存储图片的方式</li>
</ul>
<ol>
<li>绘图：Paint &amp; Canvas &amp; Bitmap<br>Bitmap可以理解为画架或者画布，它是像素的集合，是色彩的表现和承载者；<br>Canvas可以理解为画家的各种操作，通过操作Paint在Bitmap上进行创作；<br>Paint可以理解为画笔，可以自定义各种色彩等。</li>
</ol>
<p>[Android利用canvas画各种图形][Android_canvas]<br>Canvas.drawBitmap 贴图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">*  bitmap 位图</span></span><br><span class="line"><span class="comment">*  left 绘制区域距离左边界偏移量</span></span><br><span class="line"><span class="comment">*  top 绘制区域距离上边界偏移量</span></span><br><span class="line"><span class="comment">*  paint 画笔</span></span><br><span class="line"><span class="comment">* 在View中指定位置绘制bitmap</span></span><br><span class="line"><span class="comment">* 注：传入的参数中的偏移量是指对于View的偏移。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawBitmap</span><span class="params">(<span class="meta">@NonNull</span> Bitmap bitmap, <span class="type">float</span> left, <span class="type">float</span> top, </span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> Paint paint)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">*  bitmap 位图</span></span><br><span class="line"><span class="comment">*  src bitmap需要绘制的面积，若src的面积小于bitmap时会对bitmap进行裁剪，</span></span><br><span class="line"><span class="comment">*      一般来说需要绘制整个bitmap时可以为null </span></span><br><span class="line"><span class="comment">*  dst 在画布中指定绘制bitmap的位置，当这个区域的面积与bitmap要显示的面积不匹配时，</span></span><br><span class="line"><span class="comment">*      会进行缩放，不可为null </span></span><br><span class="line"><span class="comment">*  paint 画笔</span></span><br><span class="line"><span class="comment">* 在指定位置绘制指定大小的bitmap</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawBitmap</span><span class="params">(<span class="meta">@NonNull</span> Bitmap bitmap, <span class="meta">@Nullable</span> Rect src, <span class="meta">@NonNull</span> RectF dst,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> Paint paint)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawBitmap</span><span class="params">(<span class="meta">@NonNull</span> Bitmap bitmap, <span class="meta">@Nullable</span> Rect src, <span class="meta">@NonNull</span> Rect dst,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> Paint paint)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">*  bitmap 位图</span></span><br><span class="line"><span class="comment">*  matrix 当绘制位图时需要转变时使用的矩阵</span></span><br><span class="line"><span class="comment">*  paint 画笔</span></span><br><span class="line"><span class="comment">* 使用指定的矩阵绘制位图</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawBitmap</span><span class="params">(<span class="meta">@NonNull</span> Bitmap bitmap, <span class="meta">@NonNull</span> Matrix matrix, </span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> Paint paint)</span></span><br></pre></td></tr></table></figure>

<p>Matrix 实现基本变换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义矩阵</span></span><br><span class="line"><span class="type">Matrix</span> <span class="variable">matrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();  </span><br><span class="line"><span class="comment">// 【缩放图像】</span></span><br><span class="line">matrix.postScale(<span class="number">0.8f</span>, <span class="number">0.9f</span>);  </span><br><span class="line"><span class="comment">// 【向左旋转】</span></span><br><span class="line">matrix.postRotate(-<span class="number">90</span>);  </span><br><span class="line"><span class="comment">// 【移动图像】</span></span><br><span class="line">matrix.postTranslate(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 【裁减图像】</span></span><br><span class="line">Bitmap.createBitmap(Bitmap source, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height, Matrix m, <span class="type">boolean</span> filter)</span><br></pre></td></tr></table></figure>

<p>canvas绘制圆角矩形</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备画笔</span></span><br><span class="line"><span class="type">Paint</span> <span class="variable">paint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">paint.setAntiAlias(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 准备裁剪的矩阵</span></span><br><span class="line"><span class="type">Rect</span> <span class="variable">rect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, originBitmap.getWidth(), originBitmap.getHeight());</span><br><span class="line"><span class="type">RectF</span> <span class="variable">rectF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectF</span>(<span class="keyword">new</span> <span class="title class_">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, originBitmap.getWidth(), originBitmap.getHeight()));</span><br><span class="line"> </span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">roundBitmap</span> <span class="operator">=</span> Bitmap.createBitmap(originBitmap.getWidth(), originBitmap.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line"><span class="type">Canvas</span> <span class="variable">canvas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Canvas</span>(roundBitmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆角矩阵，radius为圆角大小</span></span><br><span class="line">canvas.drawRoundRect(rectF, radius, radius, paint);</span><br><span class="line"></span><br><span class="line">paint.setXfermode(<span class="keyword">new</span> <span class="title class_">PorterDuffXfermode</span>(PorterDuff.Mode.SRC_IN)); </span><br><span class="line">canvas.drawBitmap(originBitmap, rect, rect, paint);</span><br></pre></td></tr></table></figure>

<ol>
<li>开源框架</li>
</ol>
<ul>
<li>Picasso包体积小、清晰，但功能有局限不能加载gif、只能缓存全尺寸；</li>
<li>Glide功能全面，擅长大型图片流，提交较大；</li>
<li>Fresco内存优化，减少oom，体积更大</li>
</ul>
<h3 id="Bitmap-导致OOM-原因-性能优化"><a href="#Bitmap-导致OOM-原因-性能优化" class="headerlink" title="Bitmap 导致OOM 原因 &amp; 性能优化"></a>Bitmap 导致OOM 原因 &amp; 性能优化</h3><p>[性能优化——Bitmap优化 原因 &amp; 方案][Bitmap_ _ _]</p>
<h3 id="Bitmap-压缩策略"><a href="#Bitmap-压缩策略" class="headerlink" title="Bitmap 压缩策略"></a>Bitmap 压缩策略</h3><ol>
<li>更换图片格式<br>Android目前常用的图片格式有png，jpeg和webp，</li>
</ol>
<ul>
<li>png：无损压缩图片格式，支持Alpha通道，Android切图素材多采用此格式</li>
<li>jpeg：有损压缩图片格式，不支持背景透明，适用于照片等色彩丰富的大图压缩，不适合logo</li>
<li>webp：是一种同时提供了有损压缩和无损压缩的图片格式，派生自视频编码格式VP8，从谷歌官网来看，无损webp平均比png小26%，有损的webp平均比jpeg小25%~34%，无损webp支持Alpha通道，有损webp在一定的条件下同样支持，有损webp在Android4.0（API 14）之后支持，无损和透明在Android4.3（API18）之后支持<br>采用webp能够在保持图片清晰度的情况下，可以有效减小图片所占有的磁盘空间大小</li>
</ul>
<ol>
<li>质量压缩<br>质量压缩并不会改变图片在内存中的大小，仅仅会减小图片所占用的磁盘空间的大小，因为质量压缩不会改变图片的分辨率，而图片在内存中的大小是根据widthheight一个像素的所占用的字节数计算的，宽高没变，在内存中占用的大小自然不会变，质量压缩的原理是通过改变图片的位深和透明度来减小图片占用的磁盘空间大小，所以不适合作为缩略图，可以用于想保持图片质量的同时减小图片所占用的磁盘空间大小。另外，由于png是无损压缩，所以设置quality无效</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">originBitmap.compress(format, quality, bos);</span><br></pre></td></tr></table></figure>

<ol>
<li>采样率压缩<br>采样率压缩是通过设置BitmapFactory.Options.inSampleSize，来减小图片的分辨率，进而减小图片所占用的磁盘空间和内存大小。<br>设置的inSampleSize会导致压缩的图片的宽高都为1&#x2F;inSampleSize，整体大小变为原始图片的inSampleSize平方分之一，当然，这些有些注意点：<br>1、inSampleSize小于等于1会按照1处理<br>2、inSampleSize只能设置为2的平方，不是2的平方则最终会减小到最近的2的平方数，如设置7会按4进行压缩，设置15会按8进行压缩。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">options.inSampleSize = inSampleSize;</span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">resultBitmap</span> <span class="operator">=</span> BitmapFactory.decodeFile(originFile.getAbsolutePath(), options);</span><br></pre></td></tr></table></figure>

<ol>
<li>缩放压缩<br>通过减少图片的像素来降低图片的磁盘空间大小和内存大小，可以用于缓存缩略图<br>实现方式如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeFile(originFile.getAbsolutePath());</span><br><span class="line">    <span class="comment">//设置缩放比</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">radio</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">result</span> <span class="operator">=</span> Bitmap.createBitmap(bitmap.getWidth() / radio, bitmap.getHeight() / radio, Bitmap.Config.ARGB_8888);</span><br><span class="line">    <span class="type">Canvas</span> <span class="variable">canvas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Canvas</span>(result);</span><br><span class="line">    <span class="type">RectF</span> <span class="variable">rectF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectF</span>(<span class="number">0</span>, <span class="number">0</span>, bitmap.getWidth() / radio, bitmap.getHeight() / radio);</span><br><span class="line">    <span class="comment">//将原图画在缩放之后的矩形上</span></span><br><span class="line">    canvas.drawBitmap(bitmap, <span class="literal">null</span>, rectF, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h2 id="大图加载：从网络加载一个10M的图片，说下注意事项？"><a href="#大图加载：从网络加载一个10M的图片，说下注意事项？" class="headerlink" title="大图加载：从网络加载一个10M的图片，说下注意事项？"></a>大图加载：从网络加载一个10M的图片，说下注意事项？</h2><p>[Android高效加载大图、多图解决方案，有效避免程序OOM][Android_OOM]<br>由于Android加载大图时容易导致OOM，所以应该对大图的加载单独处理，共有3点需要注意：</p>
<ol>
<li>图片压缩<br>由于图片的分辨率比手机屏幕分辨率高很多，因此应该根据ImageView控件大小对高分辨率的图片进行适当的压缩，防止OOM出现。</li>
<li>分块加载<br>如果图片尺寸过大，但指向获取图片的某一小块区域时，可以对图片分块加载。适用于地图绘制的场景。在Android中BitmapRegionDecoder类的功能就是加载一张图片的指定区域。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line">mDecoder = BitmapRegionDecoder.newInstance(mFile.getAbsolutePath(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取原图片宽高</span></span><br><span class="line">mDecoder.getWidth();</span><br><span class="line">mDecoder.getHeight();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载(10, 10) - (80, 80) 区域内原始精度的Bitmap对象</span></span><br><span class="line"><span class="type">Rect</span> <span class="variable">rect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">80</span>, <span class="number">80</span>);</span><br><span class="line">BitmapFactory.<span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">options.inSampleSize = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> mDecoder.decodeRegion(rect, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收释放Native层内存</span></span><br><span class="line">mDecoder.recycle();</span><br></pre></td></tr></table></figure>

<ol>
<li>图片三级缓存机制——可以让组件快速地重新加载和处理图片，避免网络加载的性能损耗<br>图片的三级缓存机制是指加载图片时，分别访问内存、文件和网络而获取图片数据的机制。</li>
</ol>
<ul>
<li>一级：内存缓存LruCache<br>LruCache是Android提供的一个缓存工具类，采用最近最少使用算法。把最近使用的对象用强引用存储在LinkedHashMap中，并把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。<br>Android先访问内存，如果内存中没有缓存数据，则访问缓存文件。</li>
<li>二级：文件缓存<br>DiskLruCache是缓存工具类，存储位置是外存。<br>缓存数据的存储路径优先考虑SD卡的缓存目录，在SD卡下新建一个缓存文件用来存储缓存数据。若缓存文件中没有缓存数据，则联网加载图片。</li>
<li>三级：联网加载<br>通过网络请求加载网络图片，并将图片数据保存到内存和缓存文件中。</li>
</ul>
<h2 id="说一下三级缓存的原理？"><a href="#说一下三级缓存的原理？" class="headerlink" title="说一下三级缓存的原理？"></a>说一下三级缓存的原理？</h2><p><img src="https://mark.cuckooing.cn/pics/pic_6fcde8d5.png" alt="pic_6fcde8d5.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 从缓存（内存缓存，磁盘缓存）中获取Bitmap</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Bitmap <span class="title function_">getBitmap</span><span class="params">(String url)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">         <span class="keyword">if</span> (mLruCache.get(url) != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">             <span class="comment">// 从LruCache缓存中取</span></span><br><span class="line">             Log.i(TAG,<span class="string">&quot;从LruCahce获取&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span> mLruCache.get(url);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">             <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> MD5Utils.md5(url);</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                 <span class="keyword">if</span> (mDiskLruCache.get(key) != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                     <span class="comment">// 从DiskLruCahce取</span></span><br><span class="line">                     <span class="type">Snapshot</span> <span class="variable">snapshot</span> <span class="operator">=</span> mDiskLruCache.get(key);</span><br><span class="line">                     <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                     <span class="keyword">if</span> (snapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                         bitmap = BitmapFactory.decodeStream(snapshot.getInputStream(<span class="number">0</span>));</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">					bitmap = HttpUtils.getImageFromNet(url);</span><br><span class="line">				&#125;</span><br><span class="line">             <span class="comment">// 存入缓存</span></span><br><span class="line">             putBitmap(url, bitmap);</span><br><span class="line">             <span class="keyword">return</span> bitmap;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 存入缓存（内存缓存，磁盘缓存）</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putBitmap</span><span class="params">(String url, Bitmap bitmap)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">         <span class="comment">// 存入LruCache缓存</span></span><br><span class="line">         mLruCache.put(url, bitmap);</span><br><span class="line">         <span class="comment">// 判断是否存在DiskLruCache缓存，若没有存入</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> MD5Utils.md5(url);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">             <span class="keyword">if</span> (mDiskLruCache.get(key) == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                 DiskLruCache.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> mDiskLruCache.edit(key);</span><br><span class="line">                 <span class="keyword">if</span> (editor != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                     <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> editor.newOutputStream(<span class="number">0</span>);</span><br><span class="line">                     <span class="keyword">if</span> (bitmap.compress(CompressFormat.JPEG, <span class="number">100</span>, outputStream)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                         editor.commit();</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                         editor.abort();</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                mDiskLruCache.flush();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LruCache-DiskLruCache原理？"><a href="#LruCache-DiskLruCache原理？" class="headerlink" title="LruCache &amp; DiskLruCache原理？"></a>LruCache &amp; DiskLruCache原理？</h2><ul>
<li>LruCache 内存缓存<br>LruCache是android提供的一个缓存工具类（android-support-v4包），其算法是LRU（最近最少使用）算法。<br>它把最近使用的对象用“强引用”存储在LinkedHashMap中，并且把最近最少使用的对象在缓存值达到预设定值之前就从内存中移除。<br>适用于缓存图片。</li>
<li>源码分析<br>算法原理：<br>LruCache把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。（最近使用的数据在尾部，老数据在头部）<br>put</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LruCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;K, V&gt; map;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">LruCache</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">         <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;maxSize &lt;= 0&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">this</span>.maxSize = maxSize;         </span><br><span class="line">         <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);     </span><br><span class="line">&#125;</span><br><span class="line">LruCache的put方法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">         </span><br><span class="line">		<span class="comment">// 如果该值在缓存中存在便返回，否则在LinkedList中插入新值。并根据缓存大小整理内存，若缓存大小超过预定值，则移除最近最少使用值</span></span><br><span class="line">		V previous;</span><br><span class="line">        <span class="comment">// 对map进行操作之前，先进行同步操作（HashMap是线程不安全的，应该先进行同步操作）</span></span><br><span class="line">	   	<span class="comment">// synchronized加锁，表示一次只能有一个方法进入该线程</span></span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">             putCount++;</span><br><span class="line">             size += safeSizeOf(key, value);</span><br><span class="line">		<span class="comment">// 向map中加入缓存对象,若缓存中已存在，返回已有的值，否则执行插入新的数据，并返回null，并将缓存恢复为之前的值</span></span><br><span class="line">             previous = map.put(key, value)</span><br><span class="line">             <span class="keyword">if</span> (previous != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                 size -= safeSizeOf(key, previous);</span><br><span class="line">             &#125;         </span><br><span class="line">&#125;          </span><br><span class="line">			<span class="keyword">if</span> (previous != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">             entryRemoved(<span class="literal">false</span>, key, previous, value);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 根据缓存大小整理内存，看是否需要移除LinkedHashMap中的元素</span></span><br><span class="line">         trimToSize(maxSize);</span><br><span class="line">         <span class="keyword">return</span> previous;     &#125;</span><br></pre></td></tr></table></figure>

<p>trimToSize(maxSize)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// while循环，不断移除LinkedHashMap中双向链表表头表头元素（近期最少使用的数据），直到满足当前缓存大小小于或等于最大可缓存大小</span></span><br><span class="line">		<span class="comment">// 如果当前缓存大小已小于等于最大可缓存大小，则直接返回，不需要再移除LinkedHashMap数据</span></span><br><span class="line">	<span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     	<span class="keyword">break</span>; &#125;</span><br><span class="line">			<span class="comment">// 得到双向链表表头header的下一个Entry（近期最少使用的数据=表头数据）</span></span><br><span class="line">            Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class="line">            key = toEvict.getKey();</span><br><span class="line">            value = toEvict.getValue();</span><br><span class="line">			<span class="comment">// 移除当前取出的Entry并重新计算当前缓存大小</span></span><br><span class="line">            map.remove(key);</span><br><span class="line">            size -= safeSizeOf(key, value);</span><br><span class="line">            evictionCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        entryRemoved(<span class="literal">true</span>, key, value, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 如果该值在缓存中存在或可被创建便返回，当调用LruCache的get()方法获取集合中的缓存对象时，就代表访问了一次该元素，将会更新队列，移动到表尾,这个更新过程就是在LinkedHashMap中的get()方法中完成的。</span></span><br><span class="line">    V mapValue;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="comment">// 在hashMap中查找有没有这个key对应的节点(这个地方只要是get一次就会把命中的节点往队尾移动)</span></span><br><span class="line">        mapValue = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (mapValue != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> mapValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见LruCache中维护了一个集合LinkedHashMap，该LinkedHashMap是以访问顺序排序的。</p>
<ul>
<li>当调用put()方法时，就会在结合中添加元素，并调用trimToSize()判断缓存是否已满，如果满了就删除队头元素，即近期最少访问的元素。</li>
<li>当调用get()方法访问缓存对象时，就会调用LinkedHashMap的get()方法获得对应集合元素，同时会更新该元素到队尾。</li>
<li>使用<br>初始化缓存类，设定大小并重写sizeOf()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 内存缓存 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxMemory</span> <span class="operator">=</span> (<span class="type">int</span>)(Runtime.getRuntime().totalMemory()/<span class="number">1024</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cacheSize</span> <span class="operator">=</span> maxMemory / <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//1. 初始化这个cache前需要设定这个cache的大小，这里的大小官方推荐是用当前app可用内存的八分之一</span></span><br><span class="line">    mMemoryCache = <span class="keyword">new</span> <span class="title class_">LruCache</span>&lt;String, Bitmap&gt;(memoryCache) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">sizeOf</span><span class="params">(String key, Bitmap bitmap)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="comment">// 2. 重写此方法来衡量每张图片的大小，默认返回可缓存图片数量。</span></span><br><span class="line">                <span class="keyword">return</span> bitmap.getRowBytes() * bitmap.getHeght() / <span class="number">1024</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>重写 添加&#x2F;删除 缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将bitmap添加到内存中去</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBitmapToMemoryCache</span><span class="params">(String key, Bitmap bitmap)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (getBitmapFromMemCache(key) == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            mMemoryCache.put(key, bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过key来从内存缓存中获得bitmap对象</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap <span class="title function_">getBitmapFromMemCache</span><span class="params">(String key)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> mMemoryCache.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>LruCache加载图片 实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBitmap</span><span class="params">(<span class="type">int</span> resId, ImageView imageView)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="keyword">final</span> <span class="type">String</span> <span class="variable">imageKey</span> <span class="operator">=</span> String.valueOf(resId);</span><br><span class="line">	<span class="comment">// 首先会在 LruCache 的缓存中进行检查。</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> getBitmapFromMemCache(imageKey);</span><br><span class="line">	<span class="keyword">if</span> (bitmap != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="comment">// 如果找到了相应的键值，则会立刻更新ImageView </span></span><br><span class="line">		imageView.setImageBitmap(bitmap);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="comment">// 否则开启一个后台线程来加载这张图片</span></span><br><span class="line">		imageView.setImageResource(R.drawable.image_placeholder);</span><br><span class="line">		<span class="type">BitmapWorkerTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapWorkerTask</span>(imageView);</span><br><span class="line">		task.execute(resId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title class_">AsyncTask</span>&lt;Integer, Void, Bitmap&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="comment">// 在后台加载图片</span></span><br><span class="line">	<span class="comment">// BitmapWorkerTask 还要把新加载的图片的键值对放到缓存中。</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> Bitmap <span class="title function_">doInBackground</span><span class="params">(Integer... params)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">final</span> <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> decodeSampledBitmapFromResource(</span><br><span class="line">				getResources(), params[<span class="number">0</span>], <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">		addBitmapToMemoryCache(String.valueOf(params[<span class="number">0</span>]), bitmap);</span><br><span class="line">		<span class="keyword">return</span> bitmap;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>DiskLruCache 硬盘&#x2F;外存缓存<br>不同于LruCache，LruCache是将数据缓存到内存中去，而DiskLruCache是外部缓存（默认位置：&#x2F;sdcard&#x2F;Android&#x2F;data&#x2F;&#x2F;cache），例如可以将网络下载的图片永久的缓存到手机外部存储中去，并可以将缓存数据取出来使用，DiskLruCache不是google官方所写，但是得到了官方推荐，DiskLruCache没有编写到SDK中去，是由square团队开发的一个第三方开源库。</li>
<li>打开缓存<br>首先调用getDiskCacheDir()方法获取到缓存地址的路径，然后判断一下该路径是否存在，如果不存在就创建一下。接着调用DiskLruCache的open()方法来创建实例，并把四个参数传入即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DiskLruCache</span> <span class="variable">mDiskLruCache</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="type">File</span> <span class="variable">cacheDir</span> <span class="operator">=</span> getDiskCacheDir(context, <span class="string">&quot;bitmap&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!cacheDir.exists()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		cacheDir.mkdirs();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize)</span></span><br><span class="line">	<span class="comment">// directory:数据缓存地址</span></span><br><span class="line">	<span class="comment">// appVersion:当前应用程序版本号</span></span><br><span class="line">	<span class="comment">// 指定同一个key可以对应多少缓存文件，基本为1</span></span><br><span class="line">	<span class="comment">// 指定最多可以缓存多少字节数据</span></span><br><span class="line">	mDiskLruCache = DiskLruCache.open(cacheDir, getAppVersion(context), <span class="number">1</span>, <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getDiskCacheDir<br>缓存地址通常都会存放在 &#x2F;sdcard&#x2F;Android&#x2F;data&#x2F;&#x2F;cache 这个路径下面，但如果这个手机没有SD卡，或者SD正好被移除了的情况，应该专门写一个方法来获取缓存地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> File <span class="title function_">getDiskCacheDir</span><span class="params">(Context context, String uniqueName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	String cachePath;</span><br><span class="line">	<span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())</span><br><span class="line">			|| !Environment.isExternalStorageRemovable()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 当SD卡存在或者SD卡不可被移除的时候，就调用getExternalCacheDir()方法来获取缓存路径:/sdcard/Android/data/&lt;application package&gt;/cache</span></span><br><span class="line">		cachePath = context.getExternalCacheDir().getPath();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 否则就调用getCacheDir()方法来获取缓存路径:/data/data/&lt;application package&gt;/cache，接着又将获取到的路径和一个uniqueName进行拼接，作为最终的缓存路径返回。</span></span><br><span class="line">		cachePath = context.getCacheDir().getPath();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>(cachePath + File.separator + uniqueName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>写入缓存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="type">String</span> <span class="variable">imageUrl</span> <span class="operator">=</span> <span class="string">&quot;https://img-my.csdn.net/uploads/201309/01/1378037235_7476.jpg&quot;</span>;</span><br><span class="line">			<span class="comment">// 获得imageUrl的MD5编码格式字符串，符合文件的命名规则</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> hashKeyForDisk(imageUrl);</span><br><span class="line">			<span class="comment">// 获取DiskLruCache.Editor类实例进行写入操作</span></span><br><span class="line">			DiskLruCache.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> mDiskLruCache.edit(key);</span><br><span class="line">			<span class="keyword">if</span> (editor != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">				<span class="comment">// 调用Editor的newOutputStream()方法来创建一个输出流</span></span><br><span class="line">				<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> editor.newOutputStream(<span class="number">0</span>);</span><br><span class="line">				<span class="comment">// 访问urlString中传入的网址，并通过outputStream写入到本地</span></span><br><span class="line">				<span class="keyword">if</span> (downloadUrlToStream(imageUrl, outputStream)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">					editor.commit();	<span class="comment">// 写入结束后提交，才能写入生效</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">					editor.abort();		<span class="comment">// 否则放弃写入</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			mDiskLruCache.flush();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>hashKeyForDisk<br>写入的操作是借助DiskLruCache.Editor这个类完成，通过调用DiskLruCache的edit()方法来获取实例，edit(String key)接口需要传入一个参数key，这个key将会成为缓存文件的文件名，并且必须要和图片的URL是一一对应的。（不适合直接用URL作为key：1.过长2.含特殊字符）最简单的做法就是将图片的URL进行MD5编码，编码后的字符串肯定是唯一的，并且只会包含0-F这样的字符，完全符合文件的命名规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">hashKeyForDisk</span><span class="params">(String key)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	String cacheKey;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">final</span> <span class="type">MessageDigest</span> <span class="variable">mDigest</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">		mDigest.update(key.getBytes());</span><br><span class="line">		cacheKey = bytesToHexString(mDigest.digest());</span><br><span class="line">	&#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		cacheKey = String.valueOf(key.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cacheKey;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">bytesToHexString</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> Integer.toHexString(<span class="number">0xFF</span> &amp; bytes[i]);</span><br><span class="line">		<span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			sb.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		sb.append(hex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问urlString中传入的网址，并通过outputStream写入到本地</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">downloadUrlToStream</span><span class="params">(String urlString, OutputStream outputStream)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">BufferedOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">BufferedInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">final</span> <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(urlString);</span><br><span class="line">		urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">		in = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(urlConnection.getInputStream(), <span class="number">8</span> * <span class="number">1024</span>);</span><br><span class="line">		out = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(outputStream, <span class="number">8</span> * <span class="number">1024</span>);</span><br><span class="line">		<span class="type">int</span> b;</span><br><span class="line">		<span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			out.write(b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">if</span> (urlConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			urlConnection.disconnect();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="keyword">if</span> (out != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">				out.close();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">				in.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读取缓存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="type">String</span> <span class="variable">imageUrl</span> <span class="operator">=</span> <span class="string">&quot;https://img-my.csdn.net/uploads/201309/01/1378037235_7476.jpg&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> hashKeyForDisk(imageUrl);</span><br><span class="line">	<span class="comment">// public synchronized Snapshot get(String key) throws IOException</span></span><br><span class="line">	<span class="comment">// get()方法要求传入一个key来获取到相应的缓存数据,key 为 将图片URL进行MD5编码后的值</span></span><br><span class="line">	DiskLruCache.<span class="type">Snapshot</span> <span class="variable">snapShot</span> <span class="operator">=</span> mDiskLruCache.get(key);</span><br><span class="line">	<span class="keyword">if</span> (snapShot != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 获取到的DiskLruCache.Snapshot对象,调用它的getInputStream()方法就可以得到缓存文件的输入流了</span></span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> snapShot.getInputStream(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">// 使用了BitmapFactory的decodeStream()方法将文件流解析成Bitmap对象，然后把它设置到ImageView当中</span></span><br><span class="line">		<span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeStream(is);</span><br><span class="line">		mImage.setImageBitmap(bitmap);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>LruCache &amp; DiskLruCache 对比</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>缓存</th> 
   <th>LruCache</th> 
   <th>DiskLruCache</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>简介</td> 
   <td>内存缓存</td> 
   <td>硬盘/外存缓存</td> 
  </tr> 
  <tr> 
   <td>核心算法</td> 
   <td>LRU</td> 
   <td>LRU</td> 
  </tr> 
  <tr> 
   <td>存储位置</td> 
   <td>内存</td> 
   <td>/sdcard/Android/data//cache<br>SD卡</td> 
  </tr> 
  <tr> 
   <td>特点</td> 
   <td>读写速度快，存储空间小</td> 
   <td>读写速度稍慢，存储空间大</td> 
  </tr> 
 </tbody> 
</table>

<h2 id="如果让你设计一个图片加载库，你会如何设计？"><a href="#如果让你设计一个图片加载库，你会如何设计？" class="headerlink" title="如果让你设计一个图片加载库，你会如何设计？"></a>如果让你设计一个图片加载库，你会如何设计？</h2><p>[Android高效异步图片加载框架][Android]<br>整体架构</p>
<ul>
<li>单例实现：单例模式调用图片加载框架</li>
<li>缓存策略：三级缓存策略（LruCache内存缓存、DiskCache硬盘缓存、联网加载）</li>
<li>任务队列：每发起一个新的加载图片的请求，封装成Task添加到的任务队列TaskQueue中去（FIFO）</li>
<li>线程池：后台轮询线程。该线程在第一次初始化实例的时候启动，然后会一直在后台运行；当每发起一次加载图片请求的时候，除了会创建一个新的任务到任务队列TaskQueue中去，同时发一个消息到后台线程，后台线程去使用线程池去TaskQueue去取一个任务执行<br>（线程池：在任务众多的情况下，系统要为每一个任务创建一个线程，而任务执 行完毕后会销毁每一个线程，所以会造成线程频繁地创建与销毁。）</li>
<li>图片压缩：将图片实际大小按缩放比进行压缩</li>
</ul>
<p>具体实现</p>
<ol>
<li>初始化 图片加载类</li>
</ol>
<ul>
<li>单例模式创建实例，并初始化信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XCImageLoader</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">XCImageLoader</span> <span class="variable">mInstance</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// 单例模式</span></span><br><span class="line">	LruCache&lt;String,Bitmap&gt; mLruCache；	<span class="comment">// 内存缓存，存储图片</span></span><br><span class="line">	ExecutorService mThreadPool；		<span class="comment">// 线程池	</span></span><br><span class="line">	LinkedList&lt;Runnable&gt; mTaskQueue；	<span class="comment">// 任务队列</span></span><br><span class="line">	Semaphore mPoolTThreadSemaphore；	<span class="comment">// 线程池信号量</span></span><br><span class="line">	<span class="comment">// 单例模式实现</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> XCImageLoader <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">synchronized</span> (XCImageLoader.class)</span><br><span class="line">            &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    mInstance = <span class="keyword">new</span> <span class="title class_">XCImageLoader</span>(DEAFULT_THREAD_COUNT);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">XCImageLoader</span><span class="params">(<span class="type">int</span> threadCount)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        init(threadCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadCount 线程池中线程数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> threadCount)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 初始化后台轮询线程</span></span><br><span class="line">        initBackThread();</span><br><span class="line">        <span class="comment">// 获取当前应用的最大可用内存</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxMemory</span> <span class="operator">=</span> (<span class="type">int</span>) Runtime.getRuntime().maxMemory();</span><br><span class="line">        <span class="comment">// 初始化LruCache大小</span></span><br><span class="line">        mLruCache = <span class="keyword">new</span> <span class="title class_">LruCache</span>&lt;String,Bitmap&gt;(maxMemory/<span class="number">8</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">sizeOf</span><span class="params">(String key, Bitmap value)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            	<span class="comment">// 计算每张图片byte大小</span></span><br><span class="line">                <span class="keyword">return</span> value.getRowBytes() * value.getHeight();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        mThreadPool = Executors.newFixedThreadPool(threadCount);</span><br><span class="line">        <span class="comment">// 创建任务队列</span></span><br><span class="line">        mTaskQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Runnable&gt;();</span><br><span class="line">        <span class="comment">// 线程池信号量 = threadCount 用于限制线程池中线程数量</span></span><br><span class="line">        <span class="comment">// 信号量的数量和我们加载图片的线程个数一致；</span></span><br><span class="line">        <span class="comment">// 每取一个任务去执行，我们会让信号量减一；每完成一个任务，会让信号量+1，再去取任务</span></span><br><span class="line">        mPoolTThreadSemaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(threadCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>后台轮询线程<br>后台线程中，创建一个Handler用来处理图片加载任务发过来的图片显示消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化后台轮询线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initBackThread</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 后台轮询线程</span></span><br><span class="line">        mPoolThread = <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                Looper.prepare();</span><br><span class="line">                mPoolThreadHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>()&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        <span class="comment">//从线程池中取出一个任务开始执行</span></span><br><span class="line">                        mThreadPool.execute(getTaskFromQueue());</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        	<span class="comment">// 获取信号量（semaphore --）</span></span><br><span class="line">                            mPoolTThreadSemaphore.acquire();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">//释放信号量（semaphore ++）</span></span><br><span class="line">                mPoolThreadHandlerSemaphore.release();</span><br><span class="line">                Looper.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        mPoolThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>加载图片<br>采用三级缓存策略处理图片加载</li>
</ol>
<ul>
<li>从内存LruCache中加载，如果存在则从LruCache中取出显示。否则，新建一个图片加载任务并添加到任务队列，此时会通知后台线程去线程池中取出一个线程来执行。</li>
<li>从硬盘DiskCache中加载，如果存在则从本地文件中加载显示。</li>
<li>否则从网络直接下载图片并显示。</li>
<li>将图片写入LruCache和DiskCache中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载图片并显示到ImageView上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayImage</span><span class="params">(<span class="keyword">final</span> String path,<span class="keyword">final</span> ImageView imageView</span></span><br><span class="line"><span class="params">        ,<span class="keyword">final</span> <span class="type">boolean</span> isFromNet)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            imageView.setTag(path);</span><br><span class="line">        <span class="keyword">if</span>(mUIHandler == <span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            mUIHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>()&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">// 获取得到图片，为imageview回调设置图片</span></span><br><span class="line">                    <span class="type">ImageHolder</span> <span class="variable">holder</span> <span class="operator">=</span> (ImageHolder) msg.obj;</span><br><span class="line">                    <span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> holder.bitmap;</span><br><span class="line">                    <span class="type">ImageView</span> <span class="variable">imageview</span> <span class="operator">=</span> holder.imageView;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> holder.path;</span><br><span class="line">                    <span class="comment">// 将path与getTag存储路径进行比较，防止错乱</span></span><br><span class="line">                    <span class="keyword">if</span> (imageview.getTag().toString().equals(path))</span><br><span class="line">                    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        <span class="keyword">if</span>(bmp != <span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                            imageview.setImageBitmap(bmp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据path在缓存中获取bitmap</span></span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">bm</span> <span class="operator">=</span> getBitmapFromLruCache(path);</span><br><span class="line">        <span class="keyword">if</span> (bm != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            refreshBitmap(path, imageView, bm);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//如果没有LruCache，则创建任务并添加到任务队列中</span></span><br><span class="line">            addTaskToQueue(createTask(path, imageView, isFromNet));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加任务到任务队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTaskToQueue</span><span class="params">(Runnable runnable)</span></span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mTaskQueue.add(runnable);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (mPoolThreadHandler == <span class="literal">null</span>)</span><br><span class="line">                mPoolThreadHandlerSemaphore.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        mPoolThreadHandler.sendEmptyMessage(<span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据参数，创建一个任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Runnable <span class="title function_">createTask</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> ImageView imageView,</span></span><br><span class="line"><span class="params">                                <span class="keyword">final</span> <span class="type">boolean</span> isFromNet)</span></span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="type">Bitmap</span> <span class="variable">bm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (isFromNet)</span><br><span class="line">                &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> getDiskCacheDir(imageView.getContext(),</span><br><span class="line">                            Utils.makeMd5(path));</span><br><span class="line">                    <span class="keyword">if</span> (file.exists())<span class="comment">// 如果在缓存文件中发现</span></span><br><span class="line">                    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        Log.v(TAG, <span class="string">&quot;disk cache image :&quot;</span> + path);</span><br><span class="line">                        bm = loadImageFromLocal(file.getAbsolutePath(),</span><br><span class="line">                                imageView);</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        <span class="keyword">if</span> (mIsDiskCacheEnable)<span class="comment">// 检测是否开启硬盘缓存</span></span><br><span class="line">                        &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">downloadState</span> <span class="operator">=</span> ImageDownloadUtils</span><br><span class="line">                                    .downloadImageByUrl(path, file);</span><br><span class="line">                            <span class="keyword">if</span> (downloadState)<span class="comment">// 如果下载成功</span></span><br><span class="line">                            &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                                Log.v(TAG,</span><br><span class="line">                                        <span class="string">&quot;download image :&quot;</span> + path</span><br><span class="line">                                                + <span class="string">&quot; to disk cache: &quot;</span></span><br><span class="line">                                                + file.getAbsolutePath());</span><br><span class="line">                                bm = loadImageFromLocal(file.getAbsolutePath(),</span><br><span class="line">                                        imageView);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 直接从网络加载</span></span><br><span class="line">                            bm = ImageDownloadUtils.downloadImageByUrl(path,</span><br><span class="line">                                    imageView);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    bm = loadImageFromLocal(path, imageView);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3、把图片加入到缓存</span></span><br><span class="line">                setBitmapToLruCache(path, bm);</span><br><span class="line">                refreshBitmap(path, imageView, bm);</span><br><span class="line">                mPoolTThreadSemaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>显示图片<br>很多情况下，网络或者本地的图片都比较大，而用于显示ImageView显示大小比较小，这时候就需要我们进行图片的压缩，再显示到ImageView上面去。节省内存。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据url下载图片并压缩</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title function_">downloadImageByUrl</span><span class="params">(String urlStr, ImageView imageview)</span></span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(urlStr);</span><br><span class="line">            <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(conn.getInputStream());</span><br><span class="line">            is.mark(is.available());</span><br><span class="line">            BitmapFactory.<span class="type">Options</span> <span class="variable">opts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">            opts.inJustDecodeBounds = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 获取bitmap（获取图片的宽和高）</span></span><br><span class="line">            <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeStream(is, <span class="literal">null</span>, opts);</span><br><span class="line">            <span class="comment">// 获取ImageView显示的宽和高</span></span><br><span class="line">            <span class="type">ImageSize</span> <span class="variable">imageViewSize</span> <span class="operator">=</span> ImageUtils.getImageViewSize(imageview);</span><br><span class="line">            <span class="comment">// 按照ImageView控件大小与图片大小的缩放比解析位图</span></span><br><span class="line">            opts.inSampleSize = ImageUtils.calculateInSampleSize(opts,</span><br><span class="line">                    imageViewSize.width, imageViewSize.height);</span><br><span class="line">            opts.inJustDecodeBounds = <span class="literal">false</span>;</span><br><span class="line">            is.reset();</span><br><span class="line">            bitmap = BitmapFactory.decodeStream(is, <span class="literal">null</span>, opts);</span><br><span class="line">            conn.disconnect();</span><br><span class="line">            <span class="keyword">return</span> bitmap;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span> (is != <span class="literal">null</span>)</span><br><span class="line">                    is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">            &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过UIHandler发消息来显示Bitmap到ImageView上去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新图片到ImageView</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshBitmap</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> ImageView imageView,</span></span><br><span class="line"><span class="params">                               Bitmap bm)</span></span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        <span class="type">ImageHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageHolder</span>();</span><br><span class="line">        holder.bitmap = bm;</span><br><span class="line">        holder.path = path;</span><br><span class="line">        holder.imageView = imageView;</span><br><span class="line">        message.obj = holder;</span><br><span class="line">        mUIHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Github 下载经典实例分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageLoader</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"><span class="comment">//    关于异步加载图片的思路是：</span></span><br><span class="line"><span class="comment">//    1.第一次进入时，是没有图片的，这时候我们会启动一个线程池，异步的从网上获得图片数据，为了防止图片过大导致OOM，可以调用BitmapFactory中的Options类对图片进行适当的缩放，最后再显示主线程的ImageView上。</span></span><br><span class="line"><span class="comment">//    2.把加载好的图片以图片的Url做为唯一的key存入内存缓存当中，并严格的控制好这个缓存的大小，防止OOM的发生。</span></span><br><span class="line"><span class="comment">//    3.把图片缓存在SD当中，如果没有SD卡就放在系统的缓存目录cache中，以保证在APP退出后，下次进来能看到缓存中的图片，这样就可以让使你的APP不会给客户呈现一片空白的景象。</span></span><br><span class="line"><span class="comment">//    4.用户第二次进来的时候，加载图片的流程则是倒序的，首先从内容中看是否存在缓存图片，如果没有就从SD卡当中寻找，再没有然后才是从网络中获取图片数据。这样做的既可以提高加载图片的效率，同时也节约了用户的流量。</span></span><br><span class="line"></span><br><span class="line">    MemoryCache memoryCache=<span class="keyword">new</span> <span class="title class_">MemoryCache</span>();</span><br><span class="line">    FileCache fileCache;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;ImageView, String&gt; imageViews= Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;ImageView, String&gt;());</span><br><span class="line">    ExecutorService executorService;</span><br><span class="line">    Handler handler=<span class="keyword">new</span> <span class="title class_">Handler</span>();<span class="comment">//handler to display images in UI thread</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageLoader</span><span class="params">(Context context)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        fileCache=<span class="keyword">new</span> <span class="title class_">FileCache</span>(context);</span><br><span class="line">        executorService= Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> stub_id= R.drawable.ic_launcher_background;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DisplayImage</span><span class="params">(String url, ImageView imageView)</span></span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        imageViews.put(imageView, url);</span><br><span class="line">        Bitmap bitmap=memoryCache.get(url);</span><br><span class="line">        <span class="keyword">if</span>(bitmap!=<span class="literal">null</span>)</span><br><span class="line">            imageView.setImageBitmap(bitmap);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            queuePhoto(url, imageView);</span><br><span class="line">            imageView.setImageResource(stub_id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">queuePhoto</span><span class="params">(String url, ImageView imageView)</span></span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        PhotoToLoad p=<span class="keyword">new</span> <span class="title class_">PhotoToLoad</span>(url, imageView);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">PhotosLoader</span>(p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bitmap <span class="title function_">getBitmap</span><span class="params">(String url)</span></span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        File f=fileCache.getFile(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//from SD cache</span></span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">b</span> <span class="operator">=</span> decodeFile(f);</span><br><span class="line">        <span class="keyword">if</span>(b!=<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//from web</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            Bitmap bitmap=<span class="literal">null</span>;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">imageUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">            <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection)imageUrl.openConnection();</span><br><span class="line">            conn.setConnectTimeout(<span class="number">30000</span>);</span><br><span class="line">            conn.setReadTimeout(<span class="number">30000</span>);</span><br><span class="line">            conn.setInstanceFollowRedirects(<span class="literal">true</span>);</span><br><span class="line">            InputStream is=conn.getInputStream();</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">            Utils.CopyStream(is, os);</span><br><span class="line">            os.close();</span><br><span class="line">            conn.disconnect();</span><br><span class="line">            bitmap = decodeFile(f);</span><br><span class="line">            <span class="keyword">return</span> bitmap;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> OutOfMemoryError)</span><br><span class="line">                memoryCache.clear();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//decodes image and scales it to reduce memory consumption</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap <span class="title function_">decodeFile</span><span class="params">(File f)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//decode image size</span></span><br><span class="line">            BitmapFactory.<span class="type">Options</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">            o.inJustDecodeBounds = <span class="literal">true</span>;</span><br><span class="line">            FileInputStream stream1=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            BitmapFactory.decodeStream(stream1,<span class="literal">null</span>,o);</span><br><span class="line">            stream1.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Find the correct scale value. It should be the power of 2.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> REQUIRED_SIZE=<span class="number">70</span>;</span><br><span class="line">            <span class="type">int</span> width_tmp=o.outWidth, height_tmp=o.outHeight;</span><br><span class="line">            <span class="type">int</span> scale=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span>(width_tmp/<span class="number">2</span>&lt;REQUIRED_SIZE || height_tmp/<span class="number">2</span>&lt;REQUIRED_SIZE)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                width_tmp/=<span class="number">2</span>;</span><br><span class="line">                height_tmp/=<span class="number">2</span>;</span><br><span class="line">                scale*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//decode with inSampleSize</span></span><br><span class="line">            BitmapFactory.<span class="type">Options</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">            o2.inSampleSize=scale;</span><br><span class="line">            FileInputStream stream2=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            Bitmap bitmap=BitmapFactory.decodeStream(stream2, <span class="literal">null</span>, o2);</span><br><span class="line">            stream2.close();</span><br><span class="line">            <span class="keyword">return</span> bitmap;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Task for the queue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">PhotoToLoad</span></span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">public</span> String url;</span><br><span class="line">        <span class="keyword">public</span> ImageView imageView;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">PhotoToLoad</span><span class="params">(String u, ImageView i)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            url=u;</span><br><span class="line">            imageView=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">PhotosLoader</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        PhotoToLoad photoToLoad;</span><br><span class="line">        PhotosLoader(PhotoToLoad photoToLoad)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="built_in">this</span>.photoToLoad=photoToLoad;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span>(imageViewReused(photoToLoad))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                Bitmap bmp=getBitmap(photoToLoad.url);</span><br><span class="line">                memoryCache.put(photoToLoad.url, bmp);</span><br><span class="line">                <span class="keyword">if</span>(imageViewReused(photoToLoad))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                BitmapDisplayer bd=<span class="keyword">new</span> <span class="title class_">BitmapDisplayer</span>(bmp, photoToLoad);</span><br><span class="line">                handler.post(bd);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Throwable th)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                th.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">imageViewReused</span><span class="params">(PhotoToLoad photoToLoad)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        String tag=imageViews.get(photoToLoad.imageView);</span><br><span class="line">        <span class="keyword">if</span>(tag==<span class="literal">null</span> || !tag.equals(photoToLoad.url))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Used to display bitmap in the UI thread</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BitmapDisplayer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Bitmap bitmap;</span><br><span class="line">        PhotoToLoad photoToLoad;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BitmapDisplayer</span><span class="params">(Bitmap b, PhotoToLoad p)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     bitmap=b;photoToLoad=p;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span>(imageViewReused(photoToLoad))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(bitmap!=<span class="literal">null</span>)</span><br><span class="line">                photoToLoad.imageView.setImageBitmap(bitmap);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                photoToLoad.imageView.setImageResource(stub_id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearCache</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        memoryCache.clear();</span><br><span class="line">        fileCache.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="第七章-布局"><a href="#第七章-布局" class="headerlink" title="第七章 布局"></a>第七章 布局</h1><ul>
<li>布局</li>
<li><ul>
<li>六大布局 特点</li>
<li>约束布局</li>
<li>LinearLayout，RelativeLayout性能对比</li>
<li>检测布局深度</li>
<li>布局优化</li>
<li><ul>
<li>include、merge、ViewStub标签</li>
</ul>
</li>
</ul>
</li>
<li>面试</li>
<li><ul>
<li>你知道布局文件到控件对象的过程吗？（Android布局文件映射源码分析）</li>
</ul>
</li>
</ul>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="六大布局-特点"><a href="#六大布局-特点" class="headerlink" title="六大布局 特点"></a>六大布局 特点</h3><p>[菜鸟教程][Link 7]<br>[Android知识体系总结之Android部分之Android中的布局篇][Android_Android_Android]</p>
<table> 
 <thead> 
  <tr> 
   <th>布局</th> 
   <th>介绍</th> 
   <th>常用属性</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>LinearLayour<br>线性布局</td> 
   <td>LinearLayout容器中的组件一个挨一个排列，通过控制android:orientation属性，可控制各组件是横向排列还是纵向排列</td> 
   <td>orientation：布局中组件排列方式<br>gravity：该组件所包含的子元素的对齐方式（horizontal/vertical）<br>layout_gravity：该组件在父容器里的对齐方式<br>layout_width：布局的宽度（wrap_content（布局实际大小）/match_parent（填满父容器））<br>layout_height：布局的高度（参数同上）<br>layout_weight：布局的权重（需要相应设置layout_height/width=0dp）</td> 
  </tr> 
  <tr> 
   <td>RelativeLayout<br>相对布局</td> 
   <td>相对布局可以让子控件以其兄弟控件或父控件为参考按照其相对位置进行布局，适用于复杂的嵌套布局</td> 
   <td>1. 根据父容器定位，如layout_alignParentLeft\Right\Top\Bottom（左\右\顶部\底部对齐）layout_centerHorizontal\Vertical\InParent（水平\垂直\整体居中）<br>2. 根据兄弟组件定位，如layout_toLeftOf\RightOf\above\below（参考组件左\右\上\下方）layout_alignTop\Bottom\Left\Right（顶部\底部\左\右对齐）<br>3. margin：偏移，设置该组件与父容器的边距<br>4. padding:填充，设置组件内部元素间的边距</td> 
  </tr> 
  <tr> 
   <td>TableLayout<br>表格布局</td> 
   <td>TableLayout继承自Linearout，本质上仍然是线性布局管理器。表格布局采用行、列的形式来管理UI组件<br>每个TableLayout都是由一个或多个TableRow组成的，一个TableRow就代表TableLayout的一行<br>（不声明行数、列数。tablerow的个数为表格的行数，tablerow中组件个数为该行的列数）</td> 
   <td>android:collapseColumns:设置需要被隐藏的列的序号<br>android:shrinkColumns:设置允许被收缩的列的列序号<br>android:stretchColumns:设置运行被拉伸的列的列序号<br>android:layout_column=“2”:表示的就是跳过第二个,直接显示到第三个格子处（从1开始计算）<br>android:layout_span=“4”:表示合并4个单元格,也就说这个组件占4个单元格</td> 
  </tr> 
  <tr> 
   <td>FrameLayout<br>帧布局</td> 
   <td>帧布局或叫层布局，从屏幕左上角按照层次堆叠方式布局，后面的控件覆盖前面的控件。帧布局为每个加入其中的组件创建一个空白的区域(称为一帧)，每个子组件占据一帧，这些帧会根据gravity属性执行自动对齐</td> 
   <td>android:foreground：设置改帧布局容器的前景图像<br>android:foregroundGravity：设置前景图像显示的位置</td> 
  </tr> 
  <tr> 
   <td>GridLayout<br>表格布局</td> 
   <td>GridLayout把整个容器划分为rows × columns个网格，每个网格可以放置一个组件。提供了setRowCount(int)和setColumnCount(int)方法来控制该网格的行和列的数量</td> 
   <td>android:orientation：子组件排列方式<br>android:layout_gravity：子组件对齐方式<br>android:rowCount：设置网格布局行数<br>android:columnCount：设置网格布局列数<br>android:layout_row：设置该组件位于第几行<br>android:layout_columnL设置该组件位于第几列</td> 
  </tr> 
  <tr> 
   <td>AbsoluteLayout<br>绝对布局（过时）</td> 
   <td></td> 
   <td></td> 
  </tr> 
 </tbody> 
</table>

<h3 id="约束布局"><a href="#约束布局" class="headerlink" title="约束布局"></a>约束布局</h3><p>ConstraintLayout则是使用约束的方式来指定各个控件的位置和关系的，它有点类似于RelativeLayout，但远比RelativeLayout要更强大。<br>ConstraintLayout非常适合使用可视化方式编写界面（而不适合用XML书写），且ConstraintLayout可以有效地解决布局嵌套过多的问题（复杂的布局总会伴随着多层的嵌套，而嵌套越多，程序的性能也就越差）<br>[Android新特性介绍：ConstraintLayout完全解析][Android_ConstraintLayout]</p>
<h3 id="LinearLayout，RelativeLayout性能对比"><a href="#LinearLayout，RelativeLayout性能对比" class="headerlink" title="LinearLayout，RelativeLayout性能对比"></a>LinearLayout，RelativeLayout性能对比</h3><ol>
<li>在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout<br>根据LinearLayout、FrameLayout和RelativeLayout的onMeasure()源码可分析得，相同层级下RelativeLayout性能最低：</li>
</ol>
<ul>
<li>RelativeLayout会让子View调用2次onMeasure</li>
<li>若当前RelativeLayout布局的子View计算的高度与RelativeLayout布局不同，会引发效率问题</li>
</ul>
<ol>
<li>如果能用RelativeLayout减少LinearLayout布局的层级，则使用RelativeLayout<br>采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。</li>
<li>LinearLayout慎用layout_weight<br>LinearLayout 在有weight时，也会调用子View2次onMeasure</li>
</ol>
<h3 id="检测布局深度"><a href="#检测布局深度" class="headerlink" title="检测布局深度"></a>检测布局深度</h3><ul>
<li>Dump UI Hierarchy for UI Atomator，分析UI层级</li>
<li>HierachyViewer</li>
</ul>
<h3 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h3><ul>
<li>布局优化思想<br>减少Overdraw（过度绘制）（一般通过减少UI层级、简化布局实现）</li>
</ul>
<blockquote>
<p>Overdraw：描述的是屏幕上的某个像素在同一帧时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，就会导致某些像素区域被绘制了多次，浪费大量的CPU以及GPU资源。</p>
</blockquote>
<ul>
<li>布局优化方法</li>
</ul>
<ol>
<li>善用相对布局RelativeLayout<br>可以通过扁平的RelativeLayout降低LinearLayout嵌套所产生布局树的层级</li>
<li>使用抽象布局标签include、merge、ViewStub</li>
</ol>
<ul>
<li>&lt; include &#x2F;&gt;<br>include标签常用于将布局中的公共部分提取出来</li>
<li>&lt; merge &#x2F;&gt;<br>merge标签是作为include标签的一种辅助扩展来使用，它的主要作用是为了防止在引用布局文件时产生多余的布局嵌套（merge能够减少include可能产生的层级）</li>
<li>&lt; ViewStub &#x2F;&gt;<br>ViewStub是View的子类。他是一个轻量级View， 隐藏的，没有尺寸的View。他可以用来在程序运行时简单的填充布局文件</li>
</ul>
<ol>
<li>使用Android最新的布局方式ConstaintLayout　　<br>ConstraintLayout允许你在不适用任何嵌套的情况下创建大型而又复杂的布局。它与RelativeLayout非常相似，所有的view都依赖于兄弟控件和父控件的相对关系。但是，ConstraintLayout比RelativeLayout更加灵活</li>
</ol>
<h4 id="include、merge、ViewStub标签"><a href="#include、merge、ViewStub标签" class="headerlink" title="include、merge、ViewStub标签"></a>include、merge、ViewStub标签</h4><ul>
<li>include<br>include标签常用于将布局中的公共部分提取出来，解决重复定义布局的问题。<br>下面是一个自定义的titlebar文件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android:background=<span class="string">&quot;@color/titlebar_bg&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">               android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">               android:src=<span class="string">&quot;@drawable/gafricalogo&quot;</span> /&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure>

<p>在应用中使用titlebar布局文件，我们通过标签,布局文件如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:background=<span class="string">&quot;@color/app_bg&quot;</span></span><br><span class="line">    android:gravity=<span class="string">&quot;center_horizontal&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;include layout=<span class="string">&quot;@layout/titlebar&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">              android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">              android:text=<span class="string">&quot;@string/hello&quot;</span></span><br><span class="line">              android:padding=<span class="string">&quot;10dp&quot;</span> /&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>merge<br>merge标签与include标签组合使用，可以有效减少View树的层次来优化布局<br>一个线性布局中嵌套一个文本视图，主布局如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/layout_wrap&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span> &gt;</span><br><span class="line">    &lt;include</span><br><span class="line">        android:id=<span class="string">&quot;@+id/layout_import&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        layout=<span class="string">&quot;@layout/include_text&quot;</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>（1）单独使用include标签的嵌套布局，下面是嵌套布局的include_text.xml文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span> &gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/textView&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>通过hierarchyviewer我们可以看到主布局View树的部分层级结构如下图：<br><img src="https://mark.cuckooing.cn/pics/pic_0fa5fbde.png" alt="pic_0fa5fbde.png"><br>（2）merge与include标签组合使用的布局，下面是嵌套布局的include_text.xml文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;merge xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> &gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/textView&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;Hello World!&quot;</span>/&gt;</span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure>

<p>通过hierarchyviewer我们可以看到主布局View树的部分层级结构如下图：<br><img src="https://mark.cuckooing.cn/pics/pic_1a1c21bc.png" alt="pic_1a1c21bc.png"><br>对比截图就可以发现上面的四层结构，现在已经是三层结构了。当我们使用标签的时候，系统会自动忽略merge层级，而把TextView直接放置与平级。</p>
<ul>
<li>ViewStub<br>ViewStub 标签实质上是一个宽高都为 0 的不可见 的轻量级View，占用资源非常小。可以通过延迟加载布局的方式优化布局提升渲染性能。适用于布局复杂却很少用的布局，如网络请求失败提示，列表为空提示，引导界面等。<br>这里的延迟加载是指初始化时, 程序无需显示该标签所指向的布局文件（ViewStub 控件占用内存相比于其他控件很小）。 只有在特定的条件下（View.setVisibility(View.VISIBLE)或View.inflate()）, 所指向的布局文件才需要被渲染, 且此布局文件直接将当前的 ViewStub 替换掉。</li>
</ul>
<blockquote>
<p>在开发过程中，经常会遇到这样一种情况，有些布局很复杂但是却很少使用。例如条目详情、进度条标识或者未读消息等，这些情况如果在一开始初始化，虽然设置可见性View.GONE,但是在Inflate的时候View仍然会被Inflate，仍然会创建对象，由于这些布局又相当复杂，所以会很消耗系统资源。</p>
</blockquote>
<p>定义ViewStub布局文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/layout_wrap&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span> &gt;</span><br><span class="line">    &lt;ViewStub</span><br><span class="line">        android:id=<span class="string">&quot;@+id/stub_image&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:inflatedId=<span class="string">&quot;@+id/image_import&quot;</span></span><br><span class="line">        android:layout=<span class="string">&quot;@layout/layout_image&quot;</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>layout_image.xml文件如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/layout_image&quot;</span>&gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/imageView&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>加载ViewStub布局文件：<br>动态加载ViewStub所包含的布局文件有两种方式，方式一使用使用inflate()方法，方式二就是使用setVisibility(View.VISIBLE)。<br>ViewStub一旦visible&#x2F;inflated,此时ViewStub所指向的布局文件（layout_image.xml）替换掉当前的ViewStub控件，它自己就不在是View试图层级的一部分了。所以后面无法再使用ViewStub来控制布局。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ViewStub viewStub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.layout_main2);</span><br><span class="line">    viewStub = (ViewStub) findViewById(R.id.stub_image);</span><br><span class="line">    <span class="comment">//viewStub.inflate();//方式一</span></span><br><span class="line">    viewStub.setVisibility(View.VISIBLE);<span class="comment">//方式二</span></span><br><span class="line">    <span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> (ImageView) findViewById(R.id.imageView);</span><br><span class="line">    imageView.setImageResource(R.drawable.image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例View层级截图如下：<br><img src="https://mark.cuckooing.cn/pics/pic_8656cbee.png" alt="pic_8656cbee.png"></p>
<h2 id="面试-1"><a href="#面试-1" class="headerlink" title="面试"></a>面试</h2><h3 id="你知道布局文件到控件对象的过程吗？（Android布局文件映射源码分析）"><a href="#你知道布局文件到控件对象的过程吗？（Android布局文件映射源码分析）" class="headerlink" title="你知道布局文件到控件对象的过程吗？（Android布局文件映射源码分析）"></a>你知道布局文件到控件对象的过程吗？（Android布局文件映射源码分析）</h3><table> 
 <thead> 
  <tr> 
   <th>布局文件映射两种方式</th> 
   <th>setContentView()</th> 
   <th>inflate()</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>调用</td> 
   <td><code>setContentView(R.layout.main)</code></td> 
   <td><code>View view = inflate.inflate(R.layout.main,null);</code></td> 
  </tr> 
  <tr> 
   <td>作用</td> 
   <td>将XML布局文件直接显示UI</td> 
   <td>将XML布局文件转换为一个View对象</td> 
  </tr> 
 </tbody> 
</table>



<h1 id="第八章-性能优化"><a href="#第八章-性能优化" class="headerlink" title="第八章 性能优化"></a>第八章 性能优化</h1><ul>
<li>内存优化</li>
<li><ul>
<li>ANR &amp; CRASH 产生的原因是什么？如何解决？</li>
<li>内存溢出 &amp; 内存泄漏 &amp; 内存抖动 是什么？产生原因？解决方案？</li>
<li>Bitmap优化 原因 &amp; 方案？</li>
<li>谈谈你项目中内存优化的一些经验？</li>
</ul>
</li>
<li>启动优化</li>
<li><ul>
<li>什么是冷启动 &amp; 热启动？启动流程？如何优化启动？</li>
</ul>
</li>
<li>布局优化</li>
<li><ul>
<li>你知道哪些布局优化的方案？</li>
</ul>
</li>
</ul>
<h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>[Carson_Ho：Android性能优化：这是一份全面&amp;详细的内存优化指南][Carson_Ho_Android]</p>
<h3 id="ANR-CRASH-产生的原因是什么？如何解决？"><a href="#ANR-CRASH-产生的原因是什么？如何解决？" class="headerlink" title="ANR &amp; CRASH 产生的原因是什么？如何解决？"></a>ANR &amp; CRASH 产生的原因是什么？如何解决？</h3><table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>定义</th> 
   <th>原因</th> 
   <th>解决</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>ANR</td> 
   <td>application not response，应用程序的UI线程响应超时</td> 
   <td>一般是主线程未及时响应用户的输入事件（如触摸、按键）；或者当前的事件正在被处理，但是由于耗时太长没有能够及时完成<br>常见：主线程频繁进行耗时操作</td> 
   <td>使用多线程，将耗时操作交给工作线程执行</td> 
  </tr> 
  <tr> 
   <td>Crash</td> 
   <td>应用程序崩溃</td> 
   <td>引起应用程序崩溃的很多原因时因为内存溢出OOM，因此需要避免OOM现象</td> 
   <td>内存优化，如：<br>1. 避免内存泄露<br>2. 避免内存抖动<br>3. 图片Bitmap优化<br>4. 提高代码质量 &amp; 减少代码数量</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="内存溢出-内存泄漏-内存抖动-是什么？产生原因？解决方案？"><a href="#内存溢出-内存泄漏-内存抖动-是什么？产生原因？解决方案？" class="headerlink" title="内存溢出 &amp; 内存泄漏 &amp; 内存抖动 是什么？产生原因？解决方案？"></a>内存溢出 &amp; 内存泄漏 &amp; 内存抖动 是什么？产生原因？解决方案？</h3><ol>
<li>内存泄露</li>
</ol>
<ul>
<li>定义<br>当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</li>
<li>本质原因<br>持有引用的对象的生命周期&gt;被引用的对象的生命周期</li>
<li>内存泄露 原因 &amp; 解决方案<br>（1）集合类</li>
<li>原因<br>集合中添加对象时，集合会存储着该对象的引用。导致该对象不可被回收，从而引起内存泄露。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">example</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	ArrayList&lt;Object&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">		arr.add(obj);	<span class="comment">// arr中存储obj的引用（在栈内存中的地址）</span></span><br><span class="line">		obj = <span class="literal">null</span>;		<span class="comment">// 虽释放元素obj本身，但由于arr中仍持有obj的引用，导致GC仍无法回收obj对象，引起内存泄露</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mark.cuckooing.cn/pics/pic_85fbd085.png" alt="pic_85fbd085.png"></p>
<ul>
<li>解决<br>集合类 添加集合元素对象 后，在使用后必须从集合中删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空集合对象 &amp; 设置为null</span></span><br><span class="line">arr.clear();</span><br><span class="line">arr = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>（2）Static关键字修饰成员变量</p>
<ul>
<li>原因<br>由于Static关键字修饰的成员变量的生命周期 &#x3D; 应用程序的生命周期。若Static关键字所引用实例 &lt; 应用程序的生命周期时，当引用实例需结束生命周期销毁时，会因静态变量的持有而无法被回收，从而出现内存泄露。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例模式</span></span><br><span class="line"><span class="comment">// 由于单例模式中对象由于其静态特性，因此单例模式引用对象的生命周期 = 应用程序生命周期</span></span><br><span class="line"><span class="comment">// 则若单例模式持有一个 生命周期小于应用生命周期 的对象引用，则当该实例对象被销毁时，由于单例对象仍持有该对象的引用，导致该对象无法销毁，引起内存泄露</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SingleInstance instance;</span><br><span class="line">	<span class="keyword">public</span> Context context;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SingleInstance</span><span class="params">(context)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">this</span>.context = context;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> SingleInstance <span class="title function_">getInstance</span><span class="params">(Context context)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">			synchronize(<span class="built_in">this</span>)</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="literal">null</span>)</span><br><span class="line">					instance = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>(context);</span><br><span class="line">	<span class="comment">// 若传入的context 是 activity 的 context</span></span><br><span class="line">	<span class="comment">// 则当该activiy生命周期结束被销毁时，由于单例模式的instance扔持有该activity的引用，导致activity无法被销毁，引起内存泄露</span></span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决</li>
<li>尽量避免 Static 成员变量引用资源耗费过多的实例（如 Context）。若需引用 Context，则尽量使用Applicaiton的Context</li>
<li>使用 弱引用（WeakReference） 代替 强引用 持有实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SingleInstance</span><span class="params">(context)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="comment">// 单例模式的context 应该为应用的context（ApplicationContext）</span></span><br><span class="line">		<span class="built_in">this</span>.context = context.getApplicationContext();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>（3）非静态内部类&#x2F;匿名类<br>[菜鸟教程：Java 内部类详解][Java]<br>非静态内部类 &#x2F; 匿名类 默认持有 外部类的引用：因为非静态内部类依赖外部类，可以通过内部类对外部类的引用来访问外部类的成员变量和成员方法。<br>而静态内部类则不持有外部类的引用：静态内部类不依赖外部类。<br>（3.1）多线程：AsyncTask、实现Runnable接口、继承Thread类</p>
<ul>
<li>原因<br>多线程类为非静态内部类&#x2F;匿名类，实例化后默认持有外部类的引用。因此当工作线程正在处理任务时，当Activity被销毁时，由于工作线程持有外部类Activity的引用，导致Activity无法被垃圾回收器回收，从而造成内存泄露。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		</span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();	<span class="comment">// 创建多线程实例new MyThread()，此时t默认持有外部类MainActivity的引用</span></span><br><span class="line">		t.start();	<span class="comment">// 开启线程</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建Thread内部类，实现多线程</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="meta">@override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">				<span class="comment">// 若线程执行的5秒内，MainActivity被销毁，但由于工作线程持有外部类的引用，因此MainActivity无法被GC回收，会造成内存泄露</span></span><br><span class="line">				Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     e.printStackTrace();&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决<br>（1）将非静态内部类 设置为 静态内部类<br>静态内部类 不默认持有外部类的引用，因此工作线程不持有MainActivity的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br></pre></td></tr></table></figure>

<p>（2）当外部类结束生命周期时，强制结束线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="built_in">super</span>.onDestroy();</span><br><span class="line">	thread.stop();	<span class="comment">// 外部类Activity生命周期结束时，强制结束线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3.2）消息传递机制Handler</p>
<ul>
<li>原因<br>因为消息队列中的Message持有Handler实例的引用，Handler实例为 非静态内部类&#x2F;匿名类 持有外部类Activity的引用。即Message-&gt;Handler-&gt;Activity。<br>因此当Handler 消息队列中仍有未处理的消息&#x2F;正在处理消息时，若外部类MainActivity销毁（Handler 生命周期 &gt; Activity 生命周期），由于Activity被引用，因此GC无法回收MainActivity导致内存泄露</li>
<li>解决<br>将Handler子类设置为静态内部类 ，则Handler不会引用MainActivity实例<br>使用WeakReference弱引用持有Activity实例，则垃圾回收期进行扫描时，只要发现了具有弱引用的对象，便会回收它的内存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		<span class="comment">// 传入当前Activity实例（弱引用）</span></span><br><span class="line">		<span class="type">MyHandler</span> <span class="variable">mh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHandler</span>(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 1. 自定义Handler子类，设置为静态内部类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 2. 定义弱引用实例</span></span><br><span class="line">		<span class="keyword">private</span> WeakReference&lt;Activity&gt; reference;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">MyHandler</span><span class="params">(Activity activity)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			refrence = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Activity&gt;(activity);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			System.out.println(msg.obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）资源对象使用后未关闭</p>
<ul>
<li>原因<br>对于资源的使用（如 广播BraodcastReceiver、文件流File、数据库游标Cursor、图片资源Bitmap等），若在Activity销毁时无及时关闭 &#x2F; 注销这些资源，则这些资源将不会被回收，从而造成内存泄漏</li>
<li>解决<br>在Activity销毁时 及时关闭 &#x2F; 注销资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于 广播BraodcastReceiver：注销注册</span></span><br><span class="line">unregisterReceiver()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 文件流File：关闭流</span></span><br><span class="line">InputStream / OutputStream.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于数据库游标cursor：使用后关闭游标</span></span><br><span class="line">cursor.close（）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 图片资源Bitmap：Android分配给图片的内存只有8M，若1个Bitmap对象占内存较多，当它不再被使用时，应调用recycle()回收此对象的像素所占用的内存；最后再赋为null </span></span><br><span class="line">Bitmap.recycle()；</span><br><span class="line">Bitmap = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于动画（属性动画）</span></span><br><span class="line"><span class="comment">// 将动画设置成无限循环播放repeatCount = “infinite”后</span></span><br><span class="line"><span class="comment">// 在Activity退出时记得停止动画</span></span><br></pre></td></tr></table></figure>

<p>（5）其他</p>
<ul>
<li>Context<br>Context的生命周期大于Context所引用实例的生命周期时，会造成内存泄露。应该尽量使用ApplicationContext代替ActivityContext。</li>
<li>ListView<br>在滑动ListView获取最新的View时，每次都在getView()中重新实例化一个View对象，不仅浪费资源、时间，也使内存占用越来越大。导致内存泄露。<br><img src="https://mark.cuckooing.cn/pics/pic_4d98abcb.png" alt="pic_4d98abcb.png"></li>
</ul>
<ol>
<li>内存溢出 &amp; 内存泄露 &amp; 内存抖动 对比</li>
</ol>
<table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>定义</th> 
   <th>原因</th> 
   <th>解决</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>内存溢出</td> 
   <td>应用程序所需内存超出系统分配的内存限额，从而导致内存溢出</td> 
   <td>内存中加载的数据量过于庞大，如一次从数据库取出过多数据<br>内存泄露<br>代码中存在死循环或循环产生过多重复的对象实体（内存抖动）<br>使用的第三方软件中的BUG<br>启动参数内存值设定的过小</td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>内存泄露</td> 
   <td>当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏</td> 
   <td>持有引用者的生命周期&gt;被引用者的生命周期：<br>集合类<br>Static关键字修饰成员变量<br>非静态内部类/匿名类<br>资源对象使用后未关闭</td> 
   <td>集合类：回收集合元素<br>Static关键字修饰的成员变量：避免Static引用过多实例<br>非静态内部类/匿名类：使用静态内部类<br>资源使用后未关闭：关闭资源对象</td> 
  </tr> 
  <tr> 
   <td>内存抖动</td> 
   <td>内存大小不断浮动的现象</td> 
   <td>由于大量、临时的小对象频繁创建，导致程序频繁地分配内存 &amp; 垃圾回收器（GC）频繁回收内存<br>垃圾收集器（GC）频繁地回收内存会导致卡顿，甚至内存溢出（OOM）——大量、临时的小对象频繁创建会导致内存碎片，使得当需分配内存时，虽总体上有剩余内存可分配，但由于这些内存不连续，导致无法模块分配。系统则视为内存不够，故导致内存溢出OOM</td> 
   <td>尽量避免频繁创建大量、临时的小对象</td> 
  </tr> 
 </tbody> 
</table>

<ol>
<li>辅助分析内存泄露的工具</li>
</ol>
<ul>
<li>MAT(Memory Analysis Tools)</li>
<li>Heap Viewer</li>
<li>Allocation Tracker</li>
<li>Memory Monitor（Android Studio 自带 的图形化检测内存工具，用于跟踪系统 &#x2F; 应用的内存使用情况）</li>
<li>LeakCanary</li>
</ul>
<h3 id="Bitmap优化-原因-方案？"><a href="#Bitmap优化-原因-方案？" class="headerlink" title="Bitmap优化 原因 &amp; 方案？"></a>Bitmap优化 原因 &amp; 方案？</h3><ul>
<li>原因<br>图片资源（Bitmap）非常消耗内存，占用App内存大部分。Android系统分配给每个应用程序内存有限，因此可能引发内存溢出（OOM），导致应用崩溃（Crash）</li>
<li>方案</li>
</ul>
<ol>
<li>使用完毕后释放图片资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案1：采用软引用</span></span><br><span class="line">reference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Bitmap&gt;(bm);</span><br><span class="line"><span class="comment">// 方案2：Bitmap像素数据回收</span></span><br><span class="line">bm.recycle();</span><br></pre></td></tr></table></figure>

<ol>
<li>根据分辨率适配 &amp; 缩放图片</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decodeSampledBitmapFromResource</span><span class="params">(Resources res, <span class="type">int</span> resId,<span class="type">int</span> reqWidth, <span class="type">int</span> reqHeight)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="comment">// 1. 加载图片前获取图片实际长宽值</span></span><br><span class="line">	BitmapFactory.<span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">	options.inJustDecodeBounds = <span class="literal">true</span>;	<span class="comment">// 禁止为bitmap分配内存</span></span><br><span class="line">	BitmapFactory.decodeResource(res,resId,options);	<span class="comment">//	对位图进行解析</span></span><br><span class="line">	<span class="comment">// 2. 计算图片的压缩比inSampleSize，对图片进行压缩</span></span><br><span class="line">	options.inSampleSize = calculateInSampleSize(options,reqWidth,reqHeight);</span><br><span class="line">	<span class="comment">// 3. 用获取到的inSampleSzie再次解析图片，可获得压缩后的图片</span></span><br><span class="line">	options.inJustDecodeBounds = <span class="literal">false</span>;	<span class="comment">// 在解析图片后创建Bitmap对象并为图片分配内存</span></span><br><span class="line">	<span class="keyword">return</span> Bitmap.decodeResource(res,resId,options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根据图片控件的宽/高对图片大小进行适配——计算对应的缩放比inSampleSize=实际宽高/目标宽高</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateInSampleSize</span><span class="params">(BitmapFactory.Options options,<span class="type">int</span> reqWidth,<span class="type">int</span> reqHeight)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="type">int</span> <span class="variable">imageHeight</span> <span class="operator">=</span> options.outHeight;</span><br><span class="line">	<span class="type">int</span> <span class="variable">imageWidth</span> <span class="operator">=</span> options.outWidth;</span><br><span class="line">	<span class="type">int</span> <span class="variable">inSampleSize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(imageHeight &gt; reqHeight || imageWidth&gt;reqWidth)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">heightRatio</span> <span class="operator">=</span> Math.round((<span class="type">float</span>)imageHeight/(<span class="type">float</span>)reqHeight);</span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">widthRatio</span> <span class="operator">=</span> Math.round((<span class="type">float</span>)imageWidth/(<span class="type">float</span>)reqWidth);</span><br><span class="line">		inSampleSize = heightRatio &lt; widthRatio?heightRatio : widthRatio;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> inSampleSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>按需选择合适的解码方式<br><img src="https://mark.cuckooing.cn/pics/pic_2c84b3b7.png" alt="pic_2c84b3b7.png"><br>不同的图片解码方式 对应的 内存占用大小 相差很大。根据需求通过 BitmapFactory.inPreferredConfig 设置 合适的解码方式。（默认使用的解码方式：ARGB_8888）</li>
<li>设置图片缓存——三级缓存机制</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 从缓存（内存缓存，磁盘缓存）中获取Bitmap</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Bitmap <span class="title function_">getBitmap</span><span class="params">(String url)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">         <span class="keyword">if</span> (mLruCache.get(url) != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">             <span class="comment">// 从LruCache缓存中取</span></span><br><span class="line">             Log.i(TAG,<span class="string">&quot;从LruCahce获取&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span> mLruCache.get(url);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">             <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> MD5Utils.md5(url);</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                 <span class="keyword">if</span> (mDiskLruCache.get(key) != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                     <span class="comment">// 从DiskLruCahce取</span></span><br><span class="line">                     <span class="type">Snapshot</span> <span class="variable">snapshot</span> <span class="operator">=</span> mDiskLruCache.get(key);</span><br><span class="line">                     <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                     <span class="keyword">if</span> (snapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                         bitmap = BitmapFactory.decodeStream(snapshot.getInputStream(<span class="number">0</span>));</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">					bitmap = HttpUtils.getImageFromNet(url);</span><br><span class="line">				&#125;</span><br><span class="line">             <span class="comment">// 存入缓存</span></span><br><span class="line">             putBitmap(url, bitmap);</span><br><span class="line">             <span class="keyword">return</span> bitmap;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 存入缓存（内存缓存，磁盘缓存）</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putBitmap</span><span class="params">(String url, Bitmap bitmap)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">         <span class="comment">// 存入LruCache缓存</span></span><br><span class="line">         mLruCache.put(url, bitmap);</span><br><span class="line">         <span class="comment">// 判断是否存在DiskLruCache缓存，若没有存入</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> MD5Utils.md5(url);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">             <span class="keyword">if</span> (mDiskLruCache.get(key) == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                 DiskLruCache.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> mDiskLruCache.edit(key);</span><br><span class="line">                 <span class="keyword">if</span> (editor != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                     <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> editor.newOutputStream(<span class="number">0</span>);</span><br><span class="line">                     <span class="keyword">if</span> (bitmap.compress(CompressFormat.JPEG, <span class="number">100</span>, outputStream)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                         editor.commit();</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                         editor.abort();</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                mDiskLruCache.flush();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h3 id="谈谈你项目中内存优化的一些经验？"><a href="#谈谈你项目中内存优化的一些经验？" class="headerlink" title="谈谈你项目中内存优化的一些经验？"></a>谈谈你项目中内存优化的一些经验？</h3><p><img src="https://mark.cuckooing.cn/pics/pic_b195ff95.png" alt="pic_b195ff95.png"></p>
<h2 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h2><h3 id="什么是冷启动-热启动？启动流程？如何优化启动？"><a href="#什么是冷启动-热启动？启动流程？如何优化启动？" class="headerlink" title="什么是冷启动 &amp; 热启动？启动流程？如何优化启动？"></a>什么是冷启动 &amp; 热启动？启动流程？如何优化启动？</h3><ul>
<li>冷启动 &amp; 热启动</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>方式</th> 
   <th>冷启动</th> 
   <th>热启动</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>定义</td> 
   <td>启动应用时，后台没有该应用的进程（例：第一次开启应用，上一次彻底退出应用），这时系统会重新创建一个新的进程分配给该应用，这种启动方式就是冷启动</td> 
   <td>启动应用时，后台已有该应用的进程（例：按back,home键，应用退出，但仍保留在后台，可进入任务列表查看），从已有的进程中启动应用，这种启动方式就是热启动</td> 
  </tr> 
  <tr> 
   <td>特点</td> 
   <td>系统会重新创建一个新进程分配给它。<br>因此会先创建和初始化Application类，再创建和初始化MainActivity类，包括一系列测量布局绘制，最后显示在界面上</td> 
   <td>系统直接从已有进程中启动应用。<br>因此不必创建和初始化Application，直接创建和初始化MainActivity，包括一系列测量不聚会知，显示在界面上</td> 
  </tr> 
  <tr> 
   <td>流程</td> 
   <td>Zygote进程中fork创建出一个新的进程 –&gt; Application构造器 –&gt; attachBaseContext() –&gt; onCreate() –&gt; Activity构造器 –&gt; onCreate –&gt; 配置主题背景等属性 –&gt; onStart() –&gt; onResume –&gt; 测量布局绘制显示在界面上</td> 
   <td>（没有Application创建和初始化）Activity构造器 –&gt; onCreate –&gt; 配置主题背景等属性 –&gt; onStart() –&gt; onResume –&gt; 测量布局绘制显示在界面上</td> 
  </tr> 
 </tbody> 
</table>

<ul>
<li>优化启动方案</li>
<li>黑白屏优化<br>系统在启动Activity的setContentView之前绘制窗体，此时布局资源还未加载，于是使用了默认的背景色。<br>解决：把启动图bg_splash设置为窗体背景，避免刚刚启动App的时候出现，黑&#x2F;白屏</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=<span class="string">&quot;Theme.AppLauncher&quot;</span> parent=<span class="string">&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot;</span>&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:windowBackground&quot;</span>&gt;<span class="meta">@drawable</span>/bg_splash&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>配置启动页面SplashActivity的清单文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">&quot;tv.douyu.view.activity.SplashActivity&quot;</span></span><br><span class="line">        android:screenOrientation=<span class="string">&quot;portrait&quot;</span> android:theme=<span class="string">&quot;@style/Theme.AppLauncher&quot;</span>&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class="line">            &lt;category android:name=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>onCreate优化<br>onCreate()耗时长会影响应用程序布局绘制的时间。因此应该减少onCreate工作量。<br>一般重写Application，在onCreate()方法中做一些初始化操作（如第三方SDK配置），可以将这些较大的第三方库通过开启一个异步线程中进行初始化。</li>
</ul>
<h2 id="布局优化-1"><a href="#布局优化-1" class="headerlink" title="布局优化"></a>布局优化</h2><h3 id="你知道哪些布局优化的方案？"><a href="#你知道哪些布局优化的方案？" class="headerlink" title="你知道哪些布局优化的方案？"></a>你知道哪些布局优化的方案？</h3><p>[Android性能优化之布局优化][Android]</p>
<ul>
<li>布局优化思想<br>减少Overdraw（过度绘制）（一般通过减少UI层级、简化布局实现）</li>
</ul>
<blockquote>
<p>Overdraw：描述的是屏幕上的某个像素在同一帧时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，就会导致某些像素区域被绘制了多次，浪费大量的CPU以及GPU资源。</p>
</blockquote>
<ul>
<li>布局优化方法</li>
</ul>
<ol>
<li>善用相对布局RelativeLayout<br>可以通过扁平的RelativeLayout降低LinearLayout嵌套所产生布局树的层级</li>
<li>使用抽象布局标签include、merge、ViewStub<br>[include、merge、ViewStub标签?][include_merge_ViewStub]</li>
</ol>
<ul>
<li>&lt; include &#x2F;&gt;<br>include标签常用于将布局中的公共部分提取出来</li>
<li>&lt; merge &#x2F;&gt;<br>merge标签是作为include标签的一种辅助扩展来使用，它的主要作用是为了防止在引用布局文件时产生多余的布局嵌套（merge能够减少include可能产生的层级）<br>直接使用include标签引入了之前的LinearLayout之后导致了界面多了一个层级，若引入merge标签则可以减少一个层级</li>
<li>&lt; ViewStub &#x2F;&gt;<br>ViewStub是View的子类。他是一个轻量级View， 隐藏的，没有尺寸的View。他可以用来在程序运行时简单的填充布局文件</li>
</ul>
<ol>
<li>使用Android最新的布局方式ConstaintLayout　　<br>ConstraintLayout允许你在不适用任何嵌套的情况下创建大型而又复杂的布局。它与RelativeLayout非常相似，所有的view都依赖于兄弟控件和父控件的相对关系。但是，ConstraintLayout比RelativeLayout更加灵活</li>
</ol>
<h1 id="第九章-JNI"><a href="#第九章-JNI" class="headerlink" title="第九章 JNI"></a>第九章 JNI</h1><ul>
<li>JNI</li>
<li><ul>
<li>JNI &amp; NDK</li>
<li>JNI 原理 —— 为什么java能够调用c&#x2F;c++函数</li>
<li>JNI如何实现数据传递？</li>
<li>你用JNI实现过什么功能吗？怎么实现的？</li>
</ul>
</li>
</ul>
<p>[JNI：java native方法与JNI实现][JNI_java native_JNI]</p>
<h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><h3 id="JNI-NDK"><a href="#JNI-NDK" class="headerlink" title="JNI &amp; NDK"></a>JNI &amp; NDK</h3><p>JNI &amp; NDK 定义 &amp; 介绍 &amp; 区别</p>
<table> 
 <tbody> 
  <tr> 
   <td></td> 
   <td>JNI</td> 
   <td>NDK</td> 
  </tr> 
  <tr> 
   <td>定义</td> 
   <td>Java Native Interface，即 Java本地接口</td> 
   <td>Native Development Kit，是 Android的一个工具开发包</td> 
  </tr> 
  <tr> 
   <td>简介</td> 
   <td>使得Java 与 本地其他类型语言（如C、C++）交互<br>即在 Java代码 里调用 C、C++等语言的代码 或 C、C++代码调用 Java 代码</td> 
   <td>快速开发C、 C++的动态库，并自动将so和应用一起打包成 APK<br>即可通过NDK在Android中使用JNI与本地代码（C/C++）交互</td> 
  </tr> 
  <tr> 
   <td>作用</td> 
   <td colspan="2">因为Java具备跨平台的特点，所以Java与本地代码交互能力很弱，通过 JNI 增强Java与本地代码进行交互能力<br>1. 运行效率高：java是解释型语言，运行效率较低，C/C++效率高很多通过JNI把耗时操作交给C/C++能提高Java运行效率<br> 2. 安全性高：java代码编译成的.class文件安全性较低，可通过JNI把重要的业务逻辑交给C/C++实现。由于C/C++反编译困难，因此安全性较高<br>3. 功能扩展性好：可以方便使用其他开发语言的开源哭<br>4. 易于代码复用和移植：使用本地代码（C/C++）开发的代码不仅可以在Android使用，还可以在别的平台上使用</td> 
  </tr> 
  <tr> 
   <td>使用</td> 
   <td>1. 在Java中声明Native方法（即需要调用的本地方法）<br>2. 编译上述 Java源文件javac（得到 .class文件）<br>3. 通过 javah 命令导出JNI的头文件（.h文件）<br>4. 使用 Java需要交互的本地代码 实现在 Java中声明的Native方法<br>5. 编译.so库文件<br>6. 通过Java命令执行 Java程序，最终实现Java调用本地代码</td> 
   <td>1. 配置 Android NDK环境<br>2. 创建 Android 项目，并与 NDK进行关联<br>3. 在 Android 项目中声明所需要调用的 Native方法<br>4. 使用 Android需要交互的本地代码 实现在Android中声明的Native方法(比如 Android 需要与 C++ 交互，那么就用C++ 实现 Java的Native方法)<br>5. 通过 ndk - bulid 命令编译产生.so库文件<br>6. 编译 Android Studio 工程，从而实现 Android 调用本地代码</td> 
  </tr> 
  <tr> 
   <td>联系</td> 
   <td colspan="2">JNI是实现的目的，NDK是Android中实现JNI的工具。<br>在Android开发环境中，通过 NDK开发工具包 实现 JNI 的功能（实现java 与本地语言交互）</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="JNI-原理-——-为什么java能够调用c-c-函数"><a href="#JNI-原理-——-为什么java能够调用c-c-函数" class="headerlink" title="JNI 原理 —— 为什么java能够调用c&#x2F;c++函数"></a>JNI 原理 —— 为什么java能够调用c&#x2F;c++函数</h3><p>（1）创建JNI函数并最终编译成.dll（Windows）&#x2F;.so（Unix）（这里文件类型根据机器类型自动生成）</p>
<ul>
<li>编写带有native声明的方法的java类，生成.java文件</li>
<li>使用javac命令编译所编写的java类，生成.class文件</li>
<li>使用javah -jni java类名生成扩展名为h的头文件，也即生成.h文件</li>
<li>使用C&#x2F;C++（或者其他编程想语言）实现本地方法，创建.h文件的实现，也就是创建.cpp文件实现.h文件中的方法</li>
<li>将C&#x2F;C++编写的文件生成动态连接库，生成dll文件</li>
</ul>
<p>（2）当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会加载一次。在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等。<br>如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。当本地方法被调用时，虚拟机通过调用java.system.loadLibrary()加载这些DLL文件实现本地方法。</p>
<h3 id="JNI如何实现数据传递？"><a href="#JNI如何实现数据传递？" class="headerlink" title="JNI如何实现数据传递？"></a>JNI如何实现数据传递？</h3><ul>
<li>Java调用C&#x2F;C++语言<br>在Java中声明Native方法（即需要调用的本地方法）<br>编译上述 Java源文件javac（得到 .class文件）<br>通过 javah 命令导出JNI的头文件（.h文件）<br>使用 Java需要交互的本地代码 实现在 Java中声明的Native方法<br>编译.so库文件<br>通过Java命令执行 Java程序，最终实现Java调用本地代码</li>
<li>JNI调用Java层代码<br>从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象<br>获取类的默认构造方法ID<br>查找实例方法的ID<br>创建该类的实例<br>调用对象的实例方法</li>
</ul>
<h3 id="你用JNI实现过什么功能吗？怎么实现的？"><a href="#你用JNI实现过什么功能吗？怎么实现的？" class="headerlink" title="你用JNI实现过什么功能吗？怎么实现的？"></a>你用JNI实现过什么功能吗？怎么实现的？</h3><h1 id="第十章-线程-进程"><a href="#第十章-线程-进程" class="headerlink" title="第十章 线程 &#x2F; 进程"></a>第十章 线程 &#x2F; 进程</h1><ul>
<li>基本线程实现（Thread &amp; Runnable）</li>
<li>线程池（ThreadPoolExecutor）</li>
<li><ul>
<li>简介 &amp; 优势</li>
<li>使用</li>
<li>工作原理</li>
</ul>
</li>
<li>AsyncTask</li>
<li><ul>
<li>是什么？能解决什么问题？</li>
<li>三个泛型参数作用 &amp; 四个方法？每个方法在哪个线程执行？</li>
<li>实现原理？</li>
<li>不足之处 &amp; 解决方法？</li>
</ul>
</li>
<li>Handler</li>
<li><ul>
<li>子线程一定不能更新UI吗？为什么Android系统不建议子线程访问UI？</li>
<li>定义 &amp; 作用 &amp; 六大概念</li>
<li>使用</li>
<li>Android 消息机制（工作原理 &amp; 源码分析）</li>
<li>内存泄露 &amp; 解决方案</li>
<li>面试</li>
</ul>
</li>
<li>HandlerThread</li>
<li><ul>
<li>简介</li>
<li>具体使用</li>
<li>工作原理 &amp; 源码分析</li>
</ul>
</li>
<li>IPC</li>
<li><ul>
<li>IPC 概述？</li>
<li>Binder机制 简介 &amp; 原理？</li>
<li>什么是AIDL?如何使用AIDL？AIDL工作原理（结合Binder）？</li>
</ul>
</li>
</ul>
<h2 id="基本线程实现（Thread-Runnable）"><a href="#基本线程实现（Thread-Runnable）" class="headerlink" title="基本线程实现（Thread &amp; Runnable）"></a>基本线程实现（Thread &amp; Runnable）</h2><ul>
<li>继承Thread类<br>Thread类是Java中实现多线程的具体类，封装了所需线程操作。在Android开发中用于实现多线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：自定义线程类（继承自Thread类）</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 步骤2：复写run()，定义线程的行为</span></span><br><span class="line">		<span class="meta">@override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     ...<span class="comment">//定义线程行为</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 步骤3：实例化线程对象</span></span><br><span class="line">	<span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;thread_1&quot;</span>);</span><br><span class="line">	<span class="comment">// 步骤4：通过线程对象控制线程状态，如运行start、睡眠sleep、停止stop……</span></span><br><span class="line">	mt.start();	<span class="comment">// 开启线程</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现Runnable接口<br>一个与多线程相关的抽象接口，仅定义1个方法&#x3D;run()，在Android开发中用于实现多线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：创建线程辅助类，实现Runnable接口</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 步骤2：复写run()，定义线程行为</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 步骤3：创建线程辅助对象</span></span><br><span class="line">	<span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">	<span class="comment">// 步骤4：创建线程对象，并传入线程辅助类对象</span></span><br><span class="line">	<span class="comment">// Runnable接口没有对线程的支持，必须创建线程Thread类的实例，由Thread创建的线程执行线程行为</span></span><br><span class="line">	<span class="type">Thread</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mt);</span><br><span class="line">	<span class="comment">// 步骤5：通过线程对象控制线程状态，如运行start、睡眠sleep、停止stop……</span></span><br><span class="line">	<span class="comment">// 当调用start()方法时，线程对象会自动回调线程辅助类对象的run()</span></span><br><span class="line">	td.start();</span><br></pre></td></tr></table></figure>

<ul>
<li>实现Callable接口<br>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。使用FutureTask类来包装Callable对象，通过调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">CallableThreadTest</span> <span class="variable">ctt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableThreadTest</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(ctt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 的循环变量i的值&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(ft, <span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span> + ft.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池（ThreadPoolExecutor）"><a href="#线程池（ThreadPoolExecutor）" class="headerlink" title="线程池（ThreadPoolExecutor）"></a>线程池（ThreadPoolExecutor）</h2><h3 id="简介-优势"><a href="#简介-优势" class="headerlink" title="简介 &amp; 优势"></a>简介 &amp; 优势</h3><p>线程的创建和销毁，都涉及到系统调用，消耗系统资源，所以就引入了线程池技术，避免频繁的线程创建和销毁<br>Java使用Executors接口表示线程池，具体实现类是ThreadPoolExecutor</p>
<ul>
<li>通过复用缓存在线程池中的线程 降低 线程创建&amp;销毁 造成的性能开销。</li>
<li>提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>防止线程并发数量过多，抢占系统资源从而导致阻塞。</li>
<li>提高线程的可管理性。使用线程池可以对线程进行统一的分配，调优和监控，如延时执行，定时循环执行等。</li>
</ul>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池的构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">     <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">     <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">     TimeUnit unit,</span></span><br><span class="line"><span class="params">     BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">     ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">     RejectedExecutionHandler handler)</span></span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池的使用</span></span><br><span class="line"><span class="comment">// 可以通过execute和submit两种方式来向线程池提交一个任务。</span></span><br><span class="line"><span class="comment">// execute()方法</span></span><br><span class="line"><span class="comment">// 使用execute来提交任务时，由于execute方法没有返回值，所以说我们也就无法判定任务是否被线程池执行成功。</span></span><br><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        System.out.println(<span class="string">&quot;execute方式&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// submit()方法</span></span><br><span class="line"><span class="comment">// 使用submit来提交任务时,它会返回一个future,我们就可以通过这个future来判断任务是否执行成功，还可以通过future的get方法来获取返回值。</span></span><br><span class="line"><span class="comment">// 如果子线程任务没有完成，get方法会阻塞住直到任务完成</span></span><br><span class="line"><span class="comment">// 而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时候有可能任务并没有执行完。</span></span><br><span class="line">Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        System.out.println(<span class="string">&quot;submit方式&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程池关闭</span></span><br><span class="line"><span class="comment">// 调用线程池的shutdown()或shutdownNow()方法来关闭线程池</span></span><br><span class="line"><span class="comment">// shutdown原理：将线程池状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</span></span><br><span class="line"><span class="comment">// shutdownNow原理：将线程池的状态设置成STOP状态，然后中断所有任务(包括正在执行的)的线程，并返回等待执行任务的列表。</span></span><br></pre></td></tr></table></figure>

<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>[线程池的工作原理与源码解读][Link 14]<br>[【细谈Java并发】谈谈线程池：ThreadPoolExecutor][Java_ThreadPoolExecutor]<br>核心参数<br>ThreadPoolExecutor参数最全的构造方法（根据需求配置参数）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数源码分析</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span> <span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                               <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                               TimeUnit unit,</span></span><br><span class="line"><span class="params">                               BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                               ThreadFactory threadFactory </span></span><br><span class="line"><span class="params">                               RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<table> 
 <thead> 
  <tr> 
   <th>参数</th> 
   <th>定义</th> 
   <th>说明</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>corePoolSize</td> 
   <td>核心线程数</td> 
   <td>线程池新建线程的时候，如果当前线程总数小于corePoolSize，则新建的是核心线程，如果超过corePoolSize，则新建的是非核心线程<br>核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)</td> 
  </tr> 
  <tr> 
   <td>maximumPoolSize</td> 
   <td>线程池所能容纳最大线程数</td> 
   <td>线程总数 = 核心线程数 + 非核心线程数<br>当线程总数达到该数值之后，新任务会被阻塞</td> 
  </tr> 
  <tr> 
   <td>keepAliveTime</td> 
   <td>非核心线程 限制超时时长</td> 
   <td>一个非核心线程，如果不干活(闲置状态)的时长超过这个参数所设定的时长，就会被销毁</td> 
  </tr> 
  <tr> 
   <td>unit</td> 
   <td>指定keepAliveTime参数的时间单位</td> 
   <td>枚举类型，keepAliveTime的单位，常用TimeUnit.MILLSECONDS毫秒、TimeUnit.SECOND秒、TimeUnit.MINUTE分</td> 
  </tr> 
  <tr> 
   <td>workQueue</td> 
   <td>任务队列</td> 
   <td>维护着等待执行的Runnable对象<br>当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务</td> 
  </tr> 
  <tr> 
   <td>threadFactory</td> 
   <td>线程工厂</td> 
   <td>在线程池创建新线程的方式，这是一个接口。<br>实例化时需要实现他的Thread newThread(Runnable r)方法</td> 
  </tr> 
  <tr> 
   <td>handler</td> 
   <td>用于抛出异常</td> 
   <td></td> 
  </tr> 
 </tbody> 
</table>

<p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在未来的某个时刻执行给定的任务。这个任务用一个新线程执行，或者用一个线程池中已经存在的线程执行</span></span><br><span class="line"><span class="comment"> * 如果任务无法被提交执行，要么是因为这个Executor已经被shutdown关闭，要么是已经达到其容量上限，任务会被当前的RejectedExecutionHandler处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 1. 如果当前运行线程数&lt; corePoolSize，则开启一个线程执行命令Command</span></span><br><span class="line">    <span class="comment">// Command为该线程执行的第一个命令</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 如果当前线程数&gt;= corePoolSize，则将任务添加到workQueue</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="comment">// 线程入队成功，再次检验校验位（线程池在入队后状态可能会发生变化）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);<span class="comment">// shutdown，则线程池不再接受新任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);<span class="comment">// 当前运行线程数&lt; corePoolSize</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 如果放入workQueue失败（队列满了），则开启一个新的线程执行任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">    	<span class="comment">// 4. 创建线程失败（当前线程数&gt;= maxmumPoolSize || shutdown）,调用reject拒绝接受任务</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 补充 */</span></span><br><span class="line"><span class="comment">// addWorker</span></span><br><span class="line"><span class="comment">// addWorker方法的主要工作是在线程池中创建一个新的线程并执行（如果满足线程池状态和界限），firstTask参数 用于指定新增的线程执行的第一个任务。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	...</span><br><span class="line">	w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">	...</span><br><span class="line">	t.start();	<span class="comment">//启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker.class</span></span><br><span class="line"><span class="comment">// 线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">...</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 从execute方法开始，Worker使用ThreadFactory创建新的工作线程</span></span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 调用runWorker方法执行</span></span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runWorker</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">// runWorker通过getTask不断从 阻塞队列WorkQueue 获取任务，然后执行任务   </span></span><br><span class="line"><span class="comment">// 如果getTask返回null，进入processWorkerExit方法，整个线程结束</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		....</span><br><span class="line">		task.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果workerCount &gt;&#x3D; corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li>
<li>如果workerCount &gt;&#x3D; corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果workerCount &gt;&#x3D; maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。<br><img src="https://mark.cuckooing.cn/pics/pic_365a1389.png" alt="pic_365a1389.png"><br><img src="https://mark.cuckooing.cn/pics/pic_049f15f0.png" alt="pic_049f15f0.png"></li>
</ul>
<h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>[菜鸟教程——AsyncTask][AsyncTask 1]<br>[Android面试系列文章2018之Android部分AsyncTask机制篇][Android_2018_Android_AsyncTask]</p>
<h3 id="是什么？能解决什么问题？"><a href="#是什么？能解决什么问题？" class="headerlink" title="是什么？能解决什么问题？"></a>是什么？能解决什么问题？</h3><p>一个Android已封装好的轻量级异步类，属于抽象类，使用时需要实现子类。<br>它本质上是一个封装了 线程池 和 Handler 的异步框架。</p>
<blockquote>
<p>线程池：缓存线程+复用线程，避免频繁创建 &amp; 销毁线程 所带来的系统开销</p>
</blockquote>
<p>用于：</p>
<ul>
<li>异步任务，如在工作线程中执行耗时任务</li>
<li>消息传递，如实现工作线程 &amp; 主线程 之间通信，即将工作线程处理结果传递给主线程，并在主线程中执行相关UI操作</li>
<li>和Handler一样用于处理异步任务，不过相对于前者，AsyncTask代码量更为轻量级，且后台是一个线程池，在异步任务数据比较庞大时更有优势。且使用更为简便、快捷。</li>
</ul>
<h3 id="三个泛型参数作用-四个方法？每个方法在哪个线程执行？"><a href="#三个泛型参数作用-四个方法？每个方法在哪个线程执行？" class="headerlink" title="三个泛型参数作用 &amp; 四个方法？每个方法在哪个线程执行？"></a>三个泛型参数作用 &amp; 四个方法？每个方法在哪个线程执行？</h3><ol>
<li>三个参数<br>当定义一个类来继承AsyncTask这个类时，需要为其指定3个泛型参数，用来控制AsyncTask子类执行线程各个任务时各个阶段的返回类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AsyncTask</span>&lt;Params, Progress, Result&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table> 
 <thead> 
  <tr> 
   <th>参数</th> 
   <th>说明</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>Params</td> 
   <td>开始异步任务执行时传入的参数类型，对应execute(params)中传递的参数</td> 
  </tr> 
  <tr> 
   <td>Progress</td> 
   <td>异步任务执行过程中，返回下载进度值的类型</td> 
  </tr> 
  <tr> 
   <td>Result</td> 
   <td>异步任务执行完成后，返回的结果类型，与doInBackground()的返回值类型保持一致</td> 
  </tr> 
 </tbody> 
</table>

<p>不需要指定类型时可以写成void<br>2. 四个方法<br>在主线程中执行异步任务时myAsyncTask.execute(params)时，AsyncTask会按照如下四个步骤分别执行</p>
<table> 
 <thead> 
  <tr> 
   <th>方法名</th> 
   <th>作用</th> 
   <th>调用时期</th> 
   <th>所在线程</th> 
   <th>说明</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>onPreExecute()</td> 
   <td>执行异步任务前的操作</td> 
   <td>执行 异步任务前自动调用</td> 
   <td>主线程</td> 
   <td>用于UI组件初始化操作，如显示进度条对话框</td> 
  </tr> 
  <tr> 
   <td>*doInBackground(Params params)</td> 
   <td>执行异步任务（接收输入参数并返回异步任务执行结果）</td> 
   <td>onPreExecute执行结束后，开始执行 异步任务时自动调用</td> 
   <td>子线程（后台线程池中开启一个工作线程执行）</td> 
   <td>执行网络请求等耗时操作</td> 
  </tr> 
  <tr> 
   <td>onProgressUpdate(Progress values)</td> 
   <td>在主线程中显示 工作线程任务执行的进度</td> 
   <td>当任务状态发生变化时（通过publishProgress方法）自动调用</td> 
   <td>主线程</td> 
   <td>在doInBackground中调用publishProgress(Progress) 的方法来将我们的进度实时传递给 onProgressUpdate 方法来更新</td> 
  </tr> 
  <tr> 
   <td>onPostExecute(Result result)</td> 
   <td>接收异步任务执行结果，并将结果显示到UI组件</td> 
   <td>异步任务执行结束时自动调用</td> 
   <td>主线程</td> 
   <td>显示异步任务处理结果</td> 
  </tr> 
 </tbody> 
</table>

<ol>
<li>基本使用</li>
</ol>
<ul>
<li>创建AsyncTask子类，为3个泛型参数指定类型；若不使用，可用void类型代替。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">AsyncTask</span>&lt;String, Integer, String&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法1：onPreExecute（）</span></span><br><span class="line">        <span class="comment">// 作用：执行 线程任务前的操作</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPreExecute</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            text.setText(<span class="string">&quot;加载中&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行前显示提示</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法2：doInBackground（）</span></span><br><span class="line">        <span class="comment">// 作用：接收输入参数、执行任务中的耗时操作、返回 线程任务执行的结果</span></span><br><span class="line">        <span class="comment">// 此处通过计算从而模拟“加载进度”的情况</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> String <span class="title function_">doInBackground</span><span class="params">(String... params)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (count&lt;<span class="number">99</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                    count += length;</span><br><span class="line">                    <span class="comment">// 可调用publishProgress（）显示进度, 之后将执行onProgressUpdate（）</span></span><br><span class="line">                    publishProgress(count);</span><br><span class="line">                    <span class="comment">// 模拟耗时任务</span></span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法3：onProgressUpdate（）</span></span><br><span class="line">        <span class="comment">// 作用：在主线程 显示线程任务执行的进度</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onProgressUpdate</span><span class="params">(Integer... progresses)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">            progressBar.setProgress(progresses[<span class="number">0</span>]);</span><br><span class="line">            text.setText(<span class="string">&quot;loading...&quot;</span> + progresses[<span class="number">0</span>] + <span class="string">&quot;%&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法4：onPostExecute（）</span></span><br><span class="line">        <span class="comment">// 作用：接收线程任务执行结果、将执行结果显示到UI组件</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPostExecute</span><span class="params">(String result)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// 执行完毕后，则更新UI</span></span><br><span class="line">            text.setText(<span class="string">&quot;加载完毕&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法5：onCancelled()</span></span><br><span class="line">        <span class="comment">// 作用：将异步任务设置为：取消状态</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCancelled</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">            text.setText(<span class="string">&quot;已取消&quot;</span>);</span><br><span class="line">            progressBar.setProgress(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建Async子类的实例对象（任务实例）。必须在UI线程中创建，且同一个AsyncTask实例对象只能执行1次，若执行第2次会抛出异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyTask</span> <span class="variable">mTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>手动调用execute（）从而执行异步线程任务，必须在UI线程中调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTask.execute()；</span><br></pre></td></tr></table></figure>

<h3 id="实现原理？"><a href="#实现原理？" class="headerlink" title="实现原理？"></a>实现原理？</h3><p>[黑马视频：AsyncTask 源码][AsyncTask 2]<br>[Carson_Ho：AsyncTask的原理 及其源码分析][Carson_Ho_AsyncTask_]<br>AsyncTask基本使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title class_">AsyncTask</span>&lt;String,Integer,Bitmap&gt;&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPreExecute</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onPreExecute();</span><br><span class="line">        <span class="comment">//这里是在异步操作之前执行，运行在UI线程，一般显示给用户：此时即将要去加载图片了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">doInBackground</span><span class="params">(java.lang.String... strings)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//这里执行耗时操作，运行在子线程，如网络请求图片的操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onProgressUpdate</span><span class="params">(Integer... values)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//此方法运行于UI线程,一般用来更新进度</span></span><br><span class="line">        <span class="comment">//progressBar.setProgress(values[0]);</span></span><br><span class="line">        <span class="built_in">super</span>.onProgressUpdate(values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPostExecute</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">       	<span class="comment">//此方法中result是doInBackground执行完成后返回的，而且此方法运行在UI线程，更新UI</span></span><br><span class="line">        <span class="built_in">super</span>.onPostExecute(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	MyAsyncTask.execute(<span class="string">&quot;params&quot;</span>);	<span class="comment">// AsyncTask调用execute，开始执行异步任务</span></span><br></pre></td></tr></table></figure>

<p>手动调用execute（Params… params），开始执行异步任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title function_">execute</span><span class="params">(Params... params)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// sDefaultExecutor = 任务队列 线程池类（SerialExecutor）的对象</span></span><br><span class="line">		<span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title function_">executeOnExecutor</span><span class="params">(Executor exec, Params... params)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="comment">// execute只能调用一次，若要多次执行任务，需创建新的AsyncTask</span></span><br><span class="line">    	<span class="comment">// 1. 判断AsyncTask当前执行状态</span></span><br><span class="line">        <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">case</span> RUNNING:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                            + <span class="string">&quot; the task is already running.&quot;</span>);</span><br><span class="line">                <span class="keyword">case</span> FINISHED:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                            + <span class="string">&quot; the task has already been executed &quot;</span></span><br><span class="line">                            + <span class="string">&quot;(a task can be executed only once)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mStatus = Status.RUNNING;</span><br><span class="line">        <span class="comment">// 2.onPreExecute() 方法在主线程中运行</span></span><br><span class="line">        <span class="comment">// 主线程中调用execute方法，execute中调用onPreExecute(),因此该方法也在主线程中运行</span></span><br><span class="line">        onPreExecute();</span><br><span class="line">        <span class="comment">// 3.添加参数到任务中</span></span><br><span class="line">        <span class="comment">// mWorker.mParams 保存了execute(params)方法中的参数</span></span><br><span class="line">        <span class="comment">// *补充1 mWorker 可理解为当前任务对象</span></span><br><span class="line">        <span class="comment">// mWorker 为 Callable 类型对象，实例化时复写call()方法，调用doInBackground(params)</span></span><br><span class="line">        <span class="comment">// mWorker 实例化 --&gt; Async构造方法</span></span><br><span class="line">        mWorker.mParams = params;</span><br><span class="line">        <span class="comment">// 4.执行任务</span></span><br><span class="line">        <span class="comment">// #补充2：mFutrue 可理解为当前任务的包装对象</span></span><br><span class="line">        <span class="comment">// mFuture 继承自 FutureTask</span></span><br><span class="line">        <span class="comment">// FutureTask 为Runnable 类型对象，保存callable类型变量（mWorker）</span></span><br><span class="line">        <span class="comment">// 实例化复写run方法，执行mWorker.call(),调用doInBackground(params)</span></span><br><span class="line">        <span class="comment">// 即在线程池的子线程中执行doInBackground,因此doInBackground在子线程中执行</span></span><br><span class="line">        <span class="comment">// *补充3：</span></span><br><span class="line">        <span class="comment">// 此处的exec = sDefaultExecutor = 任务队列 线程池类（SerialExecutor）的对象</span></span><br><span class="line">        <span class="comment">// 从线程池中取线程 mFuture 并执行mFuture的run方法</span></span><br><span class="line">        exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 补充1 WorkerRunnable类的构造函数</span></span><br><span class="line">	<span class="comment">// 		private final WorkerRunnable&lt;Params, Result&gt; mWorker;</span></span><br><span class="line">	<span class="comment">// 		private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123;</span></span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="comment">// 		// Callable也是任务;与Runnable区别：Callable&lt;T&gt;存在返回值=其泛型</span></span><br><span class="line">    <span class="comment">//    		Params[] mParams;</span></span><br><span class="line">    <span class="comment">//		&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 补充2 FutureTask类的构造函数（一个包装任务的包装类）</span></span><br><span class="line">    <span class="comment">// private final FutureTask&lt;Result&gt; mFuture;</span></span><br><span class="line">    <span class="comment">// public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;</span></span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//    	public FutureTask(Callable&lt;V&gt; callable) &#123;</span></span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//   	if (callable == null)</span></span><br><span class="line">    <span class="comment">//        	throw new NullPointerException();</span></span><br><span class="line">    <span class="comment">//    	this.callable = callable;</span></span><br><span class="line">    <span class="comment">//    	this.state = NEW;       </span></span><br><span class="line">   	<span class="comment">// 	&#125;</span></span><br><span class="line">   	<span class="comment">// public void run() &#123;</span></span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">   	<span class="comment">//	... 调用callable(mWorker)的call方法，执行doInBackground,并活动返回值</span></span><br><span class="line">   	<span class="comment">//  result = c.call();</span></span><br><span class="line">   	<span class="comment">//	... 处理返回值，set(result)内部最终会调用FutureTask的done()</span></span><br><span class="line">   	<span class="comment">//	set(result);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 补充3：</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：exec.execute(mFuture)</span></span><br><span class="line"><span class="comment">  * 说明：属于任务队列 线程池类（SerialExecutor）的方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SerialExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// SerialExecutor = 静态内部类</span></span><br><span class="line">        <span class="comment">// 即 是所有实例化的AsyncTask对象公有的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// SerialExecutor 内部维持了1个双向队列；</span></span><br><span class="line">        <span class="comment">// 容量根据元素数量调节</span></span><br><span class="line">        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Runnable&gt;();</span><br><span class="line">        Runnable mActive;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execute（）被同步锁synchronized修饰</span></span><br><span class="line">        <span class="comment">// 即说明：通过锁使得该队列保证AsyncTask中的任务是串行执行的</span></span><br><span class="line">        <span class="comment">// 即 多个任务需1个个加到该队列中；然后 执行完队列头部的再执行下一个，以此类推</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// 将实例化后的FutureTask类 的实例对象传入</span></span><br><span class="line">            <span class="comment">// 即相当于：向队列中加入一个新的任务</span></span><br><span class="line">            mTasks.offer(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        r.run();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        scheduleNext();-&gt;&gt;分析<span class="number">2</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 若当前无任务执行，则去队列中取出1个执行</span></span><br><span class="line">            <span class="keyword">if</span> (mActive == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                scheduleNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分析2</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">scheduleNext</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// 1. 取出队列头部任务</span></span><br><span class="line">            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 执行取出的队列头部任务</span></span><br><span class="line">                <span class="comment">// 即 调用执行任务线程池类（THREAD_POOL_EXECUTOR）</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：THREAD_POOL_EXECUTOR.execute（）</span></span><br><span class="line"><span class="comment">  * 说明：</span></span><br><span class="line"><span class="comment">  *     a. THREAD_POOL_EXECUTOR实际上是1个已配置好的可执行并行任务的线程池</span></span><br><span class="line"><span class="comment">  *     b. 调用THREAD_POOL_EXECUTOR.execute（）实际上是调用线程池的execute()去执行具体耗时任务</span></span><br><span class="line"><span class="comment">  *     c. 而该耗时任务则是初始化WorkerRunnable实例对象时复写的call（）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>AsyncTask构造方法</p>
<ul>
<li>创建了1个WorkerRunnable类 的实例对象 &amp; 复写了call()方法</li>
<li>创建了1个FutureTask类 的实例对象 &amp; 复写了 done()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AsyncTask</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 1. 初始化WorkerRunnable变量mWorker = 一个可存储参数的Callable对象</span></span><br><span class="line">    <span class="comment">// 复写call()方法,调用doInBackground(params)</span></span><br><span class="line">        mWorker = <span class="keyword">new</span> <span class="title class_">WorkerRunnable</span>&lt;Params, Result&gt;() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">public</span> Result <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                mTaskInvoked.set(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                    <span class="comment">// 执行异步操作 = 耗时操作,即 我们使用过程中复写的耗时任务</span></span><br><span class="line">                    result = doInBackground(mParams);</span><br><span class="line">                    Binder.flushPendingCommands();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    mCancelled.set(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">throw</span> tr;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    postResult(result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="comment">// 2. 初始化FutureTask变量 = 1个FutureTask</span></span><br><span class="line">        mFuture = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 结束doInBackground(params)后获得返回值会调用done</span></span><br><span class="line">        <span class="comment">// done（）简介：FutureTask内的Callable执行完后的调用方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">done</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="comment">// get()函数获取返回值result</span></span><br><span class="line">                <span class="comment">// *postResultIfNotInvoked调用postResult(result)</span></span><br><span class="line">                <span class="comment">// 即将执行完成的任务结果通过InternalHandler传递到UI进程</span></span><br><span class="line">                    postResultIfNotInvoked(get());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;An error occurred while executing doInBackground()&quot;</span>,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    postResultIfNotInvoked(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 任务的结果result和任务标识MESSAGE_POST_RESULT通过InternalHandler传递到UI线程</span></span><br><span class="line">	<span class="keyword">private</span> Result <span class="title function_">postResult</span><span class="params">(Result result)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="comment">// 创建Handler对象 -&gt;&gt; 源自InternalHandler类</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AsyncTaskResult</span>&lt;Result&gt;(<span class="built_in">this</span>, result));</span><br><span class="line">        <span class="comment">// 发送消息到Handler中</span></span><br><span class="line">        message.sendToTarget();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>InternalHandler 接收 子线程 发送消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">(Result result)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            onCancelled(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// Handler 实现</span></span><br><span class="line">        <span class="comment">// onPostExecute(result)运行在主线程</span></span><br><span class="line">            onPostExecute(result);</span><br><span class="line">        &#125;</span><br><span class="line">        mStatus = Status.FINISHED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InternalHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">InternalHandler</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="built_in">super</span>(Looper.getMainLooper());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;</span></span><br><span class="line"><span class="meta">   </span></span><br><span class="line"><span class="meta">     </span></span><br><span class="line"><span class="meta">     &quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                    <span class="comment">// 若收到的消息 = MESSAGE_POST_RESULT</span></span><br><span class="line">                	<span class="comment">// 则通过finish() 将结果通过Handler传递到主线程</span></span><br><span class="line">                    result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                	<span class="comment">// 若收到的消息 = MESSAGE_POST_PROGRESS</span></span><br><span class="line">                	<span class="comment">// 则回调onProgressUpdate()通知主线程更新进度的操作</span></span><br><span class="line">                    result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>源码流程图<br><img src="https://mark.cuckooing.cn/pics/pic_ffb1217f.png" alt="pic_ffb1217f.png"><br><img src="https://mark.cuckooing.cn/pics/pic_d254da96.png" alt="pic_d254da96.png"><br><img src="https://mark.cuckooing.cn/pics/pic_0d4c9a6e.png" alt="pic_0d4c9a6e.png"><br>总结</p>
<ol>
<li>AsyncTask派生出的子类可以实现不同的异步任务，每个异步任务均提交到线程池中执行，且只能执行一次（执行多次会出现异常）</li>
<li>需要执行一个异步任务时，AsyncTask在主线程中调用execute方法。execute中会首先调用onPreExecute，因此这个方法在主线程中执行。</li>
<li>接着，AsyncTask从线程池中取处一个子线程执行doInBackground方法来执行异步的任务，因此这个方法在子线程中执行。</li>
<li>任务执行完成后，AsyncTask会获取结果后并通过Handler向主线程发送消息，AsyncTask内部的InternalHandler收到消息并调用onPostExecute，因此这个方法在主线程中执行。</li>
</ol>
<h3 id="不足之处-解决方法？"><a href="#不足之处-解决方法？" class="headerlink" title="不足之处 &amp; 解决方法？"></a>不足之处 &amp; 解决方法？</h3><ul>
<li>内存泄漏:<br>如果AsyncTask被声明为Activity的非静态的内部类，那么AsyncTask会保留一个对创建了AsyncTask的Activity的引用。如果Activity已经被销毁，AsyncTask的后台线程还在执行，它将继续在内存里保留这个引用，导致Activity无法被回收，引起内存泄露。<br>解决方法很简单，让内部持有外部的弱引用即可解决</li>
<li>生命周期<br>在Activity的onDestory()中及时对AsyncTask进行回收，调用其cancel()方法来保证程序的稳定性。</li>
<li>结果丢失<br>当屏幕旋转或内存不足时，当前的Activity被回收，如果此时AsyncTask被声明为Activity的非静态内部类，由于AsyncTask持有的是回收之前Activity的引用，导致AsyncTask更新的结果对象为一个无效的Activity的引用，这就是结果丢失。</li>
<li>并行或串行<br>在1.6(Donut)之前: 在第一版的AsyncTask，任务是串行调度。一个任务执行完成另一个才能执行。由于串行执行任务，使用多个AsyncTask可能会带来有些问题。所以这并不是一个很好的处理异步（尤其是需要将结果作用于UI试图）操作的方法。1.6-2.3： 所有的任务并发执行，这会导致一种情况，就是其中一条任务执行出问题了，会引起其他任务出现错误。3.0之后AsyncTask又修改为了顺序执行，并且新添加了一个函数 executeOnExecutor(Executor)，如果您需要并行执行，则只需要调用该函数，并把参数设置为并行执行即可。</li>
</ul>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><h3 id="子线程一定不能更新UI吗？为什么Android系统不建议子线程访问UI？"><a href="#子线程一定不能更新UI吗？为什么Android系统不建议子线程访问UI？" class="headerlink" title="子线程一定不能更新UI吗？为什么Android系统不建议子线程访问UI？"></a>子线程一定不能更新UI吗？为什么Android系统不建议子线程访问UI？</h3><p>[为什么不能在子线程中更新UI？][UI]<br>子线程可以更新UI（在系统还未检测当前更新UI的线程是否是UI线程之前执行操作）<br>谷歌提出：“UI更新一定要在UI线程里实现” 这一规则原因如下：<br>目的在于提高移动端更新UI的效率和和安全性，以此带来流畅的体验。原因是：<br>Android的UI访问是没有加锁的，多个线程可以同时访问更新操作同一个UI控件。也就是说访问UI的时候，android系统当中的控件都不是线程安全的，这将导致在多线程模式下，当多个线程共同访问更新操作同一个UI控件时容易发生不可控的错误，而这是致命的。<br>所以Android中规定只能在UI线程中访问UI，这相当于从另一个角度给Android的UI访问加上锁，一个伪锁。</p>
<h3 id="定义-作用-六大概念"><a href="#定义-作用-六大概念" class="headerlink" title="定义 &amp; 作用 &amp; 六大概念"></a>定义 &amp; 作用 &amp; 六大概念</h3><ol>
<li>定义<br>一种Android消息传递&#x2F;异步通信机制</li>
<li>作用<br>在多线程的应用场景中，将工作线程中需更新UI的操作信息 传递到 UI主线程，从而实现 工作线程对UI的更新处理，保证多线程并发更新UI时 线程安全，实现异步消息的处理。</li>
<li>六大概念</li>
</ol>
<table> 
 <thead> 
  <tr> 
   <th>概念</th> 
   <th>定义</th> 
   <th>作用</th> 
   <th>说明</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>主线程/UI线程<br>Main Thread</td> 
   <td>当一个程序启动时，就有一个进程被操作系统（OS）创建，与此同时一个线程也立刻运行，该线程通常叫做程序的主线程</td> 
   <td>用于处理UI相关的事件</td> 
   <td>Android OS中，一个进程被创建之后，同时会自动开启一条主线程（当前Activity），主线程创建一个Looper和一个MessageQueue</td> 
  </tr> 
  <tr> 
   <td>子线程/工作线程<br>Work Thread</td> 
   <td>手动开启的线程</td> 
   <td>用于执行耗时操作，如网络请求、数据加载等</td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>消息<br>Message</td> 
   <td>线程间通讯的数据单元（Handler 发送 &amp; 响应的消息对象）</td> 
   <td>存储子线程发送给UI线程的通信信息</td> 
   <td></td> 
  </tr> 
  <tr> 
   <td>消息队列<br>Message Queue</td> 
   <td>用来存放Message对象的数据结构</td> 
   <td>用来存放Handler发送过来的消息，不按照FIFO规则执行，而是将Message以单链表的方式串联起来的（适用于插入消息MessageQueue.enqueue和取出MessageQueue.next），等待Looper的抽取<br>维护所有顶层应用对象(Activities, Broadcast receivers等)以及主线程创建的窗口</td> 
   <td>MessageQueue对象不需要手动创建，而是由Looper对象对其进行管理，一个线程最多只可以拥有一个MessageQueue</td> 
  </tr> 
  <tr> 
   <td>循环器<br>Looper</td> 
   <td>MessageQueue的管理者<br>MessageQueue与Handler通信媒介</td> 
   <td>消息循环，包括<br>消息获取：循环取出消息队列MessageQueue中消息<br>消息分发：将取出的消息发送给对应的处理者Handler</td> 
   <td>在一个线程中，如果存在Looper对象，则必定存在MessageQueue对象，并且只存在一个Looper对象和一个MessageQueue对象。在Android系统中，除了主线程有默认的Looper对象，其它线程默认是没有Looper对象。如果想让我们新创建的线程拥有Looper对象时，我们首先应调用Looper.prepare()方法，然后再调用Looper.loop()方法</td> 
  </tr> 
  <tr> 
   <td>处理者<br>Handler</td> 
   <td>消息的处理者<br>主线程与子线程的通信媒介</td> 
   <td>Handler的作用是把消息加入特定（主线程）的消息队列中:Handler.sendMessage<br>处理Looper分发过来的消息:Handler.dispatchMessage</td> 
   <td></td> 
  </tr> 
 </tbody> 
</table>

<p>MessageQueue，Handler和Looper三者之间的关系<br>一个线程Thread绑定一个循环器Looper和一个消息队列MessageQueue，对应多个处理者Handler。MessageQueue可以存放来自不同Handler发送的消息，Looper可以将消息分发给对应的Handler进行处理。</p>
<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><p>步骤1：（自定义）新创建Handler子类(继承Handler类) &amp; 复写handleMessage（）方法<br>步骤2：在主线程中创建Handler实例<br>步骤3：创建工作线程（AsyncTask、Thread、Runnable）处理耗时操作，并创建需要发送的消息对象Message，并通过引用主线程的Handler发送<br>步骤4：开启工作线程</p>
<p>Handler使用方式 因发送消息到消息队列的方式不同而不同，共分为2种：使用Handler.sendMessage（）、使用Handler.post（）</p>
<ul>
<li>sendMessage(Message msg) 发送一个消息对象到消息队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤1：（自定义）新创建Handler子类(继承Handler类) &amp; 复写handleMessage（）方法</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Mhandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过复写handlerMessage() 从而确定更新UI的操作</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// 根据不同线程发送过来的消息，执行不同的UI操作</span></span><br><span class="line">            <span class="comment">// 根据 Message对象的what属性 标识不同的消息</span></span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    mTextView.setText(<span class="string">&quot;执行了线程1的UI操作&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    mTextView.setText(<span class="string">&quot;执行了线程2的UI操作&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mTextView = (TextView) findViewById(R.id.show);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤2：在主线程中创建Handler实例</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Mhandler</span>();</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 采用继承Thread类实现多线程演示</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 步骤3：创建所需的消息对象</span></span><br><span class="line">                 <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">                 msg.what = <span class="number">1</span>; <span class="comment">// 消息标识</span></span><br><span class="line">                 msg.obj = <span class="string">&quot;A&quot;</span>; <span class="comment">// 消息内存存放</span></span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 步骤4：在工作线程中 通过Handler发送消息到消息队列中</span></span><br><span class="line">                 mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">// 步骤5：开启工作线程（同时启动了Handler）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处用2个工作线程展示</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 通过sendMessage（）发送</span></span><br><span class="line">                 <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                 <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">                 msg.what = <span class="number">2</span>; <span class="comment">//消息的标识</span></span><br><span class="line">                 msg.obj = <span class="string">&quot;B&quot;</span>; <span class="comment">// 消息的存放</span></span><br><span class="line">                 <span class="comment">// b. 通过Handler发送消息到其绑定的消息队列</span></span><br><span class="line">                 mHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>post(Runnable r) 将一个线程加入线程队列。</li>
<li>post不需要外部创建消息对象，而是内部根据传入的Runnable对象封装消息对象并通过sendMessageDelayed(getPostMessege®)放入消息队列。并通过复写Runnable对象的run()通过回调处理消息。</li>
<li>本质上，post内部是使用sendMessage实现，他们本质上没有区别。post使用更为简单。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TextView mTextView;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mTextView = (TextView) findViewById(R.id.show);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤1：在主线程中创建Handler实例</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤2：在工作线程中 发送消息到消息队列中 &amp; 指定操作UI内容</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 通过psot（）发送，需传入1个Runnable对象</span></span><br><span class="line">                mHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        <span class="comment">// 指定操作UI内容</span></span><br><span class="line">                        mTextView.setText(<span class="string">&quot;执行了线程1的UI操作&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">// 步骤3：开启工作线程（同时启动了Handler）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处用2个工作线程展示</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                mHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        mTextView.setText(<span class="string">&quot;执行了线程2的UI操作&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Android-消息机制（工作原理-源码分析）"><a href="#Android-消息机制（工作原理-源码分析）" class="headerlink" title="Android 消息机制（工作原理 &amp; 源码分析）"></a>Android 消息机制（工作原理 &amp; 源码分析）</h3><ul>
<li>工作原理<br>Handler 机制的工作流程主要包括4个步骤：异步通信准备 → 消息发送 → 消息循环 → 消息处理</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>步骤</th> 
   <th>说明</th> 
   <th>备注</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>异步通信准备</td> 
   <td>在主线程中创建 循环器Looper 对象、消息队列MessageQueue 对象、Handler 对象</td> 
   <td>三者均位于主线程<br>当MessageQueue创建后，Looper自动进入消息循环<br>此时Handler 自动绑定了 Looper 和 MessageQueue</td> 
  </tr> 
  <tr> 
   <td>消息发送</td> 
   <td>工作线程 通过Handler 发送消息Message 到消息队列MessageQueue中</td> 
   <td>消息内容一般是UI操作<br>发送消息通过Handler.sendMessage(Message msg)和Handler.post(Runnable r)发送<br>入队一般通过MessageQueue.enqueueMessage(Message)处理</td> 
  </tr> 
  <tr> 
   <td>消息循环</td> 
   <td>包括 消息出队 和 消息分发 两个步骤<br>消息出队：Looper循环取出消息队列MessageQueue中的消息Message<br>消息分发：Looper将取出的消息Message发送给创建消息的处理者Handler</td> 
   <td>如果在消息循环的过程中，消息队列MessageQueue为空队列时，线程阻塞</td> 
  </tr> 
  <tr> 
   <td>消息处理</td> 
   <td>消息处理者Handler 接受 Looper 发送过来的消息Message，并根据Messge进行UI操作</td> 
   <td></td> 
  </tr> 
 </tbody> 
</table>

<p><img src="https://mark.cuckooing.cn/pics/pic_09d1a3a0.png" alt="pic_09d1a3a0.png"><br><img src="https://mark.cuckooing.cn/pics/pic_f005a758.png" alt="pic_f005a758.png"></p>
<ul>
<li>源码分析<br>[黑马：Handler源码分析][Handler 1]<br>[Carson_Ho：深入详解Handler机制源码][Carson_Ho_Handler]<br><img src="https://mark.cuckooing.cn/pics/pic_f2cdb65b.png" alt="pic_f2cdb65b.png"><br><img src="https://mark.cuckooing.cn/pics/pic_f971e128.png" alt="pic_f971e128.png"><br>Handler.sendMessage(Message msg)<br>基本用法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 此处以 匿名内部类 的使用方式为例</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 步骤1：在主线程中 通过匿名内部类 创建Handler类对象</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">mhandler</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Handler</span>()&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="comment">// 通过复写handlerMessage()从而确定更新UI的操作</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        ...<span class="comment">// 需执行的UI操作</span></span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 步骤2：创建消息对象</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(); <span class="comment">// 实例化消息对象</span></span><br><span class="line">	msg.what = <span class="number">1</span>; <span class="comment">// 消息标识</span></span><br><span class="line">	msg.obj = <span class="string">&quot;AA&quot;</span>; <span class="comment">// 消息内容存放</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 步骤3：在工作线程中 通过Handler发送消息到消息队列中</span></span><br><span class="line">  <span class="comment">// 多线程可采用AsyncTask、继承Thread类、实现Runnable</span></span><br><span class="line">   mHandler.sendMessage(msg)</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤1：在主线程中 通过匿名内部类 创建Handler类对象</li>
<li>当创建Handler对象时，则通过 构造方法 自动关联当前线程的Looper对象 &amp; 对应的消息队列对象（MessageQueue），从而 自动绑定了 实现创建Handler对象操作的线程</li>
<li>实例化Handler对象需要复写handleMessage(Message msg)方法，对Looper分发的Message进行处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 具体使用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">mhandler</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Handler</span>()&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 通过复写handlerMessage()从而确定更新UI的操作</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                ...<span class="comment">// 需执行的UI操作</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 源码分析：Handler的构造方法</span></span><br><span class="line"><span class="comment">  * 作用：初始化Handler对象 &amp; 绑定线程</span></span><br><span class="line"><span class="comment">  * 注：</span></span><br><span class="line"><span class="comment">  *   a. Handler需绑定 线程才能使用；绑定后，Handler的消息处理会在绑定的线程中执行</span></span><br><span class="line"><span class="comment">  *   b. 绑定方式 = 先指定Looper对象，从而绑定了 Looper对象所绑定的线程（因为Looper对象本已绑定了对应线程）</span></span><br><span class="line"><span class="comment">  *   c. 即：指定了Handler对象的 Looper对象 = 绑定到了Looper对象所在的线程</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="built_in">this</span>(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// -&gt;&gt;分析1</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 分析1：this(null, false) = Handler（null，false）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">	        ...<span class="comment">// 仅贴出关键代码</span></span><br><span class="line"></span><br><span class="line">	        	<span class="comment">// 1. 指定Looper对象</span></span><br><span class="line">	            mLooper = Looper.myLooper();</span><br><span class="line">	            <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">	                    <span class="string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="comment">// Looper.myLooper()作用：获取当前线程的Looper对象；若线程无Looper对象则抛出异常</span></span><br><span class="line">	            <span class="comment">// 即 ：若线程中无创建Looper对象，则也无法创建Handler对象（并抛出异常）</span></span><br><span class="line">	            <span class="comment">// 故 若需在子线程中创建Handler对象，则需先创建Looper对象</span></span><br><span class="line">	            <span class="comment">// 主线程中会自动创建Looper对象</span></span><br><span class="line"></span><br><span class="line">	        	<span class="comment">// 2. 绑定消息队列对象（MessageQueue）</span></span><br><span class="line">	            mQueue = mLooper.mQueue;</span><br><span class="line">	            <span class="comment">// 获取该Looper对象中保存的消息队列对象（MessageQueue）</span></span><br><span class="line">	            <span class="comment">// 至此，保证了handler对象 关联上 Looper对象中MessageQueue</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤1前隐式操作：创建循环器Looper &amp; 循环队列MessageQueue 并进行 消息循环</li>
<li>创建循环器Looper &amp; 循环队列MessageQueue</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 源码分析1：Looper.prepare()</span></span><br><span class="line"><span class="comment">  * 作用：为当前线程（子线程） 创建1个循环器对象（Looper），同时也生成了1个消息队列对象（MessageQueue）</span></span><br><span class="line"><span class="comment">  * 注：需在子线程中手动调用该方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">	    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">// 1. 判断sThreadLocal是否为null，否则抛出异常</span></span><br><span class="line">	    <span class="comment">//即 Looper.prepare()方法不能被调用两次 = 1个线程中只能对应1个Looper实例</span></span><br><span class="line">	    <span class="comment">// 注：sThreadLocal = 1个ThreadLocal对象，是线程本地存储区，用于存储线程的变量</span></span><br><span class="line"></span><br><span class="line">	    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(<span class="literal">true</span>));</span><br><span class="line">	    <span class="comment">// 2. 若为初次Looper.prepare()，则创建Looper对象 &amp; 存放在ThreadLocal变量中</span></span><br><span class="line">	    <span class="comment">// 注：Looper对象是存放在Thread线程里的</span></span><br><span class="line">	    <span class="comment">// 源码分析Looper的构造方法-&gt;&gt;分析a</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">	* 分析a：Looper的构造方法</span></span><br><span class="line"><span class="comment">	* 创建Looper 同时会自动创建一个消息队列对象MessageQueue</span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">	        mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">	        <span class="comment">// 1. 创建1个消息队列对象（MessageQueue）</span></span><br><span class="line">	        <span class="comment">// 即 当创建1个Looper实例时，会自动创建一个与之配对的消息队列对象（MessageQueue）</span></span><br><span class="line"></span><br><span class="line">	        mRun = <span class="literal">true</span>;</span><br><span class="line">	        mThread = Thread.currentThread();</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 源码分析2：Looper.prepareMainLooper()</span></span><br><span class="line"><span class="comment">  * 作用：为 主线程（UI线程） 创建1个循环器对象（Looper），同时也生成了1个消息队列对象（MessageQueue）</span></span><br><span class="line"><span class="comment">  * 注：该方法在主线程（UI线程）创建时自动调用，即 主线程的Looper对象自动生成，不需手动生成</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="comment">// 在Android应用进程启动时，会默认创建1个主线程（ActivityThread，也叫UI线程）</span></span><br><span class="line">	<span class="comment">// 创建时，会自动调用ActivityThread的1个静态的main（）方法 = 应用程序的入口</span></span><br><span class="line">	<span class="comment">// main（）内则会调用Looper.prepareMainLooper()为主线程生成1个Looper对象</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">/** </span></span><br><span class="line"><span class="comment">	    * 源码分析：main（）</span></span><br><span class="line"><span class="comment">	    **/</span></span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	        ... <span class="comment">// 仅贴出关键代码</span></span><br><span class="line"></span><br><span class="line">	        Looper.prepareMainLooper(); </span><br><span class="line">	        <span class="comment">// 1. 为主线程创建1个Looper对象，同时生成1个消息队列对象（MessageQueue）</span></span><br><span class="line">	        <span class="comment">// 方法逻辑类似Looper.prepare()</span></span><br><span class="line">	        <span class="comment">// 注：prepare()：为子线程中创建1个Looper对象</span></span><br><span class="line">	        </span><br><span class="line">	        </span><br><span class="line">	        <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>(); </span><br><span class="line">	        <span class="comment">// 2. 创建主线程</span></span><br><span class="line"></span><br><span class="line">	        Looper.loop(); </span><br><span class="line">	        <span class="comment">// 3. 自动开启 消息循环 -&gt;&gt;下面将详细分析</span></span><br><span class="line"></span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建主线程时，会自动调用ActivityThread的1个静态的main（）；而main（）内则会调用Looper.prepareMainLooper()为主线程生成1个Looper对象，同时也会生成其对应的MessageQueue对象</li>
<li>生成Looper &amp; MessageQueue对象后，则会自动进入消息循环：Looper.loop（）</li>
</ul>
<blockquote>
<ol>
<li>主线程的Looper对象自动生成，不需手动生成；而子线程的Looper对象则需手动通过Looper.prepare()创建</li>
<li>在子线程若不手动创建Looper对象 则无法生成Handler对象</li>
<li>根据Handler的作用（在主线程更新UI），故Handler实例的创建场景 主要在主线程</li>
</ol>
</blockquote>
<ul>
<li>消息循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 源码分析： Looper.loop()</span></span><br><span class="line"><span class="comment">  * 作用：消息循环，即不断从消息队列MessageQueue中获取消息Message、并分发消息到Handler，知道消息为空时退出循环</span></span><br><span class="line"><span class="comment">  * 特别注意：</span></span><br><span class="line"><span class="comment">  *       a. 主线程的消息循环不允许退出，即无限循环</span></span><br><span class="line"><span class="comment">  *       b. 子线程的消息循环允许退出：调用消息队列MessageQueue的quit（）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        ...<span class="comment">// 仅贴出关键代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取当前Looper的消息队列（MessageQueue）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line">        <span class="comment">// 2. 消息循环（通过for循环 =&gt; 死循环：主线程保持不退出原因）</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// 2.1 从消息队列中取出消息</span></span><br><span class="line">            <span class="comment">// 消息队列的顺序维护使用单链表形式维护的，将消息队列中第一条数据取出来，并将第二条数据编程第一条</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); </span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     	</span><br><span class="line">            <span class="comment">// 若取出的消息为空，则线程阻塞，退出循环</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.2 获取msg的目标Handler,分发消息Message到对应的Handler</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            <span class="comment">// 把消息Message派发给消息对象msg的target属性（1个handler对象）</span></span><br><span class="line">            <span class="comment">// handler对象调用其回调方法对消息进行处理 -&gt;&gt;分析1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 释放消息占据的资源</span></span><br><span class="line">        msg.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 分析1：dispatchMessage(msg)</span></span><br><span class="line"><span class="comment">  * 定义：属于处理者类（Handler）中的方法</span></span><br><span class="line"><span class="comment">  * 作用：派发消息到对应的Handler实例 &amp; 根据传入的msg作出对应的操作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 若msg.callback属性不为空，则代表使用了post（Runnable r）发送消息</span></span><br><span class="line">    <span class="comment">// 则执行handleCallback(msg)，即回调Runnable对象里复写的run（）-&gt;&gt; 分析2</span></span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 若msg.callback属性为空，则代表使用了sendMessage（Message msg）发送消息（即此处需讨论的）</span></span><br><span class="line">            <span class="comment">// 则执行handleMessage(msg)，即回调复写的handleMessage(msg) -&gt;&gt; 分析3</span></span><br><span class="line">            handleMessage(msg);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 分析2：handleCallback(msg)</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleCallback</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        message.callback.run();</span><br><span class="line">        <span class="comment">//  Message对象的callback属性 = 传入的Runnable对象</span></span><br><span class="line">        <span class="comment">// 即回调Runnable对象里复写的run（）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">   * 分析3：handleMessage(msg)</span></span><br><span class="line"><span class="comment">   * 注：该方法 = 空方法，在创建Handler实例时复写 = 自定义消息处理方式</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">          ... <span class="comment">// 创建Handler实例时复写</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息循环的操作 &#x3D; 消息出队 + 分发给对应的Handler实例</li>
<li>分发给对应的Handler的过程：根据出队消息的归属者通过dispatchMessage(msg)进行分发，最终回调复写的handleMessage(Message msg)，从而实现 消息处理 的操作</li>
</ul>
<blockquote>
<p>特别注意：在进行消息分发时（dispatchMessage(msg)），会进行1次发送方式的判断：</p>
<ul>
<li>若msg.callback属性不为空，则代表使用了post（Runnable r）发送消息，则直接回调Runnable对象里复写的run（）</li>
<li>若msg.callback属性为空，则代表使用了sendMessage（Message<br>msg）发送消息，则回调复写的handleMessage(msg)</li>
</ul>
</blockquote>
<ul>
<li>步骤2：创建消息对象</li>
<li>Message类内部维护一个Message池，用于消息对象复用</li>
<li>若消息池有可复用消息，则返回；否则return new Message()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 具体使用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(); <span class="comment">// 实例化消息对象</span></span><br><span class="line">    msg.what = <span class="number">1</span>; <span class="comment">// 消息标识</span></span><br><span class="line">    msg.obj = <span class="string">&quot;AA&quot;</span>; <span class="comment">// 消息内容存放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 源码分析：Message.obtain()</span></span><br><span class="line"><span class="comment">  * 作用：创建消息对象</span></span><br><span class="line"><span class="comment">  * 注：创建Message对象可用关键字new 或 Message.obtain()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">  		<span class="comment">// Message内部维护了1个Message池，用于Message消息对象的复用</span></span><br><span class="line">  		<span class="comment">// 使用obtain（）则是直接从池内获取</span></span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="literal">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 建议：使用obtain（）”创建“消息对象，避免每次都使用new重新分配内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若池内无消息对象可复用，则还是用关键字new创建</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤3：在工作线程（AsynTask、Thread、Runnable）中 发送消息到消息队列中</li>
<li>将Handler实例保存到Message的target属性中（使Looper分发消息时能找到对应处理器）</li>
<li>将消息入队到绑定线程的消息队列中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 具体使用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">	mHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 源码分析：mHandler.sendMessage(msg)</span></span><br><span class="line"><span class="comment">  * 定义：属于处理器类（Handler）的方法</span></span><br><span class="line"><span class="comment">  * 作用：将消息 发送 到消息队列中（Message -&gt;&gt; MessageQueue）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(Message msg)</span></span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// -&gt;&gt; 最终调用 sendMessageAtTime(msg, uptimeMillis);</span></span><br><span class="line">    &#125;</span><br><span class="line">		   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		            <span class="comment">// 1. 获取对应的消息队列对象（MessageQueue）</span></span><br><span class="line">		            <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line"></span><br><span class="line">		            <span class="comment">// 2. 调用了enqueueMessage方法 -&gt;&gt;分析1</span></span><br><span class="line">		            <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">		        &#125;</span><br><span class="line"></span><br><span class="line">		 <span class="comment">/** </span></span><br><span class="line"><span class="comment">		   * 分析1：enqueueMessage(queue, msg, uptimeMillis)</span></span><br><span class="line"><span class="comment">		   **/</span></span><br><span class="line">		    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		         <span class="comment">// 1. 将msg.target赋值为this，即 ：把 当前的Handler实例对象作为msg的target属性（Message实例保存了发送该msg的Handler信息）</span></span><br><span class="line">		         msg.target = <span class="built_in">this</span>;</span><br><span class="line">		         <span class="comment">// 因此，当Looper的loop()中消息循环时，会从消息队列中取出每个消息msg，然后执行msg.target.dispatchMessage(msg)去处理消息</span></span><br><span class="line">		         <span class="comment">// 实际上则是将该消息派发给对应的Handler实例        </span></span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 2. 调用消息队列的enqueueMessage（）</span></span><br><span class="line">		        <span class="comment">// 即：Handler发送的消息，最终是保存到消息队列</span></span><br><span class="line">		        <span class="comment">// queue.enqueueMessage(msg, uptimeMillis）属于消息队列类（MessageQueue）的方法，入队，即 将消息 根据时间 放入到消息队列中</span></span><br><span class="line">		        <span class="comment">// 采用单链表实现：提高插入消息、删除消息的效率</span></span><br><span class="line">		        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis）;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后，随着Looper对象的无限消息循环</span></span><br><span class="line"><span class="comment">// 不断从消息队列中取出Handler发送的消息 &amp; 分发到对应Handler</span></span><br><span class="line"><span class="comment">// 最终回调Handler.handleMessage()处理消息</span></span><br></pre></td></tr></table></figure>

<p>总结</p>
<table> 
 <thead> 
  <tr> 
   <th>步骤</th> 
   <th>核心方法</th> 
   <th>说明</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>主线程创建时</td> 
   <td>Looper.prepare()<br>Looper.loop()</td> 
   <td>在ActivityThread.java主线程入口类，自动创建1个Looper，1个MessageQueue<br>并进入消息循环（不断从消息队列中取出消息Message并分发给相应的处理器msg.target.dispatchMessage(msg)）</td> 
  </tr> 
  <tr> 
   <td>创建Handler实例</td> 
   <td>Handler构造方法<br>Handler.handleMessage()</td> 
   <td>绑定当前线程（Looper &amp; MessageQueue）<br>复写回调方法对Looper分发的消息进行处理</td> 
  </tr> 
  <tr> 
   <td>创建消息对象</td> 
   <td>Message.obtain()</td> 
   <td>从Message池获取或新建Message对象</td> 
  </tr> 
  <tr> 
   <td>通过Handler发送消息到消息队列中</td> 
   <td>Handler.sendMessage()</td> 
   <td>Message.target保存Handler信息<br>调用MessageQueue.enqueueMessage()将消息放入消息队列中</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="内存泄露-解决方案"><a href="#内存泄露-解决方案" class="headerlink" title="内存泄露 &amp; 解决方案"></a>内存泄露 &amp; 解决方案</h3><ul>
<li>内存泄露<br>当一个对象已经不再被使用时，本该被回收但却因为有另外一个正在使用的对象持有它的引用从而导致它不能被回收，仍停留在堆内存中。这就导致了内存泄漏。</li>
<li>Handler内存泄露原因<br>（1）当Handler消息队列 还有未处理完的消息&#x2F;正在处理的消息时，消息队列中的Message持有Handler实例的引用<br>（2）Handler &#x3D; 非静态内部类&#x2F;匿名内部类 ，故默认持有外部类（Activity实例）的引用<br>（3）该引用关系会一直保持，直到Handler消息队列中所有消息处理完毕（未被处理 &#x2F; 正处理的消息 -&gt; Handler实例 -&gt; 外部类）<br>（4）在Handler消息队列 还有未处理的消息 &#x2F; 正在处理消息时，此时若需销毁外部类MainActivity（Handler的生命周期 &gt; 外部类的生命周期），但由于上述引用关系，垃圾回收器（GC）无法回收MainActivity，从而造成内存泄漏。<br><img src="https://mark.cuckooing.cn/pics/pic_635fa504.png" alt="pic_635fa504.png"></li>
<li>Handler内存泄露解决<br>静态内部类 + 弱引用</li>
<li>将Handler的子类设置成 静态内部类<br>静态内部类 不默认持有外部类的引用，从而使得 “未被处理 &#x2F; 正处理的消息 -&gt; Handler实例 -&gt; 外部类” 的引用关系 的引用关系 不复存在。</li>
<li>使用WeakReference弱引用持有Activity实例<br>弱引用的对象拥有短暂的生命周期。在垃圾回收器线程扫描时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler showhandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程创建时便自动创建Looper &amp; 对应的MessageQueue</span></span><br><span class="line">    <span class="comment">// 之后执行Loop()进入消息循环</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 实例化自定义的Handler类对象-&gt;&gt;分析1</span></span><br><span class="line">        <span class="comment">//注：</span></span><br><span class="line">            <span class="comment">// a. 此处并无指定Looper，故自动绑定当前线程(主线程)的Looper、MessageQueue；</span></span><br><span class="line">            <span class="comment">// b. 定义时需传入持有的Activity实例（弱引用）</span></span><br><span class="line">        showhandler = <span class="keyword">new</span> <span class="title class_">FHandler</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 启动子线程1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">                msg.what = <span class="number">1</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                msg.obj = <span class="string">&quot;AA&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                showhandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 启动子线程2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">                msg.what = <span class="number">2</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                msg.obj = <span class="string">&quot;BB&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                showhandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分析1：自定义Handler子类</span></span><br><span class="line">    <span class="comment">// 设置为：静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义 弱引用实例</span></span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Activity&gt; reference;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在构造方法中传入需持有的Activity实例</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FHandler</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// 使用WeakReference弱引用持有Activity实例</span></span><br><span class="line">            reference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Activity&gt;(activity); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过复写handlerMessage() 从而确定更新UI的操作</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;收到线程1的消息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot; 收到线程2的消息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试-2"><a href="#面试-2" class="headerlink" title="面试"></a>面试</h3><ul>
<li>[Looper死循环为什么不会导致应用卡死？][Looper]</li>
<li>[使用Handler的postDealy后消息队列有什么变化？][Handler_postDealy]</li>
<li>[可以在子线程直接new一个Handler出来吗？][new_Handler]</li>
<li>[Message对象创建的方式有哪些 &amp; 区别？][Message_ _]</li>
</ul>
<h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一个Android 已封装好的轻量级异步通信类。<br>用于实现多线程（开启工作线程执行耗时操作），异步通信与消息传递（工作线程与主线程之间通信）<br>本质上是通过继承Thread类和封装Handler类的使用，从而使得创建新线程和与其他线程进行通信变得更加方便易用</p>
<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：创建HandlerThread实例对象</span></span><br><span class="line"><span class="comment">// 传入参数 = 线程名字，作用 = 标记该线程</span></span><br><span class="line">   <span class="type">HandlerThread</span> <span class="variable">mHandlerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;handlerThread&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：启动线程</span></span><br><span class="line">   mHandlerThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：创建工作线程Handler &amp; 复写handleMessage（）</span></span><br><span class="line"><span class="comment">// 作用：关联HandlerThread的Looper对象、实现消息处理操作 &amp; 与其他线程进行通信</span></span><br><span class="line"><span class="comment">// 注：消息处理操作（HandlerMessage（））的执行线程 = mHandlerThread所创建的工作线程中执行</span></span><br><span class="line">  <span class="type">Handler</span> <span class="variable">workHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>( handlerThread.getLooper() ) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                ...<span class="comment">//消息处理</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤4：使用工作线程Handler向工作线程的消息队列发送消息</span></span><br><span class="line"><span class="comment">// 在工作线程中，当消息循环时取出对应消息 &amp; 在工作线程执行相关操作</span></span><br><span class="line">  <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">  <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">  msg.what = <span class="number">2</span>; <span class="comment">//消息的标识</span></span><br><span class="line">  msg.obj = <span class="string">&quot;B&quot;</span>; <span class="comment">// 消息的存放</span></span><br><span class="line">  <span class="comment">// b. 通过Handler发送消息到其绑定的消息队列</span></span><br><span class="line">  workHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤5：结束线程，即停止线程的消息循环</span></span><br><span class="line">  mHandlerThread.quit();</span><br></pre></td></tr></table></figure>

<h3 id="工作原理-源码分析"><a href="#工作原理-源码分析" class="headerlink" title="工作原理 &amp; 源码分析"></a>工作原理 &amp; 源码分析</h3><p>内部原理 &#x3D; Thread类 + Handler类机制，即：</p>
<ul>
<li>通过继承Thread类，快速地创建1个带有Looper对象的新工作线程</li>
<li>通过封装Handler类，快速创建Handler &amp; 与其他线程进行通信</li>
</ul>
<ol>
<li>创建HandlerThread实例对象</li>
</ol>
<ul>
<li>HandlerThread类继承自Thread类</li>
<li>创建HandlerThread类对象 &#x3D; 创建Thread类对象 + 设置线程优先级 &#x3D; 新开1个工作线程 + 设置线程优先级</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 具体使用</span></span><br><span class="line"><span class="comment">  * 传入参数 = 线程名字，作用 = 标记该线程</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">   <span class="type">HandlerThread</span> <span class="variable">mHandlerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;handlerThread&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：HandlerThread类的构造方法</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="comment">// 继承自Thread类</span></span><br><span class="line">	    </span><br><span class="line">	    <span class="type">int</span> mPriority; <span class="comment">// 线程优先级</span></span><br><span class="line">	    <span class="type">int</span> <span class="variable">mTid</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 当前线程id</span></span><br><span class="line">	    Looper mLooper; <span class="comment">// 当前线程持有的Looper对象</span></span><br><span class="line"></span><br><span class="line">	   <span class="comment">// HandlerThread类有2个构造方法</span></span><br><span class="line">	   <span class="comment">// 区别在于：设置当前线程的优先级参数，即可自定义设置 or 使用默认优先级</span></span><br><span class="line"></span><br><span class="line">		    <span class="comment">// 方式1. 默认优先级</span></span><br><span class="line">		    <span class="keyword">public</span> <span class="title function_">HandlerThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		        <span class="comment">// 通过调用父类默认的方法创建线程</span></span><br><span class="line">		        <span class="built_in">super</span>(name);</span><br><span class="line">		        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">		    &#125;</span><br><span class="line">		  </span><br><span class="line">		    <span class="comment">// 方法2. 自定义设置优先级</span></span><br><span class="line">		    <span class="keyword">public</span> <span class="title function_">HandlerThread</span><span class="params">(String name, <span class="type">int</span> priority)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		        <span class="built_in">super</span>(name);</span><br><span class="line">		        mPriority = priority;</span><br><span class="line">		    &#125;</span><br><span class="line">		    ...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>启动线程</li>
</ol>
<ul>
<li>为当前工作线程（即步骤1创建的线程）创建1个Looper对象 &amp; MessageQueue对象</li>
<li>通过持有锁机制来获得当前线程的Looper对象</li>
<li>发出通知：当前线程已经创建mLooper对象成功</li>
<li>工作线程进行消息循环，即不断从MessageQueue中取消息 &amp; 派发消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 具体使用</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">   mHandlerThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：此处调用的是父类（Thread类）的start()，最终回调HandlerThread的run（）</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 1. 获得当前线程的id</span></span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建1个Looper对象 &amp; MessageQueue对象</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 通过持有锁机制来获得当前线程的Looper对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 发出通知：当前线程已经创建mLooper对象成功</span></span><br><span class="line">            <span class="comment">// 此处主要是通知getLooper（）中的wait（）</span></span><br><span class="line">            notifyAll();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 此处使用持有锁机制 + notifyAll() 是为了保证后面获得Looper对象前就已创建好Looper对象</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 设置当前线程的优先级</span></span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 在线程循环前做一些准备工作</span></span><br><span class="line">        <span class="comment">// 该方法实现体是空的，子类可实现 / 不实现该方法</span></span><br><span class="line">        onLooperPrepared();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 进行消息循环，即不断从MessageQueue中取消息 &amp; 派发消息</span></span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建工作线程Handler &amp; 复写handleMessage（）<br>将创建的Handler 与 工作线程的Looper对象绑定，从而将Handler绑定工作线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 具体使用</span></span><br><span class="line"><span class="comment">  * 作用：将Handler关联HandlerThread的Looper对象、实现消息处理操作 &amp; 与其他线程进行通信</span></span><br><span class="line"><span class="comment">  * 注：消息处理操作（HandlerMessage（））的执行线程 = mHandlerThread所创建的工作线程中执行</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">   <span class="type">Handler</span> <span class="variable">workHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>( handlerThread.getLooper() ) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                ...<span class="comment">//消息处理</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：handlerThread.getLooper()</span></span><br><span class="line"><span class="comment">  * 作用：获得当前HandlerThread线程中的Looper对象</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">    <span class="keyword">public</span> Looper <span class="title function_">getLooper</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 若线程不是存活的，则直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 若当前线程存活，再判断线程的成员变量mLooper是否为null</span></span><br><span class="line">        <span class="comment">// 直到线程创建完Looper对象后才能获得Looper对象，若Looper对象未创建成功，则阻塞</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     				<span class="comment">// 此处会调用wait方法去等待</span></span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上述步骤run（）使用 持有锁机制 + notifyAll()  获得Looper对象后</span></span><br><span class="line">        <span class="comment">// 则通知当前线程的wait（）结束等待 &amp; 跳出循环</span></span><br><span class="line">        <span class="comment">// 最终getLooper()返回的是在run（）中创建的mLooper对象</span></span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用工作线程Handler向工作线程的消息队列发送消息</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 具体使用</span></span><br><span class="line"><span class="comment">  * 作用：在工作线程中，当消息循环时取出对应消息 &amp; 在工作线程执行相关操作</span></span><br><span class="line"><span class="comment">  * 注：消息处理操作（HandlerMessage（））的执行线程 = mHandlerThread所创建的工作线程中执行</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">  <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">  msg.what = <span class="number">2</span>; <span class="comment">//消息的标识</span></span><br><span class="line">  msg.obj = <span class="string">&quot;B&quot;</span>; <span class="comment">// 消息的存放</span></span><br><span class="line">  <span class="comment">// b. 通过Handler发送消息到其绑定的消息队列</span></span><br><span class="line">  workHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：workHandler.sendMessage(msg)</span></span><br><span class="line"><span class="comment">  * 此处的源码即Handler的源码，故不作过多描述</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<ol>
<li>结束线程，即停止线程的消息循环<br><img src="https://mark.cuckooing.cn/pics/pic_6af65aa0.png" alt="pic_6af65aa0.png"></li>
</ol>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>[带你了解android的IPC机制][android_IPC]<br>[Android 中的 IPC 方式][Android _ IPC]<br>[Android Binder机制及AIDL使用][Android Binder_AIDL]</p>
<h3 id="IPC-概述？"><a href="#IPC-概述？" class="headerlink" title="IPC 概述？"></a>IPC 概述？</h3><ul>
<li>IPC简介<br>IPC是Inter-Process Communication的缩写，含义就是跨进程通信。<br>在Android中，为每一个应用程序都分配了一个独立的虚拟机，不同虚拟机在内存分配上都有不同的地址空间，进程间相互独立、隔离。因此互相访问数据需要借助其他手段。<br>IPC主要包含两部分：（1）序列化：将对象转化为字节（Serialiazable、Parcelable）（2）Binder机制</li>
<li>实现IPC的方式</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>方式</th> 
   <th>说明</th> 
   <th>特点</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>Bundle</td> 
   <td>在Android中三大组件（Activity，Service，Receiver）都支持在Intent中传递Bundle数据，由于Bundle实现了Parcelable接口（一种特有的序列化方法），所以它可以很方便的在不同的进程之间进行传输</td> 
   <td>四大组件间的进程间通信方式，简单易用，但只能是单方向的简单数据传输，使用有一定的局限性</td> 
  </tr> 
  <tr> 
   <td>文件共享</td> 
   <td>将对象序列化之后保存到文件中，在通过反序列，将对象从文件中读取出来。此方式对文件的格式没有具体的要求，可以是文件、XML、JSON等</td> 
   <td>文件共享方式也存在着很大的局限性，如并发读/写问题，如读取的数据不完整或者读取的数据不是最新的。不适合高并发场景，并且无法做到进程间的及时通信</td> 
  </tr> 
  <tr> 
   <td>Messenger</td> 
   <td>通过Messenger来进行进程间通信，在Messenger中放入我们需要传递的数据，实现进程间数据传递。Messenger只能传递Message对象，Messenger是一种轻量级的IPC方案，它的底层实现是AIDL</td> 
   <td>Messenger内部消息处理使用Handler实现的，所以它是以串行的方式处理客服端发送过来的消息的，如果有大量的消息发送给服务器端，服务器端只能一个一个处理，如果并发量大的话用Messenger就不合适了，而且Messenger的主要作用就是为了传递消息，很多时候我们需要跨进程调用服务器端的方法，这种需求Messenger就无法做到了。</td> 
  </tr> 
  <tr> 
   <td>AIDL</td> 
   <td>用于生成可以在Android设备上两个进程之间进行进程间通信（IPC）的代码</td> 
   <td>如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。AIDL是IPC的一个轻量级实现，Android也提供了一个工具，可以自动创建Stub（类架构，类骨架）</td> 
  </tr> 
  <tr> 
   <td>ContentProvider</td> 
   <td>ContentProvider（内容提供者）是Android中的四大组件之一，为了在应用程序之间进行数据交换，Android提供了ContentProvider，ContentProvider是不同应用之间进行数据交换的API，一旦某个应用程序通过ContentProvider暴露了自己的数据操作的接口，那么不管该应用程序是否启动，其他的应用程序都可以通过接口来操作接口内的数据，包括数据的增、删、改、查等操作</td> 
   <td>使用受限，只能根据特定规则访问数据</td> 
  </tr> 
  <tr> 
   <td>Socket</td> 
   <td>Socket也是实现进程间通信的一种方式，Socket也称为“套接字”（网络通信中概念），通过Socket也可以实现跨进程通信，Socaket主要还是应用在网络通信中</td> 
   <td></td> 
  </tr> 
 </tbody> 
</table>

<h3 id="Binder机制-简介-原理？"><a href="#Binder机制-简介-原理？" class="headerlink" title="Binder机制 简介 &amp; 原理？"></a>Binder机制 简介 &amp; 原理？</h3><p>[carson_ho：Android跨进程通信：图文详解 Binder机制 原理][carson_ho_Android_ Binder_]</p>
<ul>
<li>Binder 简介<br>（1）Binder机制 是Android中实现跨进程通信（IPC）的方式<br>（2）Binder驱动 是连接Service进程、Client进程和Service Manager进程的一种虚拟的物理设备驱动<br>（3）Binder类 是一个实现了IBinder接口的类，常用用于代理模式中（AMS、AIDL）</li>
<li>Binder 机制</li>
<li>通信模型 &amp; 工作原理<br>（1）进程隔离 &amp; 跨进程通信模型</li>
<li>进程隔离<br>为了保证 安全性 &amp; 独立性，一个进程 不能直接操作或者访问另一个进程，即Android的进程是相互独立、隔离的，只能运行在自己进程所拥有的虚拟地址空间。<br>对于用户空间，不同进程之间是不能共享的，而内核空间却是可共享的。Client进程向Server进程通信，恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的。Client端与Server端进程往往采用ioctl等方法与内核空间的驱动进行交互。</li>
<li>跨进程通信（IPC）基本原理<br><img src="https://mark.cuckooing.cn/pics/pic_683231de.png" alt="pic_683231de.png"><br>（2）Binder 跨进程通信模型 &amp; 工作原理<br><img src="https://mark.cuckooing.cn/pics/pic_1691d31a.png" alt="pic_1691d31a.png"><br><img src="https://mark.cuckooing.cn/pics/pic_cf191e82.png" alt="pic_cf191e82.png"><br><img src="https://mark.cuckooing.cn/pics/pic_7e53d58e.png" alt="pic_7e53d58e.png"></li>
<li>Client进程、Server进程 &amp; Service Manager 进程之间的交互 都必须通过Binder驱动（使用 open 和 ioctl文件操作函数），而非直接交互<br>Client进程、Server进程 &amp; Service Manager进程属于进程空间的用户空间，不可进行进程间交互<br>Binder驱动 属于 进程空间的 内核空间，可进行进程间 &amp; 进程内交互</li>
<li>Binder驱动 &amp; Service Manager进程 属于 Android基础架构（Android平台，由系统实现）；而Client 进程 和 Server 进程 属于Android应用层（由开发者实现）</li>
</ul>
<blockquote>
<p>Binder 驱动创建一块接收缓存区。实现Service 进程用户空间 与 Client内核缓存区的地址映射。  </p>
<p>因此用户通过系统调用（copy_from_user）发送数据到内核缓冲区时，也相当于发送到了Server进程的用户空间；<br>同理，Server将执行的结果写入共享的接受缓存区时，也相当于发送到了内核缓存区，用户通过系统调用（copy_to_user）从内核缓存区接受Server进程返回的数据。  </p>
<p>Binder只需要通过一次数据拷贝便可实现进程间的数据传递。</p>
</blockquote>
<ul>
<li>优点</li>
<li>对比 Linux （Android基于Linux）上的其他进程通信方式（管道、消息队列、共享内存、<br>信号量、Socket），Binder 机制的优点有：<br><img src="https://mark.cuckooing.cn/pics/pic_f5296062.png" alt="pic_f5296062.png"></li>
<li>Binder 跨进程调用服务流程<br>跨进程调用系统服务的简单示例，实现浮动窗口部分代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取WindowManager服务引用</span></span><br><span class="line"><span class="type">WindowManager</span> <span class="variable">wm</span> <span class="operator">=</span> (WindowManager) getSystemService(getApplication().WINDOW_SERVICE);</span><br><span class="line"><span class="comment">//布局参数layoutParams相关设置略...</span></span><br><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> LayoutInflater.from(getApplication()).inflate(R.layout.float_layout, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//添加view</span></span><br><span class="line">wm.addView(view, layoutParams);</span><br></pre></td></tr></table></figure>

<ul>
<li>注册服务(addService)： 在Android开机启动过程中，Android会初始化系统的各种Service，并将这些Service向ServiceManager注册（即让ServiceManager管理）。这一步是系统自动完成的。</li>
<li>获取服务(getService)： 客户端想要得到具体的Service直接向ServiceManager要即可。客户端首先向ServiceManager查询得到具体的Service引用，通常是Service引用的代理对象，对数据进行一些处理操作。即第2行代码中，得到的wm是WindowManager对象的引用。</li>
<li>使用服务： 通过这个引用向具体的服务端发送请求，服务端执行完成后就返回。即第6行调用WindowManager的addView函数，将触发远程调用，调用的是运行在systemServer进程中的WindowManager的addView函数。<br>使用服务的具体执行过程<br><img src="https://mark.cuckooing.cn/pics/pic_a5b7d1b7.png" alt="pic_a5b7d1b7.png"><br>（1）Client通过获得一个Server的代理接口Proxy，对Server提供的方法进行调用。代理接口Proxy中定义的方法与Server中定义的方法是一一对应的。<br>（2）Client调用某个代理接口中的方法时，代理接口的方法会将Client传递的参数打包成Parcel对象。代理接口将Parcel发送给内核中的Binder Driver。<br>（BinderDriver底层工作：Client进程通过 系统调用 copy_from_user将数据发送到内核空间缓存区，由于 Client内核空间缓存区 &amp; Server用户空间 存在地址映射关系，因此相当于发送到Server进程用户空间，Binder通知Server进行解包）<br>（3）Server会读取Binder Driver中的请求数据，解包Parcel对象，调用相应的方法并将结果打包返回给Binder Driver。<br>（Binder底层工作：Server将结果写入自己的用户空间，由于 Client内核空间缓存区 &amp; Server用户空间 存在地址映射关系，因此相当于发送到内核缓存区，Binder通知Client获得结果，Client进程 通过 系统调用 copy_to_user() 从内核缓存区接收Server进程返回数据）<br>（4）Client的代理接口Proxy收到结果会解包并将真正的数据传送给Client。<br>整个的调用过程是一个同步过程，在Server处理的时候，Client会Block住。因此Client调用过程不应在主线程。</li>
<li>代理模式在Binder中的使用 &#x2F; 从应用层面剖析Android Binder机制<br>[从应用层面剖析Android Binder机制][Android Binder]<br><img src="https://mark.cuckooing.cn/pics/pic_b225c835.png" alt="pic_b225c835.png"><br>从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当你bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。<br>（1）AIDL中代理模式<br>[人人都会设计模式：代理模式–Proxy][Proxy]<br><img src="https://mark.cuckooing.cn/pics/pic_fe9ac159.png" alt="pic_fe9ac159.png"><br>Binder实现中含有Proxy类。<br>Proxy将客户端的请求参数通过Parcel包装后通过Binder传到远程服务端，远程服务端解析数据并执行对应的操作，同时客户端线程挂起，当服务端方法执行完毕后，再将返回结果写入到另外一个Parcel中并将其通过Binder传回到客户端Proxy，客户端Proxy会解析但会数据包中的内容并将原始结果返回给客户端真正调用者，至此，整个Binder的工作过程就完成了。<br>由此可见，Binder是一个典型的代理者模式，Parcel对象就在这个通道中跨进程传输。<br>（2）AMS中代理模式<br><img src="https://mark.cuckooing.cn/pics/pic_3026777c.png" alt="pic_3026777c.png"><br><img src="https://mark.cuckooing.cn/pics/pic_98b7fbe3.png" alt="pic_98b7fbe3.png"></li>
</ul>
<ol>
<li>IActivityManager作为ActivityManagerProxy和ActivityManagerNative的公共接口，所以两个类具有部分相同的接口，可以实现合理的代理模式；</li>
<li>ActivityManagerProxy代理类是ActivityManagerNative的内部类；</li>
<li>ActivityManagerNative是个抽象类，真正发挥作用的是它的子类ActivityManagerService（系统Service组件）。</li>
<li>ActivityManager是一个客户端，为了隔离它与，有效降低甚至消除二者的耦合度，在这中间使用了ActivityManagerProxy代理类，所有对的访问都转换成对代理类的访问，这样ActivityManager就与解耦了，这是典型的proxy的应用场景。</li>
<li>ActivityManagerService是系统统一的Service，运行在独立的进程中；通过系统ServiceManger获取；ActivityManager运行在一个进程里面，ActivityManagerService运行在另一个进程内，对象在不同的进程里面，其地址是相互独立的；采用Binder机制跨进程通信，所以我们可以得出这是一个RemoteProxy。</li>
</ol>
<p>（3）activity.bindService()</p>
<h3 id="什么是AIDL-如何使用AIDL？AIDL工作原理（结合Binder）？"><a href="#什么是AIDL-如何使用AIDL？AIDL工作原理（结合Binder）？" class="headerlink" title="什么是AIDL?如何使用AIDL？AIDL工作原理（结合Binder）？"></a>什么是AIDL?如何使用AIDL？AIDL工作原理（结合Binder）？</h3><ul>
<li>AIDL定义<br>AIDL (Android Interface Definition Language) 是一种接口定义语言，用于生成可以在Android设备上两个进程之间进行进程间通信(Interprocess Communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数，来完成进程间通信。</li>
<li>AIDL使用<br>AIDL一共分为三部分，分别是客户端、服务端和AIDL接口。</li>
</ul>
<ol>
<li>AIDL接口：用来传递的参数，提供进程间通信。<br>（1）创建.aidl文件，即接口IService（IService.aidl），用于提供暴露的方法（传递的参数）<br>IService.aidl</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IService</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="comment">// 定义暴露的方法</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">callMethodService</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Make Project后，系统会自动生成IService.java文件（位于gen&#x2F;package目录下）<br>该接口会自动生成Stub类，继承了Binder 类，同时实现了IService接口。Stub是AIDL自动生成一个实现AIDL接口的专门用于进程间通信的中间人（IBinder）类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IService</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.IInterface&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.Binder <span class="keyword">implements</span> <span class="title class_">com</span>.itheima.remoteservice.IService&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.<span class="type">String</span> <span class="variable">DESCRIPTION</span> <span class="operator">=</span> <span class="string">&quot;com.itheima.remoteservice.IService&quot;</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>,DESCRIPTION);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将IBinder 转换为 Iservice 类型</span></span><br><span class="line">	<span class="comment">// 可用于生成一个中间人</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> com.itheima.remoteservice.Iservice <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">		android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTION);</span><br><span class="line">		<span class="keyword">if</span>((iin!=<span class="literal">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.itheima.remoteservice.IService))&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="keyword">return</span> (com.itheima.remoteservice.IService)iin;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）服务端需要创建一个中间人实现IService接口，从而提供的服务方法；客户端需要获取IService接口从而得到中间人并调用服务方法。因此需要保证服务端客户端拥有同一个AIDL文件。AIDL规定拥有相同包名的AIDL文件为同一个ADIL文件。<br>在服务端和客户端下创建相同的包名，放入相同的IService.aidl，并由AIDL（系统）自动生成相同的IService.java文件（可序列化参数）</p>
<ol>
<li>服务端&#x2F;远程进程：运行在其他应用中的服务，用于提供服务。<br>（1）编写服务端代码，定义一个中间人对象，并实现接口（extends Binder implements IService &#x3D; extends Stub）。并在onBinder中返回中间人</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteService</span> <span class="keyword">extends</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 2. 返回定义的中间人对象</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBinder</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// RemoteService 提供的服务方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodService</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		System.out.println(<span class="string">&quot;Msg From RemoteService&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1. 定义一个中间人对象 IBinder </span></span><br><span class="line">	<span class="comment">// extends Binder implements IService = extends Stub</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyBinder</span> <span class="keyword">extends</span> <span class="title class_">Stub</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="meta">@override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callMethodService</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="built_in">this</span>.methodService();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）AndroidManifest.xml 配置服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=<span class="string">&quot;com.itheima.remoteservice.RemoteService&quot;</span>&gt;</span><br><span class="line">	&lt;intent-filter&gt;</span><br><span class="line">		&lt;action android:name=<span class="string">&quot;com.itheima.remoteservice&quot;</span>/&gt;</span><br><span class="line">	&lt;/intent-filter&gt;</span><br><span class="line">&lt;/setvice&gt;</span><br></pre></td></tr></table></figure>

<p>总结：服务端创建一个 Service 用来监听客户端的连接请求，然后创建一个 AIDL 文件，将暴露给客户端的接口在这个 AIDL 文件中声明，最后在 Service 中实现这个 AIDL 接口即可。</p>
<ol>
<li>客户端&#x2F;本地进程：运行在自己应用的服务，用于调用远程服务<br>（1）在MainActivity中通过asInterface方法获取中间人对象，并执行服务端方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="keyword">private</span> MyConn conn;</span><br><span class="line">	<span class="keyword">private</span> IService iservce;	<span class="comment">// 中间人对象(extends Binder)</span></span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		<span class="comment">// 1. 调用bindService获取中间人对象</span></span><br><span class="line">		<span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">		intent.setAction(<span class="string">&quot;com.itheima.remoteservice&quot;</span>);	<span class="comment">// 通过意图过滤器为服务建立关系</span></span><br><span class="line">		conn = <span class="keyword">new</span> <span class="title class_">MyConn</span>();</span><br><span class="line">		<span class="comment">// 2. 连接服务，获取中间人对象</span></span><br><span class="line">		bindService(intent,conn,flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 监视服务的状态</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyConn</span> <span class="keyword">implements</span> <span class="title class_">Connection</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="meta">@override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name,IBinder service)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="comment">// 连接成功,通过连接服务获取中间人对象（获取中间人IBinder对象方式变化）</span></span><br><span class="line">			<span class="comment">// Stub.asInterface(service) 将IBinder 转化为实现AIDL接口的 中间人对象（IService）</span></span><br><span class="line">			iservice = Stub.asInterface(service);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">//连接失败</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">(View v)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="comment">//3. 通过中间人对象调用相应方法</span></span><br><span class="line">			iService.callMethodService();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(RemoteException e)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     e.printStackTrace();&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		unbindService(conn);</span><br><span class="line">		<span class="built_in">super</span>.onDestroy();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：绑定服务端的 Service ，绑定成功后，将服务端返回的 Binder 对象转成 AIDL 接口所属的类型，然后就可以调用 AIDL 中的方法了。</p>
<ul>
<li>AIDL应用场景<br>某个游戏（如欢乐斗地主）需要支付时打开支付宝应用进行支付</li>
<li>AIDL文件解析（手写aidl）<br>.aidl文件用于向客户端暴露远程服务提供方法，用于跨进程通信。经过JVM编译后生成对应java文件，生成一个继承IInterface类的接口。<br>包含2部分：</li>
<li>实现IBookService的本地实现类Stub</li>
<li>暴露给客户端的服务方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBookService</span> <span class="keyword">extends</span> <span class="title class_">IInterface</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 继承IInterface的接口</span></span><br><span class="line"><span class="comment">// 包含两部分</span></span><br><span class="line"><span class="comment">// 1. 实现IBookService的本地实现类Stub</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">Binder</span> <span class="keyword">implements</span> <span class="title class_">IBookService</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     ...&#125;</span><br><span class="line"><span class="comment">// 2. 暴露给客户端的服务方法</span></span><br><span class="line"> List&lt;Book&gt; <span class="title function_">getBooks</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现IBookService的本地实现类Stub，包含1个构造函数，2个重要方法，一个代理内部类</p>
<ul>
<li>构造函数 public Stub() {}</li>
<li>asInterface</li>
<li>onTransact</li>
<li>Stub 内部类 Proxy</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">Binder</span> <span class="keyword">implements</span> <span class="title class_">IBookService</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DESCRIPTOR</span> <span class="operator">=</span> <span class="string">&quot;com.xud.ipc.server.IBookService&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="comment">// 服务端获取Binder，实现IBookService方法并用键值对的形式将Stub保存到Binder</span></span><br><span class="line">        <span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IBookService <span class="title function_">asInterface</span><span class="params">(IBinder binder)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="comment">// 客户端获取Binder，若为相同进程则返回对应Stub，否则返回Stub.Proxy</span></span><br><span class="line">        <span class="keyword">if</span> (binder == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// Binder中查找IInterface</span></span><br><span class="line">        <span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> binder.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">if</span> (iin != <span class="literal">null</span> &amp;&amp; iin <span class="keyword">instanceof</span> IBookService)</span><br><span class="line">            <span class="keyword">return</span> (IBookService) iin;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, <span class="meta">@NonNull</span> Parcel data, <span class="meta">@Nullable</span> Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="comment">// 客户端通过调用 remote.transcat方法后，Binder会通知服务端onTranscat接收数据并根据code执行相应方法</span></span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">                reply.writeString(DESCRIPTOR);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSAVTION_getBooks:</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                List&lt;Book&gt; result = <span class="built_in">this</span>.getBooks();</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                reply.writeTypedList(result);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSAVTION_addBook:</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                <span class="type">Book</span> <span class="variable">arg0</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (data.readInt() != <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    arg0 = Book.CREATOR.createFromParcel(data);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.addBook(arg0);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSAVTION_getBooks</span> <span class="operator">=</span> IBinder.FIRST_CALL_TRANSACTION;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSAVTION_addBook</span> <span class="operator">=</span> IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">IBookService</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现IBookService的代理类Proxy<br>Proxy是一个典型的静态代理模式，Proxy并没有实现IBookService中的方法，而是通过remote将方法请求传递到Server进程，也即是上面的Stub类处理，而remote是一个BinderProxy，包含2部分：</p>
<ul>
<li>构造方法 public Proxy(IBinder remote) {}</li>
<li>接口方法的实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">IBookService</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="comment">// 代理类，客户端通过Proxy执行服务端方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DESCRIPTOR</span> <span class="operator">=</span> <span class="string">&quot;com.xud.ipc.server.IBookService&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBinder remote;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">(IBinder remote)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// return new Proxy(binder); remote本质上是服务端Stub的引用</span></span><br><span class="line">        <span class="built_in">this</span>.remote = remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInterfaceDescriptor</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> remote;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 实现IBookService接口的方法</span></span><br><span class="line">	<span class="comment">// 1. 将数据进行序列化</span></span><br><span class="line">	<span class="comment">// 2. 并调用服务端的方法remote.transact(Stub.TRANSAVTION_getBooks, data, replay, 0);</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getBooks</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">replay</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        List&lt;Book&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            remote.transact(Stub.TRANSAVTION_getBooks, data, replay, <span class="number">0</span>);</span><br><span class="line">            replay.readException();</span><br><span class="line">            result = replay.createTypedArrayList(Book.CREATOR);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            replay.recycle();</span><br><span class="line">            data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">replay</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (book != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                data.writeInt(<span class="number">1</span>);</span><br><span class="line">                book.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                data.writeInt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            remote.transact(Stub.TRANSAVTION_addBook, data, replay, <span class="number">0</span>);</span><br><span class="line">            replay.readException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            replay.recycle();</span><br><span class="line">            data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>AIDL工作原理<br>Binder机制运行主要包括三部分：注册服务、获取服务和使用服务。注册服务和获取服务主要涉及C的内容，不予介绍。主要介绍使用服务时AIDL工作原理。<br>.aidl文件生成的java代码是一个接口文件，继承了android.os.IInterface，用于声明暴露给Client端的具体服务。这个接口生成的java文件包括两部分：</li>
<li>静态内部抽象类Stub</li>
<li>声明了具体的功能的抽象方法（aidl文件中声明的方法）<br>（1）Binder对象的获取<br>Binder是实现跨进程通信的基础，那么Binder对象在服务端和客户端是共享的，是同一个Binder对象。在客户端通过Binder对象获取实现了IInterface接口的对象来调用远程服务，然后通过Binder来实现参数传递。</li>
<li>服务端获取Binder对象并保存IInterface接口对象<br>服务端创建binder实现Stub类并实现AIDL抽象函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IBookManager.<span class="type">Stub</span> <span class="variable">mbinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBookManager</span>.Stub() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//添加书本</span></span><br><span class="line">        <span class="keyword">if</span> (!mBookList.contains(book)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            mBookList.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> mBookList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Binder中两个关键方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Binder具有被跨进程传输的能力是因为它实现了IBinder接口。系统会为每个实现了该接口的对象提供跨进程传输</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Binder</span> implement IBinder &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="comment">// Binder具有的完成特定任务的能力是通过它的IInterface的对象获得的</span></span><br><span class="line">	<span class="comment">// IInterface 实现接口方法的binder</span></span><br><span class="line">	<span class="comment">// attachInterface方法会将（descriptor，plus）作为（key,value）对存入Binder对象中的一个Map对象中，Binder对象可通过attachInterface方法持有一个IInterface对象（即plus）的引用，并依靠它获得完成特定任务的能力。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attachInterface</span><span class="params">(IInterface plus, String descriptor)</span></span><br><span class="line">    <span class="comment">// 从IBinder中继承而来</span></span><br><span class="line">    <span class="comment">// 根据key值（即参数 descriptor）查找相应的IInterface对象</span></span><br><span class="line">    IInterface <span class="title function_">queryLocalInterface</span><span class="params">(Stringdescriptor)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务端进程，通过实现private IBookManager.Stub mbinder &#x3D; new IBookManager.Stub() {}抽象类，获得Binder对象。 并保存了IInterface对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>, DESCRIPTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端获取Binder对象并获取IInterface接口对象<br>通过bindService获得Binder对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClient.<span class="built_in">this</span>.bindService(intentService, mServiceConnection, BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>

<p>然后通过Binder对象获得IInterface对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">mServiceConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder binder)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//通过服务端onBind方法返回的binder对象得到IBookManager的实例，得到实例就可以调用它的方法了</span></span><br><span class="line">        mIBookManager = IBookManager.Stub.asInterface(binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mIBookManager = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中asInterface(binder)方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.lvr.aidldemo.IBookManager <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="literal">null</span>)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="literal">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.lvr.aidldemo.IBookManager))) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> ((com.lvr.aidldemo.IBookManager) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.lvr.aidldemo.IBookManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先通过queryLocalInterface(DESCRIPTOR);查找到对应的IInterface对象，然后判断对象的类型，如果是同一个进程调用则返回IBookManager对象，由于是跨进程调用则返回Proxy对象，即Binder类的代理对象。<br>（2）客户端调用服务端方法<br>实现IBookService的代理类Proxy，Proxy是一个典型的静态代理模式，Proxy并没有实现IBookService中的方法，而是通过remote将方法请求传递到Server进程，交给Stub类处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">IBookService</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DESCRIPTOR</span> <span class="operator">=</span> <span class="string">&quot;com.xud.ipc.server.IBookService&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBinder remote;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">(IBinder remote)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.remote = remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInterfaceDescriptor</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getBooks</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">replay</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        List&lt;Book&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            remote.transact(Stub.TRANSAVTION_getBooks, data, replay, <span class="number">0</span>);</span><br><span class="line">            replay.readException();</span><br><span class="line">            result = replay.createTypedArrayList(Book.CREATOR);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            replay.recycle();</span><br><span class="line">            data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">replay</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (book != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                data.writeInt(<span class="number">1</span>);</span><br><span class="line">                book.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                data.writeInt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            remote.transact(Stub.TRANSAVTION_addBook, data, replay, <span class="number">0</span>);</span><br><span class="line">            replay.readException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            replay.recycle();</span><br><span class="line">            data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端获得了Binder类的代理对象Proxy，并且通过代理对象获得了IInterface对象，那么就可以调用接口的具体实现方法了，来实现调用服务端方法的目的。<br>以addBook方法为例，调用该方法后，客户端线程挂起，等待唤醒：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(com.lvr.aidldemo.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        ..........</span><br><span class="line">        <span class="comment">//第一个参数：识别调用哪一个方法的ID</span></span><br><span class="line">        <span class="comment">//第二个参数：Book的序列化传入数据</span></span><br><span class="line">        <span class="comment">//第三个参数：调用方法后返回的数据</span></span><br><span class="line">        <span class="comment">//最后一个不用管</span></span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125;</span><br><span class="line">    ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>省略部分主要完成对添加的Book对象进行序列化工作，然后调用transact方法。<br>Proxy对象中的transact调用发生后，会引起系统的注意，系统意识到Proxy对象想找它的真身Binder对象（系统其实一直存着Binder和Proxy的对应关系）。于是系统将这个请求中的数据转发给Binder对象，Binder对象将会在onTransact中收到Proxy对象传来的数据，于是它从data中取出客户端进程传来的数据，又根据第一个参数确定想让它执行添加书本操作，于是它就执行了服务端相应操作，并把结果写回reply。代码概略如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">    com.lvr.aidldemo.Book _arg0;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        _arg0 = com.lvr.aidldemo.Book.CREATOR.createFromParcel(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        _arg0 = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里调用服务端实现的addBook方法</span></span><br><span class="line">    <span class="built_in">this</span>.addBook(_arg0);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在transact方法获得_reply并返回结果，本例中的addList方法没有返回值。<br>客户端线程被唤醒。因此调用服务端方法时，应开启子线程，防止UI线程堵塞，导致ANR。<br>因此对于Binder跨进程通信过程，可以总结为：</p>
<ol>
<li>创建IService.aidl文件，声明暴露给Client的方法。系统将自动创建对应IService.java继承IInterface，包含Stub类和一系列暴露的抽象方法。作为跨进程通信的接口。<br>Stub类：继承Binder，实现IService接口。Server通过创建Stub实例，实现接口中定义的方法，处理Client的调用请求。包含一个构造函数、两个重要的方法和一个代理类：</li>
</ol>
<ul>
<li>public Stub()：创建Stub实例，在Binder中保存IInterface对象，服务端获取Binder</li>
<li>public static IService asInterface(IBinder binder)：根据key值查找相应的IInterface对象，客户端获取Binder</li>
<li>protected boolean onTranscat(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags)：进程间通信的方法，Client调用Proxy对象的transact后，会将数据传给Server的onTransact，执行Client想要执行的方法<br>抽象方法：IService中声明的暴露给Client的方法</li>
</ul>
<ol>
<li>Server进程端创建Stub实例，实现接口方法，使之可以处理Client进程端的调用请求；</li>
<li>Client进程端持有BinderProxy，当要调用IService中的方法时，实际上通过BinderProxy.transact()方法调用，经过Binder驱动跨进程传递之后，最终找到Server端onTransact()执行；</li>
<li>Server的onTransact收到Client传来的数据后，根据code来执行Client调用的方法。<br><img src="https://mark.cuckooing.cn/pics/pic_734e9df6.png" alt="pic_734e9df6.png"></li>
</ol>
<h1 id="第十一章-WebView"><a href="#第十一章-WebView" class="headerlink" title="第十一章 WebView"></a>第十一章 WebView</h1><ul>
<li>WebView</li>
<li><ul>
<li>Hybird 开发</li>
<li>WebView 是什么 &amp; 作用 &amp; 内核</li>
<li>WebView 基本使用</li>
<li><ul>
<li>WebSettings &amp; WebViewClient &amp; WebChromeClient</li>
<li>使用案例</li>
</ul>
</li>
<li>WebView 与 JS 交互方式</li>
<li>WebView 导致内存泄露 原因 &amp; 解决</li>
<li>WebView 优化方案 &amp; 框架</li>
<li><ul>
<li>前端H5的缓存机制（WebView 缓存机制）</li>
<li>资源预加载</li>
<li>自身构建缓存</li>
</ul>
</li>
<li>Hybird 框架</li>
</ul>
</li>
</ul>
<h2 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h2><h3 id="Hybird-开发"><a href="#Hybird-开发" class="headerlink" title="Hybird 开发"></a>Hybird 开发</h3><p>Hybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。<br>hybrid开发其实就是在App开发过程中既使用到了web（H5）开发技术也使用到了native开发技术，通过这两种技术混合实现的App就是我们通常说的hybrid app，而通过这两种技术混合开发就是hybrid开发。</p>
<ol>
<li>为何需要hybird开发</li>
</ol>
<ul>
<li>使用Native开发的方式人员要求高，只是一个简单的功能就需要IOS程序员和Android程序员各自完成；</li>
<li>使用Native开发的方式版本迭代周期慢，每次完成版本升级之后都需要上传到App Store并审核，升级，重新安装等，升级成本高；</li>
<li>使用hybrid开发的方式简单方便，同一套代码既可以在IOS平台使用，也可以在Android平台使用，提高了开发效率与代码的可维护性；</li>
<li>使用hybrid开发的方式升级简单方便，只需要服务器端升级一下就好了，对用户而言完全是透明了，免去了Native升级中的种种不便；</li>
</ul>
<blockquote>
<p>通过对比可以发现hybrid开发方式现对于native实现主要的优势就是更新版本快，代码维护方便，当然了这两个优点也是我们推崇使用hybrid开发app的主要因素。</p>
</blockquote>
<ol>
<li>Android中如何实现Bybird开发</li>
</ol>
<p>有两种方案：</p>
<ul>
<li>使用第三方hybrid框架（集成度高，不容易定制化处理）</li>
<li>自己使用webview加载（定制化程度高，问题可控，但是相对与第三方框架集成度不够高）</li>
</ul>
<h3 id="WebView-是什么-作用-内核"><a href="#WebView-是什么-作用-内核" class="headerlink" title="WebView 是什么 &amp; 作用 &amp; 内核"></a>WebView 是什么 &amp; 作用 &amp; 内核</h3><ul>
<li>简介</li>
</ul>
<p>WebView是一个基于webkit引擎、展现web页面的控件。</p>
<blockquote>
<p>Android的Webview在低版本和高版本采用了不同的webkit版本内核，4.4后直接使用了Chrome。</p>
</blockquote>
<ul>
<li>显示和渲染Web页面</li>
<li>直接加载url</li>
<li>直接使用html文件（网络上或本地assets中）作布局</li>
<li>使用JavaScript交互调用H5和Native</li>
</ul>
<h3 id="WebView-基本使用"><a href="#WebView-基本使用" class="headerlink" title="WebView 基本使用"></a>WebView 基本使用</h3><p>前提：添加网络权限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="WebSettings-WebViewClient-WebChromeClient"><a href="#WebSettings-WebViewClient-WebChromeClient" class="headerlink" title="WebSettings &amp; WebViewClient &amp; WebChromeClient"></a>WebSettings &amp; WebViewClient &amp; WebChromeClient</h4><ol>
<li>WebSetting<br>对WebView进行配置和管理</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebView</span>(<span class="built_in">this</span>)</span><br><span class="line"><span class="type">WebView</span> <span class="variable">webview</span> <span class="operator">=</span> (WebView) findViewById(R.id.webView1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明WebSettings子类</span></span><br><span class="line"><span class="type">WebSettings</span> <span class="variable">webSettings</span> <span class="operator">=</span> webView.getSettings();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果访问的页面中要与Javascript交互，则webview必须设置支持Javascript</span></span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="literal">true</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//支持插件</span></span><br><span class="line">webSettings.setPluginsEnabled(<span class="literal">true</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//设置自适应屏幕，两者合用</span></span><br><span class="line">webSettings.setUseWideViewPort(<span class="literal">true</span>); <span class="comment">//将图片调整到适合webview的大小 </span></span><br><span class="line">webSettings.setLoadWithOverviewMode(<span class="literal">true</span>); <span class="comment">// 缩放至屏幕的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缩放操作</span></span><br><span class="line">webSettings.setSupportZoom(<span class="literal">true</span>); <span class="comment">//支持缩放，默认为true。是下面那个的前提。</span></span><br><span class="line">webSettings.setBuiltInZoomControls(<span class="literal">true</span>); <span class="comment">//设置内置的缩放控件。若为false，则该WebView不可缩放</span></span><br><span class="line">webSettings.setDisplayZoomControls(<span class="literal">false</span>); <span class="comment">//隐藏原生的缩放控件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他细节操作</span></span><br><span class="line">webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); <span class="comment">//关闭webview中缓存 </span></span><br><span class="line">webSettings.setAllowFileAccess(<span class="literal">true</span>); <span class="comment">//设置可以访问文件 </span></span><br><span class="line">webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>); <span class="comment">//支持通过JS打开新窗口 </span></span><br><span class="line">webSettings.setLoadsImagesAutomatically(<span class="literal">true</span>); <span class="comment">//支持自动加载图片</span></span><br><span class="line">webSettings.setDefaultTextEncodingName(<span class="string">&quot;utf-8&quot;</span>);<span class="comment">//设置编码格式</span></span><br></pre></td></tr></table></figure>

<p>常用：设置WebView缓存<br>当加载 html 页面时，WebView会在&#x2F;data&#x2F;data&#x2F;包名目录下生成 database 与 cache 两个文件夹<br>请求的 URL记录保存在 WebViewCache.db，而 URL的内容是保存在 WebViewCache 文件夹下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优先使用缓存: </span></span><br><span class="line">    WebView.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); </span><br><span class="line">        <span class="comment">//缓存模式如下：</span></span><br><span class="line">        <span class="comment">//LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据</span></span><br><span class="line">        <span class="comment">//LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。</span></span><br><span class="line">        <span class="comment">//LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.</span></span><br><span class="line">        <span class="comment">//LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//不使用缓存: </span></span><br><span class="line">	WebView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 结合使用（离线加载）</span></span><br><span class="line">	<span class="keyword">if</span> (NetStatusUtil.isConnected(getApplicationContext())) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);<span class="comment">//根据cache-control决定是否从网络上取数据。</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);<span class="comment">//没网，则从本地获取，即离线加载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>WebViewClient<br>处理各种通知 &amp; 请求事件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Webview</span> <span class="variable">webview</span> <span class="operator">=</span> (WebView) findViewById(R.id.webView1);</span><br><span class="line"></span><br><span class="line">   webView.loadUrl(<span class="string">&quot;http://www.google.com/&quot;</span>);	<span class="comment">// 加载一个网页</span></span><br><span class="line">   webView.loadUrl(<span class="string">&quot;file:///android_asset/test.html&quot;</span>);	<span class="comment">// 加载apk包中的html页面</span></span><br><span class="line">   webView.loadUrl(<span class="string">&quot;content://com.android.htmlfileprovider/sdcard/test.html&quot;</span>);	<span class="comment">// 加载手机本地的html页面</span></span><br><span class="line"></span><br><span class="line">    webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>()&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">          <span class="comment">// shouldOverrideUrlLoading()方法，使得打开网页时不调用系统浏览器， 而是在本WebView中显示,在网页上的所有加载都经过这个方法</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">onPageStarted</span><span class="params">(WebView view, String url, Bitmap favicon)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">         <span class="comment">// 开始加载页面调用的，我们可以设定一个loading的页面，告诉用户程序在等待网络响应。</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageFinished</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">         <span class="comment">// 在页面加载结束时调用。我们可以关闭loading 条，切换程序动作。</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceivedError</span><span class="params">(WebView view, <span class="type">int</span> errorCode, String description, String failingUrl)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="keyword">switch</span>(errorCode)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// App里面使用webview控件的时候遇到了诸如404这类的错误的时候，若也显示浏览器里面的那种错误提示页面就显得很丑陋了</span></span><br><span class="line">		<span class="comment">// 那么这个时候我们的app就需要加载一个本地的错误提示页面</span></span><br><span class="line">		<span class="comment">// 步骤1：写一个html文件（error_handle.html），用于出错时展示给用户看的提示页面</span></span><br><span class="line">		<span class="comment">// 步骤2：将该html文件放置到代码根目录的assets文件夹下</span></span><br><span class="line">		<span class="comment">// 步骤3：复写WebViewClient的onRecievedError方法</span></span><br><span class="line">                <span class="keyword">case</span> HttpStatus.SC_NOT_FOUND:</span><br><span class="line">                <span class="comment">//该方法传回了错误码，根据错误类型可以进行不同的错误分类处理</span></span><br><span class="line">                    view.loadUrl(<span class="string">&quot;file:///android_assets/error_handle.html&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>WebChromeClient<br>辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">webview.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>()&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProgressChanged</span><span class="params">(WebView view, <span class="type">int</span> newProgress)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 获得网页的加载进度并显示</span></span><br><span class="line">          <span class="keyword">if</span> (newProgress &lt; <span class="number">100</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">              <span class="type">String</span> <span class="variable">progress</span> <span class="operator">=</span> newProgress + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">              progress.setText(progress);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceivedTitle</span><span class="params">(WebView view, String title)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="comment">// 获取Web页中的标题</span></span><br><span class="line">       		titleview.setText(title)；</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>（1）需求<br>实现显示“<a target="_blank" rel="noopener" href="http://www.baidu.com”、获取其标题、提示加载开始/">www.baidu.com”、获取其标题、提示加载开始</a> &amp; 结束和获取加载进度<br>（2）实现<br>步骤1：添加访问网络权限<br>AndroidManifest.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>步骤2：主布局<br>activity_main.xml</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;RelativeLayout&gt;</span><br><span class="line">   &lt;!-- 获取网站的标题--&gt;</span><br><span class="line">    &lt;TextView android:id=<span class="string">&quot;@+id/title&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--开始加载提示--&gt;</span><br><span class="line">    &lt;TextView android:id=<span class="string">&quot;@+id/text_beginLoading&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--获取加载进度--&gt;</span><br><span class="line">    &lt;TextView android:id=<span class="string">&quot;@+id/text_Loading&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--结束加载提示--&gt;</span><br><span class="line">    &lt;TextView android:id=<span class="string">&quot;@+id/text_endLoading&quot;</span>/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--显示网页区域--&gt;</span><br><span class="line">    &lt;WebView android:id=<span class="string">&quot;@+id/webView1&quot;</span>/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>

<p>步骤3：实现显示“<a target="_blank" rel="noopener" href="http://www.baidu.com”、获取其标题、提示加载开始/">www.baidu.com”、获取其标题、提示加载开始</a> &amp; 结束和获取加载进度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    WebView mWebview;</span><br><span class="line">    WebSettings mWebSettings;</span><br><span class="line">    TextView beginLoading,endLoading,loading,mtitle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        </span><br><span class="line">        mWebview = (WebView) findViewById(R.id.webView1);</span><br><span class="line">        beginLoading = (TextView) findViewById(R.id.text_beginLoading);</span><br><span class="line">        endLoading = (TextView) findViewById(R.id.text_endLoading);</span><br><span class="line">        loading = (TextView) findViewById(R.id.text_Loading);</span><br><span class="line">        mtitle = (TextView) findViewById(R.id.title);</span><br><span class="line">        <span class="comment">// webSettings 对WebView进行配置和管理</span></span><br><span class="line">        mWebSettings = mWebview.getSettings();</span><br><span class="line">        mWebview.loadUrl(<span class="string">&quot;http://www.baidu.com/&quot;</span>);</span><br><span class="line">        <span class="comment">// WebViewClient 处理各种通知 &amp; 请求事件</span></span><br><span class="line">        <span class="comment">//设置不用系统浏览器打开,直接显示在当前Webview</span></span><br><span class="line">        mWebview.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                view.loadUrl(url);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置WebChromeClient类</span></span><br><span class="line">        mWebview.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//获取网站标题</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceivedTitle</span><span class="params">(WebView view, String title)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                System.out.println(<span class="string">&quot;标题在这里&quot;</span>);</span><br><span class="line">                mtitle.setText(title);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取加载进度</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProgressChanged</span><span class="params">(WebView view, <span class="type">int</span> newProgress)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span> (newProgress &lt; <span class="number">100</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="type">String</span> <span class="variable">progress</span> <span class="operator">=</span> newProgress + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">                    loading.setText(progress);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newProgress == <span class="number">100</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="type">String</span> <span class="variable">progress</span> <span class="operator">=</span> newProgress + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">                    loading.setText(progress);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置WebViewClient类</span></span><br><span class="line">        mWebview.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//设置加载前的函数</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageStarted</span><span class="params">(WebView view, String url, Bitmap favicon)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                System.out.println(<span class="string">&quot;开始加载了&quot;</span>);</span><br><span class="line">                beginLoading.setText(<span class="string">&quot;开始加载了&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置结束加载函数</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageFinished</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                endLoading.setText(<span class="string">&quot;结束加载了&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击返回上一页面而不是退出浏览器</span></span><br><span class="line">    <span class="comment">// 在不做任何处理前提下 ，浏览网页时点击系统的“Back”键,整个 Browser 会调用 finish()而结束自身</span></span><br><span class="line">    <span class="comment">// 解决：在当前Activity中处理并消费掉该 Back 事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onKeyDown</span><span class="params">(<span class="type">int</span> keyCode, KeyEvent event)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; mWebview.canGoBack()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            mWebview.goBack();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onKeyDown(keyCode, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁Webview</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (mWebview != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            mWebview.loadDataWithBaseURL(<span class="literal">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// mWebview.clearCache 清除网页访问留下的缓存（针对整个应用程序）</span></span><br><span class="line">            mWebview.clearHistory(); <span class="comment">// 清除当前webview访问的历史记录（针对当前访问记录）</span></span><br><span class="line">            <span class="comment">// 先从父容器中移除webview,然后再销毁webview -&gt;&gt; 防止内存泄露</span></span><br><span class="line">            ((ViewGroup) mWebview.getParent()).removeView(mWebview);</span><br><span class="line">            mWebview.destroy();</span><br><span class="line">            mWebview = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WebView-与-JS-交互方式"><a href="#WebView-与-JS-交互方式" class="headerlink" title="WebView 与 JS 交互方式"></a>WebView 与 JS 交互方式</h3><ul>
<li>Android 调用 JS 方法<br>通过WebView的loadUrl</li>
<li>Web端</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">      &lt;title&gt;js_test&lt;/title&gt;</span><br><span class="line">     &lt;script&gt;</span><br><span class="line">    <span class="comment">// Android调用JS的方法</span></span><br><span class="line">   function <span class="title function_">callJS</span><span class="params">(message)</span>&#123;</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      alert(<span class="string">&quot;Android调用了JS的callJS方法:参数为&quot;</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Android端</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HybirdTestctivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;file:///android_asset/js_test.html&quot;</span>;</span><br><span class="line"></span><br><span class="line">    WebView mWebView;</span><br><span class="line">    Button btn1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_hybird_testctivity);</span><br><span class="line">        mWebView = (WebView) findViewById(R.id.webView1);</span><br><span class="line">        btn1 = (Button) findViewById(R.id.btn1_hybird);</span><br><span class="line">        <span class="type">WebSettings</span> <span class="variable">webSettings</span> <span class="operator">=</span> mWebView.getSettings();</span><br><span class="line">        webSettings.setJavaScriptEnabled(<span class="literal">true</span>);        <span class="comment">// 设置与Js交互的权限</span></span><br><span class="line">        webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>);        <span class="comment">// 设置允许JS弹窗</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先载入JS代码</span></span><br><span class="line">        <span class="comment">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class="line">        mWebView.loadUrl(url);</span><br><span class="line">        <span class="comment">// 由于设置了弹窗检验调用结果,所以需要支持js对话框</span></span><br><span class="line">        <span class="comment">// webview只是载体，内容的渲染需要使用webviewChromClient类去实现</span></span><br><span class="line">        <span class="comment">// 通过设置WebChromeClient对象处理JavaScript的对话框</span></span><br><span class="line">        mWebView.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsAlert</span><span class="params">(WebView view, String url, String message, <span class="keyword">final</span> JsResult result)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            	<span class="comment">// 通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 消息</span></span><br><span class="line">                <span class="comment">// 设置响应js 的Alert()函数</span></span><br><span class="line">                AlertDialog.<span class="type">Builder</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlertDialog</span>.Builder(HybirdTestctivity.<span class="built_in">this</span>);</span><br><span class="line">                b.setTitle(<span class="string">&quot;Alert&quot;</span>);</span><br><span class="line">                b.setMessage(message);</span><br><span class="line">                b.setPositiveButton(android.R.string.ok, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialog, <span class="type">int</span> which)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        result.confirm();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                b.setCancelable(<span class="literal">false</span>);</span><br><span class="line">                b.create().show();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">switch</span> (view.getId())&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">case</span> R.id.btn1_hybird:</span><br><span class="line">                <span class="comment">// Android通过WebView调用 JS 代码——通过webView.loadUrl</span></span><br><span class="line">                mWebView.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        <span class="comment">// 注意调用的JS方法名要对应上</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Message From Android&quot;</span>;</span><br><span class="line">                        mWebView.loadUrl(<span class="string">&quot;javascript:callJS(&#x27;&quot;</span>+msg+<span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line">                &#125;&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>JS 调用 Android 方法<br>使用@addJavascriptInterface 注入 java 对象来实现</li>
<li>创建要注入的Java类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建注入的Java类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeInterface</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NativeInterface</span><span class="params">(Context context)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义JS需要调用的方法</span></span><br><span class="line">    <span class="comment">// 被JS调用的方法必须加入@JavascriptInterface注解</span></span><br><span class="line">    <span class="meta">@JavascriptInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Log.i(<span class="string">&quot;AndroidNative&quot;</span>, <span class="string">&quot;hello: &quot;</span>+ msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JavascriptInterface</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDataFromAndroid</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Log.i(<span class="string">&quot;AndroidNative&quot;</span>, <span class="string">&quot;getDataFromAndroid: &quot;</span>+<span class="string">&quot;JS调用了Android的getDataFromAndroid方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Android Data&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Android端</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置与Js交互的权限</span></span><br><span class="line">        webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// JSBridge实现JS调用Android:通过addJavascriptInterface()将Java对象注入到JS对象</span></span><br><span class="line">        <span class="comment">// NativeInterface类对象注入到js的AndroidNative对象</span></span><br><span class="line">        mWebView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">NativeInterface</span>(<span class="built_in">this</span>), <span class="string">&quot;AndroidNative&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>Web端</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">      &lt;title&gt;js_test&lt;/title&gt;</span><br><span class="line">     &lt;script&gt;</span><br><span class="line">   <span class="comment">// JS调用Android方法</span></span><br><span class="line">   function <span class="title function_">hello_android</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 由于对象映射，所以调用AndroidNative对象等于调用Android映射的对象</span></span><br><span class="line">        AndroidNative.hello(<span class="string">&quot;js调用了android中的hello方法&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function <span class="title function_">getDataFromAndroid_android</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 由于对象映射，所以调用AndroidNative对象等于调用Android映射的对象</span></span><br><span class="line">        alert(AndroidNative.getDataFromAndroid());</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">   &lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;button1&quot;</span> onclick=<span class="string">&quot;javascript:hello_android();&quot;</span>&gt;点击按钮则调用hello_android函数&lt;/button&gt;</span><br><span class="line">   &lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;button2&quot;</span> onclick=<span class="string">&quot;javascript:getDataFromAndroid_android();&quot;</span>&gt;点击按钮则调用getDataFromAndroid_android函数&lt;/button&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>JS 消息回调拦截</li>
<li>通过 WebViewClient 的方法shouldOverrideUrlLoading ()回调拦截 url<br>（1）在JS约定所需要的Url协议</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">      &lt;title&gt;Carson_Ho&lt;/title&gt;</span><br><span class="line">      </span><br><span class="line">     &lt;script&gt;</span><br><span class="line">         function <span class="title function_">callAndroid</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">            <span class="comment">/*约定的url协议为：js://webview?arg1=111&amp;arg2=222*/</span></span><br><span class="line">            document.location = <span class="string">&quot;js://webview?arg1=111&amp;arg2=222&quot;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击按钮则调用callAndroid（）方法  --&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">     &lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;button1&quot;</span> <span class="string">&quot;callAndroid()&quot;</span>&gt;点击调用Android代码&lt;/button&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>（2）在Android通过WebViewClient复写shouldOverrideUrlLoading ()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复写WebViewClient类的shouldOverrideUrlLoading方法</span></span><br><span class="line">mWebView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                                      <span class="meta">@Override</span></span><br><span class="line">                                      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                                          <span class="comment">// 步骤2：根据协议的参数，判断是否是所需要的url</span></span><br><span class="line">                                          <span class="comment">// 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span></span><br><span class="line">                                          <span class="comment">//假定传入进来的 url = &quot;js://webview?arg1=111&amp;arg2=222&quot;（同时也是约定好的需要拦截的）</span></span><br><span class="line"></span><br><span class="line">                                          <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(url);                                 </span><br><span class="line">                                          <span class="comment">// 如果url的协议 = 预先约定的 js 协议</span></span><br><span class="line">                                          <span class="comment">// 就解析往下解析参数</span></span><br><span class="line">                                          <span class="keyword">if</span> ( uri.getScheme().equals(<span class="string">&quot;js&quot;</span>)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                                              <span class="comment">// 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议</span></span><br><span class="line">                                              <span class="comment">// 所以拦截url,下面JS开始调用Android需要的方法</span></span><br><span class="line">                                              <span class="keyword">if</span> (uri.getAuthority().equals(<span class="string">&quot;webview&quot;</span>)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                                                 <span class="comment">//  步骤3：</span></span><br><span class="line">                                                  <span class="comment">// 执行JS所需要调用的逻辑</span></span><br><span class="line">                                                  System.out.println(<span class="string">&quot;js调用了Android的方法&quot;</span>);</span><br><span class="line">                                                  <span class="comment">// 可以在协议上带有参数并传递到Android上</span></span><br><span class="line">                                                  HashMap&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                                                  Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line"></span><br><span class="line">                                              &#125;</span><br><span class="line"></span><br><span class="line">                                              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                                          &#125;</span><br><span class="line">                                          <span class="keyword">return</span> <span class="built_in">super</span>.shouldOverrideUrlLoading(view, url);</span><br><span class="line">                                      &#125;</span><br><span class="line">                                  &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 消息<br>（1）Web端调用prompt() 调用JS输入框</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">      &lt;title&gt;Carson_Ho&lt;/title&gt;</span><br><span class="line">      </span><br><span class="line">     &lt;script&gt;</span><br><span class="line">        </span><br><span class="line">	function <span class="title function_">clickprompt</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 调用prompt（）</span></span><br><span class="line">    <span class="keyword">var</span> result=prompt(<span class="string">&quot;js://demo?arg1=111&amp;arg2=222&quot;</span>);</span><br><span class="line">    alert(<span class="string">&quot;demo &quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击按钮则调用clickprompt()  --&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">     &lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;button1&quot;</span> <span class="string">&quot;clickprompt()&quot;</span>&gt;点击调用Android代码&lt;/button&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>（2）在Android通过WebChromeClient复写onJsPrompt（）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">mWebView.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                                        <span class="comment">// 拦截输入框(原理同方式2)</span></span><br><span class="line">                                        <span class="comment">// 参数message:代表promt（）的内容（不是url）</span></span><br><span class="line">                                        <span class="comment">// 参数result:代表输入框的返回值</span></span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsPrompt</span><span class="params">(WebView view, String url, String message, String defaultValue, JsPromptResult result)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                                            <span class="comment">// 根据协议的参数，判断是否是所需要的url(原理同方式2)</span></span><br><span class="line">                                            <span class="comment">// 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span></span><br><span class="line">                                            <span class="comment">//假定传入进来的 url = &quot;js://webview?arg1=111&amp;arg2=222&quot;（同时也是约定好的需要拦截的）</span></span><br><span class="line"></span><br><span class="line">                                            <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(message);</span><br><span class="line">                                            <span class="comment">// 如果url的协议 = 预先约定的 js 协议</span></span><br><span class="line">                                            <span class="comment">// 就解析往下解析参数</span></span><br><span class="line">                                            <span class="keyword">if</span> ( uri.getScheme().equals(<span class="string">&quot;js&quot;</span>)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                                                <span class="comment">// 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议</span></span><br><span class="line">                                                <span class="comment">// 所以拦截url,下面JS开始调用Android需要的方法</span></span><br><span class="line">                                                <span class="keyword">if</span> (uri.getAuthority().equals(<span class="string">&quot;webview&quot;</span>)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                                                    <span class="comment">//</span></span><br><span class="line">                                                    <span class="comment">// 执行JS所需要调用的逻辑</span></span><br><span class="line">                                                    System.out.println(<span class="string">&quot;js调用了Android的方法&quot;</span>);</span><br><span class="line">                                                    <span class="comment">// 可以在协议上带有参数并传递到Android上</span></span><br><span class="line">                                                    HashMap&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                                                    Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line"></span><br><span class="line">                                                    <span class="comment">//参数result:代表消息框的返回值(输入值)</span></span><br><span class="line">                                                    result.confirm(<span class="string">&quot;js调用了Android的方法成功啦&quot;</span>);</span><br><span class="line">                                                &#125;</span><br><span class="line">                                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                            <span class="keyword">return</span> <span class="built_in">super</span>.onJsPrompt(view, url, message, defaultValue, result);</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过alert()和confirm()拦截的原理相同，此处不作过多讲述</span></span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// 拦截JS的警告框</span></span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsAlert</span><span class="params">(WebView view, String url, String message, JsResult result)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                                            <span class="keyword">return</span> <span class="built_in">super</span>.onJsAlert(view, url, message, result);</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// 拦截JS的确认框</span></span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsConfirm</span><span class="params">(WebView view, String url, String message, JsResult result)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                                            <span class="keyword">return</span> <span class="built_in">super</span>.onJsConfirm(view, url, message, result);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="WebView-导致内存泄露-原因-解决"><a href="#WebView-导致内存泄露-原因-解决" class="headerlink" title="WebView 导致内存泄露 原因 &amp; 解决"></a>WebView 导致内存泄露 原因 &amp; 解决</h3><p>不再使用WebView对象后不销毁，导致占用的内存长期无法回收，从而造成内存泄露。<br>WebView关联Activity的时候会自动创建线程，绑定了Activity Context。而Activity无法确定这个线程的销毁时间，这个线程的生命周期和我们Activity生命周期是不一样的，这就导致了Activity销毁时，WebView还持有Activity的引用，从而出现内存泄漏问题。<br>WebView与Activity Context绑定。销毁WebView的时候，需要释放Activity的Context，否则会内存泄露。</p>
<ol>
<li>在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (mWebView != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            mWebView.loadDataWithBaseURL(<span class="literal">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">            mWebView.clearHistory();</span><br><span class="line">			<span class="comment">// 在关闭了Activity时，如果Webview的音乐或视频，还在播放。就必须销毁Webview</span></span><br><span class="line">			<span class="comment">// 但是注意：webview调用destory时,webview仍绑定在Activity上</span></span><br><span class="line">			<span class="comment">//这是由于自定义webview构建时传入了该Activity的context对象，因此需要先从父容器中移除webview,然后再销毁webview:</span></span><br><span class="line">            ((ViewGroup) mWebView.getParent()).removeView(mWebView);</span><br><span class="line">            mWebView.destroy();</span><br><span class="line">            mWebView = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>不在xml中定义 WebView ，而是在需要的时候在Activity中创建，并且Context使用 getApplicationContext()</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinearLayout</span>.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">        mWebView = <span class="keyword">new</span> <span class="title class_">WebView</span>(getApplicationContext());</span><br><span class="line">        mWebView.setLayoutParams(params);</span><br><span class="line">        mLayout.addView(mWebView);</span><br></pre></td></tr></table></figure>

<ol>
<li>开启独立进程加载WebView页面，页面关闭后关闭进程</li>
</ol>
<h3 id="WebView-优化方案-框架"><a href="#WebView-优化方案-框架" class="headerlink" title="WebView 优化方案 &amp; 框架"></a>WebView 优化方案 &amp; 框架</h3><p>WebView 性能问题</p>
<ul>
<li>Android WebView 里 H5 页面加载速度慢<br>（1）渲染速度慢：JS解析效率低、手机硬件设备性能低<br>（2）资源加载慢：H5页面资源多、网络请求数量多</li>
<li>耗费流量<br>（1）每次使用时需要重新加载Android WebView H5页面<br>（2）发送大量网络请求</li>
</ul>
<p>上述问题导致了Android WebView的H5 页面体验 与 原生Native 存在较大差距。</p>
<h4 id="前端H5的缓存机制（WebView-缓存机制）"><a href="#前端H5的缓存机制（WebView-缓存机制）" class="headerlink" title="前端H5的缓存机制（WebView 缓存机制）"></a>前端H5的缓存机制（WebView 缓存机制）</h4><ul>
<li>浏览器 缓存机制<br>根据 HTTP 协议头里的 Cache-Control（或 Expires）和 Last-Modified（或 Etag）等字段来控制文件缓存的机制<br>Android WebView内置自动实现，即不需要设置即实现（属于浏览器内核机制），用于存储静态资源文件，如JS、CSS、字体、图片等。</li>
<li>Application Cache 缓存机制<br>以文件为单位进行缓存，且文件有一定更新机制（类似于浏览器缓存机制，是浏览器缓存的补充），是专门为 Web App离线使用而开发的缓存机制<br>用于存储静态文件（如JS、CSS、字体文件）</li>
<li>Dom Storage 缓存机制<br>通过存储字符串的 Key - Value 对来提供，存储控件大、安全、便捷（Dom Storage 机制类似于 Android 的 SharedPreference机制）<br>用于存储临时、简单的数据。</li>
<li>Web SQL Database 缓存机制<br>基于 SQL 的数据库存储机制，充分利用数据库的优势，可方便对数据进行增加、删除、修改、查询。存储适合数据库的结构化数据。</li>
<li>Indexed Database 缓存机制<br>属于 NoSQL 数据库，通过存储字符串的 Key - Value 对来提供（取代Web SQL Database 缓存机制）。通过数据库的事务机制进行数据操作，可对对象任何属性生成索引，方便查询。存储控件大。可存储任何类型对象。<br>适用于存储复杂、数据量大的结构化数据。</li>
</ul>
<h4 id="资源预加载"><a href="#资源预加载" class="headerlink" title="资源预加载"></a>资源预加载</h4><p>包括 WebView对象 &amp; H5资源 预加载</p>
<ul>
<li>原因<br>首次创建WebView对象耗时<br>首次加载H5页面耗时（后续打开H5页面时便有缓存）</li>
<li>具体实现</li>
<li>在Android的 BaseApplication 里初始化一个WebView对象（用于加载常用的H5页面资源）；当需要使用这些页面时，直接从BaseApplication中使用该WebView对象显示、</li>
</ul>
<h4 id="自身构建缓存"><a href="#自身构建缓存" class="headerlink" title="自身构建缓存"></a>自身构建缓存</h4><ul>
<li>原因<br>H5页面有一些更新频率低、常用 &amp; 固定的静态资源文件（如JS、CSS文件、图片等）。每次重新加载会浪费很多时间、流量。</li>
<li>解决方案</li>
</ul>
<ol>
<li>事先将更新频率较低、常用 &amp; 固定的H5静态资源 文件（如JS、CSS文件、图片等） 放到本地</li>
<li>拦截H5页面的资源网络请求 并进行检测</li>
<li>如果检测到本地具有相同的静态资源 就 直接从本地读取进行替换 而 不发送该资源的网络请求 到 服务器获取</li>
</ol>
<ul>
<li>具体实现<br>重写WebViewClient 的 shouldInterceptRequest 方法，当向服务器访问这些静态资源时进行拦截，检测到是相同的资源则用本地资源代替</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设现在需要拦截一个图片的资源并用本地资源进行替代</span></span><br><span class="line"></span><br><span class="line">        mWebview.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// 重写 WebViewClient  的  shouldInterceptRequest （）</span></span><br><span class="line">            <span class="comment">// API 21 以下用shouldInterceptRequest(WebView view, String url)</span></span><br><span class="line">            <span class="comment">// API 21 以上用shouldInterceptRequest(WebView view, WebResourceRequest request)</span></span><br><span class="line">            <span class="comment">// 下面会详细说明</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// API 21 以下用shouldInterceptRequest(WebView view, String url)</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> WebResourceResponse <span class="title function_">shouldInterceptRequest</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 步骤1:判断拦截资源的条件，即判断url里的图片资源的文件名</span></span><br><span class="line">                <span class="keyword">if</span> (url.contains(<span class="string">&quot;logo.gif&quot;</span>)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="comment">// 假设网页里该图片资源的地址为：http://abc.com/imgage/logo.gif</span></span><br><span class="line">                <span class="comment">// 图片的资源文件名为:logo.gif</span></span><br><span class="line"></span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 步骤2:创建一个输入流</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        is =getApplicationContext().getAssets().open(<span class="string">&quot;images/abc.png&quot;</span>);</span><br><span class="line">                        <span class="comment">// 步骤3:获得需要替换的资源(存放在assets文件夹里)</span></span><br><span class="line">                        <span class="comment">// a. 先在app/src/main下创建一个assets文件夹</span></span><br><span class="line">                        <span class="comment">// b. 在assets文件夹里再创建一个images文件夹</span></span><br><span class="line">                        <span class="comment">// c. 在images文件夹放上需要替换的资源（此处替换的是abc.png图片）</span></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 步骤4:替换资源</span></span><br><span class="line">                    <span class="type">WebResourceResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebResourceResponse</span>(<span class="string">&quot;image/png&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;utf-8&quot;</span>, is);</span><br><span class="line">                    <span class="comment">// 参数1：http请求里该图片的Content-Type,此处图片为image/png</span></span><br><span class="line">                    <span class="comment">// 参数2：编码类型</span></span><br><span class="line">                    <span class="comment">// 参数3：存放着替换资源的输入流（上面创建的那个）</span></span><br><span class="line">                    <span class="keyword">return</span> response;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.shouldInterceptRequest(view, url);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">           <span class="comment">// API 21 以上用shouldInterceptRequest(WebView view, WebResourceRequest request)</span></span><br><span class="line">            <span class="meta">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> WebResourceResponse <span class="title function_">shouldInterceptRequest</span><span class="params">(WebView view, WebResourceRequest request)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">               <span class="comment">// 步骤1:判断拦截资源的条件，即判断url里的图片资源的文件名</span></span><br><span class="line">                <span class="keyword">if</span> (request.getUrl().toString().contains(<span class="string">&quot;logo.gif&quot;</span>)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="comment">// 假设网页里该图片资源的地址为：http://abc.com/imgage/logo.gif</span></span><br><span class="line">                <span class="comment">// 图片的资源文件名为:logo.gif</span></span><br><span class="line"></span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 步骤2:创建一个输入流</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        is = getApplicationContext().getAssets().open(<span class="string">&quot;images/abc.png&quot;</span>);</span><br><span class="line">                         <span class="comment">// 步骤3:获得需要替换的资源(存放在assets文件夹里)</span></span><br><span class="line">                        <span class="comment">// a. 先在app/src/main下创建一个assets文件夹</span></span><br><span class="line">                        <span class="comment">// b. 在assets文件夹里再创建一个images文件夹</span></span><br><span class="line">                        <span class="comment">// c. 在images文件夹放上需要替换的资源（此处替换的是abc.png图片</span></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 步骤4:替换网络返回资源</span></span><br><span class="line">                    <span class="type">WebResourceResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebResourceResponse</span>(<span class="string">&quot;image/png&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;utf-8&quot;</span>, is);</span><br><span class="line">                    <span class="comment">// 参数1：http请求里该图片的Content-Type,此处图片为image/png</span></span><br><span class="line">                    <span class="comment">// 参数2：编码类型</span></span><br><span class="line">                    <span class="comment">// 参数3：存放着替换资源的输入流（上面创建的那个）</span></span><br><span class="line">                    <span class="keyword">return</span> response;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.shouldInterceptRequest(view, request);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hybird-框架"><a href="#Hybird-框架" class="headerlink" title="Hybird 框架"></a>Hybird 框架</h3><p>[腾讯祭出大招VasSonic，让你的H5页面首屏秒开][VasSonic_H5]</p>
<p>优化方案：</p>
<ol>
<li>启动流程彻底拆分，设计为一个状态机按序按需执行</li>
<li>View相关拆分模块化设计，尽可能懒加载，IO异步化</li>
<li>X5内核在手Q中的独立进程中提前预加载</li>
<li>创建WebView对象复用池</li>
<li>静态直出</li>
<li>离线预推：把页面的资源提前拉取到本地，当用户加载资源的时候，相当于从本地加载，即使没有网络，也能展示首屏页面。这个也就是大家熟悉的离线包。（在弱网络或者网速比较差的环境下加载资源耗时耗资源）</li>
<li>并行加载</li>
<li>动态缓存（将用户的已经加载的页面内容缓存下来，等用户下此点击页面的时候，我们先加载展示页面缓存，第一时间让用户看到内容，然后同时去请求新的页面数据，等新的页面数据拉取下来之后，我们再重新加载一遍即可。）</li>
<li>页面分离</li>
<li>请求规范约定</li>
<li>首次加载 &amp; 非首次加载之 完全缓存&#x2F;增量数据&#x2F;模块更新</li>
</ol>
<h1 id="第十二章-Android第三方库源码"><a href="#第十二章-Android第三方库源码" class="headerlink" title="第十二章 Android第三方库源码"></a>第十二章 Android第三方库源码</h1><ul>
<li>EventBus</li>
<li><ul>
<li>EventBus理解</li>
<li>EventBus源码分析</li>
<li>EventBus项目实战</li>
</ul>
</li>
<li>okHttp</li>
<li><ul>
<li>简介</li>
<li>使用</li>
<li>工作原理</li>
<li><ul>
<li>源码解读</li>
<li>总结</li>
<li>设计模式</li>
</ul>
</li>
<li>封装</li>
<li>网络框架对比</li>
</ul>
</li>
<li>Glide</li>
<li><ul>
<li>简介</li>
<li>使用</li>
<li>工作原理（非重点）</li>
<li>图片加载框架对比</li>
</ul>
</li>
</ul>
<h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h2><p>[<a target="_blank" rel="noopener" href="https://github.com/greenrobot/EventBus][https_github.com_greenrobot_EventBus]">https://github.com/greenrobot/EventBus][https_github.com_greenrobot_EventBus]</a></p>
<h3 id="EventBus理解"><a href="#EventBus理解" class="headerlink" title="EventBus理解"></a>EventBus理解</h3><p>[EventBus原理解析笔记以及案例实战（结合demo）][EventBus_demo]</p>
<ul>
<li>什么是 EventBus<br>EventBus（事件总线）是一个Android端优化的 发布&#x2F;订阅 消息总线。简化了应用程序内各个组件、组件与后台线程间（活动Activity、碎片Fragment、进程Thread、服务Service等）的通信方式；<br>使用 发布&#x2F;订阅 机制对代码进行解耦，移除了不必要的依赖，使APP项目用更少的代码量实现更好的质量；<br>优点：<br>（1）简化应用程序内各个组件、组件与后台线程间通讯方式<br>（2）分离事件发布者和订阅者，实现完全解耦<br>（3）移除不必要的依赖关系（避免易错的生命周期问题）<br>（4）可继承、优先级、粘滞性<br>（5）代码更简洁、性能更好、移动应用更快、更小<br>缺点：<br>（1）EventBus中的事件分发是通过事件类名（订阅方法的参数类型）决定的，这就导致了当接受者过多或相同参数时很难理清消息流。<br>（2）EventBus中发布者（publisher）只能单向广播，无法获得订阅者（subscriber）对事件处理的相应</li>
<li>EventBus 三个角色</li>
</ul>
<ol>
<li>Event：事件。可以是任意类型，EventBus根据事件类型进行全局通知。</li>
<li>Subscriber：事件订阅者。事件方法名任意取名，需要加上注解@subscribe，并指定线程模型。<br>EventBus 3.0 有四种线程模型（订阅者 &amp; 发布者可位于任意线程），分别是：</li>
</ol>
<ul>
<li>POSTING：默认，表示事件处理函数的线程跟发布事件的线程在同一个线程。</li>
<li>MAIN：表示事件处理函数的线程在主线程(UI)线程，因此在这里不能进行耗时操作。若当前线程不是主线程，则通过Handler将消息发送给主线程。</li>
<li>BACKGROUND：表示事件处理函数的线程在后台线程，因此不能进行UI操作。如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程，如果果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。</li>
<li>ASYNC：表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。</li>
</ul>
<ol>
<li>Publisher：事件发布者。可在任意线程里发布事件</li>
</ol>
<ul>
<li>EventBus 的使用<br>（1）引入依赖</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.greenrobot:eventbus:3.1.1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>（2）定义事件<br>定义一个事件的封装对象。在程序内部就使用该对象作为通信的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEvent</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> String msg;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyEvent</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）定义订阅者，注册事件 &amp; 处理事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button mButton;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用EventBus的接收方法的Activity，需要注册监听</span></span><br><span class="line">        EventBus.getDefault().register(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        mButton = findViewById(R.id.bt_toAc2);</span><br><span class="line">        mButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, SecondActivity.class);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册onEvent()监听事件</span></span><br><span class="line"><span class="comment">     * 加入注解加入注解Subscribe并指定线程模型为主线程MAIN（默认为POSTING）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Subscribe</span>（threadMode = ThreadMode.MAIN）</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(MyEvent event)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        popOutToast(<span class="string">&quot;接收到Event：&quot;</span> + event.msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * onDestroy中从EventBus中取消注册该Activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        EventBus.getDefault().unregister(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装弹出短时Toast提示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 企图弹出的文本内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">popOutToast</span><span class="params">(String text)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Toast.makeText(MainActivity.<span class="built_in">this</span>,text,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）定义发布者，发布事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button mButton;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_second);</span><br><span class="line"></span><br><span class="line">        mButton = findViewById(R.id.bt_sendMsg);</span><br><span class="line">        mButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">           		<span class="comment">// 点击按钮，发布事件</span></span><br><span class="line">                EventBus.getDefault().post(<span class="keyword">new</span> <span class="title class_">MyEvent</span>(<span class="string">&quot;Event From Publisher&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>EventBus &amp; BroadcastReceiver &amp; Handler<br>EventBus、BroadcastReceiver和Handler均是Android中进程间消息传递的方式</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>EventBus</th> 
   <th>BroadcastReceiver</th> 
   <th>Handler</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>定义</td> 
   <td>EventBus是一个Android端优化的publish/subscribe消息总线</td> 
   <td>Android四大组件之一，广播，全局监听器</td> 
   <td>Handler运行在主线程中，通过Message与子线程进行数据传递，解决子线程无法更新UI问题</td> 
  </tr> 
  <tr> 
   <td>范围</td> 
   <td>应用内组件间、线程间通信</td> 
   <td>同一app内部的同一组件内的消息通信（单个或多个线程之间）；<br>同一app内部的不同组件之间的消息通信（单个进程）；<br>同一app具有多个进程的不同组件之间的消息通信；<br>不同app之间的组件之间消息通信</td> 
   <td>同一进程中不同线程间通信（主要是UI线程 &amp; 子线程）</td> 
  </tr> 
  <tr> 
   <td>消息</td> 
   <td>事件，可以是任意类型对象</td> 
   <td>intent</td> 
   <td>Message类型</td> 
  </tr> 
  <tr> 
   <td>适用场景</td> 
   <td>应用内的消息事件广播</td> 
   <td>系统内全局性的消息传递，尤其包括：<br>1. 系统事件监听（电量、网络等）<br>2. 多进程通信</td> 
   <td>UI线程 与 子线程 之间消息传递</td> 
  </tr> 
  <tr> 
   <td>优点</td> 
   <td>1. 订阅者和发布者耦合度低，调度灵活，不依赖Context<br>2. 可继承、优先级、粘滞性<br>3. 轻量</td> 
   <td>1. 四大组件之一，与sdk链接紧密，监听系统广播<br> 2. 跨进程通信</td> 
   <td>适用于目标具体明确的调度，处理简单的耗时操作</td> 
  </tr> 
  <tr> 
   <td>缺点</td> 
   <td>EventBus中的事件分发是通过注解函数的参数类型决定的，这就导致了当接受者过多或相同参数时很难理清消息流</td> 
   <td>1. 资源占用多，依赖Context 2. 同一进程不同线程消息传递回调函数复杂（适用EventBus/Observer）</td> 
   <td>消息高度绑定，发布者与接受者高度耦合，代码冗余</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="EventBus源码分析"><a href="#EventBus源码分析" class="headerlink" title="EventBus源码分析"></a>EventBus源码分析</h3><p>[参考链接：EventBus源码解析][EventBus 4]<br>EventBus官方原理图<br><img src="https://mark.cuckooing.cn/pics/pic_07a1a672.png" alt="pic_07a1a672.png"><br>发布者（Publisher）只需要post一个event之后就不用管了，EventBus内部会将event逐一分发给订阅此event的订阅者（Subscriber）<br>EventBus用于应用内消息事件传递，方便快捷，耦合性低<br>代码实例<br>订阅者（Subscriber）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBusMain</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.content_main);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        EventBus.getDefault().register(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  - 订阅的事件 onEvent1</span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent1</span><span class="params">(RemindBean bean)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">- 订阅的事件 onEvent2</span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent2</span><span class="params">(UserInfo bean)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        EventBus.getDefault().unregister(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发布者（Publisher）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(<span class="keyword">new</span> <span class="title class_">RemindBean</span>())</span><br></pre></td></tr></table></figure>

<p>源码解析</p>
<ul>
<li>register</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>getDefault() ：Subscriber获取EventBus实例<br>EventBus 是一个单例模式，懒汉式，双重校验锁判断解决线程不安全问题</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title function_">getDefault</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (defaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span> (defaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    defaultInstance = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>register()：在EventBus中将Subscriber与其订阅的event（使用@Subscribe进行注解）关联</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object subscriber)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        - <span class="number">1.</span>先拿到这个订阅者(subscriber)类的字节码</span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line"></span><br><span class="line">        - <span class="number">2.</span> 通过这个类的字节码，拿到所有的订阅的 event,存放在List中</span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">          - <span class="number">3.</span> 循环遍历所有的订阅的方法，完成subscriber 和 subscriberMethod 的关联</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>List findSubscriberMethods(Class&lt;?&gt; subscriberClass)：内部利用反射机制（findUsingReflectionInSingleClass）通过订阅者的类的字节码文件 获取 订阅者所有的订阅事件event：</p>
<ol>
<li>通过反射扫描字节码中当前类声明的所有方法，匹配订阅方法（修饰符public、只有1个参数、含有subscribe注解）。并获取订阅方法的一系列信息如：方法第一个参数eventType（Event事件的封装对象，作为通信的信息），ThreadMode（线程模型，包括mainThread,Posting,background,async），priority（优先级），是否粘性等信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Method[] methods;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">          - <span class="number">1.</span> 通过订阅者的字节码查找当前类中所有生命的方法</span><br><span class="line">            methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">            methods = findState.clazz.getMethods();</span><br><span class="line">            findState.skipSuperClasses = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          - <span class="number">2.</span> 循环遍历所有的方法</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            - <span class="number">3.</span> 获取方法的修饰符</span><br><span class="line">            <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> method.getModifiers();</span><br><span class="line">      </span><br><span class="line">            - <span class="number">4.</span>判断修饰符，订阅方法的修饰符不能是<span class="keyword">private</span>，<span class="keyword">static</span></span><br><span class="line">            <span class="title function_">if</span> <span class="params">((modifiers &amp; Modifier.PUBLIC)</span> != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                - <span class="number">5.</span> 获取方法的所有的参数</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">                - <span class="number">6.</span>判断参数的个数，只能有<span class="number">1</span>个参数，订阅方法中</span><br><span class="line">                <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                - <span class="number">7.</span>获取方法上具有subscribe 注解</span><br><span class="line">                    <span class="type">Subscribe</span> <span class="variable">subscribeAnnotation</span> <span class="operator">=</span> method.getAnnotation(Subscribe.class);</span><br><span class="line"></span><br><span class="line">                    - <span class="number">8.</span>含有subscribe注解的方法，就是该类订阅的方法，其它不符合的可能就是普通的方法</span><br><span class="line">                    <span class="keyword">if</span> (subscribeAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                      - <span class="number">9.</span> 获取第一个参数eventType</span><br><span class="line">                        Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                          </span><br><span class="line">                        <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                          - <span class="number">10.</span> 获取注解的mode，就是我们在注解上标识的，</span><br><span class="line">                      有mainThread,Posting,background,async</span><br><span class="line">                            <span class="type">ThreadMode</span> <span class="variable">threadMode</span> <span class="operator">=</span> subscribeAnnotation.threadMode();</span><br><span class="line"></span><br><span class="line">                          - <span class="number">11.</span> 将订阅方法的一系列信息（方法名称，threadMode,优先级，是否是粘性等）添加到集合subscriberMethods中去</span><br><span class="line">                            findState.subscriberMethods.add(<span class="keyword">new</span> <span class="title class_">SubscriberMethod</span>(method, eventType, threadMode,</span><br><span class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">              - <span class="number">12.</span> 参数是多个的时候抛出异常</span><br><span class="line">                    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;@Subscribe method &quot;</span> + methodName +</span><br><span class="line">                            <span class="string">&quot;must have exactly 1 parameter but has &quot;</span> + parameterTypes.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            - <span class="number">13.</span> 方法的修饰符不是<span class="keyword">public</span>的，抛出异常                </span><br><span class="line"></span><br><span class="line">              <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(methodName +</span><br><span class="line">                        <span class="string">&quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>将订阅的事件最终保存在HashMap subscriptionsByEventType（key：eventType（事件）、value：Subscription（subscriber，subscribMethod（method,threadMode,eventType），priority）即订阅方法的一系列信息）</li>
</ol>
<ul>
<li>post</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(<span class="keyword">new</span> <span class="title class_">RemindBean</span>(<span class="string">&quot;2018-02-12&quot;</span>,<span class="string">&quot;happy&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>post(Event)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Posts the given event to the event bus. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      - <span class="number">1.</span>获取当前线程的postingThreadState 对象</span><br><span class="line">        <span class="type">PostingThreadState</span> <span class="variable">postingState</span> <span class="operator">=</span> currentPostingThreadState.get();</span><br><span class="line">      - <span class="number">2.</span> 获取里面那个事件队列</span><br><span class="line">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">        - <span class="number">3.</span> 将事件添加到队列中去</span><br><span class="line">        eventQueue.add(event);</span><br><span class="line"></span><br><span class="line">      - <span class="number">4.</span> 判断当前的event 是否在 posting</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(!postingState.isPosting)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            - <span class="number">5.</span> 是否是主线程</span><br><span class="line">            postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">            postingState.isPosting = <span class="literal">true</span>;</span><br><span class="line">            - <span class="number">6.</span> 判断是否取消</span><br><span class="line">            <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Internal error. Abort state was not reset&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//不为空，进入循环</span></span><br><span class="line">                    - <span class="number">7.</span>按照顺序，post一个 remove一个</span><br><span class="line">                    postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                postingState.isPosting = <span class="literal">false</span>;</span><br><span class="line">                postingState.isMainThread = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>遍历eventTypes（Event类及其父类），并通过postSingleEventForEventType查找所有的订阅者subscriptions。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">          - <span class="number">1.</span>根据字节码取出subscriptions,还记得我们之前在subscribe这个方法的时候，</span><br><span class="line">把subscrber,subscriberMethod 封装成一个subscription 对象。</span><br><span class="line">		<span class="comment">// subscriptionsByEventType中 key 为 eventType, value 是subscriptions对象</span></span><br><span class="line">		<span class="comment">// register 中 subscribe(subscriber,subscriberMethod):</span></span><br><span class="line">		<span class="comment">//  subscriptionsByEventType.put(eventType, subscriptions);</span></span><br><span class="line">            subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subscriptions != <span class="literal">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                - <span class="number">2.</span> 取出每一个subscription 对象</span><br><span class="line">                postingState.event = event;</span><br><span class="line">                postingState.subscription = subscription;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">aborted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                  - <span class="number">3.</span> post到相应的线程中回调</span><br><span class="line">                    postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                    aborted = postingState.canceled;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    postingState.event = <span class="literal">null</span>;</span><br><span class="line">                    postingState.subscription = <span class="literal">null</span>;</span><br><span class="line">                    postingState.canceled = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>遍历每个subscription，根据定义的不同线程模式，反射调用相关方法postToSubscription</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="type">boolean</span> isMainThread)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">case</span> POSTING:<span class="comment">//一般没定义的，这个就是post在哪个线程，响应就在哪个线程执行</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MAIN:</span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                asyncPoster.enqueue(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unknown thread mode: &quot;</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>invokeSubscriber</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">          - 反射拿到字节码clazz 反射调用方法，就收到消息了</span><br><span class="line">          <span class="comment">// Method类的invoke()方法：对带有指定参数的指定对象，调用此Method对象表示的底层方法</span></span><br><span class="line">		  <span class="comment">// public native Object invoke(Object obj, Object... args)</span></span><br><span class="line">            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="EventBus项目实战"><a href="#EventBus项目实战" class="headerlink" title="EventBus项目实战"></a>EventBus项目实战</h3><ol>
<li>请求网络时候，等网络返回时通过Handler或Broadcast通知UI；</li>
<li>两个Fragment之间需要通过Listener通讯；</li>
</ol>
<h2 id="okHttp"><a href="#okHttp" class="headerlink" title="okHttp"></a>okHttp</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>OkHttp是一个处理网络请求的开源项目,是Android端最火热的轻量级框架,由移动支付Square公司贡献用于替代HttpUrlConnection和Apache HttpClient。<br>之所以可以赢得如此多开发者的喜爱，主要得益于如下特点：</p>
<ul>
<li>支持HTTPS&#x2F;HTTP2&#x2F;WebSocket（在OkHttp3.7中已经剥离对Spdy的支持，转而大力支持HTTP2）</li>
</ul>
<blockquote>
<p>SPDY（读作“SPeeDY”）是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY是对HTTP协议的加强。新协议的功能包括数据流的多路复用、支持服务器推送技术、请求优先级、HTTP报头压缩以及强制使用SSL传输协议。</p>
</blockquote>
<ul>
<li>内部维护任务队列线程池，友好支持并发访问</li>
<li>内部维护socket连接池，支持多路复用（共享同一个Socket处理同一个服务器所有请求：同一域名的所有请求stream共享同一个tcp连接），减少连接创建开销（减少握手次数 &amp; 请求延时）</li>
<li>socket创建支持最佳路由 &amp; 自动重连</li>
<li>提供拦截器链（InterceptorChain），实现request与response的分层处理(如透明GZIP压缩，logging等)</li>
<li>基于headers的缓存策略减少重复的网络请求</li>
</ul>
<h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><ol>
<li>同步请求（GET）<br>对于同步请求在请求时需要开启子线程，请求成功后需要跳转到UI线程修改UI</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDatasync</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();<span class="comment">//创建OkHttpClient对象</span></span><br><span class="line">            <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                    .url(<span class="string">&quot;http://www.baidu.com&quot;</span>)<span class="comment">//请求接口。如果需要传参拼接到接口后面。</span></span><br><span class="line">                    .build();<span class="comment">//创建Request 对象</span></span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            response = client.newCall(request).execute();<span class="comment">//得到Response 对象</span></span><br><span class="line">            <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//此时的代码执行在子线程，修改UI的操作请使用handler跳转到UI线程。</span></span><br><span class="line">            	<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">            	<span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">            	msg.obj = result;</span><br><span class="line">            	handler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>异步请求（POST）<br>这种方式不用再次开启子线程，但回调方法是执行在子线程中，所以在更新UI时还要跳转到UI线程中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postDataAsync</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();<span class="comment">//创建OkHttpClient对象。</span></span><br><span class="line">	FormBody.<span class="type">Builder</span> <span class="variable">formBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder();<span class="comment">//创建表单请求体</span></span><br><span class="line">	formBody.add(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);<span class="comment">//传递键值对参数</span></span><br><span class="line">	<span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()<span class="comment">//创建Request 对象。</span></span><br><span class="line">    	    .url(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">        	.post(formBody.build())<span class="comment">//传递请求体</span></span><br><span class="line">        	.build();</span><br><span class="line">    <span class="comment">// 异步请求不需要开启子线程，enqueue方法会自动将网络请求部分放入子线程中执行。</span></span><br><span class="line">	client.newCall(request).enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        	<span class="keyword">if</span>(response.isSuccessful())&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        			<span class="comment">//回调的方法执行在子线程，修改UI的操作请使用handler跳转到UI线程。</span></span><br><span class="line">            		<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">            		<span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">            		msg.obj = result;</span><br><span class="line">            		handler.sendMessage(msg);</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h4><ol>
<li>创建okHttpClient对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br></pre></td></tr></table></figure>

<p>构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">OkHttpClient</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">Builder</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便我们使用，提供了一个“快捷操作”，对OkHttpClient.Builder的类成员 全部使用了默认的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  dispatcher = <span class="keyword">new</span> <span class="title class_">Dispatcher</span>();</span><br><span class="line">  protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">  connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">  proxySelector = ProxySelector.getDefault();</span><br><span class="line">  cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">  socketFactory = SocketFactory.getDefault();</span><br><span class="line">  hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">  certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">  proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">  authenticator = Authenticator.NONE;</span><br><span class="line">  connectionPool = <span class="keyword">new</span> <span class="title class_">ConnectionPool</span>();</span><br><span class="line">  dns = Dns.SYSTEM;</span><br><span class="line">  followSslRedirects = <span class="literal">true</span>;</span><br><span class="line">  followRedirects = <span class="literal">true</span>;</span><br><span class="line">  retryOnConnectionFailure = <span class="literal">true</span>;</span><br><span class="line">  connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">  readTimeout = <span class="number">10_000</span>;</span><br><span class="line">  writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>发起 HTTP 请求（同步&#x2F;异步请求）</li>
</ol>
<ul>
<li>同步网络请求</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                    .url(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> response.body().string();</span><br></pre></td></tr></table></figure>

<p>OkHttpClient实现了Call.Factory，负责根据请求创建新的Call。通过newCall创建RealCall类实例，由RealCall负责进行网络请求操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RealCall</span>(<span class="built_in">this</span>, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RealCall#execute：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);  <span class="comment">// (1)</span></span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    client.dispatcher().executed(<span class="built_in">this</span>);                                 <span class="comment">// (2)</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">result</span> <span class="operator">=</span> getResponseWithInterceptorChain();                <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    client.dispatcher().finished(<span class="built_in">this</span>);                                 <span class="comment">// (4)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RealCall 做了4件事：</p>
<ul>
<li>检查这个 call 是否已经被执行：每个 call 只能被执行一次，如果想要一个完全一样的 call，可以利用call#clone方法进行克隆。</li>
<li>利用client.dispatcher().executed(this)通知开始执行</li>
<li>调用getResponseWithInterceptorChain()函数发出网络请求，并解析返回 HTTP 结果。</li>
<li>利用client.dispatcher().finished(this)通知已经执行完毕。</li>
</ul>
<blockquote>
<p>dispatcher是OkHttpClient.Builder的成员之一，dispatcher是用于异步 HTTP请求的执行策略，在同步请求它中只用于通知执行状态。</p>
</blockquote>
<p>真正发出网络请求，解析返回结果的，还是getResponseWithInterceptorChain：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client));</span><br><span class="line">  <span class="keyword">if</span> (!retryAndFollowUpInterceptor.isForWebSocket()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(</span><br><span class="line">      retryAndFollowUpInterceptor.isForWebSocket()));</span><br><span class="line"></span><br><span class="line">  Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">      interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>the whole thing is just a stack of built-in interceptors.<br>—— OkHttp 作者</p>
</blockquote>
<p>Interceptor是 OkHttp 最核心的一个东西，它不仅只负责拦截请求进行一些额外的处理（如cookie），实际上它把实际的网络请求、缓存、透明压缩等功能统一了起来，每个功能都是一个Interceptor，连接起来成了一个Interceptor.Chain，环环相扣，最终完成一次完整的网络请求。<br>Interceptor.Chain 分布依次是：<br><img src="https://mark.cuckooing.cn/pics/pic_a18f6ce9.png" alt="pic_a18f6ce9.png"></p>
<ul>
<li>在配置OkHttpClient时设置的interceptors；</li>
<li>负责失败重试以及重定向的RetryAndFollowUpInterceptor；</li>
<li>负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的BridgeInterceptor；</li>
<li>负责读取缓存直接返回、更新缓存的CacheInterceptor；</li>
<li>负责和服务器建立连接的ConnectInterceptor；</li>
<li>配置OkHttpClient时设置的networkInterceptors；</li>
<li>负责向服务器发送请求数据、从服务器读取响应数据CallServerInterceptor。</li>
</ul>
<p>在这里，位置决定了功能，最后一个 Interceptor 一定是负责和服务器实际通讯的，重定向、缓存等一定是在实际通讯之前的。<br>责任链模式在这个Interceptor链条中得到了很好的实践。</p>
<blockquote>
<p>责任链包含了一些命令对象和一系列的处理对象，每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。该模式还描述了往该处理链的末尾添加新的处理对象的方法。<br>对于把Request变成Response这件事来说，每个Interceptor都可能完成这件事，所以我们循着链条让每个Interceptor自行决定能否完成任务以及怎么完成任务（自力更生或者交给下一个Interceptor）。这样一来，完成网络请求这件事就彻底从RealCall类中剥离了出来，简化了各自的责任和逻辑。两个字：优雅！<br>责任链模式在安卓系统中也有比较典型的实践，例如 view 系统对点击事件（TouchEvent）的处理。<br>Interceptor 实际上采用了一种分层的思想，每个Interceptor都是一层。分层简化了每一层的逻辑，每层只需要关注自己的责任（单一原则思想），而各个层之间通过约定的接口&#x2F;协议进行合作（面向接口编程思想），共同完成复杂的任务。<br>这种分层的思想在TCP&#x2F;IP协议（4层协议）中体现的淋漓尽致。</p>
</blockquote>
<p>OkHttp 主要通过ConnectInterceptor和CallServerInterceptor和服务器的进行实际通信。</p>
<ul>
<li>建立连接 ConnectInterceptor</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  <span class="type">RealInterceptorChain</span> <span class="variable">realChain</span> <span class="operator">=</span> (RealInterceptorChain) chain;</span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> realChain.request();</span><br><span class="line">  <span class="type">StreamAllocation</span> <span class="variable">streamAllocation</span> <span class="operator">=</span> realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">doExtensiveHealthChecks</span> <span class="operator">=</span> !request.method().equals(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">  <span class="type">HttpCodec</span> <span class="variable">httpCodec</span> <span class="operator">=</span> streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br><span class="line">  <span class="type">RealConnection</span> <span class="variable">connection</span> <span class="operator">=</span> streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上建立连接就是创建了一个HttpCodec对象，用于后面通信中发送和接受数据。它是对HTTP协议操作的抽象，有两个实现：Http1Codec和Http2Codec，分别对应 HTTP&#x2F;1.1 和 HTTP&#x2F;2 版本的实现。<br>创建HttpCodec对象过程就是找到一个可用的RealConnection，再利用RealConnection的输入输出（BufferdSource 和 BufferedSink）创建HttpCodec对象，供后续步骤使用。</p>
<blockquote>
<p>在Http1Codec中，它利用Okio对Socket的读写操作进行封装，Okio是对java.io和java.nio进行了封装，让我们更便捷高效的进行<br>IO 操作。</p>
</blockquote>
<ul>
<li>发送和接受数据 CallServerInterceptor</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  <span class="type">HttpCodec</span> <span class="variable">httpCodec</span> <span class="operator">=</span> ((RealInterceptorChain) chain).httpStream();</span><br><span class="line">  <span class="type">StreamAllocation</span> <span class="variable">streamAllocation</span> <span class="operator">=</span> ((RealInterceptorChain) chain).streamAllocation();</span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="variable">sentRequestMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  httpCodec.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">Sink</span> <span class="variable">requestBodyOut</span> <span class="operator">=</span> httpCodec.createRequestBody(request, request.body().contentLength());</span><br><span class="line">    <span class="type">BufferedSink</span> <span class="variable">bufferedRequestBody</span> <span class="operator">=</span> Okio.buffer(requestBodyOut);</span><br><span class="line">    request.body().writeTo(bufferedRequestBody);</span><br><span class="line">    bufferedRequestBody.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  httpCodec.finishRequest();</span><br><span class="line"></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> httpCodec.readResponseHeaders()</span><br><span class="line">      .request(request)</span><br><span class="line">      .handshake(streamAllocation.connection().handshake())</span><br><span class="line">      .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket || response.code() != <span class="number">101</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(httpCodec.openResponseBody(response))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.request().header(<span class="string">&quot;Connection&quot;</span>))</span><br><span class="line">      || <span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.header(<span class="string">&quot;Connection&quot;</span>))) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    streamAllocation.noNewStreams();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分检查代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>向服务器发送 request header；如果有 request body，就向服务器发送；</li>
<li>读取 response header，先构造一个Response对象；如果有 response body，就在 header的基础上加上 body 构造一个新的Response对象；<br>核心操作由HttpCodec对象完成，HttpCodec封装Okio，Okio封装Socket。完成网络的通信。</li>
<li>异步网络请求</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">    	    .url(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">        	.get()</span><br><span class="line">        	.build();</span><br><span class="line">	client.newCall(request).enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    		System.out.println(response.body().string());</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<p>实际调用RealCall#enqueue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> <span class="title class_">AsyncCall</span>(responseCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatcher#enqueue</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(AsyncCall call)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    runningAsyncCalls.add(call);</span><br><span class="line">    executorService().execute(call);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dispatcher 用于对异步请求进行分发、执行。<br>如果当前还能执行一个并发请求，那就立即执行，否则加入readyAsyncCalls队列。<br>正在执行的请求执行完毕之后，会调用promoteCalls()函数，来把readyAsyncCalls队列中的AsyncCall “提升” 为runningAsyncCalls，并开始执行。</p>
<p>这里的AsyncCall是RealCall的一个内部类，它实现了Runnable，所以可以被提交到ExecutorService上执行，而它在执行时会调用getResponseWithInterceptorChain()函数，并把结果通过responseCallback传递给上层使用者。<br>这样看来，同步请求和异步请求的原理是一样的，都是在getResponseWithInterceptorChain()函数中通过Interceptor链条来实现的网络请求逻辑，而异步则是通过ExecutorService实现。</p>
<ol>
<li>获取 HTTP 响应<br>在上述同步（Call#execute()执行之后）或者异步（Callback#onResponse()回调中）请求完成之后，我们就可以从Response对象中获取到响应数据了，包括 HTTP status code，status message，response header，response body 等。这里 body 部分最为特殊，因为服务器返回的数据可能非常大，所以必须通过数据流的方式来进行访问（当然也提供了诸如string()和bytes()这样的方法将流内的数据一次性读取完毕），而响应中其他部分则可以随意获取。</li>
</ol>
<ul>
<li>发送和接受数据 CallServerInterceptor</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!forWebSocket || response.code() != <span class="number">101</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  response = response.newBuilder()</span><br><span class="line">      .body(httpCodec.openResponseBody(response))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HttpCodec#openResponseBody</span><br><span class="line">提供具体 HTTP 协议版本的响应 body</span><br><span class="line">HttpCodec 利用 Okio 实现具体的数据 IO 操作</span><br></pre></td></tr></table></figure>

<ol>
<li>HTTP缓存</li>
</ol>
<ul>
<li>读取 &amp; 缓存数据 CallServerInterceptor<br>在建立连接、和服务器通讯之前，检查响应是否已经被缓存、缓存是否可用，如果是则直接返回缓存的数据，否则就进行后面的流程，并在响应返回之前，把网络的数据写入缓存。<br>具体的缓存逻辑 OkHttp 内置封装了一个Cache类，它利用DiskLruCache，用磁盘上的有限大小空间进行缓存，按照 LRU 算法进行缓存淘汰。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://mark.cuckooing.cn/pics/pic_92db496d.png" alt="pic_92db496d.png"></p>
<ul>
<li>OkHttpClient实现Call.Factory，负责为Request创建Call；</li>
<li>RealCall为具体的Call实现，其enqueue()异步接口通过Dispatcher利用ExecutorService + AsyncCall队列 实现，而最终进行网络请求时和同步execute()接口一致，都是通过getResponseWithInterceptorChain()函数实现；</li>
<li>getResponseWithInterceptorChain()中利用Interceptor拦截链，将缓存、透明压缩、网络 IO 等功能统一起来，层层实现，最终完成一次完整的网络请求。</li>
</ul>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ul>
<li>建造者模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkHttpClient</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>, Call.Factory, WebSocket.Factory &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span> Cache cache;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//从Builder中获取属性值  </span></span><br><span class="line">    OkHttpClient(Builder builder) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        ......</span><br><span class="line">        <span class="built_in">this</span>.cache = builder.cache;  </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//构造者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">        Cache cache;</span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构造cache属性值</span></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">cache</span><span class="params">(<span class="meta">@Nullable</span> Cache cache)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">          <span class="built_in">this</span>.cache = cache;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//在build方法中真正创建OkHttpClient对象，并传入前面构造的属性值</span></span><br><span class="line">        <span class="keyword">public</span> OkHttpClient <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在创建OkHttpClient的时候</span></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">  .cache(<span class="comment">/*创建cache对象*/</span>)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure>

<ul>
<li>工厂模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Call</span> <span class="keyword">extends</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  </span><br><span class="line">  Request <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">  Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException; </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>;  </span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isExecuted</span><span class="params">()</span>;  </span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isCanceled</span><span class="params">()</span>; </span><br><span class="line">  Call <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//创建Call实现对象的工厂</span></span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//创建新的Call，里面包含了Request对象。</span></span><br><span class="line">    Call <span class="title function_">newCall</span><span class="params">(Request request)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkHttpClient</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>, Call.Factory, WebSocket.Factory &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RealCall</span> <span class="keyword">implements</span> <span class="title class_">Call</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>观察者模式</li>
</ul>
<p>源码中的EventListener对请求&#x2F;响应过程中的每一个Event通过方法回调的方式通知前方用户，用户需要自己实现EventListener中的所需要的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestHeadersStart</span><span class="params">(Call call)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestHeadersEnd</span><span class="params">(Call call, Request request)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestBodyStart</span><span class="params">(Call call)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestBodyEnd</span><span class="params">(Call call, <span class="type">long</span> byteCount)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">responseHeadersStart</span><span class="params">(Call call)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">responseHeadersEnd</span><span class="params">(Call call, Response response)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">responseBodyStart</span><span class="params">(Call call)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">responseBodyEnd</span><span class="params">(Call call, <span class="type">long</span> byteCount)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>单例模式</li>
</ul>
<p>创建OkHttpClient对象的时候，就推荐使用单例模式，防止创建多个OkHttpClient对象，损耗资源；</p>
<ul>
<li>策略模式</li>
</ul>
<p>在CacheInterceptor中，在响应数据的选择中使用了策略模式，选择缓存数据还是选择网络访问。<br>CacheInterceptor根据一个缓存策略，来决定选择缓存数据，还是网络请求数据：</p>
<ol>
<li>请求头包含 “If-Modified-Since” 或 “If-None-Match” 暂时不走缓存</li>
<li>客户端通过 cacheControl 指定了无缓存，不走缓存</li>
<li>客户端通过 cacheControl 指定了缓存，则看缓存过期时间，符合要求走缓存。</li>
<li>如果走了网络请求，响应状态码为 304（只有客户端请求头包含 “If-Modified-Since” 或 “If-None-Match” ，服务器数据没变化的话会返回304状态码，不会返回响应内容）， 表示客户端继续用缓存。</li>
</ol>
<ul>
<li>责任链模式<br>okhttp可以针对请求配置很多拦截器，而这些拦截器正是通过责任链模式链接起来，并最终返回处理的结果。</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>由于okhttp是偏底层的网络请求类库，返回结果的回调方法仍然执行在子线程中，需要自己跳转到UI线程，使用麻烦。为了使用方便需要对OKHttp进行再次封装。</p>
<p>[guozhengXia&#x2F;OkHttpUtils][guozhengXia_OkHttpUtils]<br>最简单的okhttp封装，CallBack方法执行在UI线程。支持get请求，post请求，支持文件上传和下载。</p>
<h3 id="网络框架对比"><a href="#网络框架对比" class="headerlink" title="网络框架对比"></a>网络框架对比</h3><p><img src="https://mark.cuckooing.cn/pics/pic_dac1ae53.png" alt="pic_dac1ae53.png"></p>
<h2 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Glide，一个被google所推荐的图片加载库，作者是bumptech。这个库被广泛运用在google的开源项目中，包括2014年的google I&#x2F;O大会上发布的官方app。<br>Glide滑行的意思，可以看出这个库的主旨就在于让图片加载变的流畅。</p>
<ul>
<li>多样化媒体加载<br>Glide 不仅是一个图片缓存，它支持 Gif、WebP、缩略图。甚至是 Video</li>
<li>生命周期绑定 &amp; 动态管理</li>
<li>高效缓存策略<br>（1）支持Memory和Disk图片缓存<br>（2）内存开销小（Glide根据ImageView大小缓存图片 &amp; 使用合理的解码方式）</li>
</ul>
<h3 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h3><ol>
<li>导入</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.github.bumptech.glide:glide:3.7.0&#x27;</span>  </span><br><span class="line">    implementation <span class="string">&#x27;com.android.support:support-v4:23.2.1&#x27;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>基础使用<br>（1）基本方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://img1.dzwww.com:8080/tupian_pl/20150813/16/7858995348613407436.jpg&quot;</span>;</span><br><span class="line"><span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> (ImageView) findViewById(R.id.imageView);</span><br><span class="line">Glide.with(context)</span><br><span class="line">    .load(url)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure>

<ul>
<li>with(Context context) 决定Glide加载图片的生命周期<br>可以使用 Activity、FragmentActivity、android.support.v4.app.Fragment、android.app.Fragment 等对象。将 Activity&#x2F;Fragment 对象作为参数的好处是，图片的加载会和 Activity&#x2F;Fragment 的生命周期保持一致，例如：onPaused 时暂停加载，onResume 时又会自动重新加载。所以在传参的时候建议使用 Activity&#x2F;Fragment 对象，而不是 Context。</li>
<li>load(String url) 加载图片URL<br>url包括网络图片、本地图片、应用资源、二进制流、Uri对象等等（重载）</li>
<li>into(ImageView imageView) 需要显示图片的目标 ImageView<br>（2）扩展方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context)</span><br><span class="line">    .load(url)</span><br><span class="line">    <span class="comment">// 占位符：出现图片加载慢或者加载不出来的情况</span></span><br><span class="line">    .placeholder(R.drawable.place_image)<span class="comment">// 加载图片过程占位符，加载完成会替换占位符</span></span><br><span class="line">    .error(R.drawable.error_image)	<span class="comment">// 加载图片错误占位符</span></span><br><span class="line">    .thumbnail( <span class="number">0.2f</span> )				<span class="comment">// 显示原始图片20%大小作为略缩图</span></span><br><span class="line">    .crossFade()					<span class="comment">// 开启Glide默认图片淡出淡入动画</span></span><br><span class="line">    .override(width,height)			<span class="comment">// 指定图片大小（Glide会自动判断ImageView的大小，然后将对应的图片像素加载本地，节省内存开支）</span></span><br><span class="line">    .centerCrop()					<span class="comment">// 将图片按比例缩放到可以完全填充ImageView，图片可能显示不完整</span></span><br><span class="line">    .fitCenter()					<span class="comment">// 将图片缩放到小于等于ImageView尺寸，图片一定显示完整</span></span><br><span class="line">    .diskCacheStrategy(DiskCacheStrategy.RESULT)	<span class="comment">// 图片缓存策略：只缓存最终加载图</span></span><br><span class="line">    .diskCacheStrategy(DiskCacheStrategy.NONE)	<span class="comment">// 禁用Glide缓存机制</span></span><br><span class="line">    .diskCacheStrategy(DiskCacheStrategy.SOURCE)	<span class="comment">// 只缓存全尺寸加载图</span></span><br><span class="line">    .priority(Priority.HIGH)		<span class="comment">// 对于同一时间加载多个图片，优先加载对于用户更重要的图片</span></span><br><span class="line">    .asGif()						<span class="comment">// 只显示动态图</span></span><br><span class="line">    .asBitmap()						<span class="comment">// 只显示静态图（不设置时，Glide会自动判断图片格式）</span></span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure>

<ol>
<li>进阶使用</li>
</ol>
<ul>
<li>Target</li>
<li>Transformations<br>通过 Transformations 操作 bitmap 来实现，我们可以修改图片的任意属性：尺寸，范围，颜色，像素位置等等。fitCenter 和 centerCrop ，这两个是 Glide 已经实现的Transformations。<br>自定义Transformation，继承BitmapTransformation接口<br>图片切圆角操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundTransformation</span> <span class="keyword">extends</span> <span class="title class_">BitmapTransformation</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoundTransformation</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>(context, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoundTransformation</span><span class="params">(Context context, <span class="type">int</span> px)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>(context);</span><br><span class="line">        <span class="built_in">this</span>.radius = px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Bitmap <span class="title function_">transform</span><span class="params">(BitmapPool pool, Bitmap toTransform, <span class="type">int</span> outWidth, <span class="type">int</span> outHeight)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> roundCrop(pool, toTransform);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bitmap <span class="title function_">roundCrop</span><span class="params">(BitmapPool pool, Bitmap source)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (source == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">result</span> <span class="operator">=</span> pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Canvas</span> <span class="variable">canvas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Canvas</span>(result);</span><br><span class="line">        <span class="type">Paint</span> <span class="variable">paint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">        paint.setShader(<span class="keyword">new</span> <span class="title class_">BitmapShader</span>(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));</span><br><span class="line">        paint.setAntiAlias(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">RectF</span> <span class="variable">rectF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectF</span>(<span class="number">0f</span>, <span class="number">0f</span>, source.getWidth(), source.getHeight());</span><br><span class="line">        canvas.drawRoundRect(rectF, radius, radius, paint);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + Math.round(radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图片顺时针旋转90度操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RotateTransformation</span> <span class="keyword">extends</span> <span class="title class_">BitmapTransformation</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">rotateRotationAngle</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RotateTransformation</span><span class="params">(Context context, <span class="type">float</span> rotateRotationAngle)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>( context );</span><br><span class="line">        <span class="built_in">this</span>.rotateRotationAngle = rotateRotationAngle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Bitmap <span class="title function_">transform</span><span class="params">(BitmapPool pool, Bitmap toTransform, <span class="type">int</span> outWidth, <span class="type">int</span> outHeight)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Matrix</span> <span class="variable">matrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line"></span><br><span class="line">        matrix.postRotate(rotateRotationAngle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Bitmap.createBitmap(toTransform, <span class="number">0</span>, <span class="number">0</span>, toTransform.getWidth(), toTransform.getHeight(), matrix, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + Math.round(rotateRotationAngle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个Transformation</span></span><br><span class="line">Glide.with(context)</span><br><span class="line">    .load(mUrl)</span><br><span class="line">    .transform(<span class="keyword">new</span> <span class="title class_">RoundTransformation</span>(context , <span class="number">20</span>))</span><br><span class="line">    .into(mImageView);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个Transformation不能使用链式形式多次调用，否则之前的配置会被覆盖</span></span><br><span class="line"><span class="comment">// 把一个图片切圆角，然后做了顺时针旋转90度处理。</span></span><br><span class="line">Glide.with(context)</span><br><span class="line">    .load(mUrl)</span><br><span class="line">    .transform(<span class="keyword">new</span> <span class="title class_">RoundTransformation</span>(context , <span class="number">20</span>) ，  <span class="keyword">new</span> <span class="title class_">RotateTransformation</span>(context , <span class="number">90f</span>))</span><br><span class="line">    .into(mImageView);</span><br></pre></td></tr></table></figure>

<p>这里有一个 GLide Transformations 的库，它提供了很多 Transformation 的实现，非常值得去看，不必重复造轮子对吧！<br>[wasabeef&#x2F;glide-transformations][wasabeef_glide-transformations]</p>
<ul>
<li>Animate<br>自定义缩放动画</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;set xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:fillAfter=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;scale</span><br><span class="line">        android:duration=<span class="string">&quot;@android:integer/config_longAnimTime&quot;</span></span><br><span class="line">        android:fromXScale=<span class="string">&quot;0.1&quot;</span></span><br><span class="line">        android:fromYScale=<span class="string">&quot;0.1&quot;</span></span><br><span class="line">        android:pivotX=<span class="string">&quot;50%&quot;</span></span><br><span class="line">        android:pivotY=<span class="string">&quot;50%&quot;</span></span><br><span class="line">        android:toXScale=<span class="string">&quot;1&quot;</span></span><br><span class="line">        android:toYScale=<span class="string">&quot;1&quot;</span>/&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context)</span><br><span class="line">    .load(mUrl)</span><br><span class="line">    .transform(<span class="keyword">new</span> <span class="title class_">RoundTransformation</span>(<span class="built_in">this</span> , <span class="number">20</span>))</span><br><span class="line">    .animate( R.anim.zoom_in )</span><br><span class="line">    .into(mImageView);</span><br></pre></td></tr></table></figure>

<ul>
<li>Modules</li>
</ul>
<h3 id="工作原理（非重点）"><a href="#工作原理（非重点）" class="headerlink" title="工作原理（非重点）"></a>工作原理（非重点）</h3><ol>
<li>主流程<br><img src="https://mark.cuckooing.cn/pics/pic_95081a50.png" alt="pic_95081a50.png"><br>三件大事：</li>
</ol>
<ul>
<li>准备数据<br>Glide中存在大量的类和对象，Glide在初始时，就尽量把所有需要使用的对象构造并封装，层层传递。<br>第一阶段：构建GenericRequest对象（面向用户构建，受用户调用API或修改配置所影响）<br>第二阶段：从GenericRequest对象中，解封得到需要对象，构建出decodeJob对象，是异步处理中核心对象（面向Glide构建）</li>
<li>异步处理<br>经过前面大量准备工作，这一步，Glide在工作线程中进行图片数据请求，包括三步：<br>（1）发起网络请求，拿到数据流；<br>（2）将数据流解码成bitmap对象；<br>（3）将bitmap对象转码成Drawable对象</li>
<li>切换到主线程<br>切换为主线程，将Drawable对象显示</li>
</ul>
<ol>
<li>源码解读</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="built_in">this</span>).load(url).into(imageView);</span><br></pre></td></tr></table></figure>

<ul>
<li>with(Context&#x2F;Activity&#x2F;Fragment)</li>
</ul>
<p>得到一个RequestManager对象（实现request和Activity&#x2F;Fragment生命周期的关联）<br>Glide再根据传入的with()方法的参数确定图片加载的生命周期：</p>
<ul>
<li>Application类型参数——应用程序生命周期</li>
<li>非Application类型参数——Activity&#x2F;Fragment生命周期</li>
<li>load（url）</li>
</ul>
<p>实质上还是做前期的数据准备，主要就是构造对象，封装对象。<br>得到一个DrawableTypeRequest对象（extends DrawableRequestBuilder）</p>
<ul>
<li>into（imageView）</li>
</ul>
<p>into比较复杂，其涉及了“准备数据”，“异步处理”，“切换到主线程”这三大步的内容。包括：<br>（1）准备过程 第一阶段：构造出GenericRequest对象（封装了Glide中所有的相关对象）<br>（2）准备过程 第二阶段：使用 第一阶段 生成的GenericRequest对象，从GenericRequest对象取出各种需要的对象，传递给Engine的load函数，最终构造出了decodeJob对象。<br>（3）异步调用 ： 使用decodeJob 对象进行：</p>
<ul>
<li>发起网络请求，拿到数据流</li>
<li>将数据流解码成bitmap对象</li>
<li>将bitmap对象转码成Drawable对象（保证静图和动图的类型一致性（动图的类型是Drawable））<br>（4）切换到主线程，显示Drawable对象<br>通过Handler机制，Glide从工作线程切换到主线程，并最终将Drawable对象显示到ImageView上。</li>
</ul>
<h3 id="图片加载框架对比"><a href="#图片加载框架对比" class="headerlink" title="图片加载框架对比"></a>图片加载框架对比</h3><p><img src="https://mark.cuckooing.cn/pics/pic_41422c71.png" alt="pic_41422c71.png"></p>
<h1 id="第十三章-杂七杂八"><a href="#第十三章-杂七杂八" class="headerlink" title="第十三章 杂七杂八"></a>第十三章 杂七杂八</h1><ul>
<li>进程保活</li>
<li><ul>
<li>Android进程回收策略 及 进程优先级</li>
<li>进程保活方案</li>
<li>Service如何保持不被杀死</li>
</ul>
</li>
<li>屏幕适配</li>
<li>混生开发</li>
<li><ul>
<li>React Native、weex、Flutter ？对比？</li>
<li>谷歌新出的官方开发语言Kotlin了解吗 &amp; 和Java相比它有哪些特点。</li>
<li>ReactNative 和 Android 如何交互？</li>
</ul>
</li>
<li>一个APP从启动到主页面显示经历了哪些过程？</li>
<li>APP 推送</li>
<li>Android 虚拟机及编译过程</li>
<li><ul>
<li>Dalvik虚拟机</li>
<li>ART虚拟机与Dalvik虚拟机的区别</li>
<li>Android APK 编译打包流程</li>
</ul>
</li>
<li>Android dex分包方案和热补丁原理</li>
<li><ul>
<li>Android dex文件 &amp; 类加载器DexLoader</li>
<li>dex分包方案</li>
<li>热补丁</li>
</ul>
</li>
<li>Android 插件化</li>
<li>Android MVP模式</li>
</ul>
<h2 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h2><p>[关于 Android 进程保活，你所需要知道的一切][Android 2]</p>
<h3 id="Android进程回收策略-及-进程优先级"><a href="#Android进程回收策略-及-进程优先级" class="headerlink" title="Android进程回收策略 及 进程优先级"></a>Android进程回收策略 及 进程优先级</h3><ul>
<li>Android 进程回收策略（一种根据 OOM_ADJ 阈值级别触发相应力度的内存回收的机制）<br>Android 系统将尽量长时间地保持应用进程，但随着打开的应用越多，后台应用进程也越多。容易导致系统内存不足。<br>为了新建进程或运行更重要的进程，最终需要清除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程的状态等，给进程分配一个优先级。当系统内存不足时，系统会按照优先级高低依次清除进程，回收系统资源。</li>
<li>进程优先级</li>
</ul>
<table> 
 <tbody> 
  <tr> 
   <td>优先级排序</td> 
   <td>进程类型</td> 
   <td>说明</td> 
  </tr> 
  <tr> 
   <td>1</td> 
   <td>前台进程</td> 
   <td>用户当前操作所必需的进程。通常在任意给定时间前台进程都为数不多。<br>只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。</td> 
  </tr> 
  <tr> 
   <td>2</td> 
   <td>可见进程</td> 
   <td>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程，可见进程被视为是极其重要的进程。<br>除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</td> 
  </tr> 
  <tr> 
   <td>3</td> 
   <td>服务进程</td> 
   <td>尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。<br>因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</td> 
  </tr> 
  <tr> 
   <td>4</td> 
   <td>后台进程</td> 
   <td>后台进程对用户体验没有直接影响，通常会有很多后台进程在运行，它们会保存在 LRU 列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。<br>系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 </td> 
  </tr> 
  <tr> 
   <td>5</td> 
   <td>空进程</td> 
   <td>保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。<br> 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</td> 
  </tr> 
 </tbody> 
</table>

<table></table>

<h3 id="进程保活方案"><a href="#进程保活方案" class="headerlink" title="进程保活方案"></a>进程保活方案</h3><p>核心思想：提高进程优先级</p>
<ol>
<li>通过开启服务提升进程优先级<br>对于需要在后台长期运行的操作可以通过创建对应的服务Service（排名3）而不是在Activity开启一个后台子线程（排名4）提高进程优先级</li>
<li>利用通知（Notification）提升权限<br>启动一个前台的Service进程，这样会在系统的通知栏生成一个通知（Notification），使用户可见该运行的app。从而使进程的优先级仅仅低于用户当前正在交互的进程，与可见进程优先级一致，使进程被杀死的概率大大降低。</li>
<li>通过广播唤醒（不同app进程之间&#x2F;系统提供广播）</li>
</ol>
<ul>
<li>场景1：系统监听开机、网络状态、拍照等事件，产生广播唤醒app</li>
<li>场景2：接入第三方SDK唤醒相应的app进程（如微信sdk，包括微信支付会唤醒微信、或者支付宝会唤醒淘宝等同属于阿里系的app）经常通过推送SDK对app进程保活</li>
</ul>
<h3 id="Service如何保持不被杀死"><a href="#Service如何保持不被杀死" class="headerlink" title="Service如何保持不被杀死"></a>Service如何保持不被杀死</h3><ol>
<li>onStartCommand方法，返回START_STICKY<br>服务的onStartCommand方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line"><span class="comment">// intent - 启动时，启动组件传递过来的intent（其他组件如activity传递参数）</span></span><br><span class="line"><span class="comment">// flags - 启动请求时是否有额外参数，默认为0</span></span><br><span class="line"><span class="comment">// startId - 指明当前服务的唯一ID，与stopSelfResult(startId)配合使用，可以更安全地根据ID停止服务</span></span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onStartCommand 返回值</p>
<table> 
 <thead> 
  <tr> 
   <th>返回值</th> 
   <th>含义</th> 
   <th>适用场景</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>START_STICKY</td> 
   <td>当Service因内存不足而被系统kill后，一段时间后内存再次空闲时，系统将会尝试重新创建此Service，一旦创建成功后将回调onStartCommand方法，但其中的Intent将是null，也就是onStartCommand方法虽然会执行但是获取不到intent信息</td> 
   <td>这个状态下比较适用于任意时刻开始、结束的服务如音乐播放器</td> 
  </tr> 
  <tr> 
   <td>START_NOT_STICKY</td> 
   <td>当Service因内存不足而被系统kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此Service。除非程序中再次调用startService启动此Service，这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务</td> 
   <td>某个Service执行的工作被中断几次无关紧要</td> 
  </tr> 
  <tr> 
   <td>START_REDELIVER_INTENT</td> 
   <td>当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，任何挂起 Intent均依次传递。与START_STICKY不同的是，其中的传递的Intent将是非空，是最后一次调用startService中的intent</td> 
   <td>适用于主动执行应该立即恢复的作业（例如下载文件）的服务</td> 
  </tr> 
 </tbody> 
</table>

<p>手动返回START_STICKY，当service因内存不足被kill，等到内存空闲后，service又被重新创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">    flags = START_STICKY;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.onStartCommand(intent, flags, startId);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在AndroidManifest中通过android:priority提升service优先级<br>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority &#x3D; “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;service  </span><br><span class="line">    android:name=<span class="string">&quot;com.dbjtech.acbxt.waiqin.UploadService&quot;</span>  </span><br><span class="line">    android:enabled=<span class="string">&quot;true&quot;</span> &gt;  </span><br><span class="line">    &lt;intent-filter android:priority=<span class="string">&quot;1000&quot;</span> &gt;  </span><br><span class="line">        &lt;action android:name=<span class="string">&quot;com.dbjtech.myservice&quot;</span> /&gt;  </span><br><span class="line">    &lt;/intent-filter&gt;  </span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用startForeground 将service放到前台状态，提升service进程优先级<br>Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是:<br>前台进程( FOREGROUND_APP)、可视进程(VISIBLE_APP )、次要服务进程(SECONDARY_SERVER )、后台进程 (HIDDEN_APP)、内容供应节点(CONTENT_PROVIDER)、空进程(EMPTY_APP)<br>当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">	<span class="comment">//添加下列代码将后台Service变成前台Service</span></span><br><span class="line">	<span class="comment">//构建&quot;点击通知后打开MainActivity&quot;的Intent对象</span></span><br><span class="line">	<span class="type">Intent</span> <span class="variable">notificationIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>,MainActivity.class);</span><br><span class="line">	<span class="type">PendingIntent</span> <span class="variable">pendingIntent</span> <span class="operator">=</span> PendingIntent.getActivity(<span class="built_in">this</span>,<span class="number">0</span>,notificationIntent,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//新建Builer对象</span></span><br><span class="line">	Notification.<span class="type">Builder</span> <span class="variable">builer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notification</span>.Builder(<span class="built_in">this</span>);</span><br><span class="line">	builer.setContentTitle(<span class="string">&quot;前台服务通知的标题&quot;</span>);<span class="comment">//设置通知的标题</span></span><br><span class="line">	builer.setContentText(<span class="string">&quot;前台服务通知的内容&quot;</span>);<span class="comment">//设置通知的内容</span></span><br><span class="line">	builer.setSmallIcon(R.mipmap.ic_launcher);<span class="comment">//设置通知的图标</span></span><br><span class="line">	builer.setContentIntent(pendingIntent);<span class="comment">//设置点击通知后的操作</span></span><br><span class="line"></span><br><span class="line">	<span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> builer.getNotification();<span class="comment">//将Builder对象转变成普通的notification</span></span><br><span class="line">	startForeground(<span class="number">1</span>, notification);<span class="comment">//让Service变成前台Service,并在系统的状态栏显示出来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>onDestroy方法里重启service<br>service +broadcast 方式，就是当service调用ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；或直接startService()重新打开服务</li>
</ol>
<h2 id="屏幕适配"><a href="#屏幕适配" class="headerlink" title="屏幕适配"></a>屏幕适配</h2><p>[一种极低成本的Android屏幕适配方式——字节跳动技术团队][Android 3]</p>
<ul>
<li>传统dp适配方式<br>android中的dp在渲染前会将dp转为px，计算公式：</li>
<li>px &#x3D; density * dp;</li>
<li>density &#x3D; dpi &#x2F; 160;</li>
<li>px &#x3D; dp * (dpi &#x2F; 160);</li>
</ul>
<p>而dpi是根据屏幕真实的分辨率和尺寸来计算的，每个设备都可能不一样的。<br>通常情况下，一部手机的分辨率是宽x高，屏幕大小是以寸为单位，那么三者的关系是（屏幕分辨率为：1920*1080，屏幕尺寸为5吋的话，那么dpi为440。）<br><img src="https://mark.cuckooing.cn/pics/pic_1e6932e5.png" alt="pic_1e6932e5.png"><br>由于不同手机屏幕尺寸、分辨率不同，因此dpi的值很乱，导致dp适配效果（px &#x3D; (dpi&#x2F;160)*dp）结果很乱，没有规律，因此应该使用新的适配方式。</p>
<ul>
<li>屏幕适配切入点<br>根据 dp和px的转换公式 ：px &#x3D; dp * density ，可通过修改density保证所有设备计算出的px值满足该设备的要求。<br>布局文件中dp的转换，最终都是调用 TypedValue#applyDimension(int unit, float value, DisplayMetrics metrics) 来进行转换。因此我们只需要修改 DisplayMetrics 中和 dp 转换相关的变量即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">applyDimension</span><span class="params">(<span class="type">int</span> unit, <span class="type">float</span> value,</span></span><br><span class="line"><span class="params">                                   DisplayMetrics metrics)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">case</span> COMPLEX_UNIT_PX:</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">case</span> COMPLEX_UNIT_DIP:</span><br><span class="line">        <span class="keyword">return</span> value * metrics.density;</span><br><span class="line">    <span class="keyword">case</span> COMPLEX_UNIT_SP:</span><br><span class="line">        <span class="keyword">return</span> value * metrics.scaledDensity;</span><br><span class="line">    <span class="keyword">case</span> COMPLEX_UNIT_PT:</span><br><span class="line">        <span class="keyword">return</span> value * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">72</span>);</span><br><span class="line">    <span class="keyword">case</span> COMPLEX_UNIT_IN:</span><br><span class="line">        <span class="keyword">return</span> value * metrics.xdpi;</span><br><span class="line">    <span class="keyword">case</span> COMPLEX_UNIT_MM:</span><br><span class="line">        <span class="keyword">return</span> value * metrics.xdpi * (<span class="number">1.0f</span>/<span class="number">25.4f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最终方案<br>下面假设设计图宽度是360dp，以宽维度来适配。<br>那么适配后的 density &#x3D; 设备真实宽(单位px) &#x2F; 360，接下来只需要把我们计算好的 density 在系统中修改下即可。同时应该修改文字的scaledDensity，可以通过计算之前scaledDensity和density的比获得现在的scaledDensity。并通过registerComponentCallbacks注册监听文字的切换。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> sRoncompatDennsity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> sRoncompatScaledDensity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setCustomDensity</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="keyword">final</span> <span class="meta">@NonNull</span> Application application)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//application</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">DisplayMetrics</span> <span class="variable">appDisplayMetrics</span> <span class="operator">=</span> application.getResources().getDisplayMetrics();</span><br><span class="line">    <span class="keyword">if</span> (sRoncompatDennsity == <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        sRoncompatDennsity = appDisplayMetrics.density;</span><br><span class="line">        sRoncompatScaledDensity = appDisplayMetrics.scaledDensity;</span><br><span class="line">        application.registerComponentCallbacks(<span class="keyword">new</span> <span class="title class_">ComponentCallbacks</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span> (newConfig != <span class="literal">null</span> &amp;&amp; newConfig.fontScale &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    sRoncompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLowMemory</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算宽为360dp 同理可以设置高为640dp的根据实际情况</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">targetDensity</span> <span class="operator">=</span> appDisplayMetrics.widthPixels / <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">targetScaledDensity</span> <span class="operator">=</span> targetDensity * (sRoncompatScaledDensity / sRoncompatDennsity);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">targetDensityDpi</span> <span class="operator">=</span> (<span class="type">int</span>) (targetDensity * <span class="number">160</span>);</span><br><span class="line"></span><br><span class="line">    appDisplayMetrics.density = targetDensity;</span><br><span class="line">    appDisplayMetrics.densityDpi = targetDensityDpi;</span><br><span class="line">    appDisplayMetrics.scaledDensity = targetScaledDensity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//activity</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">DisplayMetrics</span> <span class="variable">activityDisplayMetrics</span> <span class="operator">=</span> activity.getResources().getDisplayMetrics();</span><br><span class="line"></span><br><span class="line">    activityDisplayMetrics.density = targetDensity;</span><br><span class="line">    activityDisplayMetrics.densityDpi = targetDensityDpi;</span><br><span class="line">    activityDisplayMetrics.scaledDensity = targetScaledDensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="混生开发"><a href="#混生开发" class="headerlink" title="混生开发"></a>混生开发</h2><p>跨平台开发是为了增加代码复用，减少开发者对多个平台差异适配的工作量，降低开发成本，提高业务专注的同时，提供比web更好的体验。</p>
<h3 id="React-Native、weex、Flutter-？对比？"><a href="#React-Native、weex、Flutter-？对比？" class="headerlink" title="React Native、weex、Flutter ？对比？"></a>React Native、weex、Flutter ？对比？</h3><table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>React Native</th> 
   <th>weex</th> 
   <th>Flutter</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>出品</td> 
   <td>Facebook</td> 
   <td>Alibaba</td> 
   <td>Google</td> 
  </tr> 
  <tr> 
   <td>语言</td> 
   <td>JavaScript</td> 
   <td>JavaScript</td> 
   <td>Dart</td> 
  </tr> 
  <tr> 
   <td>引擎</td> 
   <td>JSCore</td> 
   <td>JS V8</td> 
   <td>Flutter Engine</td> 
  </tr> 
  <tr> 
   <td>设计模式</td> 
   <td>React</td> 
   <td>Vue</td> 
   <td>响应式</td> 
  </tr> 
  <tr> 
   <td>社区</td> 
   <td>丰富，Facebook终点维护</td> 
   <td>有点残念，托管apache</td> 
   <td>较多拥护者</td> 
  </tr> 
  <tr> 
   <td>难度</td> 
   <td>较大</td> 
   <td>较小</td> 
   <td>一般</td> 
  </tr> 
  <tr> 
   <td>支持</td> 
   <td>Android IOS</td> 
   <td>Android IOS Web</td> 
   <td>Android IOS 等等</td> 
  </tr> 
  <tr> 
   <td>现状</td> 
   <td>作为RN平台最大支持者Airbnb放弃使用RN<br>项目庞大维护困难，第三方库良莠不齐，兼容性差</td> 
   <td>被托管到了Apache，拭目以待</td> 
   <td>Flutter 是 Google 跨平台移动UI框架，被重点维护</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="谷歌新出的官方开发语言Kotlin了解吗-和Java相比它有哪些特点。"><a href="#谷歌新出的官方开发语言Kotlin了解吗-和Java相比它有哪些特点。" class="headerlink" title="谷歌新出的官方开发语言Kotlin了解吗 &amp; 和Java相比它有哪些特点。"></a>谷歌新出的官方开发语言Kotlin了解吗 &amp; 和Java相比它有哪些特点。</h3><p>由 JetBrains 开发。用于现代多平台应用的静态编程语言。<br>Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。<br>Kotlin已正式成为Android官方支持开发语言。<br>兼容&#x2F;无缝对接java，可以java代码和kotlin代码互相调用。一键java转kotlin，如果你有遗留的java代码，可以一键转换<br>与Java对比</p>
<ul>
<li>更简洁：这是它重要的优点之一，可以比Java编写少得多的代码。</li>
<li>更安全：Kotlin是空安全的，它在编译期间就会处理各种为null的情况，无需像java一样添加很多的判空代码，节约很多调试空指针异常的时间，很大程度上避免出现NullPointException。</li>
<li>易扩展：扩展函数意味着我们不仅可以扩展我们原有写好的类，还可以扩展系统级的类，非常灵活，另外如果在类里编写扩展函数，那么只对当前类生效。</li>
<li>函数式：Kotlin使用了很多函数式编程的概念，比如用到了lambda表达式来更方便地解决问题。</li>
<li>Kotlin Android Extensions：再也不用编写烦人的findViewById()了，如果你集成了ButterKnife，是时候删除对它的依赖了，Kotlin支持了对于View以id形式访问。</li>
<li>不用写分号，就像你看到的上述代码一样，对于很多写过脚本语言的童鞋来说，不要写分号这一点真是节省了很多时间，对于一天写几百行几千行甚至上万行代码的童鞋们来说，相当于省了多少个分号.</li>
</ul>
<h3 id="ReactNative-和-Android-如何交互？"><a href="#ReactNative-和-Android-如何交互？" class="headerlink" title="ReactNative 和 Android 如何交互？"></a>ReactNative 和 Android 如何交互？</h3><p>[ReactNative 官方文档][ReactNative]</p>
<ul>
<li>Android 端</li>
</ul>
<p>创建一个原生模块类CommonModule，继承ReactContextBaseJavaModule，并复写getName()方法，创建暴露给RN调用的方法，并使用@ReactMethod注解修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonModule</span> <span class="keyword">extends</span> <span class="title class_">ReactContextBaseJavaModule</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonModule</span><span class="params">(ReactApplicationContext reactContext)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>(reactContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 实现getName()方法，该方法用来返回RN，在JS端标记这个模块</span></span><br><span class="line">    <span class="comment">// JS端可以通过 React.NativeModules.CommonModule 访问到这个模块</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CommonModule&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ReactMethod</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 加上@ReactMethod注解用于暴露给RN调用的方法</span></span><br><span class="line">    <span class="comment">// 该方法返回值类型为void，因为RN跨语言访问时是异步进行的，原生代码执行结束只能通过回调函数或发送消息给RN</span></span><br><span class="line">	<span class="comment">// 调用该方法弹出一个弹窗到界面</span></span><br><span class="line">    Toast.makeText(reactContext, msg, Toast.LENGTH_LONG).show()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建类 CommonPackage 实现接口 ReactPackage 包管理器，并把第1步中创建好的 CommonModule 类添加进来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonPackage</span> <span class="keyword">implements</span> <span class="title class_">ReactPackage</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">JavaScriptModule</span>&gt;&gt; createJSModules() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;ViewManager&gt; <span class="title function_">createViewManagers</span><span class="params">(ReactApplicationContext reactContext)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;NativeModule&gt; <span class="title function_">createNativeModules</span><span class="params">(</span></span><br><span class="line"><span class="params">                              ReactApplicationContext reactContext)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    List&lt;NativeModule&gt; modules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    modules.add(<span class="keyword">new</span> <span class="title class_">CommonModule</span>(reactContext));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modules;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>将创建好的 CommonPackage 包管理器添加到 ReactPackage 列表中，即在MainApplication.java文件中getPackages方法中提供</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title function_">getPackages</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> Arrays.&lt;ReactPackage&gt;asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MainReactPackage</span>(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CommonPackage</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ReactNative 端</li>
</ul>
<p>把原生模块封装成一个JavaScript模块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      NativeModules &#125; from <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> NativeModules.CommonModule;</span><br></pre></td></tr></table></figure>

<p>调用该模块方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CommonModule from <span class="string">&#x27;./CommonModule&#x27;</span>;</span><br><span class="line">CommonModule.show(<span class="string">&#x27;Awesome&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>补：RN 用 Promise 机制与安卓原生代码通信<br>在原生代码 CommonModule 类中创建桥接方法，当桥接的方法最后一个参数是 Promise 对象，那么该方法就会返回一个JS 的 Promise 对象给对应的 JS 方法<br>首先需要在 CommonModule 中定义一个暴露给 RN 的方法，并且要用 @ReactMethod 标识</p>
<ul>
<li>Android端 发送消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReactMethod</span></span><br><span class="line">fun <span class="title function_">rnCallNativePromise</span><span class="params">(String msg,Promise promise)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    Toast.makeText(reactContext, msg, Toast.LENGTH_LONG).show();</span><br><span class="line">    promise.resolve(<span class="string">&quot;Android 发送消息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RN端 收到消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">commonModule</span> <span class="operator">=</span> NativeModules.CommonModule;</span><br><span class="line">function <span class="title function_">callAndroidPromise</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	commonModule.rnCallNativePromise(<span class="string">&#x27;RN Promise 调用 Android 原生&#x27;</span>)</span><br><span class="line">    .then((msg) =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Alert.alert(<span class="string">&#x27;RN Promise 收到消息&#x27;</span>, msg)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">catch</span>((error) =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        console.log(error)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个APP从启动到主页面显示经历了哪些过程？"><a href="#一个APP从启动到主页面显示经历了哪些过程？" class="headerlink" title="一个APP从启动到主页面显示经历了哪些过程？"></a>一个APP从启动到主页面显示经历了哪些过程？</h2><p>[Github：一个APP从启动到主页面显示经历了哪些过程？][Github_APP]<br><img src="https://mark.cuckooing.cn/pics/pic_d22f897f.png" alt="pic_d22f897f.png"><br>创建进程（AMS → Zygote）</p>
<ol>
<li>点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；</li>
<li>system_server进程接收到请求后，调用ASM的startActivity方法，最后向zygote进程发送创建进程的请求；</li>
<li>Zygote进程fork出新的子进程，即App进程；</li>
<li>App进程内调用ActivityThread.main()方法，随后依次调用Looper.prepareLoop()和Looper.loop()来开启消息循环。<br>绑定Application（App → AMS）</li>
<li>App进程随后调用attach()方法，通过Binder IPC向sytem_server进程发起attachApplication请求；</li>
<li>system_server进程在收到请求后，将进程和指定的Application绑定起来。<br>显示Activity界面（AMS → App）</li>
<li>此时系统已经拥有了该application的进程，它通过binder IPC向App进程发送scheduleLaunchActivity请求启动一个新进程的activity；</li>
<li>App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；</li>
<li>主线程在收到Message后，开始创建目标Activity，通过performLaunchActiivty()方法回调Activity.onCreate()和onStart()方法。</li>
<li>到此，App便正式启动，开始进入Activity生命周期，执行完onCreate&#x2F;onStart&#x2F;onResume方法，UI渲染结束后便可以看到App的主界面。</li>
</ol>
<p>补充：Binder通信<br><img src="https://mark.cuckooing.cn/pics/pic_634bee87.png" alt="pic_634bee87.png"><br>简称:<br>ATP: ApplicationThreadProxy syetem_server 客户端<br>AMS: ActivityManagerService syetem_server 服务端<br>AT: ApplicationThread 新创建&#x2F;App进程 服务端<br>AMP: ActivityManagerProxy 新创建&#x2F;App进程 客户端</p>
<p>图解:<br>①system_server进程中调用startProcessLocked方法,该方法最终通过socket方式,将需要创建新进程的消息告知Zygote进程,并阻塞等待Socket返回新创建进程的pid;<br>②Zygote进程接收到system_server发送过来的消息, 则通过fork的方法，将zygote自身进程复制生成新的进程，并将ActivityThread相关的资源加载到新进程app process,这个进程可能是用于承载activity等组件;<br>③ 在新进程app process向servicemanager查询system_server进程中binder服务端AMS, 获取相对应的Client端,也就是AMP. 有了这一对binder c&#x2F;s对, 那么app process便可以通过binder向跨进程system_server发送请求,即attachApplication()<br>④system_server进程接收到相应binder操作后,经过多次调用,利用ATP向app process发送binder请求, 即bindApplication. system_server拥有ATP&#x2F;AMS, 每一个新创建的进程都会有一个相应的AT&#x2F;AMP,从而可以跨进程 进行相互通信. 这便是进程创建过程的完整生态链。</p>
<h2 id="APP-推送"><a href="#APP-推送" class="headerlink" title="APP 推送"></a>APP 推送</h2><ol>
<li>定义 &amp; 使用场景</li>
</ol>
<ul>
<li>定义<br>服务端主动发送消息，客户端被动接收服务端数据</li>
<li>使用场景<br>广告、及时通讯</li>
</ul>
<ol>
<li>实现原理</li>
</ol>
<ul>
<li>轮询（Pull）<br>应用程序隔固定时间主动与服务器进行连接并查询是否有新的消息。<br>不适用于即时通讯产品，客户端需要不断检测服务器数据（每隔很短时间连一次服务器），浪费客户端资源（CPU、网络流量、系统电量）</li>
<li>SMS（Push）<br>服务器有新消息时，发送1条类似短信的信令给客户端，客户端通过拦截信令，解析消息内容 &#x2F; 向服务器获取信息。<br>可以实现实时操作，但是实现成本很高，需要向移动公司缴纳相应费用。</li>
<li>长连接（Push）<br>长连接是目前APP推送 最佳 &amp; 主要 的底层实现机制<br>客户端主动和服务器建立TCP长连接之后, 客户端定期向服务器发送心跳包, 有消息的时候, 服务器直接通过这个已经建立好的TCP连接通知客户端。<br>（1）TCP长连接<br>长连接即客户端与服务端建立连接后，互相通信，数据发送完成后也不主动断开连接，之后有需要发送的数据就继续通过该连接发送。<br>TCP连接在默认情况下为长连接，即如果连接双方不主动关闭连接，这个连接就一直存在。有一些情况会导致连接切断，如：链路故障，服务器宕机，NAT超时，网络状态变化……<br>（2）心跳包（保活TCP连接）<br>客户端通过每隔一段时间发送一段极短的数据，证明客户端还活着。如果服务端在一定时间收不到客户端数据，则说明连接断开，服务端便不再向该客户端发送推送消息。</li>
</ul>
<ol>
<li>解决方案</li>
</ol>
<ul>
<li>C2DM<br>Google提供了C2DM（Cloud to Device Messaging）服务。Android Cloud to Device Messaging (C2DM)是一个用来帮助开发者从服务器向Android应用程序发送数据的服务。该服务提供了一个简单的、轻量级的机制，允许服务器可以通知移动应用程序直接与服务器进行通信，以便于从服务器获取应用程序更新和用户数据。C2DM服务负责处理诸如消息排队等事务并向运行于目标设备上的应用程序分发这些消息。<br><img src="https://mark.cuckooing.cn/pics/pic_bd5d5b2c.png" alt="pic_bd5d5b2c.png"></li>
<li>MQTT协议<br>轻量级的消息发布&#x2F;订阅协议，基于Push方式，wmqtt.jar 是IBM提供的MQTT协议的实现。</li>
<li>XMPP协议<br>Extensible Messageing and Presence Protocol，可扩展消息与存在协议，是基于可扩展标记语言（XML）的协议，是目前主流的四种IM协议之一。</li>
</ul>
<blockquote>
<p>主流四种IM协议：XMPP协议、IMPP协议（即时信息和空间协议）、PRIM协议（空间和即时信息协议）、SIP协议（即时通讯和空间平衡扩充的进程开始协议）</p>
</blockquote>
<p>XMPP协议是针对消息推送的协议，精简。开源、简单且可扩展性强。</p>
<ul>
<li>第三方平台（激光推送）</li>
<li>自己搭建一个推送平台<br>[Android的socket通信的长连接，有心跳检测][Android_socket]<br>[高效 保活长连接：手把手教你实现 自适应的心跳保活机制][Link 6]<br>（1）长连接 &amp;&amp; 心跳检测（保活长连接）</li>
<li>长连接<br>在Android中建立长连接，不能使用HttpUrlConnection或者HttpClient等网络请求API，因为它们是属于上层的、HTTP协议的。Java为开发者提供了网络套接字Socket。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initSocket</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException, IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(HOST, PORT);</span><br><span class="line">		mSocket = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Socket&gt;(socket);</span><br><span class="line">		mReadThread = <span class="keyword">new</span> <span class="title class_">ReadThread</span>(socket);</span><br><span class="line">		mReadThread.start();</span><br><span class="line">		mHandler.postDelayed(heartBeatRunnable, HEART_BEAT_RATE);<span class="comment">// 初始化成功后，就准备发送心跳包（HEART_BEAT_RATE 毫秒后发送）</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>心跳检测<br>通过Handler.postDelayed(Runnable , TimeMillis)实现定时发送心跳检测功能。因为客户端与服务端可能不属于同一线程，考虑AIDL。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送心跳包</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">mHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">heartBeatRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="keyword">if</span> (System.currentTimeMillis() - sendTime &gt;= HEART_BEAT_RATE) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">				<span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> sendMsg(<span class="string">&quot;&quot;</span>);<span class="comment">// 就发送一个\r\n过去, 如果发送失败，就重新初始化一个socket</span></span><br><span class="line">				<span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">					mHandler.removeCallbacks(heartBeatRunnable);</span><br><span class="line">					mReadThread.release();</span><br><span class="line">					releaseLastSocket(mSocket);</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">InitSocketThread</span>().start();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			mHandler.postDelayed(<span class="built_in">this</span>, HEART_BEAT_RATE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>（2）封装发送数据 &#x2F; 解析接收数据<br>建立Socket长连接后，数据在Socket通道中以字节流的形式传输，通过InputStream和outputStream读取和发送数据。我们应该定义通信的数据格式（如HTTP格式包含：协议头+协议主体+校验码），可参考XMPP协议封装数据。</p>
<h2 id="Android-虚拟机及编译过程"><a href="#Android-虚拟机及编译过程" class="headerlink" title="Android 虚拟机及编译过程"></a>Android 虚拟机及编译过程</h2><h3 id="Dalvik虚拟机"><a href="#Dalvik虚拟机" class="headerlink" title="Dalvik虚拟机"></a>Dalvik虚拟机</h3><ol>
<li>Dalvik 虚拟机<br>Dalvik是Google公司自己设计用于Android平台的Java虚拟机，它是Android平台的重要组成部分，支持dex格式（Dalvik Executable）的Java应用程序的运行。dex格式是专门为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。Google对其进行了特定的优化，使得Dalvik具有高效、简洁、节省资源的特点。从Android系统架构图知，Dalvik虚拟机运行在Android的运行时库层。<br>Dalvik作为面向Linux、为嵌入式操作系统设计的虚拟机，主要负责完成对象生命周期管理、堆栈管理、线程管理、安全和异常管理，以及垃圾回收等。</li>
<li>特点</li>
</ol>
<ul>
<li>体积小，占用内存空间小；</li>
<li>专有的DEX可执行文件格式，体积更小，执行速度更快；</li>
<li>常量池采用32位索引值，寻址类方法名，字段名，常量更快；</li>
<li>基于寄存器架构，并拥有一套完整的指令系统；</li>
<li>提供了对象生命周期管理，堆栈管理，线程管理，安全和异常管理以及垃圾回收等重要功能；</li>
<li>所有的Android程序都运行在Android系统进程里，每个进程对应着一个Dalvik虚拟机实例。</li>
</ul>
<ol>
<li>DVM &amp; JVM 区别<br>（1）执行文件不同<br>Java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码。<br><img src="https://mark.cuckooing.cn/pics/pic_e948b0d3.png" alt="pic_e948b0d3.png"><br>传统的Java程序经过编译，生成Java字节码保存在class文件中，Java虚拟机通过解码class文件中的内容来运行程序。<br>Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX（Dalvik Executable）可执行文件中。Dalvik虚拟机通过解释DEX文件来执行这些字节码。<br>Dalvik可执行文件体积小。Android SDK中有一个叫dx的工具负责将Java字节码转换为Dalvik字节码。<br>dx工具消除java类文件的冗余信息，重新组合形成一个常量池，所有的类文件共享同一个常量池。由于dx工具对常量池的压缩，使得相同的字符串，常量在DEX文件中只出现一次，从而减小了文件的体积。<br><img src="https://mark.cuckooing.cn/pics/pic_8c898abe.png" alt="pic_8c898abe.png"><br>简单来讲，dex格式文件就是将多个class文件中公有的部分统一存放，去除冗余信息。<br>（2）架构不同<br>Java虚拟机基于栈架构，Dalvik虚拟机基于寄存器架构。<br>Java虚拟机基于栈架构，程序在运行时虚拟机需要频繁的从栈上读取或写入数据，这个过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构。数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式要快很多。</li>
<li>结构<br><img src="https://mark.cuckooing.cn/pics/pic_98efc38b.png" alt="pic_98efc38b.png"><br>一个应用首先经过DX工具将class文件转换成Dalvik虚拟机可以执行的dex文件，然后由类加载器加载原生类和Java类，接着由解释器根据指令集对Dalvik字节码进行解释、执行。最后，根据dvm_arch参数选择编译的目标机体系结构。</li>
</ol>
<h3 id="ART虚拟机与Dalvik虚拟机的区别"><a href="#ART虚拟机与Dalvik虚拟机的区别" class="headerlink" title="ART虚拟机与Dalvik虚拟机的区别"></a>ART虚拟机与Dalvik虚拟机的区别</h3><p>Android 从5.0开始默认使用ART虚拟机执行程序,抛弃了Dalvik虚拟机.加快了Android的运行效率,提高系统的流畅性。<br>ART 机制<br>ART代表Android Runtime，其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time (JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，即翻译工作是在程序运行时进行的。这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。<br>ART则完全改变了这套做法，在应用安装时就预编译字节码到机器语言，这一机制叫Ahead-Of-Time (AOT）编译，ART在APK在安装时就对其包含的Dex字节码进行翻译，得到对应的本地机器指令，于是就可以在运行时直接执行了，即翻译工作是在APK安装时进行的。应用程序执行将更有效率，启动更快；缺点就是需占用更大的存储空间与更长的应用安装时间（空间换取时间策略）。<br>ART虚拟机相对于Dalvik虚拟机的提升</p>
<table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>Dalvik虚拟机</th> 
   <th>ART虚拟机</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>预编译</td> 
   <td>采用的是JIT来做及时翻译(动态翻译)，在运行时将dex通过解释器翻译成native code</td> 
   <td>使用了AOT直接在安装时将dex翻译成native code</td> 
  </tr> 
  <tr> 
   <td>垃圾回收机制</td> 
   <td>标记-清除 算法<br>（非并发过程STW）如果出现内存不足时，GC频繁会导致UI卡顿掉帧不流畅</td> 
   <td>标记-压缩 + 部分并发<br>提高GC效率</td> 
  </tr> 
  <tr> 
   <td>内存管理</td> 
   <td>内存碎片化严重（标记清除算法）</td> 
   <td>进行内存管理，减少内存碎片化，提高内存效率<br>（标记-压缩：将不连续的物理内存块进行压缩）</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="Android-APK-编译打包流程"><a href="#Android-APK-编译打包流程" class="headerlink" title="Android APK 编译打包流程"></a>Android APK 编译打包流程</h3><p><img src="https://mark.cuckooing.cn/pics/pic_049e6353.png" alt="pic_049e6353.png"></p>
<ol>
<li>Java编译器对工程本身的java代码进行编译，这些java代码有三个来源：app的源代码，由资源文件生成的R文件(aapt工具)，以及有aidl文件生成的java接口文件(aidl工具)。产出为.class文件。<br>①用AAPT编译R.java文件<br>②编译AIDL的java文件<br>③把java文件编译成class文件</li>
<li>.class文件和依赖的三方库文件通过dex工具生成Delvik虚拟机可执行的.dex文件，包含了所有的class信息，包括项目自身的class和依赖的class。产出为.dex文件。</li>
<li>apkbuilder工具将.dex文件和编译后的资源文件生成未经签名对齐的apk文件。这里编译后的资源文件包括两部分，一是由aapt编译产生的编译后的资源文件，二是依赖的三方库里的资源文件。产出为未经签名的.apk文件。</li>
<li>分别由Jarsigner和zipalign对apk文件进行签名和对齐，生成最终的apk文件。<br>总结为：编译–&gt;DEX–&gt;打包–&gt;签名和对齐</li>
</ol>
<h2 id="Android-dex分包方案和热补丁原理"><a href="#Android-dex分包方案和热补丁原理" class="headerlink" title="Android dex分包方案和热补丁原理"></a>Android dex分包方案和热补丁原理</h2><p>[Android dex分包方案和热补丁原理][Android dex 1]<br>[安卓App热补丁动态修复技术介绍][App]</p>
<h3 id="Android-dex文件-类加载器DexLoader"><a href="#Android-dex文件-类加载器DexLoader" class="headerlink" title="Android dex文件 &amp; 类加载器DexLoader"></a>Android dex文件 &amp; 类加载器DexLoader</h3><ol>
<li>类加载器简介<br>对于Android的应用程序，本质上虽然也是用Java开发，并且使用标准的Java编译器编译出Class文件，但最终的APK文件中包含的却是dex类型的文件。dex文件是将所需的所有Class文件重新打包，打包的规则不是简单的压缩，而是完全对Class文件内部的各种函数表、变量表等进行优化，并产生一个新的文件，这就是dex文件。由于dex文件是一种经过优化的Class文件，因此要加载这样特殊的Class文件就需要特殊的类装载器，这就是DexClassLoader，Android SDK中提供的DexClassLoader类就是出于这个目的。<br>DexClassLoader是一个可以从包含classes.dex实体的.jar或.apk文件中加载classes的类加载器。可以用于实现dex的动态加载、代码热更新等等。<br>DexClassLoader和PathClassLoader的区别</li>
</ol>
<ul>
<li>DexClassLoader：能够加载未安装的jar&#x2F;apk&#x2F;dex（可加载外部dex文件，如SD卡中）</li>
<li>PathClassLoader：Android 系统类&amp;应用类的加载器，只能加载系统中已经安装过的apk（&#x2F;data&#x2F;data&#x2F;包名目录下apk）</li>
</ul>
<ol>
<li>加载原理<br>Android的ClassLoader体系<br><img src="https://mark.cuckooing.cn/pics/pic_98c3c355.png" alt="pic_98c3c355.png"><br>由上图可以看出，在叶子节点上，我们能使用到的是DexClassLoader和PathClassLoader，两个叶子节点的类都继承BaseDexClassLoader中，而具体的类加载逻辑也在此类中：<br>&#x2F;&#x2F; BaseDexClassLoader.java</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Throwable&gt;();  </span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> pathList.findClass(name, suppressedExceptions);  -&gt;&gt; 分析<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        <span class="type">ClassNotFoundException</span> <span class="variable">cnfe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;Didn&#x27;t find class \&quot;&quot;</span> + name + <span class="string">&quot;\&quot; on path: &quot;</span> + pathList);  </span><br><span class="line">        <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">            cnfe.addSuppressed(t);  </span><br><span class="line">       &#125;  </span><br><span class="line">        <span class="keyword">throw</span> cnfe;  </span><br><span class="line">    &#125;  </span><br><span class="line">     <span class="keyword">return</span> c;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 分析1:DexPathList.findClass</span></span><br><span class="line"><span class="keyword">public</span> Class <span class="title function_">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        <span class="type">DexFile</span> <span class="variable">dex</span> <span class="operator">=</span> element.dexFile;  </span><br><span class="line">        <span class="keyword">if</span> (dex != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> dex.loadClassBinaryName(name, definingContext, suppressed);  </span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                <span class="keyword">return</span> clazz;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">    <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上述函数可知，当我们需要加载一个class时，实际是从pathList（DexPathList）中去查找。pathList是一个存储dex文件（每个dex文件实际上是一个DexFile对象）的数组（Element数组，Element是一个内部类），然后依次去加载所需要的class文件，直到找到为止。</p>
<h3 id="dex分包方案"><a href="#dex分包方案" class="headerlink" title="dex分包方案"></a>dex分包方案</h3><ol>
<li>分包原因<br>当一个app的功能越来越复杂，代码量越来越多，也许有一天便会突然遇到下列现象：</li>
</ol>
<ul>
<li>生成的apk在2.3以前的机器无法安装，提示INSTALL_FAILED_DEXOPT<br>Android2.3及以前版本用来执行dexopt(用于优化dex文件)的内存只分配了5M</li>
<li>方法数量过多，编译时出错，提示：Conversion to Dalvik format failed:Unable to execute dex: method ID not in [0, 0xffff]: 65536<br>一个dex文件最多只支持65536个方法</li>
</ul>
<ol>
<li>分包原理<br>将编译好的class文件拆分打包成2个dex，在运行时再动态加载第二个dex文件中。（绕过dex方法数量的限制以及安装时的检查）<br>此时，除了第一个dex文件（一个apk唯一包含一个dex文件），其他dex文件都以资源的方式存放在安装包中，并在Application的onCreate()回调中被注意到系统的ClassLoader中。</li>
<li>分包流程</li>
</ol>
<ul>
<li>编译时分包<br>（1）将 $ {classes}（该文件夹下都是要打包到第一个dex的文件）打包生成第一个dex。<br>（2）将 $ {secclasses}中的文件打包生成第二个dex，并将其打包到资资源文件中</li>
<li>将dex分包（第二个dex）注入ClassLoader<br>根据DexClassLoader加载原理：遍历一个存储dex文件的数组，然后依次去加载所需要的class文件，直到找到为止。知注入的解决方案：假如我们将第二个dex文件放入这个数组中，那么在加载第二个dex包中的类时，应该可以直接找到。<br>在我们自定义的BaseApplication的onCreate中，我们执行注入操作：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">inject</span><span class="params">(String libPath)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasBaseDexClassLoader</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        Class.forName(<span class="string">&quot;dalvik.system.BaseDexClassLoader&quot;</span>);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        hasBaseDexClassLoader = <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (hasBaseDexClassLoader) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        <span class="type">PathClassLoader</span> <span class="variable">pathClassLoader</span> <span class="operator">=</span> (PathClassLoader)sApplication.getClassLoader();  </span><br><span class="line">        <span class="type">DexClassLoader</span> <span class="variable">dexClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DexClassLoader</span>(libPath, sApplication.getDir(<span class="string">&quot;dex&quot;</span>, <span class="number">0</span>).getAbsolutePath(), libPath, sApplication.getClassLoader());  </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">            <span class="type">Object</span> <span class="variable">dexElements</span> <span class="operator">=</span> combineArray(getDexElements(getPathList(pathClassLoader)), getDexElements(getPathList(dexClassLoader)));  </span><br><span class="line">            <span class="type">Object</span> <span class="variable">pathList</span> <span class="operator">=</span> getPathList(pathClassLoader);  </span><br><span class="line">            setField(pathList, pathList.getClass(), <span class="string">&quot;dexElements&quot;</span>, dexElements);  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            <span class="keyword">return</span> android.util.Log.getStackTraceString(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数libPath是第二个dex包的文件信息（包含完整路径，我们当初将其打包到了assets目录下），然后将其使用DexClassLoader来加载。</li>
<li>通过反射获取PathClassLoader中的DexPathList中的Element数组（已加载了第一个dex包，由系统加载），以及DexClassLoader中的DexPathList中的Element数组（刚将第二个dex包加载进去）</li>
<li>将两个Element数组合并之后，再将其赋值给PathClassLoader的Element数组<br>通常情况下，dexElements数组中只会有一个元素，就是apk安装包中的classes.dex<br>而我们则可以通过反射，强行的将一个外部的dex文件添加到此dexElements中，这就是dex的分包原理了。</li>
</ul>
<p>现在试着启动app，并在TestUrlActivity（在第一个dex包中）中去启动SecondActivity（在第二个dex包中），启动成功。这种方案是可行。</p>
<blockquote>
<p>注意点：</p>
<ol>
<li>由于第二个dex包是在Application的onCreate中动态注入的，如果dex包过大，会使app的启动速度变慢，因此，在dex分包过程中一定要注意，第二个dex包不宜过大。</li>
<li>由于上述第一点的限制，假如我们的app越来越臃肿和庞大，往往会采取dex分包方案和插件化方案配合使用，将一些非核心独立功能做成插件加载，核心功能再分包加载。</li>
</ol>
</blockquote>
<blockquote>
<p>为什么使用DexClassLoader加载第二个包而不用PathClassLoader?<br>因为PathClassLoader只能加载已安装到系统中（即&#x2F;data&#x2F;app目录下）的apk文件。第二个包位于资源文件中dex文件，因此只能用DexClassLoader加载。</p>
</blockquote>
<p>源码可参考Google MultiDex方案的实现。</p>
<h3 id="热补丁"><a href="#热补丁" class="headerlink" title="热补丁"></a>热补丁</h3><ol>
<li>适用场景<br>当一个App发布之后，突然发现了一个严重bug需要进行紧急修复，这时候公司各方就会忙得焦头烂额：重新打包App、测试、向各个应用市场和渠道换包、提示用户升级、用户下载、覆盖安装。有时候仅仅是为了修改了一行代码，也要付出巨大的成本进行换包和重新发布。<br>这时候就提出一个问题：有没有办法以补丁的方式动态修复紧急Bug，不再需要重新发布App，不再需要用户重新下载，覆盖安装？<br>空间Android独立版5.2发布后，收到用户反馈，结合版无法跳转到独立版的访客界面，每天都较大的反馈。在以前只能紧急换包，重新发布。成本非常高，也影响用户的口碑。最终决定使用热补丁动态修复技术，向用户下发Patch，在用户无感知的情况下，修复了外网问题，取得非常好的效果。</li>
<li>实现原理<br>该方案基于的是android dex分包方案的。原理可概括为：<br>App的一个ClassLoader可以包含多个dex文件，每个dex文件是一个Element，多个dex文件排列成一个有序的数组dexElements，当找类的时候，会按顺序遍历dex文件，然后从当前遍历的dex文件中找类，如果找类则返回，如果找不到从下一个dex文件继续查找。<br>理论上，Dex分包方案中是没有重复类的，因此，如果在不同的dex中有重复的类存在，那么会优先选择排在前面的dex文件的类，如下图：<br><img src="https://mark.cuckooing.cn/pics/pic_5670b1fc.png" alt="pic_5670b1fc.png"><br>在此基础上，我们构想了热补丁的方案，把有问题的类打包到一个dex（patch.dex）中去，然后把这个dex补丁包插入到Elements的最前面，这样出现bug的类就会被覆盖。如下图：<br><img src="https://mark.cuckooing.cn/pics/pic_d83aa9bd.png" alt="pic_d83aa9bd.png"></li>
<li>实现方案</li>
</ol>
<ul>
<li>把需修复、含Bug的类 独立打包到1个Dex文件中（记为：patch.dex）</li>
<li>将该 Dex文件 插入到ClassLoader中集合 dexElements的最前面<br><img src="https://mark.cuckooing.cn/pics/pic_097b87ef.png" alt="pic_097b87ef.png"></li>
</ul>
<h2 id="Android-插件化"><a href="#Android-插件化" class="headerlink" title="Android 插件化"></a>Android 插件化</h2><p>[H3c —— Android插件化开发][H3c _ Android]</p>
<ol>
<li>简介<br>所谓插件化，就是让我们的应用不必再像原来一样把所有的内容都放在一个apk中，可以把一些功能和逻辑单独抽出来放在插件apk中，然后主apk做到［按需调用］，这样的好处是一来可以减少主apk的体积，让应用更轻便，二来可以做到热插拔（将功能需要的时候插上去，废弃的时候拔下来），更加动态化。<br>插件化可以解决如下问题：</li>
</ol>
<ul>
<li>应用体积越来越大，需要拆分apk完成模块化与热部署——减小主包大小</li>
<li>应用频繁更新，用户黏性降低——不发版上新功能</li>
<li>需求不确定时，添加新功能——允许动态添加新功能，一旦不适用或发生问题，可以进行动态替换（不需要紧急发布补丁或进行升级）</li>
<li>主应用用户量较大，同系新应用需要导流，传统特性只能引导用户下载安装——bug修复工具</li>
</ul>
<ol>
<li>需解决的问题 &amp; 解决方案<br>插件化核心问题 —— Android动态加载<br>即动态调用外部的 dex文件，极端的情况下，Android APK自身带有的Dex文件只是一个程序的入口（或者说空壳），所有的功能都通过从服务器下载最新的Dex文件完成。<br>通过ClassLoader加载，然后通过代理模式让Activity等组件具有生命周期实现真正的功能，并且解决了资源访问问题。是解决插件化的基本问题。<br>（一）类的加载</li>
</ol>
<ul>
<li>DexClassLoader：要想实现加载外部dex文件（即插件）来实现热部署，那么必然要把其中的class文件加载到内存中。其中涉及到两种ClassLoader:DexClassLoader和PathClassLoader。而DexClassLoader可以加载外部的jar,dex等文件，正是我们需要的。</li>
<li>反射：因为插件apk与宿主apk不在一个apk内，那么一些类的访问必然要通过反射进行获取。</li>
</ul>
<p>（1）创建插件的工程PluginAUtils，并生成PluginAUtils.apk<br>（2）创建主工程PluginA，在app&#x2F;src&#x2F;main&#x2F;目录下创建asserts文件夹，把刚刚编译好的pluginA.apk放到里面。创建一个AssertsDexLoader.java用来动态加载PluginAUtils工程。<br>AssertsDexLoader逻辑为拷贝asserts里的apk文件到外置SD卡上某位置（减少应用安装体积），再把ClassLoader，拷贝的目录及文件三个参数传递给installBundleDexs()即可动态加载其方法至内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;DexClassLoader&gt; bundleDexClassLoaderList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexClassLoader&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">installBundleDexs</span><span class="params">(ClassLoader loader, File dexDir, List&lt;File&gt; files)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="type">DexClassLoader</span> <span class="variable">bundleDexClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DexClassLoader</span>(</span><br><span class="line">                    f.getAbsolutePath(), dexDir.getAbsolutePath(), <span class="literal">null</span>,                    loader);</span><br><span class="line">            bundleDexClassLoaderList.add(bundleDexClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用DexClassLoader代替PathClassLoader除了可以解决Dex加载与系统版本密切问题之外，还可以将第三方apk复制到外置SD卡上减少应用安装后的体积。<br>（3）在任何需要的地方通过反射调用即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class 获取方式</span></span><br><span class="line"><span class="comment">// 用插件化apk直接创建系统的DexClassLoader</span></span><br><span class="line"><span class="comment">// 反射调用的时候先检查PathClassLoader中是否存在，如果不存在就在DexClassLoader list中查找。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;debug: class find in main classLoader&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (DexClassLoader bundleDexClassLoader : bundleDexClassLoaderList) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            Class&lt;?&gt; clazz = bundleDexClassLoader.loadClass(className);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                System.out.println(<span class="string">&quot;debug: class find in bundle classLoader&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>(className + <span class="string">&quot; not found exception&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runAssertsDexMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Class&lt;?&gt; clazz = loadClass(<span class="string">&quot;h3c.plugina.PluginAUtils&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getConstructor();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bundleUtils</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">printSumMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;showToastInfo&quot;</span>, Context.class);</span><br><span class="line">        printSumMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        printSumMethod.invoke(bundleUtils, getApplicationContext());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（二）生命周期的管理</p>
<ul>
<li>代理模式插件化实现的过程主要靠欺上瞒下，坑蒙拐骗来实现。想想虽然加载进来了Activity等组件，但也仅仅是最为一个对象而存在，并没有在AndroidManifest中注册，没有生命周期的回调，并不能实现我们想要的效果。因此无论是dynamic_load_apk通过代理activity来操控插件activity的方式，还是DroidPlugin通过hook activity启动过程来启动插件activity的方式，都是对代理模式的应用。<br>（1）宿主代理Activity模式（静态代理模式）<br>宿主代理无需在宿主中注册Activity，所有跳转均由一个傀儡Activity完成，这样的好处是无需过多的改变宿主即可完成插件开发，但是插件Activity并不享有系统提供的生命周期，其所有生命周期必须由宿主通过反射的方式传递。</li>
<li>在PluginA工程中创建BaseActivity.java，关键代码如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 通过隐式调用宿主的ProxyActivity</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PROXY_VIEW_ACTION</span> <span class="operator">=</span> <span class="string">&quot;h3c.pluginapp.ProxyActivity&quot;</span>;</span><br><span class="line">    <span class="comment">// 因为插件的Activity没有Context，所以一切与Context的行为都必须通过宿主代理Activity实现！</span></span><br><span class="line">    <span class="keyword">protected</span> Activity mProxyActivity;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProxy</span><span class="params">(Activity proxyActivity)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mProxyActivity = proxyActivity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mProxyActivity.setContentView(layoutResID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">findViewById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> mProxyActivity.findViewById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插件的startActivity其实就是调用宿主开启另一个ProxyActivity</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startActivity</span><span class="params">(String className)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(PROXY_VIEW_ACTION);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;Class&quot;</span>, className);</span><br><span class="line">        mProxyActivity.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在PluginA工程中创建AActivity.java和BActivity.java。让AActivity可以点击跳转到BActivity即可。</li>
<li>重新编译PluginA，将Apk替换到宿主中。</li>
<li>在宿主工程中创建ProxyActivity.java并在AndroidManifest文件中注册。关键代码:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 因为插件Activity获得的是宿主的Context，这样就拿不到自己的资源，所以这里要用插件的Resource替换ProxyActivity的Resource！</span></span><br><span class="line">    <span class="keyword">private</span> Resources mBundleResources;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">attachBaseContext</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        replaceContextResources(context);</span><br><span class="line">        <span class="built_in">super</span>.attachBaseContext(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceContextResources</span><span class="params">(Context context)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> context.getClass().getDeclaredField(<span class="string">&quot;mResources&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == mBundleResources) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                mBundleResources = AssertsDexLoader.getBundleResource(context,                    context.getDir(AssertsDexLoader.APK_DIR, Context.MODE_PRIVATE).</span><br><span class="line">                                getAbsolutePath() + <span class="string">&quot;/app-debug.apk&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            field.set(context, mBundleResources);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// ProxyActivity要加载的插件Activity名字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> getIntent().getStringExtra(<span class="string">&quot;Class&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            Class&lt;?&gt; localClass = AssertsDexLoader.loadClass(className);</span><br><span class="line">            Constructor&lt;?&gt; localConstructor = localClass</span><br><span class="line">                    .getConstructor(<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> localConstructor.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;);</span><br><span class="line">            <span class="comment">// 把当前的傀儡Activity注入到插件中</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">setProxy</span> <span class="operator">=</span> localClass.getMethod(<span class="string">&quot;setProxy&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      Activity.class &#125;);</span><br><span class="line">            setProxy.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            setProxy.invoke(instance, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      <span class="built_in">this</span> &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用插件的onCreate()</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">onCreate</span> <span class="operator">=</span> localClass.getDeclaredMethod(<span class="string">&quot;onCreate&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      Bundle.class &#125;);</span><br><span class="line">            onCreate.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            onCreate.invoke(instance, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      <span class="literal">null</span> &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, ProxyActivity.class);</span><br><span class="line">intent.putExtra(<span class="string">&quot;Class&quot;</span>, <span class="string">&quot;h3c.plugina.AActivity&quot;</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>（2）宿主动态创建Activity模式（动态代理模式）<br>Activity有着自己的生命周期，但是必须提前在宿主AndroidManifest文件中注册。</p>
<p>（三）资源的加载<br>要想获得资源文件必须得到一个Resource对象，想要获得插件的资源文件，必须得到一个插件的Resource对象，好在android.content.res.AssetManager.java中包含一个私有方法addAssetPath。只需要将apk的路径作为参数传入，就可以获得对应的AssetsManager对象，从而创建一个Resources对象，然后就可以从Resource对象中访问apk中的资源了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入插件的AssetManager</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AssetManager <span class="title function_">createAssetManager</span><span class="params">(String apkPath)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">AssetManager</span> <span class="variable">assetManager</span> <span class="operator">=</span> AssetManager.class.newInstance();</span><br><span class="line">        AssetManager.class.getDeclaredMethod(<span class="string">&quot;addAssetPath&quot;</span>, String.class).invoke(</span><br><span class="line">                assetManager, apkPath);</span><br><span class="line">        <span class="keyword">return</span> assetManager;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        th.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得插件的Resource</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Resources <span class="title function_">getBundleResource</span><span class="params">(Context context, String apkPath)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">AssetManager</span> <span class="variable">assetManager</span> <span class="operator">=</span> createAssetManager(apkPath);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Resources</span>(assetManager, context.getResources().getDisplayMetrics(), context.getResources().getConfiguration());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宿主中跳转到ProxyActivity，根据传入的参数反射创建一个插件的Activity，把插件的Resource注入到自己中，并把自己注入到插件Activity中实现生命周期的同步。</p>
<h2 id="Android-MVP模式"><a href="#Android-MVP模式" class="headerlink" title="Android MVP模式"></a>Android MVP模式</h2><ol>
<li>MVC模式 &amp; 缺点<br>MVC，全称Model-View-Controller，即模型-视图-控制器。 具体如下：</li>
</ol>
<ul>
<li>View：对应于布局文件</li>
<li>Model：业务逻辑和实体模型</li>
<li>Controllor：对应于Activity</li>
</ul>
<p>缺点<br>MVC模式下实际上就是Activty与Model之间交互，View完全独立出来了。<br>View对应于布局文件，其实能做的事情特别少，实际上关于该布局文件中的数据绑定的操作，事件处理的代码都在Activity中，造成了Activity既像View又像Controller，使得Activity变得臃肿。<br><img src="https://mark.cuckooing.cn/pics/pic_608c4e84.png" alt="pic_608c4e84.png"><br>2. MVP模式 &amp; 优点<br>MVP，全称 Model-View-Presenter，即模型-视图-层现器。具体如下：</p>
<ul>
<li>View 对应于Activity，负责View的绘制以及与用户交互</li>
<li>Model 依然是业务逻辑和实体模型</li>
<li>Presenter 负责完成View于Model间的交互</li>
</ul>
<p>优点<br>MVP模式通过Presenter实现数据和视图之间的交互，简化了Activity的职责。同时即避免了View和Model的直接联系，又通过Presenter实现两者之间的沟通。<br>MVP模式减少了Activity的职责，简化了Activity中的代码，将复杂的逻辑代码提取到了Presenter中进行处理，模块职责划分明显，层次清晰。与之对应的好处就是，耦合度更低，更方便的进行测试。<br><img src="https://mark.cuckooing.cn/pics/pic_8ca2bae2.png" alt="pic_8ca2bae2.png"></p>
<ol>
<li>MVP &amp; MVC 区别<br><img src="https://mark.cuckooing.cn/pics/pic_70b6752e.png" alt="pic_70b6752e.png"><br>MVC中是允许Model和View进行交互的，而MVP中很明显，Model与View之间的交互由Presenter完成。还有一点就是Presenter与View之间的交互是通过接口的。</li>
<li>MVP模式 典例 —— 登录案例<br>结构图<br><img src="https://mark.cuckooing.cn/pics/pic_da49ca33.png" alt="pic_da49ca33.png"><br>1.Model层<br>在本例中，M0del层负责对从登录页面获取地帐号密码进行验证（一般需要请求服务器进行验证，本例直接模拟这一过程）。 从上图的包结构图中可以看出，Model层包含内容：<br>①实体类bean<br>②接口，表示Model层所要执行的业务逻辑<br>③接口实现类，具体实现业务逻辑，包含的一些主要方法<br>下面以代码的形式一一展开。<br>①实体类bean</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装了用户名、密码，方便数据传递。<br>②接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoginModel</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(User user, OnLoginFinishedListener listener)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中OnLoginFinishedListener 是presenter层的接口，方便实现回调presenter，通知presenter业务逻辑的返回结果，具体在presenter层介绍。<br>③接口实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginModelImpl</span> <span class="keyword">implements</span> <span class="title class_">LoginModel</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(User user, <span class="keyword">final</span> OnLoginFinishedListener listener)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> user.getUsername();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Handler</span>().postDelayed(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="type">boolean</span> <span class="variable">error</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(username))&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    listener.onUsernameError();<span class="comment">//model层里面回调listener</span></span><br><span class="line">                    error = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(password))&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    listener.onPasswordError();</span><br><span class="line">                    error = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!error)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    listener.onSuccess();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Model层逻辑：延时模拟登陆（2s），如果用户名或者密码为空则登陆失败，否则登陆成功。<br>2.View层<br>视图：将Modle层请求的数据呈现给用户。一般的视图都只是包含用户界面(UI)，而不包含界面逻辑，界面逻辑由Presenter来实现。<br>从上图的包结构图中可以看出，View包含内容：<br>①接口，上面我们说过Presenter与View交互是通过接口。其中接口中方法的定义是根据Activity用户交互需要展示的控件确定的。<br>②接口实现类，将上述定义的接口中的方法在Activity中对应实现具体操作。<br>下面以代码的形式一一展开。<br>①接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoginView</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//login是个耗时操作，我们需要给用户一个友好的提示，一般就是操作ProgressBar</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showProgress</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hideProgress</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">//login当然存在登录成功与失败的处理，失败给出提示</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUsernameError</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPasswordError</span><span class="params">()</span>;</span><br><span class="line">   <span class="comment">//login成功，也给个提示</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showSuccess</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述5个方法都是presenter根据model层返回结果需要view执行的对应的操作。<br>②接口实现类<br>即对应的登录的Activity，需要实现LoginView接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">LoginView</span>, View.OnClickListener &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> ProgressBar progressBar;</span><br><span class="line">    <span class="keyword">private</span> EditText username;</span><br><span class="line">    <span class="keyword">private</span> EditText password;</span><br><span class="line">    <span class="keyword">private</span> LoginPresenter presenter;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_login);</span><br><span class="line">        progressBar = (ProgressBar) findViewById(R.id.progress);</span><br><span class="line">        username = (EditText) findViewById(R.id.username);</span><br><span class="line">        password = (EditText) findViewById(R.id.password);</span><br><span class="line">        findViewById(R.id.button).setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">       <span class="comment">//创建一个presenter对象，当点击登录按钮时，让presenter去调用model层的login()方法，验证帐号密码</span></span><br><span class="line">        presenter = <span class="keyword">new</span> <span class="title class_">LoginPresenterImpl</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        presenter.onDestroy();</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showProgress</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        progressBar.setVisibility(View.VISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hideProgress</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        progressBar.setVisibility(View.GONE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsernameError</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        username.setError(getString(R.string.username_error));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPasswordError</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        password.setError(getString(R.string.password_error));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">         progressBar.setVisibility(View.GONE);</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>,<span class="string">&quot;login success&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setPassword(password.getText().toString());</span><br><span class="line">        user.setUsername(username.getText().toString());</span><br><span class="line">        presenter.validateCredentials(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>View层实现Presenter层需要调用的控件操作，方便Presenter层根据Model层返回的结果进行操作View层进行对应的显示。<br>3.Presenter层<br>Presenter是用作Model和View之间交互的桥梁。 从上图的包结构图中可以看出，Presenter包含内容：<br>①接口，包含Presenter需要进行Model和View之间交互逻辑的接口，以及上面提到的Model层数据请求完成后回调的接口。<br>②接口实现类，即实现具体的Presenter类逻辑。<br>下面以代码的形式一一展开。<br>①接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnLoginFinishedListener</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onUsernameError</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onPasswordError</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Model层得到请求的结果，需要回调Presenter层，让Presenter层调用View层的接口方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoginPresenter</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">validateCredentials</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登陆的Presenter 的接口，实现类为LoginPresenterImpl，完成登陆的验证，以及销毁当前view。<br>②接口实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginPresenterImpl</span> <span class="keyword">implements</span> <span class="title class_">LoginPresenter</span>, OnLoginFinishedListener &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> LoginView loginView;</span><br><span class="line">    <span class="keyword">private</span> LoginModel loginModel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginPresenterImpl</span><span class="params">(LoginView loginView)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.loginView = loginView;</span><br><span class="line">        <span class="built_in">this</span>.loginModel = <span class="keyword">new</span> <span class="title class_">LoginModelImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validateCredentials</span><span class="params">(User user)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (loginView != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            loginView.showProgress();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        loginModel.login(user, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        loginView = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUsernameError</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (loginView != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            loginView.setUsernameError();</span><br><span class="line">            loginView.hideProgress();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPasswordError</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (loginView != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            loginView.setPasswordError();</span><br><span class="line">            loginView.hideProgress();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (loginView != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            loginView.showSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于presenter完成二者的交互，那么肯定需要二者的实现类（通过传入参数，或者new）。<br>presenter里面有个OnLoginFinishedListener， 其在Presenter层实现，给Model层回调，更改View层的状态， 确保 Model层不直接操作View层。</p>
<p>核心流程总结<br>View与Model并不直接交互，而是使用Presenter作为View与Model之间的桥梁。其中Presenter中同时持有View层的Interface的引用以及Model层的引用，而View层持有Presenter层引用。当View层某个界面需要展示某些数据的时候，首先会调用Presenter层的引用，然后Presenter层会调用Model层请求数据，当Model层数据加载成功之后会调用Presenter层的回调方法通知Presenter层数据加载情况，最后Presenter层再调用View层的接口将加载后的数据展示给用户。本例模式：<br><img src="https://mark.cuckooing.cn/pics/pic_8d89d391.png" alt="pic_8d89d391.png"><br>一般模式：<br><img src="https://mark.cuckooing.cn/pics/pic_ce941670.png" alt="pic_ce941670.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.wuleizhenshang.love">无泪真伤</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.wuleizhenshang.love/2025/01/03/android%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/">https://www.wuleizhenshang.love/2025/01/03/android%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.wuleizhenshang.love" target="_blank">Blog-无泪真伤</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://smms.app/image/gw4uYQMBloWir5K" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2025/01/03/android%E6%8F%90%E9%97%AE200%E9%81%93/" title="Android提问问答"><img class="cover" src="https://smms.app/image/tPiv5zLXgsfGWmn" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android提问问答</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/65582252c458853aeff7c6f5.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">无泪真伤</div><div class="author-info__description">找寻自己所爱！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wuleizhenshang"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本人并非什么大佬！写博客纯属个人兴趣，记录一下个人学习经历而已，有错误请见谅！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">第一章 四大组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">介绍一下四大组件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity"><span class="toc-number">1.2.</span> <span class="toc-text">Activity</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.2.2.</span> <span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">启动过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">启动模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98-%E6%81%A2%E5%A4%8D"><span class="toc-number">1.2.5.</span> <span class="toc-text">状态保存 &amp; 恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service"><span class="toc-number">1.3.</span> <span class="toc-text">Service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">启动方式 &amp; 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88Service-%E4%B8%8E-Thread-%E5%AF%B9%E6%AF%94%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">适用场景（Service 与 Thread 对比）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-%E5%88%86%E7%B1%BB-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">Service 分类 &amp; 使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntentService"><span class="toc-number">1.3.4.</span> <span class="toc-text">IntentService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E5%92%8CActivity-%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.5.</span> <span class="toc-text">Service和Activity 通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ContentProvider"><span class="toc-number">1.4.</span> <span class="toc-text">ContentProvider</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BroadcastReceiver"><span class="toc-number">1.5.</span> <span class="toc-text">BroadcastReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">1.5.1.</span> <span class="toc-text">描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">注册方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%8F%91%E9%80%81-%E6%8E%A5%E5%8F%97-%E5%B1%8F%E8%94%BD-%E5%B9%BF%E6%92%AD"><span class="toc-number">1.5.4.</span> <span class="toc-text">使用方式：发送\接受\屏蔽 广播</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context"><span class="toc-number">1.6.</span> <span class="toc-text">Context</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">理解 &amp; 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB-1"><span class="toc-number">1.6.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">1.6.3.</span> <span class="toc-text">内存泄露</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Intent"><span class="toc-number">1.7.</span> <span class="toc-text">Intent</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E8%A6%81%E5%AE%8C%E6%88%90%E7%9A%84%E5%8A%A8%E4%BD%9C"><span class="toc-number">1.7.1.</span> <span class="toc-text">指定当前组件要完成的动作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.2.</span> <span class="toc-text">传递数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Application"><span class="toc-number">1.8.</span> <span class="toc-text">Application</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-Fragment"><span class="toc-number">2.</span> <span class="toc-text">第二章 Fragment</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-%E2%80%9C%E7%AC%AC%E4%BA%94%E7%BB%84%E4%BB%B6%E2%80%9D"><span class="toc-number">2.1.</span> <span class="toc-text">理解 &amp; “第五组件”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1"><span class="toc-number">2.2.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-Fragment%E5%8A%A0%E8%BD%BD%E5%88%B0Activity%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">使用方式 &#x2F; Fragment加载到Activity的两种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">切换方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%88%E7%BB%93%E5%90%88-ViewPager%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">懒加载（结合 ViewPager）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fragment-%E5%9B%9E%E9%80%80%E6%A0%88%EF%BC%88%E7%BB%93%E5%90%88replace%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">Fragment 回退栈（结合replace）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fragment-%E4%B8%8E-Activity-%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.7.</span> <span class="toc-text">Fragment 与 Activity 通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%87%E8%A7%81%E7%9A%84%E5%9D%91"><span class="toc-number">2.8.</span> <span class="toc-text">遇见的坑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%98%E5%82%A8"><span class="toc-number">3.</span> <span class="toc-text">第三章 存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96-%E6%95%B0%E6%8D%AE%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">数据持久化 &#x2F; 数据本地存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SharedPreferences"><span class="toc-number">3.1.1.</span> <span class="toc-text">SharedPreferences</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text">文件存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLite"><span class="toc-number">3.1.3.</span> <span class="toc-text">SQLite</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E3%80%81%E5%8A%A8%E7%94%BB"><span class="toc-number">4.</span> <span class="toc-text">第四章 自定义组件、动画</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89View"><span class="toc-number">4.1.</span> <span class="toc-text">自定义View</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity%E3%80%81PhoneWindow%E3%80%81DecorView%E3%80%81ViewRoot"><span class="toc-number">4.1.1.</span> <span class="toc-text">Activity、PhoneWindow、DecorView、ViewRoot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">View绘制流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89View-1"><span class="toc-number">4.1.3.</span> <span class="toc-text">自定义View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View%E5%88%B7%E6%96%B0-%E9%87%8D%E7%BB%98%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.4.</span> <span class="toc-text">View刷新&#x2F;重绘机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.</span> <span class="toc-text">View的事件分发机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Touch%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92-%E6%8B%A6%E6%88%AA%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.1.</span> <span class="toc-text">Touch事件的传递 &amp; 拦截机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E4%B8%AD%E7%9A%84onTouch%E3%80%81onTouchEvent-%EF%BC%88%E5%92%8ConClick%EF%BC%89-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%8F%88%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">4.2.2.</span> <span class="toc-text">事件分发中的onTouch、onTouchEvent （和onClick） 有什么区别，又该如何使用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB"><span class="toc-number">4.3.</span> <span class="toc-text">动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%8D%E7%B1%BB-%E7%89%B9%E7%82%B9-%E5%8C%BA%E5%88%AB-%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.1.</span> <span class="toc-text">种类 &amp; 特点 &amp; 区别 &amp;原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">4.3.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">4.3.3.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.4.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B0%E5%80%BC%E5%99%A8"><span class="toc-number">4.3.5.</span> <span class="toc-text">估值器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ListView-RecycleView"><span class="toc-number">4.4.</span> <span class="toc-text">ListView &amp; RecycleView</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ListView-%E5%AE%9A%E4%B9%89-%E5%8E%9F%E7%90%86-%E4%BC%98%E5%8C%96-%E5%B0%81%E8%A3%85%EF%BC%9F"><span class="toc-number">4.4.1.</span> <span class="toc-text">ListView 定义 &amp; 原理 &amp; 优化 &amp; 封装？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RecycleView-%E5%AF%B9%E6%AF%94-%E5%BA%94%E7%94%A8"><span class="toc-number">4.4.2.</span> <span class="toc-text">RecycleView 对比 &amp; 应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PopupWindow-Dialog"><span class="toc-number">4.5.</span> <span class="toc-text">PopupWindow &amp; Dialog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PopupWindow"><span class="toc-number">4.5.1.</span> <span class="toc-text">PopupWindow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dialog"><span class="toc-number">4.5.2.</span> <span class="toc-text">Dialog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PopupWindow-Dialog-%E5%8C%BA%E5%88%AB"><span class="toc-number">4.5.3.</span> <span class="toc-text">PopupWindow &amp; Dialog 区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BD%91%E7%BB%9C-%E4%B9%8B-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">5.</span> <span class="toc-text">第五章 网络 之 计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">计算机体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%E3%80%81%E7%BB%84%E6%88%90%E4%B8%8E%E5%8A%9F%E8%83%BD"><span class="toc-number">5.1.1.</span> <span class="toc-text">计算机网络概念、组成与功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%88%E5%90%84%E5%B1%82%E5%8A%9F%E8%83%BD%EF%BC%89"><span class="toc-number">5.1.2.</span> <span class="toc-text">计算机网络分层结构（各层功能）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ISO-OSI-7%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%88%E6%9D%83%E5%A8%81%EF%BC%89"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">ISO&#x2F;OSI 7层模型（权威）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-IP-4%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%AE%9E%E7%94%A8%EF%BC%89"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">TCP&#x2F;IP 4层模型（实用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%88%E6%8A%98%E4%B8%AD%EF%BC%89"><span class="toc-number">5.1.2.3.</span> <span class="toc-text">5层模型（折中）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">5.2.</span> <span class="toc-text">一. 物理层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">5.3.</span> <span class="toc-text">二. 数据链路层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">5.3.1.</span> <span class="toc-text">基本功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">封装成帧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">透明传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">差错检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">5.3.2.</span> <span class="toc-text">相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">局域网</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">以太网</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MAC%E5%9C%B0%E5%9D%80"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">MAC地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">5.3.2.4.</span> <span class="toc-text">交换机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">5.4.</span> <span class="toc-text">三. 网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%9E%84%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94%EF%BC%88%E4%BA%92%E8%81%94%E7%BD%91%EF%BC%89"><span class="toc-number">5.4.1.</span> <span class="toc-text">异构网络互联（互联网）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9-%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91"><span class="toc-number">5.4.2.</span> <span class="toc-text">路由选择 &amp; 分组转发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%A1%A8"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">路由表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%9B%AE%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%8F%B7%E5%88%B6%E4%BD%9C%E8%B7%AF%E7%94%B1%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8MAC%E5%9C%B0%E5%9D%80-%E5%AF%BB%E5%9D%80%EF%BC%9F"><span class="toc-number">5.4.2.1.1.</span> <span class="toc-text">为什么不用目的主机号制作路由表 &#x2F; 为什么不直接用MAC地址&#x2F;寻址？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.2.1.2.</span> <span class="toc-text">内部结构 &#x2F; 工作原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E7%AE%97%E6%B3%95"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">分组转发算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4-IPv6"><span class="toc-number">5.4.3.</span> <span class="toc-text">IPv4 &amp; IPv6</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">IP数据报格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">IP地址编址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5-1981%EF%BC%9A%E5%88%86%E7%B1%BBIP%E5%9C%B0%E5%9D%80%EF%BC%882%E7%BA%A7%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">5.4.3.2.1.</span> <span class="toc-text">第一阶段 1981：分类IP地址（2级结构）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-1985%EF%BC%9A%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%EF%BC%883%E7%BA%A7%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">5.4.3.2.2.</span> <span class="toc-text">第二阶段 1985：子网划分（3级结构）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5-1987%EF%BC%9ACIDR%EF%BC%88%E6%97%A0%E5%88%86%E7%B1%BB-%E7%BD%91%E7%BB%9C%E5%89%8D%E7%BC%80%EF%BC%89"><span class="toc-number">5.4.3.2.3.</span> <span class="toc-text">第三阶段 1987：CIDR（无分类 &#x2F; 网络前缀）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5-1994%EF%BC%9ANAT%EF%BC%88%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">5.4.3.2.4.</span> <span class="toc-text">第四阶段 1994：NAT（地址转换）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.4.4.</span> <span class="toc-text">相关协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%EF%BC%88Adress-Resolution-Protocol%EF%BC%89"><span class="toc-number">5.4.4.1.</span> <span class="toc-text">ARP 地址解析协议（Adress Resolution Protocol）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DHCP-%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE%EF%BC%88Dynamic-Host-Configuration-Protocol%EF%BC%89"><span class="toc-number">5.4.4.2.</span> <span class="toc-text">DHCP 动态主机设置协议（Dynamic Host Configuration Protocol）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ICMP-%E7%BD%91%E7%BB%9C%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE%EF%BC%88Internet-Control-Message-Protocol%EF%BC%89"><span class="toc-number">5.4.4.3.</span> <span class="toc-text">ICMP 网络控制报文协议（Internet Control Message Protocol）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VPN-%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91"><span class="toc-number">5.4.4.4.</span> <span class="toc-text">VPN 虚拟专用网</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.4.5.</span> <span class="toc-text">路由协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEIGP%EF%BC%88RIP%E3%80%81OSPF%EF%BC%89"><span class="toc-number">5.4.5.1.</span> <span class="toc-text">内部网关协议IGP（RIP、OSPF）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEEGP%EF%BC%88BGP%EF%BC%89"><span class="toc-number">5.4.5.2.</span> <span class="toc-text">外部网关协议EGP（BGP）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E5%A4%87%EF%BC%9A%E8%B7%AF%E7%94%B1%E5%99%A8"><span class="toc-number">5.4.6.</span> <span class="toc-text">网络层设备：路由器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">5.5.</span> <span class="toc-text">四. 传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AF%BB%E5%9D%80-%E7%AB%AF%E5%8F%A3"><span class="toc-number">5.5.1.</span> <span class="toc-text">传输层寻址 &amp;&amp; 端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-UDP"><span class="toc-number">5.5.2.</span> <span class="toc-text">TCP &amp;&amp; UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-UDP-%E7%89%B9%E7%82%B9"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">TCP&#x2F;UDP 特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.5.2.2.</span> <span class="toc-text">首部格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">5.5.2.3.</span> <span class="toc-text">三次握手 &amp; 四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">5.5.2.4.</span> <span class="toc-text">TCP可靠传输</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">5.5.2.4.1.</span> <span class="toc-text">超时重传</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">5.5.2.4.2.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">5.5.2.4.3.</span> <span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">5.5.2.4.4.</span> <span class="toc-text">拥塞控制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">5.6.</span> <span class="toc-text">五. 应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.6.1.</span> <span class="toc-text">网络应用模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-S%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89%E6%96%B9%E5%BC%8F"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">C&#x2F;S（客户端&#x2F;服务器）方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P2P%EF%BC%88peer-to-peer-%E5%AF%B9%E7%AD%89%EF%BC%89%E6%96%B9%E5%BC%8F"><span class="toc-number">5.6.1.2.</span> <span class="toc-text">P2P（peer to peer 对等）方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE-1"><span class="toc-number">5.6.2.</span> <span class="toc-text">相关协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.6.2.1.</span> <span class="toc-text">DNS系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FTP"><span class="toc-number">5.6.2.2.</span> <span class="toc-text">FTP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%EF%BC%88SMTP%E3%80%81POP3%E3%80%81IMAP%EF%BC%89"><span class="toc-number">5.6.2.3.</span> <span class="toc-text">电子邮件（SMTP、POP3、IMAP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WWW%EF%BC%88HTTP%EF%BC%89"><span class="toc-number">5.6.2.4.</span> <span class="toc-text">WWW（HTTP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Telent"><span class="toc-number">5.6.2.5.</span> <span class="toc-text">Telent</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95"><span class="toc-number">5.7.</span> <span class="toc-text">面试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MAC-IP%E5%9C%B0%E5%9D%80-%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">5.7.1.</span> <span class="toc-text">MAC &#x2F; IP地址 &amp; 作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E6%AC%A1%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AAurl%E7%BD%91%E5%9D%80%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.7.2.</span> <span class="toc-text">描述一次网络请求的流程&#x2F;浏览器访问一个url网址所经历的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDNS%EF%BC%9F%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">5.7.3.</span> <span class="toc-text">什么是DNS？作用是什么？工作机制？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BD%91%E7%BB%9C-%E4%B9%8B-TCP-IP"><span class="toc-number">6.</span> <span class="toc-text">第五章 网络 之 TCP&#x2F;IP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-number">6.1.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTCP%E5%8D%8F%E8%AE%AE%EF%BC%9FUDP%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.1.1.</span> <span class="toc-text">什么是TCP协议？UDP协议？它们的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BTCP-IP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%85%B7%E4%BD%93%E7%BB%86%E8%8A%82%EF%BC%9F"><span class="toc-number">6.1.2.</span> <span class="toc-text">说一下TCP&#x2F;IP三次握手，四次挥手的具体细节？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">6.2.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BHTTP%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">6.2.1.</span> <span class="toc-text">描述一下HTTP协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%EF%BC%9F"><span class="toc-number">6.2.2.</span> <span class="toc-text">HTTP请求&#x2F;响应报文？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%EF%BC%89"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">HTTP方法？（请求报文）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%EF%BC%9APOST%E4%B8%8EGET%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.2.2.1.1.</span> <span class="toc-text">面试：POST与GET区别？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F%EF%BC%88%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%EF%BC%89"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">HTTP状态码？（响应报文）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E9%A6%96%E9%83%A8%EF%BC%9F%EF%BC%88%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%B8%B8%E7%94%A8%E5%AD%97%E6%AE%B5%EF%BC%89"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">HTTP首部？（请求 &amp; 响应首部常用字段）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">6.2.3.</span> <span class="toc-text">HTTP 缓存机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%9Acookie-session"><span class="toc-number">6.2.4.</span> <span class="toc-text">浏览器缓存机制：cookie&#x2F;session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-0-HTTP1-x-HTTP2-0%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.2.5.</span> <span class="toc-text">HTTP1.0 &amp; HTTP1.x &amp; HTTP2.0区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS"><span class="toc-number">6.3.</span> <span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BHTTPS%EF%BC%9F"><span class="toc-number">6.3.1.</span> <span class="toc-text">描述一下HTTPS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%BF%9E%E6%8E%A5-%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">6.3.2.</span> <span class="toc-text">HTTPS 工作原理 &#x2F; 连接 &amp; 通信过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E4%B8%8EHTTP%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.3.3.</span> <span class="toc-text">HTTPS与HTTP区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9F"><span class="toc-number">6.3.4.</span> <span class="toc-text">对称加密 &amp; 非对称加密？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket"><span class="toc-number">6.4.</span> <span class="toc-text">Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BSocket"><span class="toc-number">6.4.1.</span> <span class="toc-text">描述一下Socket?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B-%E5%8E%9F%E7%90%86-%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">6.4.2.</span> <span class="toc-text">Socket 通信模型 &#x2F; 原理 &#x2F; 连接过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">6.4.3.</span> <span class="toc-text">Socket 使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BWebSocket%EF%BC%9F"><span class="toc-number">6.4.4.</span> <span class="toc-text">描述一下WebSocket？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-WebSocket-HTTP-%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="toc-number">6.4.5.</span> <span class="toc-text">Socket &amp; WebSocket &amp; HTTP 对比？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.5.</span> <span class="toc-text">数据传输格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">6.5.1.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON%E3%80%81XML-%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.2.</span> <span class="toc-text">JSON、XML 解析方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Andorid-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-number">6.6.</span> <span class="toc-text">Andorid 网络基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HttpClient-HttpURLConnection"><span class="toc-number">6.6.1.</span> <span class="toc-text">HttpClient &amp; HttpURLConnection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93"><span class="toc-number">6.6.2.</span> <span class="toc-text">常见网络框架总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BD%91%E7%BB%9C-%E4%B9%8B-Android%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86-%E6%A1%86%E6%9E%B6"><span class="toc-number">7.</span> <span class="toc-text">第五章 网络 之 Android网络知识&amp;框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89HttpClient%E5%92%8CHttpURLConnection%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.</span> <span class="toc-text">（一）HttpClient和HttpURLConnection的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89Volley%EF%BC%8COkHttp%EF%BC%8CRetrofit%EF%BC%88%E4%B8%89%E5%A4%A7%E5%B8%B8%E7%94%A8Android%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%EF%BC%89%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.2.</span> <span class="toc-text">（二）Volley，OkHttp，Retrofit（三大常用Android网络框架）之间的区别和核心原理和使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%EF%BC%8Cokhttp%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E7%9A%84%EF%BC%9F"><span class="toc-number">7.3.</span> <span class="toc-text">（三）网络请求缓存处理，okhttp如何处理网络缓存的？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE%E7%89%87"><span class="toc-number">8.</span> <span class="toc-text">第六章 图片</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bitmap"><span class="toc-number">8.1.</span> <span class="toc-text">Bitmap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmap-%E7%AE%80%E4%BB%8B"><span class="toc-number">8.1.1.</span> <span class="toc-text">Bitmap 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmap-%E5%AF%BC%E8%87%B4OOM-%E5%8E%9F%E5%9B%A0-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">8.1.2.</span> <span class="toc-text">Bitmap 导致OOM 原因 &amp; 性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmap-%E5%8E%8B%E7%BC%A9%E7%AD%96%E7%95%A5"><span class="toc-number">8.1.3.</span> <span class="toc-text">Bitmap 压缩策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%9B%BE%E5%8A%A0%E8%BD%BD%EF%BC%9A%E4%BB%8E%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AA10M%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%8C%E8%AF%B4%E4%B8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">大图加载：从网络加载一个10M的图片，说下注意事项？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">说一下三级缓存的原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LruCache-DiskLruCache%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">8.4.</span> <span class="toc-text">LruCache &amp; DiskLruCache原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">如果让你设计一个图片加载库，你会如何设计？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%B8%83%E5%B1%80"><span class="toc-number">9.</span> <span class="toc-text">第七章 布局</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B1%80"><span class="toc-number">9.1.</span> <span class="toc-text">布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E5%A4%A7%E5%B8%83%E5%B1%80-%E7%89%B9%E7%82%B9"><span class="toc-number">9.1.1.</span> <span class="toc-text">六大布局 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80"><span class="toc-number">9.1.2.</span> <span class="toc-text">约束布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinearLayout%EF%BC%8CRelativeLayout%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">9.1.3.</span> <span class="toc-text">LinearLayout，RelativeLayout性能对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%B8%83%E5%B1%80%E6%B7%B1%E5%BA%A6"><span class="toc-number">9.1.4.</span> <span class="toc-text">检测布局深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96"><span class="toc-number">9.1.5.</span> <span class="toc-text">布局优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#include%E3%80%81merge%E3%80%81ViewStub%E6%A0%87%E7%AD%BE"><span class="toc-number">9.1.5.1.</span> <span class="toc-text">include、merge、ViewStub标签</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95-1"><span class="toc-number">9.2.</span> <span class="toc-text">面试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E5%88%B0%E6%8E%A7%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E5%90%97%EF%BC%9F%EF%BC%88Android%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%89"><span class="toc-number">9.2.1.</span> <span class="toc-text">你知道布局文件到控件对象的过程吗？（Android布局文件映射源码分析）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">第八章 性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">10.1.</span> <span class="toc-text">内存优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ANR-CRASH-%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">10.1.1.</span> <span class="toc-text">ANR &amp; CRASH 产生的原因是什么？如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%EF%BC%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">10.1.2.</span> <span class="toc-text">内存溢出 &amp; 内存泄漏 &amp; 内存抖动 是什么？产生原因？解决方案？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmap%E4%BC%98%E5%8C%96-%E5%8E%9F%E5%9B%A0-%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">10.1.3.</span> <span class="toc-text">Bitmap优化 原因 &amp; 方案？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C%EF%BC%9F"><span class="toc-number">10.1.4.</span> <span class="toc-text">谈谈你项目中内存优化的一些经验？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96"><span class="toc-number">10.2.</span> <span class="toc-text">启动优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%B7%E5%90%AF%E5%8A%A8-%E7%83%AD%E5%90%AF%E5%8A%A8%EF%BC%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%90%AF%E5%8A%A8%EF%BC%9F"><span class="toc-number">10.2.1.</span> <span class="toc-text">什么是冷启动 &amp; 热启动？启动流程？如何优化启动？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96-1"><span class="toc-number">10.3.</span> <span class="toc-text">布局优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">10.3.1.</span> <span class="toc-text">你知道哪些布局优化的方案？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-JNI"><span class="toc-number">11.</span> <span class="toc-text">第九章 JNI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JNI"><span class="toc-number">11.1.</span> <span class="toc-text">JNI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI-NDK"><span class="toc-number">11.1.1.</span> <span class="toc-text">JNI &amp; NDK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI-%E5%8E%9F%E7%90%86-%E2%80%94%E2%80%94-%E4%B8%BA%E4%BB%80%E4%B9%88java%E8%83%BD%E5%A4%9F%E8%B0%83%E7%94%A8c-c-%E5%87%BD%E6%95%B0"><span class="toc-number">11.1.2.</span> <span class="toc-text">JNI 原理 —— 为什么java能够调用c&#x2F;c++函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">11.1.3.</span> <span class="toc-text">JNI如何实现数据传递？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%94%A8JNI%E5%AE%9E%E7%8E%B0%E8%BF%87%E4%BB%80%E4%B9%88%E5%8A%9F%E8%83%BD%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">11.1.4.</span> <span class="toc-text">你用JNI实现过什么功能吗？怎么实现的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">第十章 线程 &#x2F; 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%EF%BC%88Thread-Runnable%EF%BC%89"><span class="toc-number">12.1.</span> <span class="toc-text">基本线程实现（Thread &amp; Runnable）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88ThreadPoolExecutor%EF%BC%89"><span class="toc-number">12.2.</span> <span class="toc-text">线程池（ThreadPoolExecutor）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-%E4%BC%98%E5%8A%BF"><span class="toc-number">12.2.1.</span> <span class="toc-text">简介 &amp; 优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-2"><span class="toc-number">12.2.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">12.2.3.</span> <span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AsyncTask"><span class="toc-number">12.3.</span> <span class="toc-text">AsyncTask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">12.3.1.</span> <span class="toc-text">是什么？能解决什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8-%E5%9B%9B%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9F%E6%AF%8F%E4%B8%AA%E6%96%B9%E6%B3%95%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">12.3.2.</span> <span class="toc-text">三个泛型参数作用 &amp; 四个方法？每个方法在哪个线程执行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">12.3.3.</span> <span class="toc-text">实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">12.3.4.</span> <span class="toc-text">不足之处 &amp; 解决方法？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler"><span class="toc-number">12.4.</span> <span class="toc-text">Handler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%80%E5%AE%9A%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%96%B0UI%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88Android%E7%B3%BB%E7%BB%9F%E4%B8%8D%E5%BB%BA%E8%AE%AE%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AEUI%EF%BC%9F"><span class="toc-number">12.4.1.</span> <span class="toc-text">子线程一定不能更新UI吗？为什么Android系统不建议子线程访问UI？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-%E4%BD%9C%E7%94%A8-%E5%85%AD%E5%A4%A7%E6%A6%82%E5%BF%B5"><span class="toc-number">12.4.2.</span> <span class="toc-text">定义 &amp; 作用 &amp; 六大概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-3"><span class="toc-number">12.4.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%EF%BC%88%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%89"><span class="toc-number">12.4.4.</span> <span class="toc-text">Android 消息机制（工作原理 &amp; 源码分析）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">12.4.5.</span> <span class="toc-text">内存泄露 &amp; 解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95-2"><span class="toc-number">12.4.6.</span> <span class="toc-text">面试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HandlerThread"><span class="toc-number">12.5.</span> <span class="toc-text">HandlerThread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">12.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="toc-number">12.5.2.</span> <span class="toc-text">具体使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">12.5.3.</span> <span class="toc-text">工作原理 &amp; 源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPC"><span class="toc-number">12.6.</span> <span class="toc-text">IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IPC-%E6%A6%82%E8%BF%B0%EF%BC%9F"><span class="toc-number">12.6.1.</span> <span class="toc-text">IPC 概述？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binder%E6%9C%BA%E5%88%B6-%E7%AE%80%E4%BB%8B-%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">12.6.2.</span> <span class="toc-text">Binder机制 简介 &amp; 原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAIDL-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8AIDL%EF%BC%9FAIDL%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E7%BB%93%E5%90%88Binder%EF%BC%89%EF%BC%9F"><span class="toc-number">12.6.3.</span> <span class="toc-text">什么是AIDL?如何使用AIDL？AIDL工作原理（结合Binder）？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-WebView"><span class="toc-number">13.</span> <span class="toc-text">第十一章 WebView</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WebView"><span class="toc-number">13.1.</span> <span class="toc-text">WebView</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hybird-%E5%BC%80%E5%8F%91"><span class="toc-number">13.1.1.</span> <span class="toc-text">Hybird 开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebView-%E6%98%AF%E4%BB%80%E4%B9%88-%E4%BD%9C%E7%94%A8-%E5%86%85%E6%A0%B8"><span class="toc-number">13.1.2.</span> <span class="toc-text">WebView 是什么 &amp; 作用 &amp; 内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebView-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">13.1.3.</span> <span class="toc-text">WebView 基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSettings-WebViewClient-WebChromeClient"><span class="toc-number">13.1.3.1.</span> <span class="toc-text">WebSettings &amp; WebViewClient &amp; WebChromeClient</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">13.1.3.2.</span> <span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebView-%E4%B8%8E-JS-%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F"><span class="toc-number">13.1.4.</span> <span class="toc-text">WebView 与 JS 交互方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebView-%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-%E5%8E%9F%E5%9B%A0-%E8%A7%A3%E5%86%B3"><span class="toc-number">13.1.5.</span> <span class="toc-text">WebView 导致内存泄露 原因 &amp; 解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebView-%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88-%E6%A1%86%E6%9E%B6"><span class="toc-number">13.1.6.</span> <span class="toc-text">WebView 优化方案 &amp; 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AFH5%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%88WebView-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">13.1.6.1.</span> <span class="toc-text">前端H5的缓存机制（WebView 缓存机制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">13.1.6.2.</span> <span class="toc-text">资源预加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E8%BA%AB%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98"><span class="toc-number">13.1.6.3.</span> <span class="toc-text">自身构建缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hybird-%E6%A1%86%E6%9E%B6"><span class="toc-number">13.1.7.</span> <span class="toc-text">Hybird 框架</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-Android%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81"><span class="toc-number">14.</span> <span class="toc-text">第十二章 Android第三方库源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EventBus"><span class="toc-number">14.1.</span> <span class="toc-text">EventBus</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EventBus%E7%90%86%E8%A7%A3"><span class="toc-number">14.1.1.</span> <span class="toc-text">EventBus理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventBus%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">14.1.2.</span> <span class="toc-text">EventBus源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventBus%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98"><span class="toc-number">14.1.3.</span> <span class="toc-text">EventBus项目实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#okHttp"><span class="toc-number">14.2.</span> <span class="toc-text">okHttp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">14.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-4"><span class="toc-number">14.2.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="toc-number">14.2.3.</span> <span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">14.2.3.1.</span> <span class="toc-text">源码解读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">14.2.3.2.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">14.2.3.3.</span> <span class="toc-text">设计模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">14.2.4.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">14.2.5.</span> <span class="toc-text">网络框架对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Glide"><span class="toc-number">14.3.</span> <span class="toc-text">Glide</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">14.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-5"><span class="toc-number">14.3.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E9%9D%9E%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">14.3.3.</span> <span class="toc-text">工作原理（非重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">14.3.4.</span> <span class="toc-text">图片加载框架对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB"><span class="toc-number">15.</span> <span class="toc-text">第十三章 杂七杂八</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB"><span class="toc-number">15.1.</span> <span class="toc-text">进程保活</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5-%E5%8F%8A-%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">15.1.1.</span> <span class="toc-text">Android进程回收策略 及 进程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E6%96%B9%E6%A1%88"><span class="toc-number">15.1.2.</span> <span class="toc-text">进程保活方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%8D%E8%A2%AB%E6%9D%80%E6%AD%BB"><span class="toc-number">15.1.3.</span> <span class="toc-text">Service如何保持不被杀死</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D"><span class="toc-number">15.2.</span> <span class="toc-text">屏幕适配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E7%94%9F%E5%BC%80%E5%8F%91"><span class="toc-number">15.3.</span> <span class="toc-text">混生开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Native%E3%80%81weex%E3%80%81Flutter-%EF%BC%9F%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="toc-number">15.3.1.</span> <span class="toc-text">React Native、weex、Flutter ？对比？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%B7%E6%AD%8C%E6%96%B0%E5%87%BA%E7%9A%84%E5%AE%98%E6%96%B9%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80Kotlin%E4%BA%86%E8%A7%A3%E5%90%97-%E5%92%8CJava%E7%9B%B8%E6%AF%94%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%E3%80%82"><span class="toc-number">15.3.2.</span> <span class="toc-text">谷歌新出的官方开发语言Kotlin了解吗 &amp; 和Java相比它有哪些特点。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReactNative-%E5%92%8C-Android-%E5%A6%82%E4%BD%95%E4%BA%A4%E4%BA%92%EF%BC%9F"><span class="toc-number">15.3.3.</span> <span class="toc-text">ReactNative 和 Android 如何交互？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAAPP%E4%BB%8E%E5%90%AF%E5%8A%A8%E5%88%B0%E4%B8%BB%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">15.4.</span> <span class="toc-text">一个APP从启动到主页面显示经历了哪些过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APP-%E6%8E%A8%E9%80%81"><span class="toc-number">15.5.</span> <span class="toc-text">APP 推送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">15.6.</span> <span class="toc-text">Android 虚拟机及编译过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">15.6.1.</span> <span class="toc-text">Dalvik虚拟机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8EDalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.6.2.</span> <span class="toc-text">ART虚拟机与Dalvik虚拟机的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-APK-%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B"><span class="toc-number">15.6.3.</span> <span class="toc-text">Android APK 编译打包流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-dex%E5%88%86%E5%8C%85%E6%96%B9%E6%A1%88%E5%92%8C%E7%83%AD%E8%A1%A5%E4%B8%81%E5%8E%9F%E7%90%86"><span class="toc-number">15.7.</span> <span class="toc-text">Android dex分包方案和热补丁原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-dex%E6%96%87%E4%BB%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8DexLoader"><span class="toc-number">15.7.1.</span> <span class="toc-text">Android dex文件 &amp; 类加载器DexLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dex%E5%88%86%E5%8C%85%E6%96%B9%E6%A1%88"><span class="toc-number">15.7.2.</span> <span class="toc-text">dex分包方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E8%A1%A5%E4%B8%81"><span class="toc-number">15.7.3.</span> <span class="toc-text">热补丁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-%E6%8F%92%E4%BB%B6%E5%8C%96"><span class="toc-number">15.8.</span> <span class="toc-text">Android 插件化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-MVP%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.9.</span> <span class="toc-text">Android MVP模式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/03/android%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/" title="Android知识秘籍"><img src="https://smms.app/image/gw4uYQMBloWir5K" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android知识秘籍"/></a><div class="content"><a class="title" href="/2025/01/03/android%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/" title="Android知识秘籍">Android知识秘籍</a><time datetime="2025-01-03T12:19:51.000Z" title="发表于 2025-01-03 20:19:51">2025-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/03/android%E6%8F%90%E9%97%AE200%E9%81%93/" title="Android提问问答"><img src="https://smms.app/image/tPiv5zLXgsfGWmn" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android提问问答"/></a><div class="content"><a class="title" href="/2025/01/03/android%E6%8F%90%E9%97%AE200%E9%81%93/" title="Android提问问答">Android提问问答</a><time datetime="2025-01-03T12:19:12.000Z" title="发表于 2025-01-03 20:19:12">2025-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/" title="程序员面试金典（Java代码）"><img src="https://pic.imgdb.cn/item/67487ddcd0e0a243d4da7860.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="程序员面试金典（Java代码）"/></a><div class="content"><a class="title" href="/2024/11/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/" title="程序员面试金典（Java代码）">程序员面试金典（Java代码）</a><time datetime="2024-11-28T14:54:00.000Z" title="发表于 2024-11-28 22:54:00">2024-11-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F+7%E7%A7%8D%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="7大设计原则+23种设计模式（Java代码版本）"><img src="https://pic.imgdb.cn/item/673b421bd29ded1a8cbbff29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="7大设计原则+23种设计模式（Java代码版本）"/></a><div class="content"><a class="title" href="/2024/11/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F+7%E7%A7%8D%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="7大设计原则+23种设计模式（Java代码版本）">7大设计原则+23种设计模式（Java代码版本）</a><time datetime="2024-11-18T07:54:00.000Z" title="发表于 2024-11-18 15:54:00">2024-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" title="代码随想录学习记录"><img src="https://s2.loli.net/2024/09/16/rdv2wuJ17ghb3Qj.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码随想录学习记录"/></a><div class="content"><a class="title" href="/2024/09/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" title="代码随想录学习记录">代码随想录学习记录</a><time datetime="2024-09-16T07:54:00.000Z" title="发表于 2024-09-16 15:54:00">2024-09-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By 无泪真伤</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog! --by Wuleizhenshang</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false#  open shake (抖動特效);
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小白个人Android面试准备</title>
      <link href="/2024/02/28/%E5%87%86%E5%A4%87/"/>
      <url>/2024/02/28/%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="整体知识框架"><a href="#整体知识框架" class="headerlink" title="整体知识框架"></a>整体知识框架</h2><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403041613838.png"></p><h2 id="Java知识"><a href="#Java知识" class="headerlink" title="Java知识"></a>Java知识</h2><h3 id="Temp"><a href="#Temp" class="headerlink" title="Temp"></a>Temp</h3><p>static：是静态的意思；</p><p>final：是最后的意思；</p><p>区别：</p><p>1.final可以修饰类，方法和变量，但是static只能修饰方法和变量；</p><p>2.final可以修饰全局变量和局部变量，但是static只能修饰全局变量，不能修饰局部变量；</p><p>3.final不可以修饰代码块，但是static可以修饰代码块。</p><p><a href="https://blog.csdn.net/weixin_43826242/article/details/105405434">static与final的区别_static和final的区别-CSDN博客</a></p><p><a href="https://blog.csdn.net/xuxiao1991101/article/details/51434195">作用域public&#x2F;private&#x2F;protected的具体区别_public protected private的作用域-CSDN博客</a></p><p><strong>泛型</strong></p><p>Java的泛型符号的名称不要求，个数也不要求，一般有T type，E element，K key，V value，Java的泛型是一个占位符，先给引用类型进行占位，泛型符号可以应用在类的声明处、接口声明、方法的声明</p><p><strong>泛型类</strong></p><p><code>ArrayList&lt;E&gt;</code>和<code>HashMap&lt;K,V&gt;</code>就是泛型类</p><p>在类中声明了之后就需要在创建类的对象的时候就需要去确定类的声明处定义的泛型的具体类型，如果在构建对象的时候没有去确定类型，那么泛型的类型就是Object类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span>&lt;A,B,C&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="keyword">private</span> C c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestClass</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestClass</span><span class="params">(A a, B b, C c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">getA</span><span class="params">(A a)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定泛型类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里不指定泛型的具体类型就会默认为Object</span></span><br><span class="line">        TestClass&lt;String, String, String&gt; tt = <span class="keyword">new</span> <span class="title class_">TestClass</span>&lt;String, String, String&gt;();</span><br><span class="line">        System.out.println(tt.getA(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型接口</strong></p><p>实现类去确定泛型的具体类型，实现类确定了具体类型后在新建实现类的对象的时候就不需要去指定泛型具体的类型了（是否需要去指定类型就看类名后是否存在泛型符号）；如果实现类没有指定类型就当做Object来看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TT</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TT</span>();</span><br><span class="line">        t.getA(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TT</span> <span class="keyword">implements</span> <span class="title class_">TestInterface</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getA</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TestInterface</span>&lt;A&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getA</span><span class="params">(A a)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类也不确定类型，那么就让实现类也带泛型符号，让创建对象的时候再去确定泛型类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TT1&lt;Integer&gt; tt1 = <span class="keyword">new</span> <span class="title class_">TT1</span>&lt;Integer&gt;();</span><br><span class="line">        tt1.getA(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TT1</span>&lt;A&gt; <span class="keyword">implements</span> <span class="title class_">TestInterface</span>&lt;A&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TestInterface</span>&lt;A&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getA</span><span class="params">(A a)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArrayList&lt;E&gt;</code>和<code>HashMap&lt;K,V&gt;</code>都是实现了接口并且实现接口的时候没有直接确定泛型的类型，而直接带上泛型的符号，让用户新建对象的时候再去确定泛型的类型</p><p><strong>泛型方法</strong></p><p>在方法处可以直接使用泛型的声明符号并且类名处并没有出现泛型符号，并且需要在返回值类型处声明泛型符号，在调用方法处确定泛型类型，当然传参可以使用泛型符号，那么返回值也可以使用泛型符号，静态方法自然也可以使用泛型符号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TTMethod</span> <span class="variable">ttMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TTMethod</span>();</span><br><span class="line">        <span class="comment">//调用方法时，根据实参确定泛型的类型</span></span><br><span class="line">        ttMethod.method(<span class="string">&quot;tt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TTMethod</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">method</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="comment">//需要在返回值前面加上泛型符号声明使用泛型，这个泛型只能在方法的内部进行使用，而不能在方法外部进行使用</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>public static &lt;T&gt; List&lt;T&gt; asList(T t)</code>就是这种样式，并且返回值也是List类型并且里面为T类型</p><p><strong>泛型上下限</strong></p><p>这里有一个抽象类是Animal类，里面有一个抽象方法eat，就是相当于动物去吃什么东西，有一个饲养员的类，里面有一个fed方法就是去为动物，传入<code>List&lt;Animal&gt;</code>类型，那么如果一个集合定义为<code>List&lt;Dog&gt;</code>那么就不能传入Cat类型了，并且传入还会报错，那么这种情况饲养员的类里面的方法就不能写死，可以使用**<code>?通配符</code><strong>，就可以传入任何类型的List，但是这时候会将List里面的对象都当成Object类型来看，那么就应该使用</strong><code>public void feed(List&lt;? extends Animal&gt; animals)&#123;&#125;</code>表示传入的List类型里面的对象是Animal类的子类或本身，这种是泛型的上限确定了，并且下限不确定，往下可以是Animal子类的子类**</p><p><strong><code>pulic void method(List&lt;? super Animals&gt; animals)&#123;&#125;</code>确定下限，需要传的是Animal本身或者父类，这时候就要当做Object来看</strong></p><p><a href="https://blog.csdn.net/i_Popular/article/details/82985404">javaBean的属性为何用private-set-get而不是直接用public？_java bean属性为什么不用public的-CSDN博客</a></p><h3 id="Java特性"><a href="#Java特性" class="headerlink" title="Java特性"></a>Java特性</h3><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><h3 id="JVM和垃圾回收GC"><a href="#JVM和垃圾回收GC" class="headerlink" title="JVM和垃圾回收GC"></a>JVM和垃圾回收GC</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>JVM就是虚拟机，java虚拟机阵营有Sun HotSpot VM、BEA JRockit VM（JDK1.8合并），java虚拟机是采用虚拟化技术，隔离出一块独立的子操作系统，使Java软件不受任何影响在虚拟机内进行执行。</p><p>JVM由三个主要的子系统构成：</p><ul><li><a href="#JVM类加载子系统">类加载子系统</a>：装载具有适合名称的类或接口</li><li>运行时数据区（内存结构）：包含方法区、Java堆、Java栈、本地方法栈、指令计数器及其他隐含寄存器</li><li>执行引擎（解释器）：负责执行包含在已装载的类或接口中的指令，分配给运行时数据区的字节码将由执行引擎执行。执行引擎读取字节码并逐段执行。当一个方法被调用多次，每次都需要重新解释。</li></ul><p><strong>JVM实现了Java的平台无关性</strong></p><p><img src="https://img-blog.csdnimg.cn/2019060512472066.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p>开发人员编写Java代码，并将Java源代码文件（.java文件）通过Java编译器进行编译后形成java字节码文件（.class文件），通过<strong>类加载子系统</strong>加载到<strong>运行时数据区（内存空间）</strong>，再通过<strong>JVM执行引擎</strong>进行执行。</p><p><img src="https://img-blog.csdnimg.cn/201906051252248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p>Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。</p><p>JVM在它的生存周期中有一个明确的任务，那就是运行Java程序，因此当Java程序启动的时候，就产生JVM的一个实例；当程序运行结束的时候，该实例也跟着消失了。</p><p><a id="JVM类加载子系统"></a></p><p><strong>类加载子系统</strong></p><ul><li><p><strong>类的加载</strong></p><p>开发者编写Java代码（.java文件），之后编译成字节码（.class文件），类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p></li><li><p><strong>类生命周期</strong></p><p>类的生命周期包括加载、连接、初始化、使用和卸载：</p><ul><li>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</li><li>连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用</li><li>初始化，为类的静态变量赋予正确的初始值</li><li>使用，new出对象程序中使用</li><li>卸载，执行垃圾回收</li></ul></li><li><p><strong>类加载器</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/20190603164758648.png"></p></li><li><p><strong>类加载机制</strong></p><ul><li><p>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p></li><li><p>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p></li><li><p>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p></li></ul></li></ul><p><strong>JVM内存管理</strong></p><p><strong>下面这些都是运行时区内部的区域，前面是类加载器，后面是执行引擎和本地接口</strong></p><ul><li><p><strong>Java堆（Heap）</strong></p><p>堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有<strong>线程共享</strong>的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的通过new创建的对象实例都在这里分配内存。当对象无法在该空间申请到内存时抛出OutOfMemoryEroor异常。同时也是垃圾收集器管理的主要区域。</p><p>Java的堆内存基于Generation算法（Generational Collector）划分为新生代、年老代和持久代。新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace（Survivor0）和ToSpace（Survivor1）组成。所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。<br>分代收集，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，可以将不同生命周期的对象分代，不同的代采取不同的回收算法进行垃圾回收（GC），以便提高回收效率。</p><ul><li><p>新生代（1&#x2F;3堆空间）</p><p>几乎所有新生成的对象首先都是放在年轻代的。新生代内存按照8:1:1的比例分为一个Eden区和两个Survivor(Survivor0,Survivor1)区。大部分对象在Eden区中生成。当新对象生成，Eden Space申请失败（因为空间不足等），则会发起一次GC(Scavenge GC)。回收时先将Eden区存活对象复制到一个Survivor0区，然后清空Eden区，当这个Survivor0区也存放满了时，则将Eden区和Survivor0区存活对象复制到另一个Survivor1区，然后清空Eden和这个Survivor0区，此时Survivor0区是空的，然后将Survivor0区和Survivor1区交换，即保持Survivor1区为空， 如此往复。当Survivor1区不足以存放 Eden和Survivor0的存活对象时，就将存活对象直接存放到老年代。<strong>当对象在Survivor区躲过一次GC的话，其对象年龄便会加1</strong>，默认情况下，<strong>如果对象年龄达到15岁，就会移动到老年代中。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收</strong>。<strong>新生代大小可以由-Xmn来控制</strong>，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例。</p></li><li><p>老年代（2&#x2F;3堆空间）</p><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象。</p></li><li><p>元数据（直接内存JDK1.8后）</p><p>不属于堆内存，属于内存空间。真正与堆隔离。方法区是类逻辑上的一个抽象模板，而元空间是方法区的实现，是真实存在的内存。</p></li></ul><p><strong>MinorGC（新生代的GC），如果OldGeneration满了就会产生FullGC，新生代和老年代都进行GC</strong></p></li><li><p>方法区（Method Area）</p><p>方法区（Method Area）与Java堆一样，是各个<strong>线程共享</strong>的内存区域，类的所有字段和方法的字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息（构造方法&#x2F;接口定义）+运行时常量池都存在方法区中</p></li><li><p>程序计数器（Program Counter Register）</p><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。他是<strong>线程私有</strong>的。可看做一个指针，指向方法区中的方法字节码（用来存储指向下一跳指令的地址，也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。<br>每个方法在运行时都存储着一个独立的程序计数器，程序计数器是指定程序运行的行数指针。</p></li><li><p>JVM栈（JVM Stacks）</p><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是<strong>线程私有</strong>的，它的生命周期与线程相同。Java栈描述的是Java方法执行的内存模型：一个线程对应一个栈，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。不存在垃圾回收问题，只要线程已结束栈就出栈，生命周期与线程一致。</p></li><li><p>本地方法栈（Native Method Stacks）</p><p><strong>线程私有</strong>，可理解为java中jni调用。用于支持native方法执行，存储了每个native方法调用的状态。本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。执行引擎通过本地方法接口，利用本地方法库（C语言库）执行。</p></li></ul><p><strong>对象分配规则</strong></p><ul><li><p>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</p></li><li><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p></li><li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</p></li><li><p>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p></li><li><p>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</p></li></ul><p><strong>Java代码编译和执行过程</strong></p><p>这个过程包含了3个重要机制：</p><ul><li><p>Java源码编译机制</p><ul><li>分析和输入到符号表</li><li>注解处理</li><li>语义分析和生成class文件（最终class文件由结构数据，元数据，方法信息组成）</li></ul></li><li><p>类加载机制</p></li><li><p>类执行机制</p><p>例子：调用java Math.class，即采用执行引擎去执行Java文件。开启一个进程，其中主线程以main方法为入口执行执行Math类文件。线程在运行时，JVM为每一个线程分配一个独立的java栈，java栈里存储着栈帧，每个栈帧存储着每个方法运行时的局部变量、数据。本例Math.java存储着两个栈帧，一个为指向main方法的栈帧，一个为指向math函数的栈帧。</p></li></ul><h4 id="GC算法-垃圾回收"><a href="#GC算法-垃圾回收" class="headerlink" title="GC算法 垃圾回收"></a>GC算法 垃圾回收</h4><p>垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。 注意：垃圾回收回收的是无任何引用的对象占据的内存空间而不是对象本身。换言之，垃圾回收只会负责释放那些对象占有的内存。对象是个抽象的词，包括引用和其占据的内存空间。当对象没有任何引用时其占据的内存空间随即被收回备用，此时对象也就被销毁。但不能说是回收对象，可以理解为一种文字游戏。<br>引用：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。<br>垃圾：无任何对象引用的对象。<br>回收：清理“垃圾”占用的内存空间而非对象本身。<br>发生地点：一般发生在堆内存中，因为大部分的对象都储存在堆内存中。<br>发生时间：程序空闲时间不定时回收。</p><ul><li><p><strong>对象生命周期</strong></p><ol><li><p>创建阶段</p><p>创建阶段会为对象分配存储空间；开始构造对象；从超类到子类对static成员进行初始化；超类成员变量按照顺序初始化，递归调用超类的构造方法；子类成员变量按照顺序初始化，子类构造方法调用</p><p>一旦对象被创建并分配给某些对象赋值，这个对象的状态就切换到了应用状态</p></li><li><p>应用阶段</p><p>对象至少被一个强引用持有（强引用在后面享学的四种引用部分有写）</p></li><li><p>不可见阶段</p><p>程序本身不持有该对象任何强引用，虽然引用任然存在，这个阶段的对象可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用者持有，这些特殊的强引用称为GC  Root，存在着GC Root会导致对象内存泄露，无法被回收</p></li><li><p>不可达阶段</p><p>该对象不再被任何强引用所持有</p></li><li><p>收集阶段</p><p>当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。（不要重载finalize()方法，这会影响JVM对象分配和回收速度；并且可能造成对象再次复活）</p></li><li><p>终结阶段</p><p>当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收</p></li><li><p>对象空间重新分配阶段</p><p>垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</p></li></ol></li><li><p><strong>判断对象是否是垃圾的算法</strong></p><ol><li><p>引用计数算法</p><p>堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为1。每当有一个地方引用它时，计数器值就加1（a &#x3D; b， b被引用，则b引用的对象计数+1）。当引用失效时（一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时），计数器值就减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。</p></li><li><p>根搜索算法</p><p>首先了解一个概念：根集(Root Set)<br>所谓根集(Root Set)就是正在执行的Java程序可以访问的引用变量（注意：不是对象）的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。 这种算法的基本思路：<br>（1）通过一系列名为“GC Roots”的对象作为起始点，寻找对应的引用节点。<br>（2）找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。<br>（3）重复（2）。<br>（4）搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。<br><strong>Java和C#中都是采用根搜索算法来判定对象是否存活的。</strong></p></li></ol></li><li><p><strong>GC算法</strong></p><ol><li><p>标记清除算法</p><p>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</p><p>标记从树根可达的对象，清除（清楚不可达的对象）。标记清除的时候有停止程序运行，如果不停止，此时如果存在新产生的对象，这个对象是树根可达的，但是没有被标记（标记已经完成了），会清除掉。</p><p>递归性能低，释放空间不连续容易导致内存碎片，会导致整个程序停止运行。</p></li><li><p>复制算法</p><p>把内存分成两块区域：空闲区域和活动区域，第一还是标记（标记谁是可达的对象），标记之后把可达的对象复制到空闲区，将空闲区变成活动区，同时把以前活动区对象1，4清除掉，变成空闲区。</p><p>速度快但耗费空间，假定活动区域全部是活动对象，这个时候进行交换的时候就相当于多占用了一倍空间，但是没啥用。</p></li><li><p>标记压缩算法</p><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存<br>分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p></li></ol><p><strong>JVM采用的垃圾回收分代算法</strong></p><ul><li><p>分代GC在新生代的算法：采用了GC的复制算法，速度快，因为新生代一般是新对象，都是瞬态的用了可能很快被释放的对象。</p></li><li><p>分代GC在年老代的算法 标记／整理算法，GC后会执行压缩，整理到一个连续的空间，这样就维护着下一次分配对象的指针，下一次对象分配就可以采用碰撞指针技术，将新对象分配在第一个空闲的区域。</p></li></ul></li><li><p><strong>垃圾回收器</strong></p><p>gc会引起所有代码停止，native代码可以执行，但是不能与jvm交互，执行垃圾收集算法的时候java应用程序除垃圾收集帮助器之外的其他所有线程都会被挂起</p><ol><li><p>串行垃圾回收器</p><p>只使用一个单独的线程进行垃圾回收，通过冻结所有应用程序线程进行工作，所以可能不适合服务器环境。它最适合的是简单的命令行程序，是client级别默认的GC方式。</p></li><li><p>并行垃圾回收器</p><p>它是JVM的默认垃圾回收器。与串行垃圾回收器不同，它使用多线程进行垃圾回收。相似的是，当执行垃圾回收的时候它也会冻结所有的应用程序线程。适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式。</p></li><li><p>并发标记扫描垃圾回收器</p><p>并发标记垃圾回收使用多线程扫描堆内存，标记需要清理的实例并且清理被标记过的实例。并发标记垃圾回收器只会在下面两种情况持有应用程序所有线程。相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量。如果我们可以为了更好的程序性能分配更多的CPU，那么并发标记上扫描垃圾回收器是更好的选择相比并发垃圾回收器。</p></li></ol></li></ul><h4 id="GC分析-命令调优"><a href="#GC分析-命令调优" class="headerlink" title="GC分析 命令调优"></a>GC分析 命令调优</h4><p>JVM调优就是使Full GC不执行，使Minor GC尽可能少地执行，因为每一次Full GC都会使JVM停止运行</p><ul><li><p><strong>调优命令</strong></p><ul><li><p>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</p></li><li><p>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p></li><li><p>jmap，JVM Memory Map命令用于生成heap dump文件</p></li><li><p>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看</p></li><li><p>jstack，用于生成java虚拟机当前时刻的线程快照。</p></li><li><p>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</p></li></ul></li><li><p><strong>调优工具</strong></p><ul><li><p>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</p></li><li><p>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。</p></li><li><p>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</p></li><li><p>GChisto，一款专业分析gc日志的工具</p></li></ul></li><li><p><strong>减少GC开销的措施</strong></p><ol><li>不要显式调用System.gc()：这不一定每次都触发GC，但是会触发也会增加GC的频率</li><li>减少临时对象的使用</li><li>对象不用时显式设置为null</li><li>尽量使用StringBuffer，而不用String来累加字符串：累加字符串会new有个String对象再进行累加操作，增加了许多临时对象</li><li>能用基本类型就不用引用对象：能用int，long等就不使用Integer和Long对象</li><li>减少使用静态对象变量：静态对象属于全局变量，不会被GC</li><li>分散对象创建或删除的时间：集中短时间内大量创建新的对象会导致突然需要大量的内存，JVM面临这种情况的时候就会主动进行GC</li></ol></li></ul><h3 id="Java-Android多线程开发"><a href="#Java-Android多线程开发" class="headerlink" title="Java&#x2F;Android多线程开发"></a>Java&#x2F;Android多线程开发</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><strong>线程</strong></p><p>一个基本的CPU执行单元 &amp; 程序执行流的最小单元，比进程更小的可独立运行的基本单位，可理解为：轻量级进程<br>组成：线程ID + 程序计数器 + 寄存器集合 + 堆栈<br>注：线程自己不拥有系统资源，与其他线程共享进程所拥有的全部资源。</p><p>进程的缺陷：</p><p>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。<br>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。<br>进程属于在处理器这一层上提供的抽象；线程则属于在进程这个层次上再提供了一层并发的抽象。线程用于提高进程的并发度。<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式：<br>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。<br>线程是进程的一个实体, 是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。<br>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</p><p><img src="https://img-blog.csdnimg.cn/20190523205139568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><ul><li><p>守护线程</p><p>为其他线程提供一种通用服务，如垃圾回收线程</p></li><li><p>非守护线程</p><ul><li>主线程（UI线程）</li><li>子线程（工作线程）</li></ul></li></ul><p>（区别在于虚拟机是否已退出，所有用户线程结束后就没有守护的必要，守护线程就会终止，虚拟机就会同样退出，反之，如果有任意的工作线程还在运行，守护线程就不会终止，虚拟机就不会退出，守护线程不属于不可或缺的存在）</p><p>线程优先级可分为10个级别，分别用Thread类常量表示，可通过setPriority(int grade)进行优先级设置，默认线程优先级是5，即 Thread.NORM_PRIORITY</p><p><strong>多线程</strong></p><p>一个程序（进程）运行时产生多个线程（任务）同时进行。</p><ol><li>目的：</li></ol><p>提高CPU资源的利用率：</p><ul><li><p>避免阻塞（异步调用）</p><p>单个线程中的程序是顺序执行的，如果前面的操作发生了阻塞，就会影响到后面的操作</p></li><li><p>避免CPU空转</p><p>如果服务器只用单线程，处理完一条HTTP请求再处理下一条就会使CPU中存在大量空闲时间，处理一条请求还设计很多如数据库访问、磁盘IO等操作，这些操作的速度比CPU慢很多，等待这些响应的时候，CPU不能去处理新的请求，只能处于等待状态，服务器的性能就会很差劲</p></li><li><p>提升性能</p><p>多线程可以同时执行多个任务，对于可并发的任务而言，确实提高了性能</p></li></ul><ol start="2"><li><p>并发和并行</p><p>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。<br>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。</p><p>其实，多线程本质是并发执行程序。因为计算机任何特定时刻只能执行一个任务；多线程只是一种错觉：只是因为JVM快速调度资源来轮换线程，使得线程不断轮流执行，所以看起来好像在同时执行多个任务而已（异步执行）</p></li><li><p>线程安全</p><p>线程安全是指在并发的情况下，该代码被多个线程使用，但是线程的调度顺序不会影响任何的结果。这个时候使用多线程就只需要关心系统的内存和CPU是否够用即可，反之，线程不安全就会影响最终的结果。</p></li><li><p>同步和异步</p><p>同步:发送一个请求，等待返回再发送下一个请求，同步可以避免出现死锁，读脏数据的发生，可以保证安全性（死锁后面再看）</p><p>异步：发送一个请求，不等待返回，随时可以再发送下一个请求，异步可以提高效率，可以并发执行多项工作</p><p>Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字</p></li><li><p>Android多线程编程原则</p><p>不能阻塞UI线程：单线程会导致主线程阻塞，出现ANR错误，阻塞超过5s会出现错误</p><p>不能在UI线程之外更新UI</p><p>解决方案就是1个主线程+n个子线程，耗时任务在子线程完成，更新UI的任务在主线程完成</p><p><img src="https://img-blog.csdnimg.cn/20190523205339615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p></li><li><p>线程调度</p><p>存在大量线程的时候，采用时间片轮转的方式调度线程，线程不可能做到绝对的并发，处于Runnable就绪状态的线程就可以进入线程队列中等待CPU资源，在采用时间片的系统中每个线程都有机会获得CPU的资源进行自身的线程操作，当线程使用CPU资源的时间到后，即使线程没有完成自己的全部操作也会被JVM中断当前线程的执行，把CPU使用权切换给下一个队列等待的线程，之后等待下一次轮回再从中断处继续执行。</p></li><li><p>线程同步</p><p>当线程A使用同步方法A时，其他线程必须等到线程A使用完同步方法A后才能使用，同步方法用Synchronized进行修饰</p><ul><li><p>死锁发生的四个必要条件</p><ul><li><p>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</p></li><li><p>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</p></li><li><p>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</p></li><li><p>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</p></li></ul></li><li><p>死锁的处理方法</p><ul><li><p>鸵鸟策略</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略（忽略死锁）。<br>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p></li><li><p>死锁检测与死锁恢复</p><p>死锁检测使用资源分配图的方式，从一个节点出发进行深度优先搜索如果最终形成一个环，就是访问到访问过的节点，就说明检测到死锁的发生</p><p>利用抢占恢复、回滚恢复、杀死进程恢复</p></li><li><p>死锁预防</p><p>破坏互斥条件：例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p><p>破坏占有和等待条件：一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><p>破坏不可抢占条件</p><p>破坏环路等待：给资源统一编号，进程只能按编号顺序来请求资源。</p></li><li><p>死锁避免</p><p>安全状态和银行家算法</p><p>如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>银行家算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p></li></ul></li></ul></li><li><p>线程联合</p><p>线程A在占有CPU资源期间，通过调用**join()**方法中断自身线程执行，然后运行联合它的线程B，直到线程B执行完毕后线程A再重新排队等待CPU资源，这个过程称为线程A联合线程B</p></li></ol><p><strong>进程</strong></p><ol><li><p>定义</p><p>是进程实体的运行过程 &amp; 系统进行资源分配和调度的一个独立单位</p></li><li><p>作用</p><p>使多个程序并发执行，以提高系统的资源利用率和调度的一个独立单位</p></li><li><p>状态及状态转换</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403041652114.png"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403041652962.png"></p><ol start="4"><li><p>进程和线程区别</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403041654172.png"></p></li></ol></li></ol><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><h5 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h5><p>分为两部分：</p><p><a href="#JVM层面">JVM层面</a>、<a href = "#OS层面线程状态倾向于描述CPU">OS层面</a></p><p><a id="JVM层面"></a></p><ul><li><p><strong>JVM层面</strong></p><ul><li><p>NEW新建状态</p><p>当用new操作符创建一个线程后，如Thread thread &#x3D; new Thread()，此时线程处在新建状态。 当一个线程处于新建状态时，线程中的任务代码还没开始运行。<br>这里的开始执行具体指调用线程中start方法。（一个线程只能start一次，不能直接调用run方法，只有调用start方法才会开启新的执行线程，接着它会去调用run。在start之后，线程进入RUNNABLE状态，之后还可能会继续转换成其它状态。）</p></li><li><p>RUNNABLE就绪状态（可执行状态）</p><p>也被称为“可执行状态”。一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当调用了线程对象的start()方法即启动了线程，此时线程就处于就绪状态。<br>处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他就绪线程竞争CPU，只有获得CPU使用权才可以运行线程。比如在单核心CPU的计算机系统中，不可能同时运行多个线程，一个时刻只能有一个线程处于运行状态。对与多个处于就绪状态的线程是由Java运行时系统的线程调度程序(thread scheduler)来调度执行。<br>除了调用start()方法后让线程变成就绪状态，一个线程阻塞状态结束后也可以变成就绪状态，或者从运行状态变化到就绪状态。<br>对于Java虚拟机的RUNNABLE状态，包含OS的Ready、Running。（由于现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片”方式进行抢占式轮转调度，其中上下文切换过程很快，因此ready与running状态切换很快，对于RUNNABLE状态，就没有切换的意义了。）<br>以及部分waiting状态（即OS状态下的阻塞式I&#x2F;O操作），这些状态可统一归纳为RUNNABLE状态的官方定义：<br>处于 runnable 状态下的线程正在 Java 虚拟机中执行，但它可能正在等待来自于操作系统的其它资源，比如处理器或者其他I&#x2F;O设备等。（CPU、硬盘、网卡等资源，若在为线程服务，就认为线程在”执行”）</p></li><li><p>BLOCKED阻塞状态</p><p>线程在获取锁失败时(因为锁被其它线程抢占)，它会被加入锁的同步阻塞队列，然后线程进入阻塞状态(Blocked)。</p><p><strong>线程同步机制用于解决多线程之间竞争关系——争夺锁。在ava 在语言级直接提供了同步的机制，也即是 synchronized 关键字，进程同步还需要了解死锁机制，前面有</strong></p><p>（BLOCKED状态可以看做特殊的WAITING，表示等待同步锁的状态。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(expression) &#123;……&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">它的机制是这样的：对表达式（expresssion）求值（值的类型须是引用类型（reference type）），获取它所代表的对象，然后尝试获取这个对象的锁：</span></span><br><span class="line"><span class="comment">如果能获取锁，则进入同步块执行，执行完后退出同步块，并归还对象的锁（异常退出也会归还）；如果不能获取锁，则阻塞在这里，直到能够获取锁。如果一个线程在同步块中，则其他想进入该同步块的进程被阻塞，处于该同步块的Entry Set中，处于BLOCKED状态。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BLOCKED状态官方定义如下：</span></span><br><span class="line"><span class="comment">一个正在阻塞等待一个监视器锁的线程处于这一状态。(A thread that is blocked waiting for a monitor lock is in this state.)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>进入这个状态包括两种情况：<br>（1）进入（enter）同步块时阻塞<br>一个处于 blocked 状态的线程正在等待一个监视器锁以进入一个同步的块或方法。<br>监视器锁用于同步访问，以达到多线程间的互斥。所以一旦一个线程获取锁进入同步块，在其出来之前，如果其它线程想进入，就会因为获取不到锁而阻塞在同步块之外，这时的状态就是 BLOCKED。<br>（2）wait 之后重进入（reenter）同步块时阻塞<br>一个处于 blocked 状态的线程正在等待一个监视器锁，在其调用 Object.wait 方法之后，以再次进入一个同步的块或方法。<br>过程如下：</p><ul><li>调用 wait 方法必须在同步块中，即是要先获取锁并进入同步块，这是第一次 enter。</li><li>而调用 wait 之后则会释放该锁，并进入此锁的等待队列（wait set）中。</li><li>当收到其它线程的 notify 或 notifyAll 通知之后，等待线程并不能立即恢复执行，因为停止的地方是在同步块内，而锁已经释放了，所以它要重新获取锁才能再次进入（reenter）同步块，然后从上次 wait 的地方恢复执行。这是第二次 enter，所以叫 reenter。</li><li>但锁并不会优先给它，该线程还是要与其它线程去竞争锁，这一过程跟 enter 的过程其实是一样的，因此也可能因为锁已经被其它线程据有而导致 BLOCKED。</li></ul><p>这两种情况可总结为：当因为获取不到锁而无法进入同步块时，线程处于 BLOCKED 状态。BLOCKED状态可以看做特殊的WAITING，表示等待同步锁的状态。如果有线程长时间处于 BLOCKED 状态，要考虑是否发生了死锁（deadlock）的状况。</p></li><li><p>WAITING等待状态</p><p>当线程的运行条件不满足时，通过锁的条件等待机制(调用锁对象的wait()或显示锁条件对象的await()方法)让线程进入等待状态(WAITING)。处于等待状态的线程将不会被cpu执行，除非线程的运行条件得到满足后，其可被其他线程唤醒，进入阻塞状态(Blocked)。调用不带超时的Thread.join()方法也会进入等待状态。<br>一个正在无限期等待另一个线程执行一个特别的动作的线程处于这一状态。<br><strong>一个线程进入 WAITING 状态是因为调用了以下方法</strong>：</p><ul><li><p>不带时限的 Object.wait 方法</p></li><li><p>不带时限的 Thread.join 方法<strong>（该线程运行中但还没运行完并且运行过程中需要去运行其他线程再回来就使用这个，也叫线程联合，前面有写；这个方法和yield、sleep都是Thread中的方法，和synchronized 没关系，也不会释放锁）</strong></p><p><a href="https://www.cnblogs.com/cy0628/p/15239230.html">Thread.join()详解 - Chen洋 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/lqhtmckobe/article/details/107901065">join和sleep的区别_sleep和join的区别-CSDN博客</a></p></li></ul><p>然后会等其它线程执行一个特别的动作，比如：</p><ul><li>一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify() 或 Object.notifyAll()。</li><li>一个调用了 Thread.join 方法的线程会等待指定的线程结束。</li></ul><p>进程协作</p><p>WAITING状态所涉及的不是一个线程的独角戏，相反，它涉及多个线程，具体地讲，这是多个线程间的一种协作机制。wait&#x2F;notify与join都是线程间的一种协作机制。下面分别介绍wait&#x2F;notify场景与join场景</p><p>（1）wait&#x2F;notify场景<br>当获得锁的线程A进入同步块后发现条件不满足时，应该调用 wait()方法，这时线程A释放锁，并进入所谓的 wait set 中。这时，线程A不再活动，不再参与调度，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程A状态即是 WAITING。<br>现在的问题是：线程A什么时候才能再次活动呢？显然，最佳的时机是当条件满足的时候。<br>（此时可能存在多个类似线程A这种条件不满足的线程无法执行，与线程B争夺锁资源从而导致饥饿状态）<br>当另一个线程B执行动作使线程A执行条件满足后，它还要执行一个特别的动作，也即是“通知（notify）”处于WAITING状态的线程A，即是把它从 wait set 中释放出来，重新进入到调度队列（ready queue）中。<br>如果是 notify，则选取所通知对象的 wait set 中的一个线程释放；<br>如果是 notifyAll，则释放所通知对象的 wait set 上的全部线程。<br>但被通知线程A并不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。（这也即是所谓的 “reenter after calling Object.wait”，即BLOCKED状态。）</p><p>如果能获取锁，线程A就从 WAITING 状态变成 RUNNABLE 状态；<br>否则，从 wait set 出来，又进入 entry set，线程A就从 WAITING 状态又变成 BLOCKED 状态。<br>综上，这是一个协作机制，需要两个具有协作关系的线程A、B分别执行wait和notify。显然，这种协作关系的存在，线程A可以避免在条件不满足时的盲目尝试，也为线程B的顺利执行腾出了资源；同时，在条件满足时，又能及时得到通知。协作关系的存在使得彼此都能受益。<br>这里的协作机制也即经典的消费者-生产者问题<br>（2）join场景<br>从定义中可知，除了 wait&#x2F;notify 外，调用 join 方法也会让线程处于 WAITING 状态。<br>join 的机制中并没有显式的 wait&#x2F;notify 的调用，但可以视作是一种特殊的，隐式的 wait&#x2F;notify 机制。<br>假如有 a，b 两个线程，在 a 线程中执行 b.join()，相当于让 a 去等待 b，此时 a 停止执行，等 b 执行完了，系统内部会隐式地通知 a，使 a 解除等待状态，恢复执行。<br>换言之，a 等待的条件是 “b 执行完毕”，b 完成后，系统会自动通知 a。</p></li><li><p>TIMED_WAITING 限时等待状态</p><p>限时等待是WAITING等待状态的一种特例，主要是在时限参数和sleep方法的不同。线程在等待时我们将设定等待超时时间，如超过了我们设定的等待时间，等待线程将自动唤醒进入阻塞状态(Blocked)或就绪状态(Runnable) 。在调用Thread.sleep()方法、带有超时设定的Object.wait()方法、带有超时设定的Thread.join()方法等，线程会进入限时等待状态(TIMED_WAITING)。<br>一个正在限时等待另一个线程执行一个动作的线程处于这一状态。</p><p>带指定的等待时间的等待线程所处的状态。<strong>一个线程处于这一状态是因为用一个指定的正的等待时间（为参数）调用了以下方法中的其一</strong>：</p><ul><li>Thread.sleep</li><li>带时限（timeout）的 Object.wait</li><li>带时限（timeout）的 Thread.join</li></ul><p>（1）带参数的wait(n)<br>没有参数的wait()等价于wait(0)，表示线程永久等下去，等到天荒地老，除非收到通知。这种完全将再次活动的命运交给通知者可能会导致该线程永远等下去，无法得到执行的机会（当通知者准备执行notify时因某种原因被杀死，持有的锁也释放，此时线程执行的条件满足了，但等待的线程却因收不到通知从而一直处于等待状态）<br>此时可设置带有参数的wait(1000)，等待1秒，相当于等待两个通知，取决于哪个先到：</p><p>如果在1000毫秒内，线程A收到了线程B的通知而唤醒，则这个闹钟随之失效；<br>如果超过了1000毫秒还没收到通知，则闹钟将线程A唤醒。<br>（2）sleep<br>进入 TIMED_WAITING 状态的另一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。<br>这种情况下就是完全靠“自带闹钟”来通知。（sleep方法不会等待协作进程的通知）<br>sleep方法没有任何同步语义，与锁无关：sleep方法不会等待协作进程的通知，当线程调用sleep方法时带了锁，则sleep期间锁仍为线程所拥有。</p><p>（3）带参数的join(n)</p><p>当前线程等待指定时间，如果等待的线程执行完了就直接继续运行，如果等待指定时间到了但等待执行的线程没有运行完也继续运行（join）</p><p><strong>补充：wait 与 sleep 的区别与联系</strong><br>wait和sleep均能使线程处于等待状态</p><p>定义<br>wait方法定义在Object里面，基于对象锁，所有的对象都能使用<br>（Java里面每一个对象都有隐藏锁，也叫监视器(monitor)。当一个线程进入一个synchronized方法的时候它会获得一个当前对象的锁。）<br>sleep方法定义在Thread里面，是基于当前线程</p><ul><li><p>条件</p><p>wait必须在同步环境（synchronized方法）下使用，否则会报IllegalMonitorStateException异常</p><p>sleep方法可在任意条件下使用</p></li><li><p>功能</p><p>wait&#x2F;notify一起使用，用于线程间的通信。wait用于让线程进入等待状态，notify则唤醒正在等待的线程。</p><p>sleep用于暂停当前线程的执行，它会在一定时间内释放CPU资源给其他线程执行，超过睡眠时间则会正常唤醒。</p></li><li><p>锁的持有</p><p>在同步环境中调用wait方法会释放当前持有的锁</p><p>调用sleep则不会释放锁，一直持有锁（直到睡眠结束）</p><p>（补充sleep和join，sleep和join都是Thread的方法，主要区别就是join的内部使用了synchronized和wait，wait会释放锁，但是sleep不会释放锁）</p></li></ul></li><li><p>TERMINATED 死亡状态<br>线程执行完了（completed execution）或者因异常退出了run()方法（exited），该线程结束生命周期。</p></li></ul></li></ul><p>​</p><p><a id="OS层面线程状态倾向于描述CPU"></a></p><ul><li><p><strong>OS层面线程状态倾向于描述CPU</strong></p><ul><li><p>OS层面状态</p><p><img src="https://img-blog.csdnimg.cn/20190714105810784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p></li><li><p>JVM层面和OS层面状态对比</p><p><img src="https://img-blog.csdnimg.cn/20190714105920995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p></li></ul></li></ul><p><a id="线程阻塞"></a></p><p><strong>线程阻塞</strong></p><ul><li><p>特点</p><p>线程放弃CPU的使用，暂停运行。只有等阻塞原因消除后恢复运行；或是被其他线程中断导致该线程退出阻塞状态，同时跑出InterruptedException.</p></li><li><p>状态</p><p>BLOCKED状态 无法获取同步锁 :synchronic<br>WAITING状态（TIMED_WAITING状态） 不满足运行条件 :wait&#x2F;notify、sleep，<br>RUNNABLE状态 正在JVM中执行，占用某个资源 :阻塞式 I&#x2F;O 操作</p></li><li><p>原因</p><p>（1）Thread.sleep(int millsecond) 调用 sleep 的线程会在一定时间内将 CPU 资源给其他线程执行，超过睡眠事件后唤醒。与是否持有同步锁无关。进程处于 TIMED_WAITING 状态<br>（2）线程执行一段同步代码（Synchronic）代码，但无法获取同步锁：同步锁用于实现线程同步执行，未获得同步锁而无法进入同步块的线程处于 BLOCKED 状态<br>（3）线程对象调用 wait 方法，进入同步块的线程发现运行条件不满足，此时会释放锁，并释放CPU，等待其他线程norify。此时线程处于 WAITING 状态<br>（4）执行阻塞式I&#x2F;O操作，等待相关I&#x2F;O设备（如键盘、网卡等），为了节省CPU资源，释放CPU。此时线程处于RUNNABLE状态。</p></li><li><p>机制</p><p>（联系消费者和生产者）</p><p><a href="https://www.cnblogs.com/gagaya2/p/17794161.html">Java基础 阻塞队列的方式实现等待唤醒机制，哪里体现了等待？哪里又体现了唤醒？ - 嘎嘎鸭2 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/u011397981/article/details/130167712">【面试】Java线程阻塞和唤醒的几种方式？_java 其他线程唤醒锁住线程-CSDN博客</a></p></li></ul><h5 id="线程控制方法"><a href="#线程控制方法" class="headerlink" title="线程控制方法"></a>线程控制方法</h5><ul><li><a href = "#Synchronized">Synchronized</a></li><li><a href="#Volatile">Volatile</a></li><li><a href="#ReentrantLock">ReentrantLock</a></li></ul><h5 id="基本线程相关的类（创建线程）"><a href="#基本线程相关的类（创建线程）" class="headerlink" title="基本线程相关的类（创建线程）"></a>基本线程相关的类（创建线程）</h5><ul><li><p>Thread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">char</span> name[];<span class="comment">//表示Thread名字，可以通过Thread构造器中的参数指定线程的名字</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> priority;<span class="comment">//线程的优先级（最大值为10，最小值为1，默认为5）</span></span><br><span class="line"><span class="comment">// 守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">daemon</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//该线程是否为守护线程</span></span><br><span class="line"><span class="keyword">private</span> Runnable target;<span class="comment">//要执行的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start() 用来启动一个线程，实现多线程，当调用start方法后，系统会开启一个新线程用来执行用户定义的子任务，并为响应线程分配资源。这时线程处于就绪状态，但并没有运行，一旦得到cpu时间片，就开始执行run方法（run()称为线程体，包含要执行这个线程的内容，run()方法运行结束则线程终止）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread.run()</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程可转让cpu控制权，让别的就绪状态线程运行（切换）</span></span><br><span class="line"><span class="comment">// 调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。</span></span><br><span class="line"><span class="comment">// 注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。(和sleep一样，会继续执行原本的任务，而不是从头执行)    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread.<span class="keyword">yield</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。</span></span><br><span class="line"><span class="comment">// 但是有一点要非常注意，sleep方法不会释放锁（相当于一直持有该对象的锁），也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。</span></span><br><span class="line"><span class="comment">// 还有一点要注意，如果调用了sleep方法，必须捕获InterruptedException异常或者将该异常向上层抛出。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。    </span></span><br><span class="line">sleep(<span class="type">long</span> millis)     <span class="comment">//参数为毫秒</span></span><br><span class="line">sleep(<span class="type">long</span> millis,<span class="type">int</span> nanoseconds)    <span class="comment">//第一参数为毫秒，第二个参数为纳秒</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个线程中调用other.join(),将等待other执行完后才继续本线程。　　</span></span><br><span class="line"><span class="comment">// 假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间。   </span></span><br><span class="line">join()</span><br><span class="line">join(<span class="type">long</span> millis)     <span class="comment">//参数为毫秒</span></span><br><span class="line">join(<span class="type">long</span> millis,<span class="type">int</span> nanoseconds)    <span class="comment">//第一参数为毫秒，第二个参数为纳秒</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// interrupt()是Thread类的一个实例方法，用于中断本线程。这个方法被调用时，会立即将线程的中断标志设置为“true”。所以当中断处于“阻塞状态”的线程时，由于处于阻塞状态，中断标记会被设置为“false”，抛出一个 InterruptedException。所以我们在线程的循环外捕获这个异常，就可以退出线程了。    </span></span><br><span class="line"><span class="comment">// interrupt()并不会中断处于“运行状态”的线程，它会把线程的“中断标记”设置为true，所以我们可以不断通过isInterrupted()来检测中断标记，从而在调用了interrupt()后终止线程，这也是通常我们对interrupt()的用法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">interrupte</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li></ul><p>​<strong>一个类去继承Thread的时候必须重写该类的run方法，run方法代表了该线程要完成的任务，run方法可以称为可执行体</strong></p><p><strong>线程执行方法与状态的联系</strong></p><p><img src="https://img-blog.csdnimg.cn/20190715100019214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p><strong>中断机制</strong></p><p><a href="https://blog.csdn.net/baidu_35410857/article/details/134326995">Java多线程3种中断方式和终止方式_implements runnable线程结束-CSDN博客</a></p><p>简单来说就是线程有一个标志位，用来标记中断，但实际上并没有中断线程，而是把中断的权利交给线程本身，可以借助下面几个重要方法去实现。interrupt()会让处于睡眠状态的线程抛出InterruptedException异常。</p><ul><li>public void interrupt();&#x2F;&#x2F;每个线程都有个boolean类型的中断状态。当使用Thread的interrupt()方法时，线程的中断状态会被设置为true。</li><li>public boolean isInterrupted();&#x2F;&#x2F;判断线程是否被中断</li><li>public static boolean interrupted(); &#x2F;&#x2F; 清除中断标志，并返回原状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptedExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InterruptedExample</span> <span class="variable">interruptedExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptedExample</span>();</span><br><span class="line">        interruptedExample.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//当Thread 处于 sleep 后处于阻塞状态，收到中断请求会跑出InterruptedException异常</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            myThread.cancel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程循环执行打印一些信息，使用isInterrupted判断线程是否被中断，若中断则结束线程</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 阻塞状态下的线程抛出异常后则会被终止</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">                    <span class="comment">// 抛出InterruptedException后中断标志被清除（中断标志 重新设置为false）</span></span><br><span class="line">                    <span class="comment">// 标准做法是再次调用interrupt恢复中断，正确情景下为true</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//对线程调用interrupt()方法，不会真正中断正在运行的线程，</span></span><br><span class="line">        <span class="comment">//只是发出一个请求，由线程在合适时候结束自己。</span></span><br><span class="line">            interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//其他内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是java的Thread类的定义，Runnable是一个接口，里面有run方法，那么就可以知道Thread是Runnable接口的实现类</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableThreadTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">RunnableThreadTest</span> <span class="variable">rtt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableThreadTest</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(rtt,<span class="string">&quot;新线程1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(rtt,<span class="string">&quot;新线程2&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Callable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">      <span class="comment">//concurrent包下的接口</span></span><br><span class="line">      V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;</span><br><span class="line">  &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// 创建Callable实现体的实例，使用FutureTask类包装Callable对象</span></span><br><span class="line">  <span class="type">CallableThreadTest</span> <span class="variable">ctt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableThreadTest</span>();</span><br><span class="line">  FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(ctt);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 的循环变量i的值&quot;</span>+i);</span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//使用FutureTask对象作为Thread对象的target创建并启动新线程</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(ft,<span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</span></span><br><span class="line">  System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span>+ft.get());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">  &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ExecutionException e)</span><br><span class="line">  &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// call 方法即为线程的执行体，并且拥有返回值</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**上面三种创建线程的方式的对比**</span><br><span class="line"></span><br><span class="line">线程类继承自Thread就不能再继承其他父类了，但是编写简单，如果要访问当前线程只需要使用<span class="built_in">this</span>即可</span><br><span class="line"></span><br><span class="line">对于Runnable和Callable接口那么父类就还可以继承其他类，但是编程稍微复杂，如果要访问当前线程就需要使用Thread.currentThread()方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 高级多线程控制类</span><br><span class="line"></span><br><span class="line">Java1<span class="number">.5</span>提供了一个非常高效实用的多线程包:java.util.concurrent, 提供了大量高级工具,可以帮助开发者编写高效、易维护、结构清晰的Java多线程程序。</span><br><span class="line"></span><br><span class="line">- **ThreadLocal类**</span><br><span class="line"></span><br><span class="line">  - 实现</span><br><span class="line"></span><br><span class="line">    每个Thread都持有一个TreadLocalMap类型的变量（该类是一个轻量级的Map，功能与map一样，区别是桶里放的是entry而不是entry的链表。功能还是一个map。）以本身为key，以目标为value。</span><br><span class="line"></span><br><span class="line">  - 用处</span><br><span class="line"></span><br><span class="line">    当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，副本之间相互独立，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。常用于用户登录控制，如记录session信息。</span><br><span class="line"></span><br><span class="line">  - 常用方法</span><br><span class="line"></span><br><span class="line">    - ThreadLocal() : 创建一个线程本地变量</span><br><span class="line">    - get() : 返回此线程局部变量的当前线程副本中的值</span><br><span class="line">    - initialValue() : 返回此线程局部变量的当前线程的<span class="string">&quot;初始值&quot;</span></span><br><span class="line">    - set(T value) : 将此线程局部变量的当前线程副本中的值设置为value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **原子类**</span><br><span class="line"></span><br><span class="line">  首先需要先知道CAS机制，看后面享学课堂学习多线程下面有写到CAS机制，这个是用来解决锁机制带来的性能问题的，只是保证简单的对数据的原子性操作直接使用<span class="keyword">synchronized</span>显得杀鸡用牛刀了，毕竟加锁会带来很大的系统开销，但是使用<span class="keyword">volatile</span>不能保证原子操作，那么就需要使用CAS机制，而原子变量类就是基于CAS实现的能够保障对共享变量进行read-modify-write更新操作, 例如自增操作“count++”</span><br><span class="line"></span><br><span class="line">  **原子变量类可以保证原子性和可见性，原子变量类的内部实现通常借助一个 <span class="keyword">volatile</span>变量保证可见性, 并通过CAS保证原子性**</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  下面是原子变量类的分类</span><br><span class="line"></span><br><span class="line">  | 分组       | 类                                                           |</span><br><span class="line">  | ---------- | ------------------------------------------------------------ |</span><br><span class="line">  | 基础数据型 | AtomicInteger, AtomicLong, AtomicBoolean                     |</span><br><span class="line">  | 数组型     | AtomicIntegerArray , AtomicLongArray, AtomicReferenceArray   |</span><br><span class="line">  | 字段更新器 | AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater |</span><br><span class="line">  | 引用型     | AtomicReference, AtomicStampedReference, AtomicMarkableReference |</span><br><span class="line"></span><br><span class="line">- **容器类**</span><br><span class="line"></span><br><span class="line">  - BlockingQueue</span><br><span class="line"></span><br><span class="line">    阻塞队列。该类是java.util.concurrent包下的重要类，通过对Queue的学习可以得知，这个queue是单向队列，可以在队列头添加元素和在队尾删除或取出元素。类似于一个管　　道，特别适用于先进先出策略的一些应用场景。普通的queue接口主要实现有PriorityQueue（优先队列）。</span><br><span class="line"></span><br><span class="line">    除了传统的queue功能（表格左边的两列）之外，还提供了阻塞接口put和take，带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞，直到有空间时被唤醒；take在队　列空的时候阻塞，直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用，堪称神器。</span><br><span class="line"></span><br><span class="line">  - &lt;a href=<span class="string">&quot;#ConcurrentHashMap&quot;</span>&gt;ConcurrentHashMap&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">    高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- **Semaphore**</span><br><span class="line"></span><br><span class="line">  信号量，Semaphore有单值和多值两种，前者只能被一个线程获得，后者可以被若干个线程获得，信号量是一个非负整数（表示可以并发访问公共资源的线程数），所有通过它的线程都会将该整数减一（可使用的公共资源数目-<span class="number">1</span>），当该整数值为零时，所有试图通过它的线程都将处于等待状态。在信号量上我们定义两种操作： Wait（等待） 和 Release（释放）。 当一个线程调用Wait（等待）操作时，它要么通过然后将信号量减一（Semaphore&gt;<span class="number">0</span>）；要么一直等下去（Semaphore&lt;=<span class="number">0</span>），直到信号量大于<span class="number">0</span>或超时。Release（释放）实际上是在信号量上执行加操作，该操作之所以叫做“释放”是因为加操作实际上是释放了由信号量守护的公共资源。</span><br><span class="line">  在java中，还可以设置该信号量是否采用公平模式，如果以公平方式执行，则线程将会按到达的顺序（FIFO）执行，如果是非公平，则可以后请求的有可能排在队列的头部。</span><br><span class="line"></span><br><span class="line">  单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另一个线程释放“锁”，这可应用于死锁恢复的一些场合。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span></span><br><span class="line">  <span class="comment">//创建具有给定的许可数和给定的公平设置的Semaphore。</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//线程池</span></span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">  <span class="comment">//定义信号量，只能5个线程同时访问</span></span><br><span class="line">          <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line">          <span class="comment">//模拟20个线程同时访问</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NO</span> <span class="operator">=</span> i;</span><br><span class="line">   <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//获取许可</span></span><br><span class="line">  semaphore.acquire();</span><br><span class="line">  <span class="comment">//availablePermits()指的是当前信号灯库中有多少个可以被使用</span></span><br><span class="line">  System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() +<span class="string">&quot;进入，当前已有&quot;</span> + (<span class="number">5</span>-semaphore.availablePermits()) + <span class="string">&quot;个并发&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;index:&quot;</span>+NO);</span><br><span class="line">  Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>)*<span class="number">10</span>);</span><br><span class="line">      </span><br><span class="line">  System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;即将离开&quot;</span>);</span><br><span class="line">      <span class="comment">//访问完后，释放</span></span><br><span class="line">      semaphore.release();</span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  executor.execute(runnable);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 退出线程池</span></span><br><span class="line">          executor.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><a href="#线程池">线程池</a></strong></p></li></ul><h5 id="Java并发模型、线程安全、断点续传"><a href="#Java并发模型、线程安全、断点续传" class="headerlink" title="Java并发模型、线程安全、断点续传"></a>Java并发模型、线程安全、断点续传</h5><p>这部分直接看博客对应部分吧，更像一个总结</p><p>并发工具</p><p>基础类：Synchronized、Volatile、Final<br>java.util.concurrent包：原子类（atomic）、显示锁（ReentrantLock）、同步模式（CountDownLatch）、线程安全容器（ConcurrentHashMap、CopyOnWriteArrayList、Queue、TransferQueue）<br>感谢Doug Lea在Java 5中提供了他里程碑式的杰作java.util.concurrent包，它的出现让Java的并发编程有了更多的选择和更好的工作方式。Doug Lea的杰作主要包括以下内容：</p><ul><li><p>更好的线程安全的容器</p></li><li><p>线程池和相关的工具类</p></li><li><p>可选的非阻塞解决方案</p></li><li><p>显示的锁和信号量机制</p></li></ul><p>​    </p><p><a id="Synchronized"></a></p><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><p>  synchronized 规定了同一个时刻只允许一条线程可以进入临界区（互斥性），同时还保证了共享变量的内存可见性。此规则决定了持有同一个对象锁的多个同步块只能串行执行。<br>Java中的每个对象都可以为锁。</p><ul><li>普通同步方法，锁是当前实例对象。</li><li>静态同步方法，锁是当前类的class对象。</li><li>同步代码块，锁是括号中的对象。</li></ul><p>synchronized 是应用于同步问题的人工线程调度工具。Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内（线程进入同步块），监视器发挥作用 ，线程获得内置锁。内置锁是一个互斥锁，以为着最多只有一个线程能够获取该锁。这个锁由JVM自动获取和释放，线程进入synchronized方法时获取该对象的锁，synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的1个好处，方法抛异常的时候，锁仍然可以由JVM来自动释放。</p><p><img src="https://img-blog.csdnimg.cn/20190524075911327.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p>wait&#x2F;notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某个对象的监视器）。<br>当某个线程wait之后，其他执行该同步快的线程可以进入该同步块执行。<br>当某个线程并不持有监视器的使用权时（如上图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。<br>在synchronized块中去调用另一个对象的wait&#x2F;notify，因为不同对象的监视器不同，同样会抛出此异常。</p><p>synchronized的锁升级可以看后面享学课堂的多线程部分，里面有写到</p><p><strong>线程可以通过两种方式锁住一个对象（懵逼）</strong>：</p><ol><li>通过膨胀一个处于无锁状态（状态位001）的对象获得该对象的锁；</li><li>对象处于膨胀状态（状态位00），但LockWord指向的monitor的Owner字段为NULL，则可以直接通过CAS原子指令尝试将Owner设置为自己的标识来获得锁。</li></ol><p>获取锁（monitorenter）的大概过程：</p><ol><li><p>对象处于无锁状态时（LockWord的值为hashCode等，状态位为001），线程首先从monitor列表中取得一个空闲的monitor，初始化Nest和Owner值为1和线程标识，一旦monitor准备好，通过CAS替换monitor起始地址到LockWord进行膨胀。如果存在其它线程竞争锁的情况而导致CAS失败，则回到monitorenter重新开始获取锁的过程即可。</p></li><li><p>对象已经膨胀，monitor中的Owner指向当前线程，这是重入锁的情况（reentrant），将Nest加1，不需要CAS操作，效率高。</p></li><li><p>对象已经膨胀，monitor中的Owner为NULL，此时多个线程通过CAS指令试图将Owner设置为自己的标识获得锁，竞争失败的线程则进入第4种情况。</p></li><li><p>对象已经膨胀，同时Owner指向别的线程，在调用操作系统的重量级的互斥锁之前自旋一定的次数，当达到一定的次数如果仍然没有获得锁，则开始准备进入阻塞状态，将rfThis值原子加1，由于在加1的过程中可能被其它线程破坏对象和monitor之间的联系，所以在加1后需要再进行一次比较确保lock word的值没有被改变，当发现被改变后则要重新进行monitorenter过程。同时再一次观察Owner是否为NULL，如果是则调用CAS参与竞争锁，锁竞争失败则进入到阻塞状态。</p></li></ol><p>释放锁（monitorexit）的大概过程：</p><ol><li><p>检查该对象是否处于膨胀状态并且该线程是这个锁的拥有者，如果发现不对则抛出异常。</p></li><li><p>检查Nest字段是否大于1，如果大于1则简单的将Nest减1并继续拥有锁，如果等于1，则进入到步骤3。</p></li><li><p>检查rfThis是否大于0，设置Owner为NULL然后唤醒一个正在阻塞或等待的线程再一次试图获取锁，如果等于0则进入到步骤4。</p></li><li><p>缩小（deflate）一个对象，通过将对象的LockWord置换回原来的HashCode等值来解除和monitor之间的关联来释放锁，同时将monitor放回到线程私有的可用monitor列表。</p></li></ol><p><strong>重入锁和非重入锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不可重入锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="keyword">while</span>(isLocked)&#123;    </span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        isLocked = <span class="literal">false</span>;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可重入锁</span></span><br><span class="line"><span class="comment">/*lockBy：保存已经获得锁实例的线程，在lock()判断调用lock的线程是否已经获得当前锁实例，如果已经获得锁，则直接跳过while，无需等待。</span></span><br><span class="line"><span class="comment">lockCount：记录同一个线程重复对一个锁对象加锁的次数。否则，一次unlock就会解除所有锁，即使这个锁实例已经加锁多次了。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Thread</span>  <span class="variable">lockedBy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lockedCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span>(isLocked &amp;&amp; lockedBy != thread)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked = <span class="literal">true</span>;</span><br><span class="line">        lockedCount++;</span><br><span class="line">        lockedBy = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread() == <span class="built_in">this</span>.lockedBy)&#123;</span><br><span class="line">            lockedCount--;</span><br><span class="line">            <span class="keyword">if</span>(lockedCount == <span class="number">0</span>)&#123;</span><br><span class="line">                isLocked = <span class="literal">false</span>;</span><br><span class="line">                notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Count</span>&#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        doAdd();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对于不可重入锁，当一个线程调用print()方法时，获得了锁，这时就无法再调用doAdd()方法，这时必须先释放锁才能调用，所以称这种锁为不可重入锁，也叫自旋锁。</span></span><br><span class="line"><span class="comment">对于可重入锁，可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。</span></span><br><span class="line"><span class="comment">第一个线程执行print()方法，得到了锁，使lockedBy等于当前线程，也就是说，执行的这个方法的线程获得了这个锁，执行add()方法时，同样要先获得锁，因不满足while循环的条件，也就是不等待，继续进行，将此时的lockedCount变量，也就是当前获得锁的数量加一，当释放了所有的锁，才执行notify()。如果在执行这个方法时，有第二个线程想要执行这个方法，因为lockedBy不等于第二个线程，导致这个线程进入了循环，也就是等待，不断执行wait()方法。只有当第一个线程释放了所有的锁（一共两个锁：print方法一个锁+add方法一个锁），执行了notify()方法，第二个线程才得以跳出循环，继续执行。*/</span></span><br></pre></td></tr></table></figure><p><strong>java常用的可重入锁有synchronized和java.util.concurrent.locks.ReentrantLock</strong></p><p>注意：<br>这里要区别，同一个对象的多方法都加入synchronized关键字时，线程A 访问 (synchronized)object.A，线程B 访问 (synchronized)object.B时，必须等线程A访问完A，线程B才能访问B；此结论同样适用于对于object中使用synchronized(this)同步代码块的场景；synchronized锁定的都是当前对象！</p><p><strong>lock 机制（单独使用）实现线程竞争</strong></p><p>在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程（通过竞争获取到lock实例的线程）能执行该块内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过lock锁定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        Object lock;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">              ..<span class="keyword">do</span> something</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接用于方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">             ..<span class="keyword">do</span> something</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h5><p><strong>1. 同步方法 synchronized关键字修饰的方法</strong></p><ul><li><p>对象锁</p><p>对象锁是用于对象实例方法，或者一个对象实例上的</p></li><li><p>类锁</p><p>类锁是用于类的静态方法或者一个类的class对象上的</p><p>其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的。我们都知道，java类可能会有很多个对象，但是只有1个Class对象，也就是说类的不同实例之间共享该类的Class对象。Class对象其实也仅仅是1个java对象，只不过有点特殊而已。由于每个java对象都有1个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，不过是Class对象的锁而已。获取类的Class对象有好几种，最简单的就是MyClass.class的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      pulbic <span class="keyword">class</span> <span class="title class_">Something</span>()&#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">isSyncA</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title function_">voidisSyncB</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">static</span> synchronizedvoid <span class="title function_">cSyncA</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">static</span> synchronizedvoid <span class="title function_">cSyncB</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">/*synchronized static是某个类的范围，synchronized static cSync&#123;&#125;防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。</span></span><br><span class="line"><span class="comment">synchronized 是某实例的范围，synchronized isSync()&#123;&#125;防止多个线程同时访问这个实例中的synchronized 方法。</span></span><br><span class="line"><span class="comment">类锁和对象锁不是同1个东西，一个是类的Class对象的锁，一个是类的实例的锁。也就是说：1个线程访问静态synchronized的时候，允许另一个线程访问对象的实例synchronized方法。反过来也是成立的，因为他们需要的锁是不同的。*/</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>2. 同步代码块 synchronized关键字修饰的语句块</strong></p><p>但用Synchronized修饰同步方法有缺陷：<br>当某个线程进入同步方法获得对象锁，那么其他线程访问这里对象的同步方法时，必须等待或者阻塞，这对高并发的系统是致命的，这很容易导致系统的崩溃。如果某个线程在同步方法里面发生了死循环，那么它就永远不会释放这个对象锁，那么其他线程就要永远的等待。这是一个致命的问题。<br>因此用synchronized修饰代码块，缩小同步范围，减少了风险。<br>因此采用同步代码块，被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*同步是一种高开销的操作，因此应该尽量减少同步的内容。</span></span><br><span class="line"><span class="comment">通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSynchronized</span>   </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>   </span><br><span class="line">    &#123;    </span><br><span class="line">         <span class="keyword">synchronized</span>(<span class="built_in">this</span>)   </span><br><span class="line">         &#123;    </span><br><span class="line">              <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;    </span><br><span class="line">              <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>)   </span><br><span class="line">              &#123;    </span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + i);    </span><br><span class="line">                   <span class="keyword">try</span>   </span><br><span class="line">                   &#123;    </span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);    </span><br><span class="line">                   &#125;   </span><br><span class="line">                   <span class="keyword">catch</span> (InterruptedException ie)   </span><br><span class="line">                   &#123;    </span><br><span class="line">                   &#125;    </span><br><span class="line">              &#125;    </span><br><span class="line">         &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>   </span><br><span class="line">    &#123;    </span><br><span class="line">         <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;    </span><br><span class="line">         <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>)   </span><br><span class="line">         &#123;    </span><br><span class="line">              System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + i);    </span><br><span class="line">              <span class="keyword">try</span>   </span><br><span class="line">              &#123;    </span><br><span class="line">                   Thread.sleep(<span class="number">500</span>);    </span><br><span class="line">              &#125;   </span><br><span class="line">              <span class="keyword">catch</span> (InterruptedException ie)   </span><br><span class="line">              &#123;    </span><br><span class="line">              &#125;    </span><br><span class="line">         &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>   </span><br><span class="line">    &#123;    </span><br><span class="line">         <span class="keyword">final</span> <span class="type">TestSynchronized</span> <span class="variable">myt2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestSynchronized</span>();    </span><br><span class="line">         <span class="type">Thread</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(  <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  myt2.test1();  &#125;  &#125;, <span class="string">&quot;test1&quot;</span>  );    </span><br><span class="line">         <span class="type">Thread</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(  <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; myt2.test2();   &#125;  &#125;, <span class="string">&quot;test2&quot;</span>  );    </span><br><span class="line">         test1.start();;    </span><br><span class="line">         test2.start();    </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  <span class="comment">//上面输出结果顺序都是正确的</span></span><br><span class="line"><span class="comment">/*（可能这个结果有人会有疑问，代码里面明明是先开启test1线程，为什么先执行的是test2呢？这是因为java编译器在编译成字节码的时候，会对代码进行一个重排序，也就是说，编译器会根据实际情况对代码进行一个合理的排序，编译前代码写在前面，在编译后的字节码不一定排在前面，所以这种运行结果是正常的， 这里是题外话，最主要是检验synchronized的用法的正确性）*/</span></span><br></pre></td></tr></table></figure><p><strong>线程获得对象锁的同时，也可以获得该类锁，即同时获得两个锁，这是允许的</strong></p><p><strong>3. wait&#x2F;notify 机制实现线程协作</strong></p><p>wait&#x2F;notify机制：在Java中，可以通过配合调用Object对象的wait（）方法和notify（）方法或notifyAll（）方法来实现线程间的通信。<br>由于 wait()、notify&#x2F;notifyAll() 在synchronized 代码块执行，说明当前线程一定是获取了锁的。<br>当线程执行wait()方法时候，会将当前进程阻塞，释放当前的锁，然后让出CPU，进入等待状态。（直到接到通知或被中断为止）<br>只有当 notify&#x2F;notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，从wait()方法中继续往下执行。<br>要注意</p><p>notify唤醒阻塞的线程后，线程会接着上次的执行继续往下执行。<br>wait&#x2F;notify必须在同步方法或同步快中调用。wait()方法释放当前线程的锁，因此如果当前线程没有持有适当的锁，则抛出IllegalMonitorStateException异常。notify()方法调用前，线程也必须要获得该对象的对象级别锁，的如果调用notify（）时没有持有适当的锁，也会抛出IllegalMonitorStateException。<br>notify与notifyall区别与联系<br>notify 与 notifyall 都是用于唤醒被 wait 的线程<br>notify 调用后，如果有多个线程等待，则线程规划器任意挑选出其中一个wait（）状态的线程来发出通知，并使它等待获取该对象的对象锁。但不惊动其他同样在等待被该对象notify的线程们。当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。<br>notifyAll使所有原来在该对象上wait的线程统统退出wait的状态（即全部被唤醒，不再等待notify或notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。<br>notify后，当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以通过竞争获取该对象锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 生产者生产出来的产品交给店员</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">this</span>.product &gt;= MAX_PRODUCT)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">           &#123;</span><br><span class="line">               wait();  </span><br><span class="line">               System.out.println(<span class="string">&quot;产品已满,请稍候再生产&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">           &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">this</span>.product++;</span><br><span class="line">       System.out.println(<span class="string">&quot;生产者生产第&quot;</span> + <span class="built_in">this</span>.product + <span class="string">&quot;个产品.&quot;</span>);</span><br><span class="line">       notifyAll();   <span class="comment">//通知等待区的消费者可以取出产品了</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 消费者从店员取产品</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">this</span>.product &lt;= MIN_PRODUCT)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">try</span> </span><br><span class="line">           &#123;</span><br><span class="line">               wait(); </span><br><span class="line">               System.out.println(<span class="string">&quot;缺货,稍候再取&quot;</span>);</span><br><span class="line">           &#125; </span><br><span class="line">           <span class="keyword">catch</span> (InterruptedException e) </span><br><span class="line">           &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       System.out.println(<span class="string">&quot;消费者取走了第&quot;</span> + <span class="built_in">this</span>.product + <span class="string">&quot;个产品.&quot;</span>);</span><br><span class="line">       <span class="built_in">this</span>.product--;</span><br><span class="line">       notifyAll();   <span class="comment">//通知等待去的生产者可以生产产品了</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a id="Volatile"></a></p><h4 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h4><p><strong>Java多线程内存模式与重排序</strong></p><p>在JAVA多线程环境下，对于每个Java线程除了共享的虚拟机栈外和Java堆之外，还存在一个独立私有的工作内存，工作内存存放主存中变量的值的拷贝。每个线程独立运行，彼此之间都不可见，线程的私有堆内存中保留了一份主内存的拷贝，只有在特定需求的情况下才会与主存做交互（复制&#x2F;刷新）。<br>当数据从主内存复制到工作存储时，必须出现两个动作：第一，由主内存执行的读（read）操作；第二，由工作内存执行的相应的load操作；当数据从工作内存拷贝到主内存时，也出现两个操作：第一个，由工作内存执行的存储（store）操作；第二，由主内存执行的相应的写（write）操作<br><strong>每一个操作都是原子的，即执行期间不会被中断。</strong><br><strong>对于普通变量，一个线程中更新的值，不能马上反应在其他变量中。<br>如果需要在其他线程中立即可见，需要使用 volatile 关键字。</strong></p><p>正常变量就是下面的流程，volatile的不同，享学课堂多线程那里有图</p><p><img src="https://img-blog.csdnimg.cn/20190717092410649.png"></p><p><img src="https://img-blog.csdnimg.cn/20190717092349470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p>重排序：</p><p>在有些场景下多线程访问程序变量会表现出与程序制定的顺序不一样。因为编译器可以以优化的名义改变每个独立线程的顺序，从而使处理器不按原来的顺序执行线程。一个Java程序在从源代码到最终实际执行的指令序列之间，会经历一系列的重排序过程。<br>对于多线程共享同一内存区域这一情况，使得每个线程不知道其他线程对数据做了怎样的修改（数据修改位于线程的私有内存中，具有不可见性），从而导致执行结果不正确。因此必须要解决这一同步问题。</p><p><strong>原理</strong></p><p><a href="https://blog.csdn.net/u012813201/article/details/65642926">volatile二三事2—非原子性_volatile非原子性-CSDN博客</a></p><p>对于非volatile变量进行读写时，每个写成先从主存拷贝变量到线程缓存中，执行完操作再保存到主存中。需要进行load&#x2F;save操作。<br><strong>而volatile变量保证每次读写变量都是不经过缓存而是直接从内存读写数据。省去了load&#x2F;save操作。</strong>volatile变量不会将对该变量的操作与其他内存操作一起重排序，能及时更新到主存；且因该变量存储在主存上，所以总会返回最新写入的值。</p><p>因此volatile定义的变量具有以下特性：</p><ul><li><p>保证此变量对所有的线程的可见性。</p><p>当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存更新。因此使用volatile修饰域相当于告诉JVM该域会被其他线程更新，volatile修饰域一旦改变，相当于告诉所有其他线程该域的变化。但非volatile变量的值在线程间传递均需要通过主内存完成，看到的数据可能不是最新的数据。</p></li><li><p>禁止指令重排序优化。</p><p>有volatile修饰的变量，赋值后多执行了一个“load and save”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置）</p></li><li><p>性能较低</p><p>volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不乱序执行。</p></li><li><p>轻量级sychronized</p><p>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">            <span class="comment">//需要同步的变量加上volatile</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">account</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAccount</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> account;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里不再需要synchronized </span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">                account += money;</span><br><span class="line">            &#125;</span><br><span class="line">        ｝</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190717092714320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p></li></ul><p>final不可变<br>作用于类、方法、成员变量、局部变量。初始化完成后的不可变对象，其它线程可见。常量不会改变不会因为其它线程产生影响。Final修饰的引用类型的地址不变，同时需要保证引用类型各个成员和操作的线程安全问题。因为引用类型成员可能是可变的。<br>synchronized同步<br>作用域代码块、方法上。通过线程互斥，同一时间的同样操作只允许一个线程操作。通过字节码指令实现。<br>Volatile 修饰域<br>volatile 修饰的变量的变化保证对其它线程立即可见。<br>volatile变量的写，先发生于读。每次使用volatile修饰的变量个线程都会刷新保证变量一致性。但同步之前各线程可能仍有操作。如：各个根据volatile变量初始值分别进行一些列操作，然后再同步写赋值。每个线程的操作有先后，当一个最早的线程给线程赋值时，其它线程同步。但这时其它线程可能根据初始值做了改变，同步的结果导致其它线程工作结果丢失。根据volatile的语意使用条件：运算结果不依赖变量的当前值。<br>volatile禁止指令重排优化。<br>这个语意导致写操作会慢一些。因为读操作跟这个没关系。</p><p><a id="ReentrantLock"></a></p><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p><strong>可以看花里花哨后面的补充的五种锁机制以及不同锁的种类（操作系统课程有提到）</strong></p><ul><li>ReentrantLock</li><li>ReentrantReadWriteLock.ReadLock</li><li>ReentrantReadWriteLock.WriteLock</li></ul><p>主要目的是和synchronized一样， 两者都是为了解决同步问题，处理资源争端而产生的技术。功能类似但有一些区别。区别如下：</p><ul><li><p>lock更灵活，可以自由定义多把锁的枷锁解锁顺序（synchronized要按照先加的后解顺序）</p></li><li><p>提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。</p></li><li><p>本质上和监视器锁（即synchronized是一样的）</p></li><li><p>能力越大，责任越大，必须控制好加锁和解锁，否则会导致灾难。</p></li><li><p>和Condition类的结合。</p></li><li><p>性能更高</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">account</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">            <span class="comment">//需要声明这个锁</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="comment">//创建一个ReentrantLock实例</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAccount</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> account;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里不再需要synchronized </span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">                lock.lock();<span class="comment">//获得锁</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    account += money;</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ｝</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>ReenreantLock &amp; Synchronized 的选择</strong></p><table><thead><tr><th>比较类型</th><th>Synchronized</th><th>ReenreantLock</th></tr></thead><tbody><tr><td>锁的实现</td><td>JVM</td><td>JDK</td></tr><tr><td>等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</td><td>不可中断</td><td>可中断</td></tr><tr><td>公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</td><td>非公平</td><td>公平&#x2F;非公平（默认）</td></tr></tbody></table><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p><p>总结：Synchronized &amp; ReentrantLock &amp; Volatile 区别<br>（1）Synchronized &amp;Volatile 区别<br>AbstractQueuedSynchronizer通过构造一个基于阻塞的CLH队列容纳所有的阻塞线程，而对该队列的操作均通过Lock-Free（CAS）操作，但对已经获得锁的线程而言，ReentrantLock实现了偏向锁的功能。<br>synchronized的底层也是一个基于CAS操作的等待队列，但JVM实现的更精细，把等待队列分为ContentionList和EntryList，目的是为了降低线程的出列速度；当然也实现了偏向锁，从数据结构来说二者设计没有本质区别。但synchronized还实现了自旋锁，并针对不同的系统和硬件体系进行了优化，而Lock则完全依靠系统阻塞挂起等待线程。<br>当然Lock比synchronized更适合在应用层扩展，可以继承AbstractQueuedSynchronizer定义各种实现，比如实现读写锁（ReadWriteLock），公平或不公平锁；同时，Lock对应的Condition也比wait&#x2F;notify要方便的多、灵活的多。</p><p>（2）Synchronized &amp; ReentrantLock 区别<br>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的<br>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性<br>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。<br>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p><p><a id="线程池"></a></p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><ul><li><p>简介</p><p>Executor接口是Executor框架的一个最基本的接口，Executor框架的大部分类都直接或间接地实现了此接口，具体实现为<code>ThreadPoolExecutor类</code>。 只有一个方法<code>void execute(Runnable command);</code>，在未来某个时间执行给定的命令。该命令可能在新的线程、已入池的线程或者正调用的线程中执行，这由 Executor 实现决定。</p></li><li><p>使用原因</p><ul><li><p>频繁创建线程和销毁线程，会很大程度上影响处理的效率（创建一个线程，执行完就销毁的时间是大于直接让一个线程直接执行任务的时间的，那么就可以借助线程池去利用闲置的线程去执行新的任务，而避免频繁创建和销毁线程）</p></li><li><p>线程并发数过多就会导致抢占资源从而导致阻塞</p><p>借助线程池可以帮助我们控制最大的线程并发数量，避免因为系统资源不足而产生阻塞的问题。</p></li><li><p>对线程进行简单的管理</p><p>比如延时执行和定时循环执行等策略就可以利用线程池进行良好的实现</p></li></ul></li><li><p>线程池的构造</p><p><img src="https://img-blog.csdnimg.cn/367f96f862764d16a5f3f2d5470f96f4.png"></p><ul><li><p>核心线程数量（corePoolSize）</p><p>如果新添加任务的时候，<strong>当前运行的线程</strong>没有达到核心线程数量(corePoolSize)，就会创建新的线程来执行添加的任务。并且，当线程当中运行的线程没有达到corePoolSize的时候，即使线程一直空闲着，也不会被销毁。</p></li><li><p>任务队列（runnableTaskQueue）</p><p><strong>运行的线程数量&gt;&#x3D;核心线程数量</strong>，就会把任务添加到这个队列当中。 </p></li><li><p>最大线程数量（maximumPoolSize）</p><p>一个线程池当中总的线程数量(maximunPoolSize)为：核心线程数量+空闲线程（可以理解空闲线程为临时工）的数量</p><p>  最大线程数量可以理解为，此时线程池已经无法再次容纳更多的线程了。如果在工作队列已经满了的情况下面，创建新的线程将使得当前运行的线程超出maximunPoolSize，将触发拒绝策略。反之，如果创建新的线程没有使得当前运行的线程超过maximunPoolSize，那么线程池就会继续创建新的线程来执行任务。</p><ul><li><p>SynchronousQueue</p><p>这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大</p></li><li><p>LinkedBlockingQueue</p><p>这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize</p></li><li><p>ArrayBlockingQueue</p><p>可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误</p></li><li><p>DelayQueue</p><p>队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务</p></li></ul></li><li><p>keepAliveTime</p><p>这个属性生效的时间在于，当运行的线程数量超过corePoolSize，并且当有线程处于空闲状态的时间超过KeepAliveTime之后，将会被销毁。</p></li><li><p>unit</p><p>  空闲线程存活时间单位，也就是keepAliveTime的单位</p></li><li><p>ThreadFactory</p><p>线程工厂，线程池创建一个新的线程时候使用的”工厂”，这个涉及到”工厂模式”.</p></li><li><p>RejectedExceptionHandler（饱和策略，也称为拒绝策略）</p><p>当队列和线程池都已经满了，说明线程池处于饱和状态，那么必须采取一系列策略来处理新提交的任务。下面，一共有4种拒绝策略：</p><ul><li>直接抛出异常（默认）</li><li>只用调用者所在线程执行任务（不再提交任务，执行者提交任务的线程来执行自己提交的任务）</li><li>丢弃队列中最近一个任务</li><li>不处理最新提交的任务</li></ul></li></ul></li><li><p>线程池的类型（下面不同类型的线程池都是直接或间接配置ThreadPoolExecutor的参数实现的）</p><ul><li><p>CachedThreadPool() 可缓存线程池</p><p>线程数无限制；有空闲线程则复用空闲线程，无则新建线程；一定程度地减少频繁创建和销毁线程，减少系统开销</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>FixedThreadPool() </p><p>可以控制线程最大并发数（同时执行的线程数）；超出的线程在队列中等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nThreads =&gt; 最大线程数即maximumPoolSize</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="type">int</span> nThreads);</span><br><span class="line"></span><br><span class="line"><span class="comment">//threadFactory =&gt; 创建线程的方法，这就是我叫你别理他的那个星期六！你还看！</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="type">int</span> nThreads, ThreadFactory threadFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ScheduledThreadPool() </p><p>支持定时及周期性任务执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="type">int</span> corePoolSize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor():</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SingleThreadExecutor() 单线程化的线程池</p><p>只能有一个工作线程执行任务；所有任务按指定顺序执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">singleThreadPool</span> <span class="operator">=</span> Executors.newSingleThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190523215623633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p></li></ul></li><li><p>线程池的停止</p><p>Executor框架提供了Java线程池的能力，ExecutorService扩展了Executor，提供了管理线程生命周期的关键能力。其中，ExecutorService.submit返回了Future对象来描述一个线程任务，它有一个cancel()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptByFuture</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;?&gt; task = es.submit(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//限定时间获取结果</span></span><br><span class="line">            task.get(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="comment">//超时触发线程中止</span></span><br><span class="line">            System.out.println(<span class="string">&quot;thread over time&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">mayInterruptIfRunning</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            task.cancel(mayInterruptIfRunning);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;   </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread stop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">            interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future的get方法可以传入时间，如果限定时间内没有得到结果，将会抛出TimeoutException。此时，可以调用Future的cancel()方法，对任务所在线程发出中断请求。<br>cancel()有个参数mayInterruptIfRunning，表示任务是否能够接收到中断。<br>mayInterruptIfRunning&#x3D;true时，任务如果在某个线程中运行，那么这个线程能够被中断；<br>mayInterruptIfRunning&#x3D;false时，任务如果还未启动，就不要运行它，应用于不处理中断的任务<br>要注意，mayInterruptIfRunning&#x3D;true表示线程能接收中断，但线程是否实现了中断不得而知。线程要正确响应中断，才能真正被cancel。<br>线程池的shutdownNow()会尝试停止池内所有在执行的线程，原理也是发出中断请求。</p></li></ul><h4 id="生产者-消费者模型实现"><a href="#生产者-消费者模型实现" class="headerlink" title="生产者-消费者模型实现"></a>生产者-消费者模型实现</h4><ul><li><p><strong>采用wait()和notify()的结合方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Multithreading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Produce produce;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Produce produce)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.produce = produce;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                produce.produce();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Produce produce;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Produce produce)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.produce = produce;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                produce.consume();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓冲区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Produce</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生产产品</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">                <span class="keyword">while</span> (list.size() &gt;= MAX_SIZE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;仓库满了&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//没满</span></span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;生产了一个产品，现有&quot;</span> + list.size() + <span class="string">&quot;件产品&quot;</span>);</span><br><span class="line">                list.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费产品</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">                <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费者是&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;仓库容量为空&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不是空可以进行消费</span></span><br><span class="line">                list.remove(<span class="number">0</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;消费了一个产品，现在还剩有产品&quot;</span> + list.size());</span><br><span class="line">                list.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Produce</span> <span class="variable">produce</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Produce</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(produce)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(produce)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(produce)).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(produce)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(produce)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(produce)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="花里胡哨问题补充"><a href="#花里胡哨问题补充" class="headerlink" title="花里胡哨问题补充"></a>花里胡哨问题补充</h4><ul><li><p>volatile部分CPU缓存一致性协议</p><p><a href="#MESI缓存一致性协议">MESI缓存一致性协议</a></p></li><li><p>volatile部分指令重排的类型和原理</p><p>指令重排看上面部分+最下面多线程部分</p></li><li><p>CAS原理和ABA问题</p></li><li><p>ThreadLocal原理和内存泄露</p></li><li><p>Object的wait和notify代码和场景相关问题</p></li><li><p>concurrent包下</p></li></ul><p><a href="https://blog.csdn.net/weixin_47071411/article/details/123625542">java锁机制详解-CSDN博客</a></p><p><a href="https://baijiahao.baidu.com/s?id=1761622931223542611&wfr=spider&for=pc">想精通Java并发？五种锁机制是你必懂的！ (baidu.com)</a></p><p><a href="https://blog.csdn.net/u013025748/article/details/105499376">线程的wait和sleep方法的区别_线程的wait和sleep区别-CSDN博客</a></p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><table><thead><tr><th></th><th>重载</th><th>重写</th></tr></thead><tbody><tr><td>位置</td><td>所有重载函数必须在同一个类中</td><td>继承关系中，子类重写父类的方法</td></tr><tr><td>特点</td><td>函数名相同，参数列表不同，其他无关</td><td>函数名相同、参数列表相同、子类的返回值类型小鱼等于父类返回值类型</td></tr></tbody></table><h4 id="七大设计原则"><a href="#七大设计原则" class="headerlink" title="七大设计原则"></a>七大设计原则</h4><ul><li><p>单一职责原则</p><p>一个类&#x3D;只有一个引起它变化的原因。（<strong>只负责担任一个职责</strong>）</p><p><em>如果一个类的职责过多，即耦合度太高&#x3D;一个职责变化会影响到其他的职责</em></p></li><li><p>开放封闭原则</p><p>一个实体（类、函数、模块等）应该对外扩展开放，对内修改关闭</p><p><em>1、即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。<br>2、符合开放封闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。</em></p></li><li><p>里氏代替原则</p><p>子类必须替换掉它们的父类型</p><p><em>1、在软件开发过程中，子类替换父类后，程序的行为是一样的。<br>2、只有当子类替换掉父类后软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。</em></p></li><li><p>依赖倒置原则</p><p>细节应该依赖于抽象，而抽象不应该依赖于细节。<br>依赖倒置的本质原则就是 ：通过抽象（接口或抽象类）使各个类或模块实现彼此独立，互不影响，实现模块间的松耦合。</p><ul><li>每个类尽量都要有接口或抽象类，或者抽象类和接口两者都具备。</li><li>变量的显示类型尽量是接口或者抽象类。</li><li>任何类尽量不从具体类派生。</li><li>尽量不要覆写基类的方法</li><li>结合里氏替换原则。 父类出现的地方子类就能出现</li></ul><p><em>所谓的的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。</em></p></li><li><p>接口隔离原则</p><p>使用多个专门功能的接口，而不是使用单一的总接口。</p><p><em>不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。</em></p></li><li><p>合成复用原则</p><p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。</p><p><em>新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成&#x2F;聚合，尽量不要使用继承。</em></p></li><li><p>最少知识原则（迪米特法则）</p><p>一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。</p><p><em>1、关于迪米特法则的其他描述：只与你直接的朋友们通信；不要跟“陌生人”说话。<br>2、外观模式（Facade Pattern)和中介者模式（Mediator Pattern）就使用了迪米特法则。</em></p></li></ul><h4 id="三大类设计模式（23种）"><a href="#三大类设计模式（23种）" class="headerlink" title="三大类设计模式（23种）"></a>三大类设计模式（23种）</h4><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/image-20240423211739681.png" alt="image-20240423211739681"></p><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/mmexport1707099938077.png"></p><h5 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h5><p>对类的实例化进行抽象。封装了具体类的信息，隐藏了类的实例化过程</p><ul><li><a href="#单例模式"><strong>单例模式</strong></a></li><li><a href="#简单工厂模式"><strong>简单工厂模式</strong></a></li><li><a href="#工厂方法模式"><strong>工厂方法模式</strong></a></li><li><a href="#抽象工厂模式"><strong>抽象工厂模式</strong></a></li><li><a href="#建造者模式"><strong>建造者模式</strong></a></li><li><a href="#原型模式"><strong>原型模式</strong></a></li></ul><p><a id="单例模式"></a></p><ul><li><p><strong>单例模式（Singleton）</strong><br>单例类必须自己创建自己的唯一实例：把类的构造方法私有化，内部进行实例化，不让外部调用构造方法实例化<br>单例类必须给所有其他对象提供这一实例：定义共有方法提供该类全局唯一访问点，外部通过调用getInstance（）方法来返回唯一实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DesignPatterns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 饿汉式</span></span><br><span class="line"><span class="comment">     * 最简单的单例实现方式。依赖JVM类加载机制，保证单例只会被创建1次，即线程安全。</span></span><br><span class="line"><span class="comment">     * JVM在类的初始化阶段(即 在Class被加载后、被线程使用前)，会执行类的初始化,</span></span><br><span class="line"><span class="comment">     * 在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*    private static SingleExample instance = new SingleExample();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //函数构造权限为私有权限，其他地方无法创建</span></span><br><span class="line"><span class="comment">    private SingleExample()&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static SingleExample getInstance() &#123;</span></span><br><span class="line"><span class="comment">        return instance;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 懒汉式（按需、延迟创建单例）</span></span><br><span class="line"><span class="comment">     * 最简单的单例实现方式。有需要时才手动创建单例，即 线程不安全。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*    private static SingleExample instance = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //函数构造权限为私有权限，其他地方无法创建</span></span><br><span class="line"><span class="comment">    private SingleExample()&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static  SingleExample newInstance() &#123;</span></span><br><span class="line"><span class="comment">        // 先判断单例是否为空，以避免重复创建</span></span><br><span class="line"><span class="comment">        if( instance == null)&#123;</span></span><br><span class="line"><span class="comment">            instance = new SingleExample();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return instance;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对懒汉式优化1</span></span><br><span class="line"><span class="comment">     * 使用同步锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*    private static SingleExample instance = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //函数构造权限为私有权限，其他地方无法创建</span></span><br><span class="line"><span class="comment">    private SingleExample()&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static synchronized SingleExample newInstance() &#123;</span></span><br><span class="line"><span class="comment">        // 先判断单例是否为空，以避免重复创建</span></span><br><span class="line"><span class="comment">        if( instance == null)&#123;</span></span><br><span class="line"><span class="comment">            instance = new SingleExample();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return instance;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对懒汉式优化2</span></span><br><span class="line"><span class="comment">     * 同时也针对同步锁的优化，因为同步锁每次访问都要进行线程同步（即 调用synchronized锁)，造成过多的同步开销（加锁 = 耗时、耗能）</span></span><br><span class="line"><span class="comment">     * 双重校验锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleExample</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数构造权限为私有权限，其他地方无法创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleExample</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  SingleExample <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先判断单例是否为空，以避免重复创建</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleExample.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleExample</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 校验锁1：第1个if</span></span><br><span class="line"><span class="comment">// 作用：若单例已创建，则直接返回已创建的单例，无需再执行加锁操作</span></span><br><span class="line"><span class="comment">// 即直接跳到执行 return ourInstance</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验锁2：第2个 if</span></span><br><span class="line"><span class="comment">// 作用：防止多次创建单例问题</span></span><br><span class="line"><span class="comment">// 原理</span></span><br><span class="line">    <span class="comment">// 1. 线程A调用newInstance()，当运行到②位置时，此时线程B也调用了newInstance()</span></span><br><span class="line">    <span class="comment">// 2. 因线程A并没有执行instance = new Singleton();，此时instance仍为空，因此线程B能突破第1层 if 判断，运行到①位置等待synchronized中的A线程执行完毕</span></span><br><span class="line">    <span class="comment">// 3. 当线程A释放同步锁时，单例已创建，即instance已非空</span></span><br><span class="line">    <span class="comment">// 4. 此时线程B 从①开始执行到位置②。此时第2层 if 判断 = 为空（单例已创建），因此也不会创建多余的实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190623095121211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p></li></ul><p><a id="简单工厂模式"></a></p><ul><li><strong>简单工厂模式(SimpleFactory Pattern)</strong></li></ul><p>通过在工厂类定义一个静态方法负责生产产品对象实例。（类似现实生活中工厂生产产品）</p><p>将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。即使用者可直接消费产品而不需要知道其生产（实例化）的细节。</p><p>优点：将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；<br>把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 &amp; 面向接口编程，而不是面向实现编程。</p><p>缺点：工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；<br>违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。<br>简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一步：创建抽象产品类，定义具体产品的公共接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第二步：创建具体产品类（继承抽象产品类），定义生产的具体产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出A产品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出B产品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">product</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="工厂方法模式"></a></p><ul><li><strong>工厂方法模式(Factory Method)</strong></li></ul><p>工厂方法模式可理解为多态工厂模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定该实例化（创建）哪一个类。</p><p>解决了简单工厂的缺点，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。</p><p>（添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；<br>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。<br>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；一个具体工厂只能创建一种具体产品）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建抽象产品类，定义具体产品的公共接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建具体产品类（继承抽象产品类），定义生产的具体产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出A产品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产出B产品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建抽象工厂类，定义具体工厂的公共接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">produce</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryB</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后续需要生产什么产品就调用哪个工厂</span></span><br></pre></td></tr></table></figure><p><a id="抽象工厂模式"></a></p><ul><li><strong>抽象工厂模式(Abastract Factory)</strong></li></ul><p>抽象工厂模式，即Abstract Factory Pattern，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。<br>抽象工厂模式与工厂方法模式最大的区别：抽象工厂中每个工厂可以创建多种类的产品；而工厂方法每个工厂只能创建一类。<br>允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦。<br>可解决工厂模式缺点：每个工厂只能创建一类产品。</p><p><img src="https://img-blog.csdnimg.cn/20190623105006994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建抽象产品族类 ，定义具体产品的公共接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建抽象产品类 ，定义具体产品的公共接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ContainerProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MouldProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建具体产品类（继承抽象产品类）， 定义生产的具体产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContainerProductA</span> <span class="keyword">extends</span> <span class="title class_">ContainerProduct</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产了容器产品A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContainerProductB</span> <span class="keyword">extends</span> <span class="title class_">ContainerProduct</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产了容器产品B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MouldProductA</span> <span class="keyword">extends</span> <span class="title class_">MouldProduct</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产了模型产品A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MouldProductB</span> <span class="keyword">extends</span> <span class="title class_">MouldProduct</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产了模型产品B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建抽象工厂类，定义具体工厂的公共接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">produceContainerProduct</span><span class="params">()</span>;<span class="comment">//生产容器产品族的产品</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">produceMouldProduct</span><span class="params">()</span>;<span class="comment">//生产模型产品族的产品</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">produceContainerProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ContainerProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">produceMouldProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MouldProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryB</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">produceContainerProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ContainerProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">produceMouldProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MouldProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂 ： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品）<br>工厂方法 ：用来生产同一等级结构中的固定产品。（支持拓展增加产品）<br>抽象工厂 ：用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）</p><p><a id="建造者模式"></a></p><ul><li><strong>建造者模式(Builder Pattern)</strong></li></ul><p>适用于一个类内部数据结构过于复杂时（用于很多数据，且组织装配复杂），通过构建者模式可以对类中的数据按部就班地创建与设置。即Builder模式可以将一个类的构建和表示进行分离。<br>创建者模式又叫建造者模式，是将一个复杂的对象的构建与它的表示分离，使<br>得同样的构建过程可以创建不同的表示。创建者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态地创建具有复合属性的对象。</p><p>如果一个类构造器需要传入很多参数的时候就可以使用Builder进行重构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未重构之前</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">(String cpu, String screen, String memory, String mainboard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">        <span class="built_in">this</span>.screen = screen;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">        <span class="built_in">this</span>.mainboard = mainboard;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重构后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewComputer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NewComputer</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = builder.cpu;</span><br><span class="line">        <span class="built_in">this</span>.screen = builder.screen;</span><br><span class="line">        <span class="built_in">this</span>.memory = builder.memory;</span><br><span class="line">        <span class="built_in">this</span>.mainboard = builder.mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String screen;</span><br><span class="line">        <span class="keyword">private</span> String memory;</span><br><span class="line">        <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">cpu</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            cpu = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">screen</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            screen = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">memory</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            memory = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">mainboard</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            mainboard = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> NewComputer <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NewComputer</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NewComputer</span> <span class="variable">newComputer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Builder</span>()</span><br><span class="line">                .cpu(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                .screen(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                .memory(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                .mainboard(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="原型模式"></a></p><ul><li><strong>原型模式(Prototype Pattern)</strong></li></ul><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。<br>适用于：</p><p>类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗。<br>通过new产生一个对象需要非常繁琐的数据准备或访问权限，这时可以使用原型模式。<br>一个对象需要供给其他对象访问，而且各个对象都需要修改其值时，可以拷贝多个对象供调用者访问，即保护性拷贝。</p><p><strong>浅拷贝和深拷贝</strong><br>浅拷贝又叫影子拷贝，上面我们在拷贝文档时并没有把原文档中的字段都重新构造了一遍，而只是拷贝了引用，也就是副文档的字段引用原始文档的字段，这样的话修改副文档中的内容就会连原始文档也改掉了，这就是浅拷贝<br>深拷贝就是在浅拷贝的基础上，对于引用类型的字段也要采用拷贝的形式，比如上面的images，而像String、int这些基本数据类型则没关系<br>所以在运用原型模式时建议大家还是用深拷贝，下面我们把上面的浅拷贝改成深拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordDocument</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">//文本</span></span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; images = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WordDocument</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---WordDocument 构造函数---&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WordDocument <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">WordDocument</span> <span class="variable">document</span> <span class="operator">=</span> (WordDocument) <span class="built_in">super</span>.clone();</span><br><span class="line">            document.text = <span class="built_in">this</span>.text;</span><br><span class="line">            <span class="comment">//document.images = this.images;</span></span><br><span class="line">            <span class="comment">//改成深拷贝</span></span><br><span class="line">            document.images = (ArrayList&lt;String&gt;) <span class="built_in">this</span>.images.clone();</span><br><span class="line">            <span class="keyword">return</span> document;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印文档内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showDocument</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//省略打印</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Intent中的原型模式</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Intent</span><span class="params">(Intent o, <span class="type">boolean</span> all)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mAction = o.mAction;</span><br><span class="line">    <span class="built_in">this</span>.mData = o.mData;</span><br><span class="line">    <span class="built_in">this</span>.mType = o.mType;</span><br><span class="line">    <span class="built_in">this</span>.mPackage = o.mPackage;</span><br><span class="line">    <span class="built_in">this</span>.mComponent = o.mComponent;</span><br><span class="line">    <span class="keyword">if</span> (o.mCategories != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.mCategories = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;String&gt;(o.mCategories);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们常用的Intent，ArrayList等<br>登录模块中保存的用户信息类需要通过服务器更新用户信息，但是有很多地方需要调用，需要设置为对其他用到的模块只读，这个时候可以考虑用原型模式进行保护性拷贝</p><h5 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h5><ul><li><p><a href="#适配器模式"><strong>适配器模式</strong></a></p></li><li><p><a href="#桥梁模式"><strong>桥梁模式</strong></a></p></li><li><p><a href="#代理模式"><strong>代理模式</strong></a></p></li><li><p><a href="#装饰模式"><strong>装饰模式</strong></a></p></li><li><p><a href="#外观模式"><strong>外观模式</strong></a></p></li></ul><p><a id="适配器模式"></a></p><ul><li><strong>适配器模式(Adapter)</strong></li></ul><p>系统需要使用现有的类，而此类的接口不符合系统的需要，即接口不兼容<br>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的一些类一起工作<br>需要一个统一的输出接口，而输入端的接口不可预知</p><p>优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p><p>缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p><p>使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p><p>注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤一：为媒体播放器和更高级的媒体播放器创建接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MediaPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String audioType,String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AdvancedMediaPlayer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playVlc</span><span class="params">(String fileName)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playMp4</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤二：创建实现了 AdvancedMediaPlayer 接口的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VlcPlayer</span> <span class="keyword">implements</span> <span class="title class_">AdvancedMediaPlayer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playVlc</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;播放vlc文件，名字为&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playMp4</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        <span class="comment">//什么都不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mp4Player</span> <span class="keyword">implements</span> <span class="title class_">AdvancedMediaPlayer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playVlc</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        <span class="comment">//什么都不做</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playMp4</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;播放mp4文件，名字为&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤三：创建实现了 MediaPlayer 接口的适配器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediaAdapter</span> <span class="keyword">implements</span> <span class="title class_">MediaPlayer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AdvancedMediaPlayer advancedMediaPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MediaAdapter</span><span class="params">(String audioType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">&quot;vlc&quot;</span>))&#123;</span><br><span class="line">            advancedMediaPlayer = <span class="keyword">new</span> <span class="title class_">VlcPlayer</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>)) &#123;</span><br><span class="line">            advancedMediaPlayer = <span class="keyword">new</span> <span class="title class_">Mp4Player</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String audioType, String fileName)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">&quot;vlc&quot;</span>))&#123;</span><br><span class="line">            advancedMediaPlayer.playVlc(fileName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>)) &#123;</span><br><span class="line">            advancedMediaPlayer.playMp4(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤四：创建实现了 MediaPlayer 接口的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AudioPlayer</span> <span class="keyword">implements</span> <span class="title class_">MediaPlayer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MediaAdapter mediaAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String audioType, String fileName)</span> &#123;</span><br><span class="line">        <span class="comment">//播放 mp3 音乐文件的内置支持</span></span><br><span class="line">        <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">&quot;mp3&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Playing mp3 file. Name: &quot;</span>+ fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//mediaAdapter 提供了播放其他文件格式的支持</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">&quot;vlc&quot;</span>)</span><br><span class="line">                || audioType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>))&#123;</span><br><span class="line">            mediaAdapter = <span class="keyword">new</span> <span class="title class_">MediaAdapter</span>(audioType);</span><br><span class="line">            mediaAdapter.play(audioType, fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Invalid media. &quot;</span>+</span><br><span class="line">                    audioType + <span class="string">&quot; format not supported&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="桥梁模式"></a></p><ul><li><strong>桥梁模式(Bridge)</strong></li></ul><p>看的有点懵逼，回头再看</p><p><a id="代理模式"></a></p><ul><li><strong>代理模式</strong></li></ul><p>看的有点懵逼，回头再看</p><p><a id="装饰模式"></a></p><ul><li><strong>装饰模式(Decorate)</strong></li></ul><p>动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类（继承）更为灵活的方案。</p><p>装饰模式主要在于扩展了类的功能。装饰模式通过在被装饰组件的方法执行之前或之后加入新的方法来实现功能的扩展.</p><p>具体应用：Android源码中的ContextWrapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建实现接口的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape: Rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape: Circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建实现了 Shape 接口的抽象装饰类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Shape decoratedShape;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShapeDecorator</span><span class="params">(Shape decoratedShape)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.decoratedShape = decoratedShape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        decoratedShape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建扩展了 ShapeDecorator 类的实体装饰类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title class_">ShapeDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedShapeDecorator</span><span class="params">(Shape decoratedShape)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(decoratedShape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        decoratedShape.draw();</span><br><span class="line">        setRedBorder(decoratedShape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setRedBorder</span><span class="params">(Shape decoratedShape)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Border Color: Red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        <span class="type">ShapeDecorator</span> <span class="variable">redCircle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedShapeDecorator</span>(<span class="keyword">new</span> <span class="title class_">Circle</span>());</span><br><span class="line">        <span class="type">ShapeDecorator</span> <span class="variable">redRectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedShapeDecorator</span>(<span class="keyword">new</span> <span class="title class_">Rectangle</span>());</span><br><span class="line">        <span class="comment">//Shape redCircle = new RedShapeDecorator(new Circle());</span></span><br><span class="line">        <span class="comment">//Shape redRectangle = new RedShapeDecorator(new Rectangle());</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Circle with normal border&quot;</span>);</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\nCircle of red border&quot;</span>);</span><br><span class="line">        redCircle.draw();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\nRectangle of red border&quot;</span>);</span><br><span class="line">        redRectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="外观模式"></a></p><ul><li><strong>外观模式(Facade Pattern)</strong></li></ul><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。<br>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。<br>用于为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相机功能接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Camera</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开相机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拍照</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takePhoto</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭相机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相机功能的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MiCamera</span> <span class="keyword">implements</span> <span class="title class_">Camera</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开相机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takePhoto</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拍照&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭相机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电话功能接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//打电话</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dail</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//挂断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hangup</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电话的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneImpl</span> <span class="keyword">implements</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dail</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hangup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;挂断&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体使用，外观</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobilePhone</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Phone</span> <span class="variable">mPhone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneImpl</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Camera</span> <span class="variable">mCamera</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MiCamera</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拍照</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takePhoto</span><span class="params">()</span> &#123;</span><br><span class="line">        mCamera.open();</span><br><span class="line">        mCamera.takePhoto();</span><br><span class="line">        mCamera.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//视频聊天</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">videoChat</span><span class="params">()</span> &#123;</span><br><span class="line">        mCamera.open();</span><br><span class="line">        mPhone.dail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MobilePhone</span> <span class="variable">mobilePhone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MobilePhone</span>();</span><br><span class="line">        mobilePhone.takePhoto();</span><br><span class="line">        mobilePhone.videoChat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：很多的第三方SDK，比如友盟统计；我们平时开发过程中封装的模块，比如网络模块、ImageLoader模块等</p><h5 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h5><ul><li><a href="#模板方法模式"><strong>模板方法模式</strong></a></li><li><a href="#观察者模式"><strong>观察者模式</strong></a></li><li><a href="#状态模式"><strong>状态模式</strong></a></li><li><a href="#策略模式"><strong>策略模式</strong></a></li><li><a href="#责任链模式"><strong>责任链模式</strong></a></li></ul><p><a id="模板方法模式"></a></p><ul><li><strong>模板方法模式(Template Method)</strong></li></ul><p>定义一个模板结构，将具体内容延迟到子类去实现。在不改变模板结构的前提下在子类中重新定义模板中的内容。<br>模板方法模式是基于”继承“的；</p><p><a id="观察者模式"></a></p><ul><li><strong>观察者模式(Observer Pattern)</strong></li></ul><table><thead><tr><th>角色</th><th>说明</th></tr></thead><tbody><tr><td>抽象主题&#x2F;被观察者（Observable）</td><td>抽象主题把所有的观察者对象的引用保存在一个集合里，每个主题可以有任意数量的观察者，抽象主题提供接口，可以增加和删除观察者对象</td></tr><tr><td>具体的主题（具体的被观察者）</td><td>也就是抽象主题的子类，该角色将有关状态存入具体观察者对象，在具体主题内部状态发生改变时，通知所有注册过的观察者</td></tr><tr><td>抽象观察者</td><td>观察者的抽象类，定义了一个更新的接口</td></tr><tr><td>具体观察者</td><td>实现了抽象观察者的更新接口，在被观察者状态发生变化时更新自身的状态</td></tr></tbody></table><p>观察者模式通过将主题和观察者解耦，实现了对象之间的松耦合。当主题的状态发生改变时，所有依赖于它的观察者都会收到通知并进行相应的更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.创建Subject类（被观察者）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt;observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        notifyAllObservers();<span class="comment">//state发生变化，通知</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer:observers)&#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2.创建Observer类（抽象观察者）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3.创建具体观察者类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println( <span class="string">&quot;Binary String: &quot;</span></span><br><span class="line">                + Integer.toBinaryString( subject.getState() ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OctalObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OctalObserver</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Octal String: &quot;</span></span><br><span class="line">                + Integer.toOctalString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HexaObserver</span> <span class="keyword">extends</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HexaObserver</span><span class="params">(Subject subject)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">        <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println( <span class="string">&quot;Hex String: &quot;</span></span><br><span class="line">                + Integer.toHexString( subject.getState() ).toUpperCase() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HexaObserver</span>(subject);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">OctalObserver</span>(subject);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BinaryObserver</span>(subject);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;First state change: 15&quot;</span>);</span><br><span class="line">        subject.setState(<span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Second state change: 10&quot;</span>);</span><br><span class="line">        subject.setState(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="状态模式"></a></p><ul><li><strong>状态模式(State Pattern)</strong></li></ul><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。<br>当代码中包含着大量与对象状态有关的条件语句。此时对象行为依赖于它的状态（属性），并可以根据它的状态改变它的相关行为。</p><p>优点： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p><p>缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p><p>使用场景： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。</p><p>注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录状态接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">forward</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 评论</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">comment</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体接口实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginState</span> <span class="keyword">implements</span> <span class="title class_">UserState</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forward</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;转发成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">comment</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;评论成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未登录状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnLoginState</span> <span class="keyword">implements</span> <span class="title class_">UserState</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forward</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">comment</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserState</span> <span class="variable">userState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnLoginState</span>();<span class="comment">//默认未登录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">LoginContext</span> <span class="variable">loginContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginContext</span>();<span class="comment">//单例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LoginContext</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LoginContext <span class="title function_">getLoginContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loginContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态改变，设置状态</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userState 状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserState</span><span class="params">(UserState userState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userState = userState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forward</span><span class="params">()</span> &#123;</span><br><span class="line">        userState.forward();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">comment</span><span class="params">()</span> &#123;</span><br><span class="line">        userState.comment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LoginContext</span> <span class="variable">loginContext1</span> <span class="operator">=</span> getLoginContext();</span><br><span class="line">        <span class="comment">//未登录</span></span><br><span class="line">        loginContext1.comment();</span><br><span class="line">        <span class="comment">//登录后</span></span><br><span class="line">        loginContext1.setUserState(<span class="keyword">new</span> <span class="title class_">LoginState</span>());</span><br><span class="line">        loginContext1.comment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="策略模式"></a></p><ul><li><strong>策略模式(Stratege Pattern)</strong></li></ul><p>状态模式和策略模式的结构几乎完全一样，但它们的目的、本质却完全不一样。状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立、可相互替换的。用一句话来表述，状态模式把对象的行为包装在不同的状态对象里，每一个状态对象都有一个共同的抽象状态基类。状态模式的意图是让一个对象在其内部状态发生改变的时候，其行为也随之改变</p><p>状态模式：状态模式关注对象的内部状态改变，并相应地改变对象的行为。它将状态的管理和对象的行为解耦，使得状态变化不会导致对象行为的复杂性增加。<br>策略模式：策略模式关注对象的行为的变化，并提供了一种灵活的方式来选择不同的行为或算法。它将算法的选择和使用从对象中解耦，使得算法的变化不会影响到对象的使用者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CalculateStragety</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据公里数计算价格</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> km 公里数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">calculatePrice</span><span class="params">(<span class="type">int</span> km)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusStragety</span> <span class="keyword">implements</span> <span class="title class_">CalculateStragety</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 十公里之内一元，超过十公里每加一元钱可以坐5公里</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> km 公里数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公交车车费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculatePrice</span><span class="params">(<span class="type">int</span> km)</span> &#123;</span><br><span class="line">        <span class="comment">//超过十公里的总距离</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">extraTotal</span> <span class="operator">=</span> km - <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超过的距离是5公里的倍数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">extraFactor</span> <span class="operator">=</span> extraTotal / <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//超过的距离对5公里取余</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">fraction</span> <span class="operator">=</span> extraTotal % <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//价格计算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">1</span> + extraFactor * <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fraction &gt; <span class="number">0</span> ? ++price : price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaxiStragety</span> <span class="keyword">implements</span> <span class="title class_">CalculateStragety</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出租车车费为每公里2元</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> km 公里数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 出租车车费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculatePrice</span><span class="params">(<span class="type">int</span> km)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> km * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrafficCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TrafficCalculator</span> <span class="variable">trafficCalculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrafficCalculator</span>();</span><br><span class="line">        trafficCalculator.setCalculateStragety(<span class="keyword">new</span> <span class="title class_">BusStragety</span>());</span><br><span class="line">        trafficCalculator.calculatePrice(<span class="number">66</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CalculateStragety mCalculateStragety;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据需要注入相应的策略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> calculateStragety 注入的策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCalculateStragety</span><span class="params">(CalculateStragety calculateStragety)</span> &#123;</span><br><span class="line">        mCalculateStragety = calculateStragety;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把具体的计算委托给注入的策略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> km 公里数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 车费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calculatePrice</span><span class="params">(<span class="type">int</span> km)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mCalculateStragety.calculatePrice(km);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="责任链模式"></a></p><ul><li><strong>责任链模式(Chain of Responsibility Pattern)</strong></li></ul><p>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p>优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。</p><p>缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。</p><p>使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建抽象的记录器类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractLogger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">INFO</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEBUG</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ERROR</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//责任链中的下一个元素</span></span><br><span class="line">    <span class="keyword">protected</span> AbstractLogger nextLogger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nextLogger = nextLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logMessage</span><span class="params">(<span class="type">int</span> level, String message)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.level &lt;= level)&#123;</span><br><span class="line">            write(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nextLogger !=<span class="literal">null</span>)&#123;</span><br><span class="line">            nextLogger.logMessage(level, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String message)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建扩展了该记录器类的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title class_">AbstractLogger</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConsoleLogger</span><span class="params">(<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Standard Console::Logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorLogger</span> <span class="keyword">extends</span> <span class="title class_">AbstractLogger</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ErrorLogger</span><span class="params">(<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Error Console::Logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">AbstractLogger</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;File::Logger: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChainPatternDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AbstractLogger <span class="title function_">getChainOfLoggers</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AbstractLogger</span> <span class="variable">errorLogger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorLogger</span>(AbstractLogger.ERROR);</span><br><span class="line">        <span class="type">AbstractLogger</span> <span class="variable">fileLogger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>(AbstractLogger.DEBUG);</span><br><span class="line">        <span class="type">AbstractLogger</span> <span class="variable">consoleLogger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsoleLogger</span>(AbstractLogger.INFO);</span><br><span class="line"></span><br><span class="line">        errorLogger.setNextLogger(fileLogger);</span><br><span class="line">        fileLogger.setNextLogger(consoleLogger);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> errorLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractLogger</span> <span class="variable">loggerChain</span> <span class="operator">=</span> getChainOfLoggers();</span><br><span class="line"></span><br><span class="line">        loggerChain.logMessage(AbstractLogger.INFO, <span class="string">&quot;This is an information.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        loggerChain.logMessage(AbstractLogger.DEBUG,</span><br><span class="line">                <span class="string">&quot;This is a debug level information.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        loggerChain.logMessage(AbstractLogger.ERROR,</span><br><span class="line">                <span class="string">&quot;This is an error information.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Android知识"><a href="#Android知识" class="headerlink" title="Android知识"></a>Android知识</h2><h3 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h3><h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><p>看到讲解<strong>Activity启动过程</strong>的部分，时间有限没有细看，后面回头看</p><p><strong>Activity的四种启动方式</strong>浅看了，后面回头</p><p><strong>完全退出应用</strong>部分了解</p><p><img src="https://img-blog.csdnimg.cn/20190915145659832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p>onRestoreInstanceState的bundle参数也会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。</p><p>只有有id的组件自动保存状态</p><p>四种状态，七个方法</p><p>活动状态（Running&#x2F;Active）、暂停状态（Paused）、停止状态（Stopped）、销毁状态（Killed）</p><p>onCreate、onStart、onResume、onPause、onStop、onDestory、onRestart</p><p><strong>启动Activity流程图</strong></p><p><img src="https://img-blog.csdnimg.cn/20190526094633844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p><a href="https://blog.csdn.net/weixin_44008788/article/details/130091555">Android系统重要组件AMS_android ams-CSDN博客</a></p><p><strong>保存状态的生命周期图</strong></p><p><img src="https://img-blog.csdnimg.cn/20190520080227609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p><strong>生命周期</strong></p><p><img src="https://img-blog.csdnimg.cn/20190520202425279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p><strong>生命周期常用方法</strong><br>1、4个手动调用方法<br>startService() 启动服务<br>stopService() 关闭服务<br>bindService() 绑定服务<br>unbindService() 解绑服务<br>2、5个内部自动调用方法<br>onCreat() 创建服务<br>onStartCommand() 开始服务<br>onDestroy() 销毁服务<br>onBind() 绑定服务<br>onUnbind() 解绑服务</p><p><a href="https://blog.csdn.net/LINDAMAN00/article/details/98333095">startService()和bindService()的区别_startservice和bindservice区别-CSDN博客</a></p><p>简而言之就是不使用具体的Service里面的方法就不需要绑定Service，只需要让他自己在后台运行即可，要使用里面的具体方法就需要绑定Service，在onBind的回调会返回IBinder对象，就能调用Service里面的方法，另外，只要使用了bindService，不管之后是否解绑和停止服务，都可以调用服务中的方法，Service是UI线程</p><p><strong>分类</strong></p><p>可通信服务和不可通信服务</p><p><strong>ServiceConnection()</strong></p><p>前台服务和后台服务</p><p>本地服务和远程服务</p><p><strong>AndroidManifest.xml中Service元素常见属性</strong><br>1、android:name: 服务类名。可以是完整的包名+类名。也可使用. 代替包名。<br>2、android:exported: 其他应用能否访问该服务，如果不能，则只有本应用或有相同用户ID的应用能访问。默认为false。<br>3、android:process: 服务所运行的进程名。默认是在当前进程下运行，与包名一致。<br>4、android:permission: 申请使用该服务的权限，如果没有配置下相关权限，服务将不执行</p><p><strong>IntentService</strong></p><p>这是一个基于消息的服务，每次启动该服务并不是马上处理你的工作，而是首先会创建对应的Looper，Handler并且在MessageQueue中添加的附带客户Intent的Message对象，当Looper发现有Message的时候接着得到Intent对象通过在onHandleIntent((Intent)msg.obj)中调用你的处理程序，处理完后即会停止自己的服务，意思是Intent的生命周期跟你的处理的任务是一致的，所以这个类用下载任务中非常好，下载任务结束后服务自身就会结束退出。</p><p><strong>IntentService与service的区别</strong><br>IntentService是继承并处理异步请求的一个类，在IntentService内有一个工作线程来处理耗时操作，启动IntentService的方式和启动传统的Service一样，同时，当任务执行完后，IntentService会自动停止，而不需要我们手动去控制或stopSelf()。<br>另外，可以启动IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推。它本质上就是一个封装了HandlerThread+Handler的异步框架</p><h4 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h4><p>系统广播（BoardcastReceiver）源码分析<br>广播接受者BoardcastReceiver，并重写onReceive()方法，通过Binder 机制在AMS注册<br>广播发送者 通过Binder 机制向AMS发送广播<br>AMS根据广播发送者要求，在已注册列表中，寻找合适的广播接收器（寻找依据：IntentFilter）并将广播发送到合适的广播接受者相应的消息循环队列中<br>广播接受者通过消息循环，拿到此广播，并回调onReceive()方法。<br><strong>其中广播发送者与广播接受者的执行是异步的，即广播发送者不会关心有无接受者接收&amp;也不确定接受者何时才能接收到。</strong></p><p>本地广播（LocalBoardcastManager）的源码</p><p>构造函数是基于主线程的Looper新建了一个Handler，handleMessage中会调用接收器对广播的信息进行处理，也是LocalBroadcastManager 的核心部分</p><p>注册接收器部分，mReceivers 存储广播和过滤器信息，以BroadcastReceiver作为 key，IntentFilter链表作为 value。mReceivers 是接收器和IntentFilter的对应表，主要作用是方便在unregisterReceiver(…)取消注册，同时作为对象锁限制注册接收器、发送广播、取消接收器注册等几个过程的并发访问。<br>mActions 以Action为 key，注册这个Action的BroadcastReceiver链表为 value。mActions 的主要作用是方便在广播发送后快速得到可以接收它的BroadcastReceiver。</p><p>发送广播部分，先根据Action从mActions中取出ReceiverRecord列表，循环每个ReceiverRecord判断 filter 和 intent 中的 action、type、scheme、data、categoried 是否 match（intentFilter的match机制），是的话则保存到receivers列表中，发送 what 为MSG_EXEC_PENDING_BROADCASTS的消息，通过 Handler 去处理。 </p><p>  消息处理部分，mPendingBroadcasts转换为数组BroadcastRecord，循环每个receiver，调用其onReceive函数，这样便完成了广播的核心逻辑。</p><p>取消注册部分，从mReceivers及mActions中移除相应元素。</p><p>(1) LocalBroadcastManager 的核心实现实际还是 Handler，只是利用到了 IntentFilter 的 match 功能，至于 BroadcastReceiver 换成其他接口也无所谓，顺便利用了现成的类和概念而已。<br>(2) 因为是 Handler 实现的应用内的通信，自然安全性更好，效率更高。</p><p>本地广播发送的广播只在自身app传播。不必担心隐私数据泄露。<br>其他app无法对该app发送广播。不必担心安全漏洞的利用。<br>本地广播更加高效、安全。</p><p>高效：因为它内部是通过Handler实现的，它的sendBroadcast()方法含义并非和系统的sendBroadcast()一样，它的sendBroadcast()方法其实就是通过Handler发送了一个Message而已。<br>安全：既然它是通过Handler实现广播发送的，那么相比系统广播通过Binder机制实现那肯定更加高效，同时使用Handler来实现，别的app无法向我们应用发送该广播，而我们app内部发送的广播也不会离开我们的app。</p><p>LocalBroadcast内部协作主要是靠两个Map集合：mReceivers和mActions,当然还有一个List集合mPendingBroadcasts,这个主要存储待</p><h4 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h4><p><strong>Android中的Binder机制</strong></p><p>Binder是一种Android中实现跨进程通信（IPC）的方式</p><p><img src="https://img-blog.csdnimg.cn/20190520213431718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p><strong>ContentProvider类</strong></p><p>ContentProvider主要以表格形式组织数据（表、记录、字段）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs,  String sortOrder)</span>　<span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span></span><br><span class="line"><span class="comment">// ContentProvider创建后 或 打开系统后其它进程第一次访问该ContentProvider时 由系统进行调用</span></span><br><span class="line"><span class="comment">// 注：运行在ContentProvider进程的主线程，故不能做耗时操作</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">(Uri uri)</span></span><br><span class="line"><span class="comment">// 得到数据类型，即返回当前 Url 所代表数据的MIME类型    </span></span><br></pre></td></tr></table></figure><p><strong>ContentResolver类</strong></p><p>统一管理不同 ContentProvider间的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span>　</span><br><span class="line"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span></span><br><span class="line"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>　</span><br><span class="line"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span><br><span class="line"><span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span></span><br></pre></td></tr></table></figure><p><strong>ContentUris类</strong></p><p>操作URI</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//withAppendedId（）作用：向URI追加一个id</span></span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://cn.scu.myprovider/user&quot;</span>)</span><br><span class="line"><span class="type">Uri</span> <span class="variable">resultUri</span> <span class="operator">=</span> ContentUris.withAppendedId(uri, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// 最终生成后的Uri为：content://cn.scu.myprovider/user/7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parseId（）作用：从URL中获取ID</span></span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://cn.scu.myprovider/user/7&quot;</span>)</span><br><span class="line"><span class="type">long</span> <span class="variable">personid</span> <span class="operator">=</span> ContentUris.parseId(uri);</span><br><span class="line"><span class="comment">//获取的结果为:7</span></span><br></pre></td></tr></table></figure><p><strong>UriMatcher类</strong></p><ul><li>在ContentProvider中注册URI</li><li>根据URI匹配ContentProvider对应的数据表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：初始化UriMatcher对象</span></span><br><span class="line">    <span class="type">UriMatcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UriMatcher</span>(UriMatcher.NO_MATCH);</span><br><span class="line">    <span class="comment">//常量UriMatcher.NO_MATCH  = 不匹配任何路径的返回码</span></span><br><span class="line">    <span class="comment">// 即初始化时不匹配任何东西</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：在ContentProvider 中注册URI（addURI（））</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">URI_CODE_a</span> <span class="operator">=</span> <span class="number">1</span>；</span><br><span class="line">        <span class="type">int</span> <span class="variable">URI_CODE_b</span> <span class="operator">=</span> <span class="number">2</span>；</span><br><span class="line">        matcher.addURI(<span class="string">&quot;cn.scu.myprovider&quot;</span>, <span class="string">&quot;user1&quot;</span>, URI_CODE_a);</span><br><span class="line">        matcher.addURI(<span class="string">&quot;cn.scu.myprovider&quot;</span>, <span class="string">&quot;user2&quot;</span>, URI_CODE_b);</span><br><span class="line"><span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user1 ，则返回注册码URI_CODE_a</span></span><br><span class="line"><span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user2 ，则返回注册码URI_CODE_b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match（））</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">(Uri uri)</span> &#123;</span><br><span class="line">        <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot; content://cn.scu.myprovider/user1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(matcher.match(uri))&#123;</span><br><span class="line">        <span class="comment">// 根据URI匹配的返回码是URI_CODE_a</span></span><br><span class="line">        <span class="comment">// 即matcher.match(uri) == URI_CODE_a</span></span><br><span class="line">        <span class="keyword">case</span> URI_CODE_a:</span><br><span class="line">        <span class="keyword">return</span> tableNameUser1;</span><br><span class="line">        <span class="comment">// 如果根据URI匹配的返回码是URI_CODE_a，则返回ContentProvider中的名为tableNameUser1的表</span></span><br><span class="line">        <span class="keyword">case</span> URI_CODE_b:</span><br><span class="line">        <span class="keyword">return</span> tableNameUser2;</span><br><span class="line">        <span class="comment">// 如果根据URI匹配的返回码是URI_CODE_b，则返回ContentProvider中的名为tableNameUser2的表</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>ContentObserver类</strong></p><p>观察 Uri引起 ContentProvider 中的数据变化 &amp; 通知外界（即访问该数据访问者）：当ContentProvider 中的数据发生变化（增、删 &amp; 改）时，就会触发该 ContentObserver类通知数据变化<br>适用场景：需要频繁检测的数据库或者某个数据是否发生改变，如果使用线程去操作，很不经济而且很耗时 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：注册内容观察者ContentObserver</span></span><br><span class="line">    getContentResolver().registerContentObserver（uri）；</span><br><span class="line"><span class="comment">// 通过ContentResolver类进行注册，并指定需要观察的URI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：当该URI的ContentProvider数据发生变化时，通知外界（即访问该ContentProvider数据的访问者）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContentProvider</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span> &#123;</span><br><span class="line">        db.insert(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;userid&quot;</span>, values);</span><br><span class="line">        getContext().getContentResolver().notifyChange(uri, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 通知访问者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 步骤3：解除观察者</span></span><br><span class="line">    getContentResolver().unregisterContentObserver（uri）；</span><br><span class="line"><span class="comment">// 同样需要通过ContentResolver类进行解除</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来观察系统里短消息的数据库变化 ”表“内容观察者,只要信息数据库发生变化，都会触发该ContentObserver 派生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSContentObserver</span> <span class="keyword">extends</span> <span class="title class_">ContentObserver</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;SMSContentObserver&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">MSG_OUTBOXCONTENT</span> <span class="operator">=</span> <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">private</span> Context mContext ;</span><br><span class="line"><span class="keyword">private</span> Handler mHandler ; <span class="comment">//用Handler更新UI线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SMSContentObserver</span><span class="params">(Context context,Handler handler)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(handler);</span><br><span class="line">mContext = context ;</span><br><span class="line">mHandler = handler ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当所监听的Uri中数据发生变化回收，就会回调该方法。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChange</span><span class="params">(<span class="type">boolean</span> selfChange)</span>&#123;</span><br><span class="line">Log.i(TAG, <span class="string">&quot;the sms table has changed&quot;</span>);</span><br><span class="line"><span class="comment">//查询发件箱里的内容</span></span><br><span class="line"><span class="type">Uri</span> <span class="variable">outSMSUri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://sms/sent&quot;</span>) ;</span><br><span class="line"><span class="type">Cursor</span> <span class="variable">c</span> <span class="operator">=</span> mContext.getContentResolver().query(outSMSUri, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>,<span class="string">&quot;date desc&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(c != <span class="literal">null</span>)&#123;</span><br><span class="line">Log.i(TAG, <span class="string">&quot;the number of send is&quot;</span>+c.getCount()) ;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>() ;</span><br><span class="line"><span class="comment">//循环遍历</span></span><br><span class="line"><span class="keyword">while</span>(c.moveToNext())&#123;</span><br><span class="line"><span class="comment">// sb.append(&quot;发件人手机号码: &quot;+c.getInt(c.getColumnIndex(&quot;address&quot;)))</span></span><br><span class="line"><span class="comment">// .append(&quot;信息内容: &quot;+c.getInt(c.getColumnIndex(&quot;body&quot;)))</span></span><br><span class="line"><span class="comment">// .append(&quot;是否查看: &quot;+c.getInt(c.getColumnIndex(&quot;read&quot;)))</span></span><br><span class="line"><span class="comment">// .append(&quot;发送时间： &quot;+c.getInt(c.getColumnIndex(&quot;date&quot;)))</span></span><br><span class="line"><span class="comment">// .append(&quot;\n&quot;);</span></span><br><span class="line">sb.append(<span class="string">&quot;发件人手机号码: &quot;</span>+c.getInt(c.getColumnIndex(<span class="string">&quot;address&quot;</span>)))</span><br><span class="line">.append(<span class="string">&quot;信息内容: &quot;</span>+c.getString(c.getColumnIndex(<span class="string">&quot;body&quot;</span>)))</span><br><span class="line">.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">c.close();</span><br><span class="line">mHandler.obtainMessage(MSG_OUTBOXCONTENT, sb.toString()).sendToTarget();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>看具体样例</strong></p><h4 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h4><h5 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h5><p>Android中提供了Intent机制来协助应用间的交互与通讯，或者采用更准确的说法是，Intent不仅可用于应用程序之间，也可用于应用程序内部的activity, service和broadcast receiver之间的交互。Intent这个英语单词的本意是“目的、意向、意图”。<br>  Intent是一种运行时绑定（runtime binding)机制，它能在程序运行的过程中连接两个不同的组件。Intent负责对应应用中一次操作的动作、动作涉及数据、附加数据进行描述，通过Intent，你的程序可以向Android表达某种请求或者意愿，Android会根据意愿的内容选择适当的组件来响应。因此，Intent在这里起着一个媒体中介的作用，专门提供组件互相调用的相关信息，实现调用者与被调用者之间的解耦。</p><p><a href="https://blog.csdn.net/weixin_43183328/article/details/115218139">Intent_intent-filter多个action-CSDN博客</a></p><p><strong>Activity跳转作用</strong></p><p>显式意图和隐式意图</p><p>隐式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;net.loonggg.intent.SecondActivity&quot;</span> &gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">&lt;!-- 自定义的动作 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;net.loonggg.xxx&quot;</span> /&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 自定义的scheme和host --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">data</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">android:host</span>=<span class="string">&quot;www.baidu.com&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">android:path</span>=<span class="string">&quot;/person&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">android:scheme</span>=<span class="string">&quot;loonggg&quot;</span> /&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 自定义的类型 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">&quot;person/people&quot;</span> /&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 附加信息 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(View view)</span> &#123;</span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction(<span class="string">&quot;net.loonggg.xxx&quot;</span>);<span class="comment">//设置Intent的动作为清单指定的action</span></span><br><span class="line">intent.addCategory(<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>);<span class="comment">//与清单相同的category</span></span><br><span class="line">intent.setDataAndType(Uri.parse(<span class="string">&quot;loonggg://www.baidu.com/person&quot;</span>),</span><br><span class="line"><span class="string">&quot;person/people&quot;</span>);</span><br><span class="line">startActivity(intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>setData、setDataAndType、setType 这三种方法只能单独使用，不可共用。 intent.setData(data)和intent.setType(type)注意这两个方法会互相清除，意思就是：如果先设置setData(data)后设置setType(type)，那么后设置的setType(type)会把前面setData(data)设置的内容清除掉，而且会报错，反之一样，所以如果既要设置类型与数据，那么使用setDataAndType(data,type)这个方法。</code></p><p><strong>Intent传输数据作用</strong></p><p>基本数据类型</p><p>Bundle类型</p><p>Serializable和Parcelable</p><p>Serializable的作用是为了保存对象的属性到本地文件、数据库、网络流、rmi以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的。<br>对于对于Serializable，类只需要实现Serializable接口，并提供一个序列化版本id(serialVersionUID)即可<br>（Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。添加serialVersionUID使得在序列化时保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。）</p><p>Android的Parcelable的设计初衷是因为Serializable效率过慢，为了在程序内不同组件间以及不同Android程序间(AIDL)高效的传输数据而设计，这些数据仅在内存中存在，Parcelable是通过IBinder通信的消息的载体。</p><p>Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据，而Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化。</p><p>总结：所以在传递对象时对于需要传递的对象的序列化选择可以加以区分，需要数据持久化的建议实现Serializable接口，只在内存间数据传输时推荐使用Parcelable。</p><h5 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h5><p><strong>实现</strong></p><p>创建模式：单例模式</p><p>整个应用程序只有一个Application对象，每个App都有一个Application实例</p><p>实例模式：全局实例</p><p>不同组件都可以获得Application对象且都是同一对象</p><p>生命周期：等于Android App的生命周期</p><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><p><strong>生命周期</strong></p><p><img src="https://img-blog.csdnimg.cn/20190521200756157.png"></p><p>1、 onAttach：Fragment和Activity建立关联的时候调用，可以获得对应的Context或Activity，这里拿到的Activity是mHost.getActivity()<br>2、 onCreate：Fragment对象初始创建，用于执行初始化操作。<br>由于Fragment的onCreate调用时，关联的Activity可能没有创建好，所以不要有依赖外部Activity布局的操作。<strong>依赖Activity的操作可以放在onActivityCreate中</strong>。<br>3、 onCreateView：为Fragment创建视图（加载布局）时调用（给当前的fragment绘制UI布局，可以使用线程更新UI）<br>4、 onActivityCreated：当与Fragment关联的Activity中的onCreate方法执行完后调用（表示activity执行onCreate方法完成了的时候会调用此方法）<br>这个方法里做些和布局、状态恢复有关的操作，如<br>onViewStateRestored(Bundle)用于一个Fragment在从就状态回复，获取saveInstanceState恢复状态。<br>以上4步同步于Activity的onCreate<br>5、 onStart：Fragment可见时调用，将Fragment对象显示给用户。同步于Activity的onStart<br>6、 onResume：Fragment对象可见并可与用户交互时调用。同步于Activity的onResume<br>7、 onPause：Fragment对象与用户不再交互。同步于Activity的onPause<br>8、 onStop：Fragment对象不再显示给用户。同步于Activity的onStop<br>9、 onDestroyView：Fragment中的布局被移除时调用（表示fragment销毁相关联的UI布局）<br>10、onDestroy：Fragment状态清理完成<br>11、 onDetach：Fragment和Activity解除关联的时候调用（脱离activity）</p><ul><li><p>fragment被创建</p><p>onAttach()–&gt;onCreate()–&gt;onCreateView()–&gt;onActivityCreated()</p></li><li><p>fragment显示</p><p>onStart()–&gt;onResume()</p></li><li><p>fragment进入后台模式（进入后台只走到onDestroyView()）</p><p>onPause()–&gt;onStop()–&gt;onDestroyView()</p></li><li><p>fragment被销毁（持有它的activity被销毁）</p><p>onPause()–&gt;onStop()–&gt;onDestroyView()–&gt;onDestroy()–&gt;onDetach()</p></li><li><p>fragment重新恢复</p><p>onCreateView()–&gt;onActivityCreated()–&gt;onStart()–&gt;onResume()</p></li></ul><p><strong>与Activity生命周期对比</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/5dc236552ca47705415114c5f61bdf7a.png"></p><p>当activity处于Resumed状态时，可以自由地添加和移除fragment，也即是说，只有activity在Resumed状态时，fragment的状态可以独立改变。<br>但是，当activity离开Resumed状态，fragment的生命周期被activity控制。</p><p><strong>事实上，Fragment的生命周期除了它第一次创建或销毁之外，都是由Activity启动。</strong></p><p>也就是在Activity启动会执行onCreate()，Fragment会执行onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()，后面其他的生命周期方法Fragment都跟在Activity后面，Activity执行那么Fragment也会执行相应的代码</p><p>特别的：</p><p>正常销毁（后退键返回）</p><p>Activity:onPause()<br>Fragment:onPause()</p><p>Activity:onSaveInstanceState()<br>Fragment:onSaveInstanceState()</p><p>Activity:onStop()<br>Fragment:onStop()</p><p>Activity:onStop()<br>Fragment:onStop()</p><p>特殊部分</p><p>Fragment:onDestroyView()<br>Activity:onDestroy()<br>Fragment:onDestroy()<br>Fragment:onDetach()</p><p>后台意外销毁和返回（横竖屏切换）</p><p>Activity:onPause()<br>Fragment:onPause()</p><p>Activity:onSaveInstanceState()<br>Fragment:onSaveInstanceState()</p><p>Activity:onStop()<br>Fragment:onStop()</p><p>Fragment:onDestroyView()<br>Activity:onDestroy()<br>Fragment:onDestroy()<br>Fragment:onDetach()</p><p>Activity:onCreate()<br>Fragment:onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()</p><p>Activity:onStart()<br>Fragment:onStart()</p><p>Activity:onRestoreInstanceState()</p><p>Activity:onResume()<br>Fragment:onResume()</p><p>Activity会额外执行一个还原状态的方法onRestoreInstanceState，介于onStart和onResume之间</p><p><strong>切换Fragment的方法</strong></p><ul><li><p>通过add、hide、show方式切换Fragment时所有的view都会保存在内存，不会销毁与重建（构建好后切换只需自动调用**onHiddenChanged()**方法）（add后只是隐藏而不是销毁视图再重建，对于使用频率很高的Fragement，使用该方式的性能会更高）</p></li><li><p>通过 replace 方法进行替换的时，Fragment 都是进行了销毁，重建的过程，相当于走了一整套的生命周期（切换会自动走所有的生命周期）</p></li><li><p>使用ViewPager（构建好后切换自动调用setUserVisVleHint(true)，true就显示，false不可见进行切换，进行懒加载要调用了onCreateView（）方法进行标记判断，加标志位）</p><p>使用ViewPager与Fragment切换时，Fragment会进行预加载操作，即所有的Fragment都会提前初始化<strong>setUserVisVleHint（）</strong>方法在 Fragment 1 第一次加载的时候不走，只有在切换的时候 走该方法。<br>主动调用 setUserVisibleHint（）方法来控制第一次不会调用setUserVisibleHint方法的问题</p><p>setUserVisibleHint（）方法优先onCreateView方法，当onCreateView方法调用后还会再次调用setUserVisibleHint方法。此时要对是否调用了onCreateView（）方法进行标记判断。</p></li></ul><p><strong>一些相关类和接口</strong></p><ul><li>FragmentManager 是一个抽象类，定义了一些和 Fragment 相关的操作和内部类&#x2F;接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> FragmentTransaction <span class="title function_">beginTransaction</span><span class="params">()</span>;<span class="comment">//开启一系列对 Fragments 的操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">executePendingTransactions</span><span class="params">()</span>;<span class="comment">//FragmentTransaction.commit() 是异步执行的，如果你想立即执行，可以调用这个方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Fragment <span class="title function_">findFragmentById</span><span class="params">(<span class="meta">@IdRes</span> <span class="type">int</span> id)</span>;<span class="comment">//根据 ID 找到从 XML 解析出来的或者事务中添加的 Fragment</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Fragment <span class="title function_">findFragmentByTag</span><span class="params">(String tag)</span>;<span class="comment">//跟上面的类似，不同的是使用 tag 进行查找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">popBackStack</span><span class="params">()</span>;<span class="comment">//弹出回退栈中栈顶的 Fragment，异步执行的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">popBackStackImmediate</span><span class="params">()</span>;<span class="comment">//立即弹出回退栈中栈顶的，直接执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">popBackStack</span><span class="params">(String name, <span class="type">int</span> flags)</span>;<span class="comment">//返回栈顶符合名称的，如果传入的 name 不为空，在栈中间找到了 Fragment，那将弹出这个 Fragment 上面的所有 Fragment（类似singleTask）异步执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">popBackStackImmediate</span><span class="params">(String name, <span class="type">int</span> flags)</span>;<span class="comment">//同上，同步执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">popBackStack</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">popBackStackImmediate</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getBackStackEntryCount</span><span class="params">()</span>;<span class="comment">//获取回退栈中的元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> BackStackEntry <span class="title function_">getBackStackEntryAt</span><span class="params">(<span class="type">int</span> index)</span>;<span class="comment">//根据索引获取回退栈中的某个元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addOnBackStackChangedListener</span><span class="params">(OnBackStackChangedListener listener)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">removeOnBackStackChangedListener</span><span class="params">(OnBackStackChangedListener listener)</span>;<span class="comment">//添加或者移除一个监听器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">putFragment</span><span class="params">(Bundle bundle, String key, Fragment fragment)</span>;<span class="comment">//还定义了将一个 Fragment 实例作为参数传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Fragment <span class="title function_">getFragment</span><span class="params">(Bundle bundle, String key)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Fragment&gt; <span class="title function_">getFragments</span><span class="params">()</span>;<span class="comment">//获取 manager 中所有添加进来的 Fragment</span></span><br></pre></td></tr></table></figure><ul><li><p>BackStackEntry：Fragment 后退栈中的一个元素。</p></li><li><p>onBackStackChangedListener：后退栈变动监听器，回退栈中有变化时调用。</p></li><li><p>FragmentLifecycleCallbacks: FragmentManager 中所有的 Fragment 生命周期监听。</p></li><li><p>FragmentManager 定义的任务是由 FragmentManagerImpl 实现的。</p></li><li><p>FragmentTransaction事务</p><p>通过FragmentManager获取FragmentTransaction，beginTransaction() 返回一个新的 BackStackRecord （BackStackRecord 既是对 Fragment 进行操作的事务的真正实现，也是 FragmentManager 中的回退栈的实现），继承自FragmentTransaction</p><ul><li><p>commit() 在主线程中异步执行，其实也是 Handler 抛出任务，等待主线程调度执行。（commit() 需要在宿主 Activity 保存状态之前调用，否则会报错。<br>这是因为如果 Activity 出现异常需要恢复状态，在保存状态之后的 commit() 将会丢失，这和调用的初衷不符，所以会报错。）</p></li><li><p>commitAllowingStateLoss() 也是异步执行，但它的不同之处在于，<strong>允许在 Activity 保存状态之后调用</strong>，也就是说它遇到状态丢失不会报错。<br>因此我们一般在界面状态出错是可以接受的情况下使用它。<br>这种方式是不安全的，因为事务提交时Activity可能还没有恢复，会丢失提交的事务。</p></li><li><p>commitNow() 是同步执行的，立即提交任务。<br>前面提到 FragmentManager.executePendingTransactions() 也可以实现立即提交事务。但我们一般建议使用 commitNow(), 因为另外那位是一下子执行所有待执行的任务，可能会把当前所有的事务都一下子执行了，这有可能有副作用。<br>和 commit() 一样，commitNow() 也必须在 Activity 保存状态前调用，否则会抛异常。</p><p>此外，这个方法提交的事务可能不会被添加到 FragmentManger 的后退栈，因为你这样直接提交，有可能影响其他异步执行任务在栈中的顺序。</p></li><li><p>commitNowAllowingStateLoss()同步执行</p></li></ul></li></ul><p>对比</p><ul><li><p>Fragment</p><p>其实是对 View 的封装，它持有 view, containerView, fragmentManager, childFragmentManager 等信息</p></li><li><p>FragmentManager</p><p>是一个抽象类，它定义了对一个 Activity&#x2F;Fragment 中 添加进来的 Fragment 列表、Fragment 回退栈的操作、管理方法,还定义了获取事务对象的方法,具体实现在 FragmentImpl 中</p></li><li><p>FragmentTransation</p><p>定义了对 Fragment 添加、替换、隐藏等操作，还有四种提交方法,具体实现是在 BackStackRecord 中</p></li></ul><p><strong>添加到Activity方法</strong></p><ul><li><p>xml直接静态添加fragment标签，name指定具体的Fragment</p></li><li><p>xml使用占位符进行动态添加，如FragmentLayout，在java代码中进行添加</p></li></ul><p>Fragment 内部有一个 childFragmentManager，通过它管理子 Fragment。在添加子 Fragment 时，把子 Fragment 的布局 add 到父 Fragment 即可。</p><p><strong>与Activity通信</strong></p><p>Bundle通信</p><p>接口回调</p><p><strong>Fragment之间通信</strong></p><ul><li>通过FragmentManager标签获得Fragment对象</li></ul><p>在MenuFragment中的ListView条目点击事件中通过标签获取到MainFragment，并调用对应的setData()方法，将数据设置进去，从而达到数据传递的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lv.setOnItemClickListener(<span class="keyword">new</span> <span class="title class_">AdapterView</span>.OnItemClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view, <span class="type">int</span> position, <span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="type">MainFragment</span> <span class="variable">mainFragment</span> <span class="operator">=</span></span><br><span class="line">        (MainFragment) getActivity()</span><br><span class="line">        .getSupportFragmentManager()</span><br><span class="line">        .findFragmentByTag(<span class="string">&quot;mainFragment&quot;</span>);</span><br><span class="line">        mainFragment.setData(mDatas.get(position));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>采用接口回调的方式</li><li>第三方开源框架EventBus</li></ul><p><strong>getFragmentManager，getSupportFragmentManager ，getChildFragmentManager三者之间的区别</strong></p><ul><li><p>getFragmentManager()所得到的是所在fragment 的父容器的管理器。</p></li><li><p>getChildFragmentManager()所得到的是在fragment 里面子容器的管理器。</p></li><li><p>getSupportFragmentManager()主要用于支持 3.0以下android系统API版本，3.0以上系统可以直接调用getFragmentManager()</p></li><li><p>注：getFragmentManager到的是activity对所包含fragment的Manager，而如果是fragment嵌套fragment，那么就需要利用getChildFragmentManager()</p></li></ul><p><strong>ViewPager的适配器区别，现在用ViewPager2了，只有一个适配器了</strong></p><p>ViewPager有PagerAdapter和FragmentStatePagerAdapter</p><ul><li><p>使用FragmentPagerAdapter 时，Fragment对象会一直存留在内存中，所以当有大量的显示页时，就不适合用FragmentPagerAdapter了，FragmentPagerAdapter 适用于只有少数的page情况，像选项卡。</p><p>原因：步长外的页面会调用destroyItem，但只有onDestroyView调用了，没有调用onDestory，也没有调用onDetach，所以fragment只是把上面的view销毁了，fragment并没有销毁，下次再创建的时候，只会调用onCreateView和onActivityCreated</p></li><li><p>当使用FragmentStatePagerAdapter 时，如果Fragment不显示，那么Fragment对象会被销毁，（滑过后会保存当前界面，以及下一个界面和上一个界面（如果有），最多保存3个，其他会被销毁掉）</p><p>原因：会真正销毁（同时销毁view和fragment，调用onDestroyView以及其后面的所有销毁方法），重建时会从最初的onAttach开始一直到onActivityCreated。但在回调onDestroy()方法之前会回调onSaveInstanceState(Bundle outState)方法来保存Fragment的状态，下次Fragment显示时通过onCreate(Bundle savedInstanceState)把存储的状态值取出来，FragmentStatePagerAdapter 比较适合页面比较多的情况，像一个页面的ListView 。</p></li></ul><p>ViewPager2只有FragmentStateAdapter，继承自RecyclerView.Adapter</p><p><strong>具体实例看回自己之前的学习笔记</strong></p><p><strong>ViewPager加载Fragmet情况下实现懒加载</strong></p><p>首先需要几个标志位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">mIsPrepare</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//视图还没准备好=&gt;onCreateView</span></span><br><span class="line"><span class="type">boolean</span> mIsVisible= <span class="literal">false</span>;<span class="comment">//不可见=&gt;setUserVisibleHint</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">mIsFirstLoad</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//第一次加载</span></span><br></pre></td></tr></table></figure><p>在onCreateView中确保View已经准备好，将mIsPrepare设置为true，在setUserVisibleHint中确保当前可见后设置mIsVisible为true，第一次加载完毕后则将mIsFirstLoad置为false，避免重复加载</p><p>在onDestroyView中进行默认值的初始化，保证Fragment销毁后进行默认值的初始化</p><p><strong>卡顿优化</strong></p><ul><li><p>优化方案一：设置缓存页面数</p><p>viewPager.setOffscreenPageLimit(int limit) 能够有效地一次性缓存多个Fragment，这样就能够解决在之后每次切换时不会创建实例对象，看起来也会流畅。但是这样的做法，最大的缺点就是容易造成第一次启动时非常缓慢！如果第一次启动时间满足要求的话，就使用这种简单地办法吧。</p></li><li><p>优化方案二：避免Fragment的销毁</p><p>不管是FragmentStatePagerAdapter还是FragmentPagerAdapter，其中都有一个方法可以被覆写：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyItem</span><span class="params">(ViewGroup container, <span class="type">int</span> position, Object object)</span> &#123;</span><br><span class="line">   <span class="comment">// super.destroyItem(container, position, object);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把中间的代码注释掉就行了，这样就可以避免Fragment的销毁过程，一般情况下能够这样使用，但是容易出现一个问题,如果注释掉，一旦Activity被回收进入异常销毁状态，Fragment就无法恢复之前的状态，因此这种方法也是有纰漏和局限性的。</p><ul><li>优化方案三：避免重复创建View</li></ul><p>优化Viewpager和Fragment的方法就是尽可能地避免Fragment频繁创建，当然，最为耗时的都是View的创建。所以更加优秀的优化方案，就是在Fragment中缓存自身有关的View，防止onCreateView函数的频繁执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">View rootView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span><br><span class="line"><span class="params">                             Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rootView == <span class="literal">null</span>) &#123;</span><br><span class="line">            rootView = inflater.inflate(R.layout.fragment_my, container, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootView;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroyView</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroyView();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroyView: &quot;</span> + mParam1);</span><br><span class="line">        mIsFirstLoad=<span class="literal">true</span>;</span><br><span class="line">        mIsPrepare=<span class="literal">false</span>;</span><br><span class="line">        mIsVisible = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (rootView != <span class="literal">null</span>) &#123;</span><br><span class="line">            ((ViewGroup) rootView.getParent()).removeView(rootView);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onCreateView中将会对rootView进行null判断，如果为null，说明还没有缓存当前的View，因此会进行过缓存，反之则直接利用。当然，最为重要的是需要在onDestroyView() 方法中及时地移除rootView，因为每一个View只能拥有一个Parent，如果不移除，将会重复加载而导致程序崩溃。</p><p>其实ViewPager+Fragment的方式，ViewPager中显示的就是Fragment中所创建的View，Fragment只是一个控制器，并不会直接显示于ViewPager之中，这一点容易被忽略。</p><p><strong>Fragment的坑，如何解决</strong></p><ul><li><p>内存重启：内存重启本质就是Android系统（而非开发人员手动）杀死进程并重启进程的过程。会在进程结束前调用onSaveInstanceState保存Activity现场状态，同时会在进程创建后恢复。（屏幕旋转等配置变化也会赵成当前的Activity重启）</p><ul><li>在系统要把app资源回收之前，系统会把Activity的状态保存下来，Activity的FragmentManager负责把Activity中的Fragment保存起来。</li><li>在“内存重启”后，Activity的恢复是从栈顶逐步恢复，Fragment会在宿主Activity的onCreate方法调用后紧接着恢复（从onAttach生命周期开始）</li></ul></li><li><p>getActivity()空指针</p><ul><li>内存重启&#x2F;pop了Fragment后Fragment的异步任务仍在执行，且执行时调用了getActivity方法，此时会报空指针异常。</li><li>调用了getActivity()时，当前的Fragment已经onDetach()了宿主Activity。</li></ul><p>避免在Fragment已onDetach后再去调用宿主Activity。在Fragment基类里设置一个Activity mActivity的全局变量，在onAttach(Activity activity)里赋值，使用mActivity代替getActivity()，保证Fragment即使onDetach后，仍持有Activity的引用（有引起内存泄露的风险，但是异步任务没停止的情况下，本身就可能已内存漏，相比Crash，这种做法“安全”些）</p></li><li><p>异常：Can not perform this action after onSaveInstanceState</p><ul><li>Activity在调用onSaveInstanceState()保存当前Activity的状态后，直到Activity状态恢复之前，你commit 一个FragmentTransaction，就会抛出该异常——导致Activity状态丢失</li><li>当框架调用onSaveInstanceState()的时候，它会向这个方法传递一个Bundle参数，Activity可以用这个参数来保存页面、对话框、Fragments和视图的状态。当onSaveInstanceState返回时，会将一个Bundle对象序列化之后通过Binder接口传递给系统服务进程,并安全的保存起来。当系统晚一点想要重启Activity的时候， 它会把之前的Bundle对象传递回应用，并用来恢复Activity之前的状态。<br>所以为什么会抛出之前的异常呢？问题的根源在于Bundle这个对象仅仅是Activity在onSaveInstanceState()方法被调用那一刻的快照。这就意味着当你如果在onSaveInstanceState()之后再调用FragmentTransaction.commit()的话，由于这次Transaction没有被作为Activity状态的一部分来保存，自然也就丢失掉了。从用户的角度来说，Transaction的遗失就导致意外的UI状态丢失。那么为了维护良好的用户体验，Android系统会不惜一切代价的避免页面状态的丢失，所以在这种情况发生的时候就直接抛出了IllegalStateException。</li></ul><p>解决方案直接看博客里面的吧<a href="https://blog.csdn.net/qq_29966203/article/details/90414221">第二章 Fragment_fragment的含义和作用-CSDN博客</a></p></li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p><strong>六大布局</strong></p><ul><li><p>LinearLayout线性布局</p><p>LinearLayout容器中的组件一个挨一个排列，通过控制android:orientation属性，可控制各组件是横向排列还是纵向排列。</p></li><li><p>RelativeLayout相对布局</p><p>相对布局可以让子控件相对于兄弟控件或父控件进行布局，可以设置子控件相对于兄弟控件或父控件进行上下左右对齐。<br>RelativeLayout能替换一些嵌套视图，当我们用LinearLayout来实现一个简单的布局但又使用了过多的嵌套时，就可以考虑使用RelativeLayout重新布局。</p></li><li><p>FrameLayout帧布局</p><p>帧布局或叫层布局，从屏幕左上角按照层次堆叠方式布局，后面的控件覆盖前面的控件。帧布局为每个加入其中的组件创建一个空白的区域(称为一帧)，每个子组件占据一帧，这些帧会根据gravity属性执行自动对齐。<br>该布局在开发中设计地图经常用到，因为是按层次方式布局，我们需要实现层面显示的样式时就可以<br>采用这种布局方式，比如我们要实现一个类似百度地图的布局，我们移动的标志是在一个图层的上面。<br>TableLayout表格布局</p><p>TableLayout继承自Linearout，本质上仍然是线性布局管理器。表格布局采用行、列的形式来管理UI组件，并不需要明确地声明包含多少行、多少列，而是通过添加TableRow、其他组件来控制表格的行数和列数。</p></li><li><p>GridLayout网格布局</p><p>GridLayout把整个容器划分为rows × columns个网格，每个网格可以放置一个组件。提供了setRowCount(int)和setColumnCount(int)方法来控制该网格的行和列的数量。</p></li><li><p>AbsoluteLayout绝对布局（过时）</p></li><li><p>新的还有ConstraintLayout约束布局</p></li></ul><p><strong>RelativeLayout和LinearLayout性能对比</strong></p><p>通过网上的很多实验结果我们得之，两者绘制同样的界面时layout和draw的过程时间消耗相差无几，关键在于measure过程RelativeLayout比LinearLayout慢了一些。故从RelativeLayout和LinearLayout的onMeasure过程来探索耗时问题的根源。</p><p>根据源码我们发现RelativeLayout会根据2次排列的结果对子View各做一次measure。首先RelativeLayout中子View的排列方式是基于彼此的依赖关系，而这个<strong>依赖关系可能和Xml布局中View的顺序不同，在确定每个子View的位置的时候，需要先给所有的子View排序一下</strong>。又因为<strong>RelativeLayout允许ViewB在横向上依赖ViewA，ViewA在纵向上依赖B。所以需要横向纵向分别进行一次排序测量</strong>。<br>同时需要注意的是View.measure()方法存在以下优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">measure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; FORCE_LAYOUT) == FORCE_LAYOUT ||</span><br><span class="line">                widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class="line">                heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">        mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即如果我们或者我们的子View没有要求强制刷新，而父View给子View传入的值也没有变化（也就是说子View的位置没变化），就不会做无谓的测量。RelativeLayout在onMeasure中做横向测量时，纵向的测量结果尚未完成，只好暂时使用myHeight传入子View系统。这样会导致在子View的高度和RelativeLayout的高度不相同时（设置了Margin），上述优化会失效，在View系统足够复杂时，效率问题就会很明显。</p><p>源码中已经标注了一些注释，需要注意的是在每次对child测量完毕后，都会调用child.getMeasuredHeight()获取该子视图最终的高度，并将这个高度添加到mTotalLength中。但是getMeasuredHeight暂时避开了lp.weight&gt;0且高度为0子View，因为后面会将把剩余高度按weight分配给相应的子View。因此可以得出以下结论：<br>（1）如果我们在LinearLayout中不使用weight属性，将只进行一次measure的过程。<br>（2）如果使用了weight属性，LinearLayout在第一次测量时获取所有子View的高度，之后再将剩余高度根据weight加到weight&gt;0的子View上。<br>由此可见，weight属性对性能是有影响的。</p><p><strong>结论</strong></p><p>1、RelativeLayout慢于LinearLayout是因为它会让子View调用2次measure过程，而LinearLayout只需一次，但是有weight属性存在时，LinearLayout也需要两次measure。<br>2、RelativeLayout的子View如果高度和RelativeLayout不同，会导致RelativeLayout在onMeasure()方法中做横向测量时，纵向的测量结果尚未完成，只好暂时使用自己的高度传入子View系统。而父View给子View传入的值也没有变化就不会做无谓的测量的优化会失效，解决办法就是可以使用padding代替margin以优化此问题。<br>3、在不响应层级深度的情况下，使用Linearlayout而不是RelativeLayout。<br>4、新建一个Android项目SDK会为我们自动生成的avtivity_main.xml布局文件，然后它的根节点默认是RelativeLayout？<br>DecorView的层级深度已知且固定的，上面一个标题栏，下面一个内容栏，采用RelativeLayout并不会降低层级深度，因此这种情况下使用LinearLayout效率更高。<br>5、作为顶级View的DecorView就是个垂直方向的LinearLayout，上面是标题栏，下面是内容栏，我们常用的setContentView()方法就是给内容栏设置布局？<br>为开发者默认新建RelativeLayout是希望开发者能采用尽量少的View层级，很多效果是需要多层LinearLayout的嵌套，这必然不如一层的RelativeLayout性能更好。因此我们应该尽量减少布局嵌套，减少层级结构，使用比如viewStub，include等技巧。可以进行较大的布局优化。</p><p><strong>布局优化方案</strong></p><p>减少层级，越简单越好，减少overdraw，就能更好的突出性能</p><p>Android系统是如何处理UI组件的更新操作的？<br>1、<strong>Android需要把XML布局文件转换成GPU能够识别并绘制的对象。</strong>这个操作是在DisplayList的帮助下完成的。<strong>DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息</strong>。<br>2、<strong>CPU负责把UI组件计算</strong>成Polygons，Texture纹理，<strong>然后交给GPU进行栅格化渲染</strong>。<br>3、<strong>GPU进行栅格化渲染</strong>。（<strong>栅格化：把组件拆分到不同的像素上进行显示</strong>）<br>4、<strong>硬件展示在屏幕上</strong>。<br>需要注意的是：<strong>任何时候View中的绘制内容发生变化时，都会重新执行创建DisplayList，渲染DisplayList，更新到屏幕上等一系列操作</strong>。这个流程的表现性能取决于View的复杂程度，View的状态变化以及渲染管道的执行性能<br>Overdraw（过度绘制）：描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，<strong>如果不可见的UI也在做绘制的操作，就会导致某些像素区域被绘制了多次，浪费大量的CPU以及GPU资源。</strong>（可以通过开发者选项，打开Show GPU Overdraw的选项，观察UI上的Overdraw情况）<br>所以我们需要尽量减少Overdraw。</p><p><strong>include、merge、ViewStub标签</strong></p><ul><li><p>include标签常用于将布局中的公共部分提取出来，那么就可以直接include进去了。</p></li><li><p>merge标签是作为include标签的一种辅助扩展来使用，它的主要作用是为了防止在引用布局文件时产生多余的布局嵌套,Android渲染需要消耗时间，布局越复杂，性能就越差。如上述include标签引入了之前的LinearLayout之后导致了界面多了一个层级。这个时候用merge的话，就可以减少一个层级。（直接在include进来的布局部分使用，这样include的布局就不带LinearLayout标签了，减少嵌套）</p></li><li><p>ViewStub标签，viewstub是view的子类。他是一个轻量级View， 隐藏的，没有尺寸的View。他可以用来在程序运行时简单的填充布局文件。</p></li></ul><p><strong>检测布局深度的方法</strong></p><ul><li>Dump UI Hierarchy for UI Atomator，分析UI层级</li></ul><p>从Android Studio中启动Android Device Monitor： Tools -&gt; Android -&gt; Android Device Monitor.</p><p><img src="https://img-blog.csdnimg.cn/20190520101213890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><ul><li>HierachyViewer</li></ul><p>依次点击菜单Tools&gt;Android&gt;Android Device Monitor</p><p>启动Android Device Monitor成功之后，在新的的窗口中点击切换视图图标，选择Hierarchy View</p><h3 id="自定义组件、动画"><a href="#自定义组件、动画" class="headerlink" title="自定义组件、动画"></a>自定义组件、动画</h3><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="计网部分"><a href="#计网部分" class="headerlink" title="计网部分"></a>计网部分</h4><p>具体要背，计网已经忘光了，先直接看了面试问题部分，看理解版本</p><p><a href="https://blog.csdn.net/weixin_44616879/article/details/129056219">OSI七层模型和TCP&#x2F;IP四层模型-CSDN博客</a></p><p><strong>直接看博客，记重点先</strong></p><p><strong>作为Android开发者,需要对数据链路层的TCP&#x2F;IP,UDP协议非常了解</strong>。</p><p><a href="https://blog.csdn.net/sunyctf/article/details/129098871">如何发起一次完整的HTTP的请求流程_发送http请求-CSDN博客</a></p><p><strong>HTTP</strong></p><p>基于 <code>TCP</code> 传输协议的 <code>HTTP</code> 协议，由于是通过 四元组（<code>源IP</code>、<code>源端口</code>、<code>目的 IP</code>、<code>目的端口</code>）确定一条 <code>TCP</code> 连接</p><ul><li><p>历代http优化及原因</p><p><a href="https://blog.csdn.net/weixin_43294560/article/details/122777175">http 各版本问题和优化_http-server版本-CSDN博客</a></p><p>HTTP1.1采用持久连接：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互<br>HTTP1.0采用非持久连接：每个连接只能处理一个请求-响应事务</p></li><li><p>请求方法、响应码</p></li></ul><p>常用的为PUT和GET，HTTP协议定义了八种请求类型</p><p>状态码：</p><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><p>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求</p><ul><li>Cookie和Session区别</li></ul><p>存放位置不同</p><p>存取方式不同： Cookie中只能保存ASCII字符串，Session中可以保存任意类型的数据，甚至Java Bean乃至任何Java类、对象等。</p><p>安全性不同</p><p>有效期上的不同：Cookie的过期时间可以被设置很长。Session依赖于名为JSESSIONI的Cookie，其过期时间默认为-1，只要关闭了浏览器窗口，该Session就会过期，因此Session不能完成信息永久有效。如果Session的超时时间过长，服务器累计的Session就会越多，越容易导致内存溢出。</p><p>对服务器造成的压力不同：每个用户都会产生一个session，如果并发访问的用户过多，就会产生非常多的session，耗费大量的内存。因此，诸如Google、Baidu这样的网站，不太可能运用Session来追踪客户会话。</p><p>浏览器支持不同：Cookie运行在浏览器端，若浏览器不支持Cookie，需要运用Session和URL地址重写。</p><p>跨域支持不同： Cookie支持跨域访问（设置domain属性实现跨子域），Session不支持跨域访问</p><ul><li><p>Token、Cookie&amp;Session联系</p><p>在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。大部分你见到过的API和Web应用都使用tokens。例如Facebook, Twitter, Google+, GitHub等。<br>具有以下几点特性：<br>1、无状态、可扩展<br>2、支持移动设备<br>3、跨程序调用<br>4、安全</p></li></ul><p><strong>socket</strong></p><p>即套接字，是通信的基石，是应用层 与 TCP&#x2F;IP 协议族通信的中间软件抽象层，本质为一个封装了 TCP &#x2F; IP协议族 的编程接口（API）（不是协议，是一个编程调用接口，通过socket才能实现http协议，属于传输层）网络上的两个程序通过Socket实现一个双向的通信连接从而进行数据交换。<br>Socket是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用协议、（本地主机IP地址，本地进程的协议端口）、（远地主机IP地址，远地进程协议端口）。<br>Socket一般成对出现，一对套接字（其中一个运行在服务端一个运行在客户端）</p><ul><li>原理</li></ul><p>Socket是面向客户&#x2F;服务器模型而设计的，针对客户和服务器程序提供不同的Socket系统调用。客户随机申请一个Socket，系统为之分配一个Socket号；<strong>服务器拥有全局公认的Socket</strong>，<strong>任何客户都可以向它发出连接请求和信息请求</strong>。<br>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序提供并发服务的问题，多个TCP连接多个应用程序进程可能需要通过同一个TCP协议端口传输数据，为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP&#x2F;IP协议交互提供了套接字（socket）接口，<strong>应用层可以和传输层通过socket接口区分来自于不同应用进程或网络连接的通信，实现数据传输的并发服务</strong>。<br>即Socket相当于一个封装了TCP&#x2F;IP协议的API，提供了程序内部与外界通信的端口，并为通信双方提供了数据传输通道。Socket类型为流套接字（streamsocket）和数据报套接字(datagramsocket)。流套接字将TCP作为其端对端协议，提供了一个可信赖的字节流服务。数据报套接字使用UDP协议，提供数据打包发送服务。</p><p><img src="https://img-blog.csdnimg.cn/20190706093601597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><ul><li><p>socket和HTTP的区别</p><p>Socket是套接字，对TCP&#x2F;IP协议的封装。对端（IP地址和端口）的抽象表示。<br>HTTP协议是通信协议，是利用TCP在Web服务器和浏览器之间数据传输的协议。<br>Socket和HTTP协议本质上就不同。SOCKET本质对TCP&#x2F;IP的封装，从而提供给程序员做网络通信的接口（即端口通信）。可理解为HTTP是一辆轿车模型框架，提供了所有封装和数据传递的形式；Socket是发动机，提供了网络通信的能力。</p><p>Socket：属于传输层，因为 TCP &#x2F; IP协议属于传输层，解决的是数据如何在网络中传输的问题。<br>HTTP协议：属于 应用层，解决的是如何包装数据。</p></li></ul><p><strong>HTTPS</strong></p><p>超文本传输协议HTTP协议被用于在web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号，密码等。<br>为了解决HTTP协议的这一缺陷，需要使用使用另一种协议，安全套接字层超文本传输协议HTTPS。HTTPS在HTTP的基础上加入SSL（Secure Sockets Layer 安全套接字层）协议，SSL依靠证书来验证服务器的身份，为浏览器和服务器之间的通信加密。</p><ul><li><p>相关定义</p><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的Http通道，可理解为HTTP的加强版。实现原理是再HTTP下加入SSL层，SSL负责加密和解密数据（HTTPS &#x3D; HTTP + SSL）</p><p>HTTPS的特点在于：</p><p>内容加密：采用混合加密技术，中间者无法直接查看明文内容。<br><strong>混合加密：结合对称加密和非对称加密技术。客户端使用对称密钥对传输数据进行加密， 然后用非对称密钥对对称密钥进行加密。</strong>所以网络上传输的数据是被对称加密过的密文和用非对称加密后的密钥。因此即使被黑客截取。由于没有私钥，所以无法获取加密明文的密钥，也无法获取明文数据。<br>验证身份：确保浏览器访问的网站是经过CA验证的可信任网站。<br>数据完整性：防止传输的内容被中间人冒充或篡改。</p></li><li><p>原理</p><p>发送方将对称加密的密钥通过非对称加密的公钥进行加密，接收方使用私钥进行解密得到对称加密的密钥，再通过对称加密交换数据。Https协议通过对称加密（传输快，传输交换数据）和非对称加密（安全，传输密钥）结合处理实现的。</p></li><li><p>和HTTP区别</p><p>定义上：<br>HTTP：超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP&#x2F;IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。<br>HTTPS：HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL&#x2F;TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。<br>HTTPS协议需要CA申请证书（交费）（权威机构颁发证书——安全|自己生成的证书——不安全）<br>HTTP是超文本传输协议，信息是明文传输。HTTPS协议是SSL+HTTP协议构建的可进行加密传输、身份认证的安全的网络协议<br>HTTP和HTTPS使用不同连接方式，端口也不同（http:80，https:443）</p><p><img src="https://img-blog.csdnimg.cn/20190522184758170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p></li><li><p>加密算法</p><p>见SSL和TLS下面</p></li><li><p>hash摘要</p><p>摘要算法（Hash算法）：是一种单向算法，用户可以通过hash算法对目标信息生成特定长度的唯一hash值，却不能通过hash值重新得到目标信息，常用在不可还原的密码存储、信息完成性校验，如MD5、SHA等。CRC与MD5、SHA1等相比一般用作通信数据的校验，检错能力和安全性低，CRC计算结果是一个数值，叫做CRC值。（摘要算法用于解决 HTTP 传输数据容易被篡改的问题）</p></li><li><p>ca证书</p><p>CA(Certificate Authority，证书授权)是由认证机构服务者签发，是数字签名的技术基础保障，也是网上实体身份的证明，能够证明某一实体的身份及其公钥的合法性，证明该实体与公钥二者之间的匹配关系。<br>证书是公钥的载体，证书上的公钥与实体身份相绑定。现，一个是签名证书行的PKI机制一般为双证书机制，即一个实体应具有两个证书、两个密钥对，其中一个是加密证书，一个是签名证书，而加密证书原则上是不能用于签名的。<br>在电子商务系统中，所有实体的证书都是由证书授权中心即CA中心颁发并签名的。一个完整的、安全的电子商务系统必须建立一个完整的、合理的CA体系。CA体系由证书审批部门和证书操作部门组成。</p><p>证书原理：数字证书在用户公钥后附加了用户信息及CA的签名。公钥是密钥对的一部分，另一部分是私钥。公钥公之于众，谁都可以使用。私钥只有自己知道。由公钥加密的信息只能由与之相对应的私钥解密。为确保只有某个人才能阅读自己的信件，发送者要用收件人的公钥加密信件；收件人便可用自己的私钥解密信件。同样，为证实发件人的身份，发送者要用自己的私钥对信件进行签名；收件人可使用发送者的公钥对签名进行验证，以确认发送者的身份。<br>在线交易中您可使用数字证书验证对方身份。用数字证书加密信息，可以确保只有接收者才能解密、阅读原文，信息在传递过程中的保密性和完整性。有了数字证书网上安全才得以实现，电子邮件、在线交易和信用卡购物的安全才能得到保证。</p></li><li><p>建立连接过程</p><p><img src="https://img-blog.csdnimg.cn/20190705094620876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p>前面5步就是https握手过程 </p></li><li><p>破解：中间人攻击（协议中间人攻击）</p><p>在密码学和计算机安全领域中，中间人攻击（Man-in-the-middle attack，缩写：MITM）是指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的 Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。</p><p>简单来说攻击者就是一个介入通信的传话员，攻击者知道通信双方的所有通信内容，而且可以任意增加、删除、修改双方的通信内容，而双方对此并不知情。</p><p>而中间人攻击不仅仅局限于针对 HTTPS，对于开放性的连接，中间人攻击非常容易。比如在一个未加密的 Wi-Fi 网络中，一个攻击者可以很容易地将自己插入双方的通信之中以截取或者修改通信的内容。</p><p>在现实中，有多种方式可以确定某个实体的身份，比如个人的签名 &#x2F; 私章、组织的公章、甚至古时的信物。大部分情况下，只需要在信件最后盖上签上自己的名字或者盖上组织的公章，那么接收者就可以确定这封信件就来自于他所声称的那个人 &#x2F; 组织。在二进制的世界中，可以使用数字签名来确保某段消息 &#x2F; 某份文件确实是由他所声称的那个实体所发出来的。</p><p>不过有个问题，如果中间人在会话建立阶段把双方交换的真实公钥替换成自己的公钥了，那么中间人还是可以篡改消息的内容而双方并不知情。为了解决这个问题，需要找一个通信双方都信任的第三方来为双方确认身份。这就像大家都相信公证处，公证处拿着自己的公章为每一封信件都盖上了自己的章，证明这封信确实是由本人发出的，这样就算中间人可以替换掉通信双方消息的签名，也无法替换掉公证处的公章。这个公章，在二进制的世界里，就是<strong>数字证书</strong>，公证处就是<strong>CA（数字证书认证机构）</strong>。</p><p>数字证书就是申请人将一些必要信息（包括公钥、姓名、电子邮件、有效期）等提供给 CA，CA 在通过各种手段确认申请人确实是他所声称的人之后，用自己的私钥对申请人所提供信息计算散列值进行加密，形成数字签名，附在证书最后，再将数字证书颁发给申请人，申请人就可以使用 CA 的证书向别人证明他自己的身份了。对方收到数字证书之后，只需要用 CA 的公钥解密证书最后的签名得到加密之前的散列值，再计算数字证书中信息的散列值，将两者进行对比，只要散列值一致，就证明这张数字证书是有效且未被篡改过的。</p><p><a href="https://cloud.tencent.com/developer/news/151488">https://cloud.tencent.com/developer/news/151488</a></p></li><li><p>优缺点</p><p>优点</p><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器<br>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，防止数据在传输过程中被窃取，确保数据的完整性<br>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但是它<strong>大幅度增加了中间人攻击的成本</strong><br>缺点</p><p>相同网络环境下,HTTPS协议会使页面的加载时间延长50%，增加10%~20%耗电，此外,HTTPS协议还会影响缓存，增加数据开销和功耗（增加了加密解密过程）<br><strong>HTTPS协议的安全是有范围的，在黑客攻击、拒绝服务攻击、服务器劫持方面几乎起不到什么作用</strong><br><strong>最关键的，SSL证书信用链体系并不安全，特别是再某些国家可以控制CA根证书的情况下，中间人攻击一样可行</strong><br>成本方面：<br>（1）SSL的专业证书需要购买，功能越强大，费用越高<br>（2）SSL证书通常需要绑定固定IP，为服务器增加固定IP会增加一定费用<br>（3）HTTPS连接服务器端资源占用高，相同负载下会增加带宽和投入成本</p></li></ul><p><strong>SSL&#x2F;TLS</strong></p><p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。<br>SSL协议位于TCP&#x2F;IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：</p><p>SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 （通过对称加密实现，用来保证数据传输过程中完整性和私密性）<br>SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。（通过非对称加密实现，负责握手过程的身份认证）</p><ul><li><p>加密算法</p><p>（1）对称加密<br>原理：加密算法是公开的，靠的是密钥来加密数据。使用一个密钥加密，使用相同的密钥才能解密<br>常用算法：DES,3DES,AES<br>优点：计算量小，加密和解密速度较快，适合加密较大数据<br>缺点：在传输加密数据之前需要传递密钥，密钥传输容易泄露；一个用户需要对应一个密钥，服务器管理密钥比较麻烦</p><p>（2）非对称加密<br>原理：加密算法是公开的，有一个公钥，一个私钥（公钥和私钥不是随机的，由加密算法生成）；公钥加密只能私钥解密，私钥加密只能公钥解密，加密解密需要不同密钥<br>常用算法：RSA<br>优点：可以传输公钥（服务器—&gt;客户端）和公钥加密的数据（客户端-&gt;服务器），数据传输安全<br>缺点：计算量大，加密和解密速度慢</p></li></ul><p><strong>数据链路层，IP层</strong></p><ul><li><p>ARP和RARP协议</p><p>ARP协议：实现IP地址向物理地址的映射\ RARP协议：实现物理地址向IP地址的映射</p></li><li><p>ICMP和IGMP</p><p>ICMP协议：探测&amp;报告传输中产生的错误\IGMP协议：管理多播组测成员关系</p></li><li><p>NAT协议</p><p>NAT(网络地址转换)：在<strong>专用网连接到因特网的路由器上安装NAT软件</strong>，安装了NAT软件的路由器叫NAT路由器。<strong>当一个分组离开专用网的时候，首先要通过一个NAT路由器，它会将内部的IP源地址转换成该公司所拥有的真实IP地址</strong>。注意私有IP地址的范围。NAT通常与防火墙组合使用。</p></li><li><p>DNS</p><p>DNS（域名解析系统）：用来把便于人们使用的机器名字(域名)转换为IP地址；DNS系统采用客户&#x2F;服务器模式，其协议运行在UDP上，使用53号端口。</p></li><li><p>常见协议</p><p><a href="https://zhuanlan.zhihu.com/p/673256869">【考前必看】计算机网络各层次协议盘点总结！ - 知乎 (zhihu.com)</a></p></li></ul><p><strong>TCP</strong></p><ul><li><p>握手挥手</p><p>直接看博客理解版先吧</p><p><a href="https://blog.csdn.net/m0_38106923/article/details/108292454">一文搞懂TCP的三次握手和四次挥手_tcp三次握手和4次挥手的过程-CSDN博客</a></p></li><li><p>拥塞控制</p><p><a href="https://zhuanlan.zhihu.com/p/471415273?utm_id=0">一篇看懂【TCP协议】—TCP协议详解（值得收藏） - 知乎 (zhihu.com)</a></p></li><li><p>可靠传输原理</p><p><a href="https://blog.csdn.net/weixin_41605937/article/details/121323886">计算机网络——TCP可靠性传输原理_tcp可靠传输的工作原理-CSDN博客</a></p><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p><p>重传机制：</p><ul><li>超时重传</li><li>快速重传</li></ul><p>滑动窗口：</p><p>流量控制</p><p>拥塞控制</p></li><li><p>缺点以及如何改进</p><p>看下面UDP那个博客</p><p>TCP存在队头阻塞问题，TCP 队头阻塞的问题要从两个角度看，一个是发送窗口的队头阻塞，另外一个是接收窗口的队头阻塞（但是这个设计本来就是保证数据的有序性）</p><p>在 HTTP&#x2F;2 连接上，不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而同一 Stream 内部的帧必须是严格有序的。</p><p>但是 HTTP&#x2F;2 多个 Stream 请求都是在一条 TCP 连接上传输，这意味着多个 Stream 共用同一个 TCP 滑动窗口，那么当发生数据丢失，滑动窗口是无法往前移动的，此时就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。</p></li><li><p>http3.0针对TCP缺点改进</p><p>看下面UDP那个博客</p><p>QUIC 也借鉴 HTTP&#x2F;2 里的 Stream 的概念，在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (Stream)。<br>但是 QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口。</p><p>假如 Stream2 丢了一个 UDP 包，也只会影响 Stream2 的处理，不会影响其他 Stream，与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。</p><p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手（1RTT），再 TLS 握手（2RTT），所以需要 3RTT 的延迟才能传输数据，就算 Session 会话服务，也需要至少 2 个 RTT，这在一定程序上增加了数据传输的延迟。HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的连接 ID，连接迁移就是基于连接 ID 实现的。<br>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，因为 QUIC 也是应用层实现的协议，所以可以将 QUIC 和 TLS 协议握手的过程合并在一起，QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的 记录，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以 同时 完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p></li><li><p>TCP连接数目上限</p><p>32位ip，16位端口（2进制），一共2^48，-1就是65535</p><p>65535，先记住这个数字吧</p><p><a href="https://blog.csdn.net/z1ztai/article/details/129929722">Linux 的 TCP 连接数量最大不能超过 65535？_linux tcp连接数限制-CSDN博客</a></p></li></ul><p><a href="https://baijiahao.baidu.com/s?id=1777812703367602330&wfr=spider&for=pc">tcp和udp的区别是什么 (baidu.com)</a></p><p><strong>UDP</strong></p><p><a href="https://blog.csdn.net/weixin_72076304/article/details/126729204">2022.9.06 UDP的优缺点，UDP适用场合，UDP实现客户端与服务端的通信步骤，UDP实现客户端与服务端的通信的完整代码。_udp的优点-CSDN博客</a></p><ul><li>优缺点</li><li>和TCP比较</li><li>应用场景</li><li>一般和TCP一起出现，和TCP区别，如何通过UDP优化TCP的缺点</li></ul><p><a href="https://blog.csdn.net/u012060033/article/details/129850478">HTTP 3.0之QUIC优势和TCP弊端_如何用udp集成tcp的优势(说到http3.0),然后说到quic、tcp的滑动窗口、拥塞控制-CSDN博客</a></p><p><strong>数据格式</strong></p><p>JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>JSONObject的数据是用 { } 来表示的</p><p>JSONArray的数据是由JSONObject构成的数组，用 [ { } , { } , …… , { } ] 来表示的</p><p>把Java对象JSON序列化，Jackson速度最快，在测试中比Gson快接近50%，FastJSON和Gson速度接近。<br>把JSON反序列化成Java对象，FastJSON、Jackson速度接近，Gson速度稍慢，不过差距很小。</p><p>因此初测的结论是：不管是字符串转对象，还是对象转字符串，gson的运行性能都是fastjson的两倍，且gson拥有更好的容错性，两者都是独立的，不依赖于其它JAR，因此推荐gson!</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403021651677.png" alt="image-20240302165119246"></p><p>优势</p><ul><li>JSON数据清晰</li><li>JSON有很多工具类支持它的转换</li><li>JSON在所有主流浏览器有很好的支持</li><li>JSON在传输时数据量更小</li><li>JSON在JS中有天然的语言优势（因为它是标准的子集合）</li></ul><p>缺点</p><ul><li>不适合存储大量数据</li><li>不支持注解</li><li>不支持日期和时间类型</li></ul><h4 id="Android网络知识和框架"><a href="#Android网络知识和框架" class="headerlink" title="Android网络知识和框架"></a>Android网络知识和框架</h4><p>HttpURLConnection和HttpClient：这两种方式都支持HTTPS协议、以流的形式进行上传和下载、配置超时时间、IPv6、以及连接池等功能。</p><ul><li><p>HtttpClient</p><p>DefaultHttpClient和它的兄弟AndroidHttpClient都是HttpClient具体的实现类，它们都拥有众多的API，而且实现比较稳定，bug数量也很少。<br>但同时也由于HttpClient的API数量过多，使得我们很难在不破坏兼容性的情况下对它进行升级和扩展，结构复杂，维护成本高。<br>Android SDK中包含了HttpClient，在Android6.0版本直接删除了HttpClient类库。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> Boolean <span class="title function_">LoginGet</span><span class="params">(Context context,String username,String password)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;http://192.168.1.138:8080/chyWebTest/LoginServlet?username=&quot;</span>+username+<span class="string">&quot;&amp;password=&quot;</span>+password;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//1.创建一个HttpClient对象</span></span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultHttpClient</span>();</span><br><span class="line">        <span class="comment">//2.设置请求方式</span></span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">httpGet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(path);</span><br><span class="line">        <span class="comment">//3.执行一个Http请求（返回HttpResponse）</span></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> httpClient.execute(httpGet);</span><br><span class="line">        <span class="comment">//4.获取请求的状态码</span></span><br><span class="line">        <span class="type">StatusLine</span> <span class="variable">statusLine</span> <span class="operator">=</span> httpResponse.getStatusLine();</span><br><span class="line">        <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> statusLine.getStatusCode();</span><br><span class="line">        <span class="comment">//5.判断状态吗后获取内容</span></span><br><span class="line">        <span class="keyword">if</span>(code==<span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">//获取实体内容，中封装有Http请求返回流信息</span></span><br><span class="line">            <span class="type">HttpEntity</span> <span class="variable">entity</span> <span class="operator">=</span> httpResponse.getEntity();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> entity.getContent();</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> StreamUtil.StreamToString(inputStream);</span><br><span class="line">            <span class="keyword">if</span>(result.equals((<span class="string">&quot;success&quot;</span>)))&#123;</span><br><span class="line">                isSuccess = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSuccess;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>HttpURLConnection</p><p>HttpURLConnection是一种多用途、轻量极的HTTP客户端，使用它来进行HTTP操作可以适用于大多数的应用程序。虽然HttpURLConnection的API提供的比较简单，但是同时这也使得我们可以更加容易地去使用和扩展它。</p></li></ul><p>创建一个UrlConnManager类，然后里面提供getHttpURLConnection()方法用于配置默认的参数并返回HttpURLConnection</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HttpURLConnection <span class="title function_">getHttpURLConnection</span><span class="params">(String url)</span>&#123;</span><br><span class="line">     HttpURLConnection mHttpURLConnection=<span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         URL mUrl=<span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line">         mHttpURLConnection=(HttpURLConnection)mUrl.openConnection();</span><br><span class="line">         <span class="comment">//设置链接超时时间</span></span><br><span class="line">         mHttpURLConnection.setConnectTimeout(<span class="number">15000</span>);</span><br><span class="line">         <span class="comment">//设置读取超时时间</span></span><br><span class="line">         mHttpURLConnection.setReadTimeout(<span class="number">15000</span>);</span><br><span class="line">         <span class="comment">//设置请求参数</span></span><br><span class="line">         mHttpURLConnection.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">         <span class="comment">//添加Header</span></span><br><span class="line">         mHttpURLConnection.setRequestProperty(<span class="string">&quot;Connection&quot;</span>,<span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">         <span class="comment">//接收输入流</span></span><br><span class="line">         mHttpURLConnection.setDoInput(<span class="literal">true</span>);</span><br><span class="line">         <span class="comment">//传递参数时需要开启</span></span><br><span class="line">         mHttpURLConnection.setDoOutput(<span class="literal">true</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> mHttpURLConnection ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>发送POST请求，所以在UrlConnManager类中再写一个postParams()方法用来组织一下请求参数并将请求参数写入到输出流中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postParams</span><span class="params">(OutputStream output,List&lt;NameValuePair&gt;paramsList)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">      StringBuilder mStringBuilder=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">      <span class="keyword">for</span> (NameValuePair pair:paramsList)&#123;</span><br><span class="line">          <span class="keyword">if</span>(!TextUtils.isEmpty(mStringBuilder))&#123;</span><br><span class="line">              mStringBuilder.append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          mStringBuilder.append(URLEncoder.encode(pair.getName(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">          mStringBuilder.append(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">          mStringBuilder.append(URLEncoder.encode(pair.getValue(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      BufferedWriter writer=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(output,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">      writer.write(mStringBuilder.toString());</span><br><span class="line">      writer.flush();</span><br><span class="line">      writer.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来我们添加请求参数，调用postParams()方法将请求的参数组织好传给HttpURLConnection的输出流，请求连接并处理返回的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">useHttpUrlConnectionPost</span><span class="params">(String url)</span> &#123;</span><br><span class="line">     <span class="type">InputStream</span> <span class="variable">mInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="type">HttpURLConnection</span> <span class="variable">mHttpURLConnection</span> <span class="operator">=</span> UrlConnManager.getHttpURLConnection(url);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         List&lt;NameValuePair&gt; postParams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">         <span class="comment">//要传递的参数</span></span><br><span class="line">         postParams.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;moon&quot;</span>));</span><br><span class="line">         postParams.add(<span class="keyword">new</span> <span class="title class_">BasicNameValuePair</span>(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123&quot;</span>));</span><br><span class="line">         UrlConnManager.postParams(mHttpURLConnection.getOutputStream(), postParams);</span><br><span class="line">         </span><br><span class="line">         mHttpURLConnection.connect();</span><br><span class="line">         </span><br><span class="line">         mInputStream = mHttpURLConnection.getInputStream();</span><br><span class="line">         <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> mHttpURLConnection.getResponseCode();</span><br><span class="line">         <span class="type">String</span> <span class="variable">respose</span> <span class="operator">=</span> converStreamToString(mInputStream);</span><br><span class="line">         Log.i(<span class="string">&quot;wangshu&quot;</span>, <span class="string">&quot;请求状态码:&quot;</span> + code + <span class="string">&quot;\n请求结果:\n&quot;</span> + respose);</span><br><span class="line">         mInputStream.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最后开启线程请求网络</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">useHttpUrlConnectionGetThread</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               useHttpUrlConnectionPost(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Android2.2前不建议使用HttpURLConnection,Android4.4后，底层实现被OkHttp替换<br>Android5.0后HttpClient被官方弃用<br>所以，在Android 2.2版本以及之前的版本使用HttpClient是较好的选择，而在Android 2.3版本及以后，HttpURLConnection则是最佳的选择，它的API简单，体积较小，因而非常适用于Android项目。压缩和缓存机制可以有效地减少网络访问的流量，在提升速度和省电方面也起到了较大的作用。另外在Android 6.0版本中，HttpClient库被移除了，HttpURLConnection则是以后我们唯一的选择。</p><p><strong>主流网络请求库</strong></p><ul><li><p>简介</p><p>网络请求开源库是一个将 网络请求+异步+数据处理 封装好的类库（网络请求是Android网络请求原生方法HttpClient或HttpURLConnection，异步包括多线程、线程池，数据处理包括序列化和反序列化）<br>使用网络请求库后，实现网络请求的需求同时不需要考虑:异步请求、线程池、缓存等等；降低开发难度，缩短开发周期，使用方便</p></li><li><p>对比</p><p><strong>现在使用人数变化很大，volley3.4k，android-async-http10.6k，okhttp 45.1k，retrofit 42.5k</strong></p></li></ul><p><img src="https://img-blog.csdnimg.cn/20190711095350906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20190711095506667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p><strong>Volley</strong></p><p>后面再进行补充，用的人少加上没用过。。。</p><h5 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h5><p><img src="https://img-blog.csdnimg.cn/20190522191648150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p><a href="#OkHttp使用和工作原理">OkHttp使用和工作原理</a></p><p><a href="#OkHttp设计模式">设计模式</a></p><p><a href="#OkHttp源码解读">OkHttp源码解读</a></p><p><a id="OkHttp使用和工作原理"></a></p><ul><li><p><strong>使用和工作原理</strong></p><p>首先是OkHttpClient</p><p>（官方建议使用单例创建OkHttpClient，即一个进程中只创建一次即可，以后的每次交易都使用该实例发送交易。这是因为OkHttpClient拥有自己的连接池和线程池，这些连接池和线程池可以重复使用，这样做利于减少延迟和节省内存。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OkHttpClient的构造采用了建造者模式</span></span><br><span class="line">mOkHttpClient = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                            .addInterceptor(loggingInterceptor)</span><br><span class="line">                            .retryOnConnectionFailure(<span class="literal">true</span>)</span><br><span class="line">                            .connectTimeout(TIME_OUT, TimeUnit.SECONDS)</span><br><span class="line">                            .readTimeout(TIME_OUT, TimeUnit.SECONDS)</span><br><span class="line">                            .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Dispatcher dispatcher;<span class="comment">//调度器</span></span><br><span class="line">   <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">   Proxy proxy;<span class="comment">//代理</span></span><br><span class="line">   <span class="keyword">final</span> List&lt;Protocol&gt; protocols;<span class="comment">//协议</span></span><br><span class="line">   <span class="keyword">final</span> List&lt;ConnectionSpec&gt; connectionSpecs;<span class="comment">//传输层版本和连接协议</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors;<span class="comment">//拦截器</span></span><br><span class="line">   <span class="keyword">final</span> List&lt;Interceptor&gt; networkInterceptors;<span class="comment">//网络拦截器</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">final</span> EventListener.Factory eventListenerFactory;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">final</span> ProxySelector proxySelector;<span class="comment">//代理选择器</span></span><br><span class="line">   <span class="keyword">final</span> CookieJar cookieJar;<span class="comment">//cookie</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">   Cache cache;<span class="comment">//cache 缓存</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">   InternalCache internalCache;<span class="comment">//内部缓存</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">final</span> SocketFactory socketFactory;<span class="comment">//socket 工厂</span></span><br><span class="line">   <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">   SSLSocketFactory sslSocketFactory;<span class="comment">//安全套层socket工厂 用于https</span></span><br><span class="line">   <span class="keyword">final</span> <span class="meta">@Nullable</span></span><br><span class="line">   CertificateChainCleaner certificateChainCleaner;<span class="comment">//验证确认响应书，适用HTTPS 请求连接的主机名</span></span><br><span class="line">   <span class="keyword">final</span> HostnameVerifier hostnameVerifier;<span class="comment">//主机名字确认</span></span><br><span class="line">   <span class="keyword">final</span> CertificatePinner certificatePinner;<span class="comment">//证书链</span></span><br><span class="line">   <span class="keyword">final</span> Authenticator proxyAuthenticator;<span class="comment">//代理身份验证</span></span><br><span class="line">   <span class="keyword">final</span> Authenticator authenticator;<span class="comment">//本地省份验证</span></span><br><span class="line">   <span class="keyword">final</span> ConnectionPool connectionPool;<span class="comment">//链接池 复用连接</span></span><br><span class="line">   <span class="keyword">final</span> Dns dns; <span class="comment">//域名</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">boolean</span> followSslRedirects;<span class="comment">//安全套接层重定向</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">boolean</span> followRedirects;<span class="comment">//本地重定向</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">boolean</span> retryOnConnectionFailure;<span class="comment">//重试连接失败</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> connectTimeout;<span class="comment">//连接超时</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> readTimeout;<span class="comment">//读取超时</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> writeTimeout;<span class="comment">//写入超时</span></span><br></pre></td></tr></table></figure><p>其次是Request</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">//Request中包含客户请求的参数：url、method、headers、requestBody和tag，也采用了建造者模式。</span></span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Call其实是RealCall，其中主要方法是①同步请求：client.newCall(request).execute；②异步请求：client.newCall(request).enqueue（常用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    Call <span class="title function_">newCall</span><span class="params">(Request request)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.newRealCall(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RealCall.java</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span> &#123;</span><br><span class="line">    <span class="comment">//TODO 不能重复执行</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">      executed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    eventListener.callStart(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//TODO 交给 dispatcher调度器 进行调度</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> <span class="title class_">AsyncCall</span>(responseCallback));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*这里synchronized (this) 确保每个call只能被执行一次不能重复执行，之后Dispatcher 调度器 将 Call 加入队列，并通过线程池执行 Call，在上面的OkHttpClient就已经初始化了Dispatcher*/</span></span><br></pre></td></tr></table></figure><p>下面就是Dispatcher了，具体结构原理在后面享学课堂部分写到了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher的属性和方法</span></span><br><span class="line"><span class="comment">//TODO 同时能进行的最大请求数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequests</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">   <span class="comment">//TODO 同时请求的相同HOST的最大个数 SCHEME :// HOST [ &quot;:&quot; PORT ] [ PATH [ &quot;?&quot; QUERY ]]</span></span><br><span class="line">   <span class="comment">//TODO 如 https://restapi.amap.com  restapi.amap.com - host</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequestsPerHost</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Ready async calls in the order they&#x27;ll be run.</span></span><br><span class="line"><span class="comment">    * TODO 双端队列，支持首尾两端 双向开口可进可出，方便移除</span></span><br><span class="line"><span class="comment">    * 异步等待队列</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet.</span></span><br><span class="line"><span class="comment">    * TODO 正在进行的异步队列</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 执行异步请求</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(AsyncCall call)</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 同时请求不能超过并发数(64,可配置调度器调整)</span></span><br><span class="line">        <span class="comment">//TODO okhttp会使用共享主机即 地址相同的会共享socket</span></span><br><span class="line">        <span class="comment">//TODO 同一个host最多允许5条线程通知执行请求</span></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp;</span><br><span class="line">                runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">            <span class="comment">//TODO 加入运行队列 并交给线程池执行</span></span><br><span class="line">            runningAsyncCalls.add(call);</span><br><span class="line">            <span class="comment">//TODO AsyncCall 是一个runnable，放到线程池中去执行，查看其execute实现</span></span><br><span class="line">            executorService().execute(call);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//TODO 加入等候队列</span></span><br><span class="line">            readyAsyncCalls.add(call);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*可见Dispatcher将Call加入队列中（若同时请求数未超过最大值，则加入运行队列，放到线程池中执行；否则加入等待队列），然后通过线程池执行call。*/</span></span><br></pre></td></tr></table></figure><p>executorService() 本质上是一个线程池执行方法，用于创建一个线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title function_">executorService</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (executorService == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//TODO 线程池的相关概念 需要理解</span></span><br><span class="line">           <span class="comment">//TODO 核心线程 最大线程 非核心线程闲置60秒回收 任务队列</span></span><br><span class="line">           executorService = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                   <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>,</span><br><span class="line">                   <span class="literal">false</span>));</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">/*使用的是SynchronousQueue作为运行队列，有请求进来就创建线程去执行，这才满足网络请求的要求，高并发并按顺序进行请求*/</span></span><br><span class="line">       <span class="keyword">return</span> executorService;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>加入线程池中的Call实际是AsyncCall，继承自NamedRunnable类，而NamedRunnable实现Runnable接口，线程池中执行execute()其实就是执行AsyncCall的execute()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AsyncCall</span> <span class="keyword">extends</span> <span class="title class_">NamedRunnable</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">signalledCallback</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//TODO 责任链模式</span></span><br><span class="line">       <span class="comment">//TODO 拦截器链  执行请求</span></span><br><span class="line">       <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> getResponseWithInterceptorChain();</span><br><span class="line">       <span class="comment">//回调结果</span></span><br><span class="line">       <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">         signalledCallback = <span class="literal">true</span>;</span><br><span class="line">         responseCallback.onFailure(RealCall.<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         signalledCallback = <span class="literal">true</span>;</span><br><span class="line">         responseCallback.onResponse(RealCall.<span class="built_in">this</span>, response);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">         <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">         Platform.get().log(INFO, <span class="string">&quot;Callback failure for &quot;</span> + toLoggableString(), e);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         eventListener.callFailed(RealCall.<span class="built_in">this</span>, e);</span><br><span class="line">         responseCallback.onFailure(RealCall.<span class="built_in">this</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//TODO 移除队列</span></span><br><span class="line">       client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>下面就是拦截器的部分了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 核心代码 开始真正的执行网络请求</span></span><br><span class="line">  Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="comment">//TODO 责任链</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//TODO 在配置okhttpClient 时设置的intercept 由用户自己设置</span></span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//TODO 负责处理失败后的重试与重定向</span></span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    <span class="comment">//TODO 负责把用户构造的请求转换为发送到服务器的请求 、把服务器返回的响应转换为用户友好的响应 处理 配置请求头等信息</span></span><br><span class="line">    <span class="comment">//TODO 从应用程序代码到网络代码的桥梁。首先，它根据用户请求构建网络请求。然后它继续呼叫网络。最后，它根据网络响应构建用户响应。</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));</span><br><span class="line">    <span class="comment">//TODO 处理 缓存配置 根据条件(存在响应缓存并被设置为不变的或者响应在有效期内)返回缓存响应</span></span><br><span class="line">    <span class="comment">//TODO 设置请求头(If-None-Match、If-Modified-Since等) 服务器可能返回304(未修改)</span></span><br><span class="line">    <span class="comment">//TODO 可配置用户自己设置的缓存拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));</span><br><span class="line">    <span class="comment">//TODO 连接服务器 负责和服务器建立连接 这里才是真正的请求网络</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      <span class="comment">//TODO 配置okhttpClient 时设置的networkInterceptors</span></span><br><span class="line">      <span class="comment">//TODO 返回观察单个网络请求和响应的不可变拦截器列表。</span></span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 执行流操作(写出请求体、获得响应数据) 负责向服务器发送请求数据、从服务器读取响应数据</span></span><br><span class="line">    <span class="comment">//TODO 进行http请求报文的封装与请求报文的解析</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 创建责任链</span></span><br><span class="line">    Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="built_in">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 执行责任链</span></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>后面是根据责任链的设计模式，按照责任链去递归执行拦截器，当责任链执行完毕，如果拦截器想要拿到最终的数据做其他的逻辑处理等，这样就不用在做其他的调用方法逻辑了，直接在当前的拦截器就可以拿到最终的数据。这也是okhttp设计的最优雅最核心的功能。周执行调度器完成方法，移除队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="type">boolean</span> promoteCalls)</span> &#123;</span><br><span class="line">        <span class="type">int</span> runningCallsCount;</span><br><span class="line">        Runnable idleCallback;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">//TODO calls 移除队列</span></span><br><span class="line">            <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>);</span><br><span class="line">            <span class="comment">//TODO 检查是否为异步请求，检查等候的队列 readyAsyncCalls，如果存在等候队列，则将等候队列加入执行队列</span></span><br><span class="line">            <span class="keyword">if</span> (promoteCalls) promoteCalls();</span><br><span class="line">            <span class="comment">//TODO 运行队列的数量</span></span><br><span class="line">            runningCallsCount = runningCallsCount();</span><br><span class="line">            idleCallback = <span class="built_in">this</span>.idleCallback;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//闲置调用</span></span><br><span class="line">        <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            idleCallback.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">promoteCalls</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 检查 运行队列 与 等待队列</span></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">        <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 将等待队列加入到运行队列中</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            <span class="type">AsyncCall</span> <span class="variable">call</span> <span class="operator">=</span> i.next();</span><br><span class="line">            <span class="comment">//TODO  相同host的请求没有达到最大，加入运行队列</span></span><br><span class="line">            <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">                i.remove();</span><br><span class="line">                runningAsyncCalls.add(call);</span><br><span class="line">                executorService().execute(call);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 同步执行请求 直接返回一个请求的结果</span></span><br><span class="line"><span class="comment">/*同步请求就直接交给调度器将Call加入执行队列，然后通过拦截器链通过责任链模式真正进行网络请求，之后完成后移除队列*/</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">      executed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    <span class="comment">//TODO 调用监听的开始方法</span></span><br><span class="line">    eventListener.callStart(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//TODO 交给调度器去执行</span></span><br><span class="line">      client.dispatcher().executed(<span class="built_in">this</span>);</span><br><span class="line">      <span class="comment">//TODO 获取请求的返回数据</span></span><br><span class="line">      <span class="type">Response</span> <span class="variable">result</span> <span class="operator">=</span> getResponseWithInterceptorChain();<span class="comment">//这里就是责任链的开始部分</span></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      eventListener.callFailed(<span class="built_in">this</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//TODO 执行调度器的完成方法 移除队列</span></span><br><span class="line">      client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>​</p><p>​<strong>总结</strong></p><p>​①OkhttpClient 实现了Call.Fctory,负责为Request 创建 Call；</p><p>​②RealCall 为Call的具体实现，其enqueue() 异步请求接口通过Dispatcher()调度器利用ExcutorService实现，而最终进行网络请求时和同步的execute()接口一致，都是通过 getResponseWithInterceptorChain() 函数实现</p><p>​③getResponseWithInterceptorChain() 中利用 Interceptor 链条，责任链模式 分层实现缓存、透明压缩、网络 IO 等功能；最终将响应数据返回给用户。</p><p><a  id="OkHttp设计模式"></a></p><ul><li><p><strong>设计模式</strong></p><ul><li><p>建造者模式</p><p>创建者模式又叫建造者模式，是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。创建者模式<strong>隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象</strong>。OkHttp中<strong>HttpClient、Request构造便是通过建造者模式</strong></p></li><li><p>简单工厂模式</p><p>okhttp 实现了Call.Factory接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    Call <span class="title function_">newCall</span><span class="params">(Request request)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Call接口</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.newRealCall(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>责任链模式</p><p>责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。<strong>看完只能说设计真的精妙</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Chain</span> &#123;</span><br><span class="line">        String <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        String <span class="title function_">proceed</span><span class="params">(String request)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BridgeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 BridgeInterceptor 拦截器之前代码&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">proceed</span> <span class="operator">=</span> chain.proceed(chain.request());</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 BridgeInterceptor 拦截器之后代码 得到最终数据：&quot;</span>+proceed);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryAndFollowInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 RetryAndFollowInterceptor 拦截器之前代码&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">proceed</span> <span class="operator">=</span> chain.proceed(chain.request());</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 RetryAndFollowInterceptor 拦截器之后代码 得到最终数据：&quot;</span> + proceed);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 CacheInterceptor 最后一个拦截器 返回最终数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span>.Chain &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Interceptor&gt; interceptors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String request;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RealInterceptorChain</span><span class="params">(List&lt;Interceptor&gt; interceptors, <span class="type">int</span> index, String request)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.interceptors = interceptors;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">proceed</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取下一个责任链</span></span><br><span class="line">        <span class="type">RealInterceptorChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, index+<span class="number">1</span>, request);</span><br><span class="line">        <span class="comment">// 执行当前的拦截器</span></span><br><span class="line">        <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> interceptor.interceptor(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试和结果</span></span><br><span class="line">List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>());</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> <span class="title class_">RetryAndFollowInterceptor</span>());</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">RealInterceptorChain</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, <span class="number">0</span>, <span class="string">&quot;request&quot;</span>);</span><br><span class="line"></span><br><span class="line">        request.proceed(<span class="string">&quot;request&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出的log</span></span><br><span class="line"><span class="comment">/*执行 BridgeInterceptor 拦截器之前代码</span></span><br><span class="line"><span class="comment">执行 RetryAndFollowInterceptor 拦截器之前代码</span></span><br><span class="line"><span class="comment">执行 CacheInterceptor 最后一个拦截器 返回最终数据</span></span><br><span class="line"><span class="comment">执行 RetryAndFollowInterceptor 拦截器之后代码 得到最终数据：success</span></span><br><span class="line"><span class="comment">执行 BridgeInterceptor 拦截器之后代码 得到最终数据：success</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><a id="OkHttp源码解读"></a></p><ul><li><p><strong>源码解读</strong></p><ul><li><p>ConnectionPool连接池</p><p>管理HTTP和SPDY连接的重用，减少网络延迟。连接池是将已经创建好的连接保存在一个缓冲池中，当有请求来时，直接使用已经创建好的连接。</p><p>在okhttp中，客户端与服务端的连接被抽象为一个个的Connection，实现类是RealConnection。而ConnectionPool就是专门用来管理Connection的类。ConnectionPool用来管理connections的复用，以减少网络的延迟。一些共享一个地址（Address）的HTTP requests可能也会共享一个Connection。ConnectionPool设置这样的策略：让一些connections保持打开状态，以备将来使用。</p><p><a href="https://blog.csdn.net/songzi1228/article/details/93855680">OKHttp开源框架学习十：ConnectionPool连接池_okhttp connectionpool-CSDN博客</a></p></li><li><p>Route路由：对地址Adress的一个封装类</p></li><li><p>RouteSelector路由选择器:在OKhttp中其实其作用也就是返回一个可用的Route对象</p></li><li><p>Platform平台：用于针对不同平台适应性</p></li><li><p>Call请求（Request\Response）：代表实际的http请求，它是连接Request和response的桥梁。由于重写，重定向，跟进和重试，你简单的请求Call可能产生多个请求Request和响应Response。OkHttp会使用Call来模化满足请求的任务，然而中间的请求和响应是必要的（重定向处理和IP出错）<br>Call执行有两种方式：<br>Synchronous：线程会阻塞直到响应可读。<br>Asynchronous：在一个线程中入队请求，当你的响应可读时在另外一个线程获取回调。<br>线程中的请求取消、失败、未完成，写请求主体和读响应主体代码会遇到IOException</p></li><li><p>Dispatchar调度器：Dispatcher是okhttp3的任务调度核心类，负责管理同步和异步的请求，管理每一个请求任务的请求状态，并且其内部维护了一个线程池用于执行相应的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatchar内部维护了三个队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//等待执行的异步队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//正在执行的异步队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//同步队列</span></span><br><span class="line">一个线程池</span><br><span class="line">  executorService = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"><span class="comment">/*Deque是一个双向队列接口，Deque接口具有丰富的抽象数据形式，它支持从队列两端点检索和插入元素</span></span><br><span class="line"><span class="comment">当需要执行的线程大于所能承受的最大范围时，就把未能及时执行的任务保存在readyAsyncCalls队列中。当线程池有空余线程可以执行时，会调用promoteCall()方法把等待队列readyAsyncCalls中的任务放到线程池执行，并把任务转移到runningAsyncCalls队列中*/</span></span><br></pre></td></tr></table></figure></li><li><p>Interceptor拦截器：拦截器是一个强大的机制，它可以监控，重写和重试Calls，自带5种拦截器，在享学课堂的OkHttp部分有写，<strong>下面的缓存相关部分是缓存拦截器内相关的原理</strong></p></li><li><p>缓存Cache</p><p>Cache来自OkHttpClient<br>Cache中采用了DiskLruCache，以Request的URL的md5为key，相应Response为value。此外Cache中还通过外观模式对外提供了InternalCache接口变量，用于调用Cache中的方法，也满足面向对象的接口隔离原则和依赖倒置原则等。<br>DiskLruCache和LruCache内部都是使用了LinkedHashMap去实现缓存算法的，只不过前者针对的是将缓存存在硬盘（&#x2F;sdcard&#x2F;Android&#x2F;data&#x2F;&#x2F;cache），而后者是直接将缓存存在内存；</p></li><li><p>缓存策略CacheStrategy</p><p>CacheStrategy的内部工厂类Factory中有一个getCandidate方法，会根据实际的请求生成对应的CacheStrategy类返回，是个典型的简单工厂模式。其内部维护一个request和response，通过指定request和response来告诉CacheInterceptor是使用缓存还是使用网络请求，亦或两者同时使用。</p></li><li><p>缓存框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 1.如果设置缓存并且当前request有缓存，则从缓存Cache中获取当前请求request的缓存response</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">cacheCandidate</span> <span class="operator">=</span> cache != <span class="literal">null</span></span><br><span class="line">      ? cache.get(chain.request())</span><br><span class="line">      : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// 2.传入的请求request和获取的缓存response通过缓存策略对象CacheStragy的工厂类get方法根据一些规则获取缓存策略CacheStrategy（这里的规则根据请求的request和缓存的Response的header头部信息生成的，比如是否有noCache标志位，是否是immutable不可变，缓存是否过期等等）</span></span><br><span class="line">  <span class="type">CacheStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">  <span class="comment">// 3.生成的CacheStrategy有2个变量，networkRequest和cacheRequest，如果networkRequest为Null表示不进行网络请求，如果cacheResponse为null，则表示没有有效缓存 </span></span><br><span class="line">  <span class="type">Request</span> <span class="variable">networkRequest</span> <span class="operator">=</span> strategy.networkRequest;</span><br><span class="line">  <span class="type">Response</span> <span class="variable">cacheResponse</span> <span class="operator">=</span> strategy.cacheResponse;</span><br><span class="line">  <span class="comment">// 4.缓存不可用，关闭</span></span><br><span class="line">  <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">    closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 5.如果networkRequest和cacheResponse都为Null,则表示不请求网络且缓存为null，返回504，请求失败</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(<span class="number">504</span>)</span><br><span class="line">        .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 6.如果不请求网络，但存在缓存，则不请求网络，直接返回缓存，结束，不执行下一个拦截器</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 7.否则，请求网络，并调用下一个拦截器链，将请求转发到下一个拦截器</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">networkResponse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    networkResponse = chain.proceed(networkRequest);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//8.请求网络，并且网络请求返回HTTP_NOT_MODIFIED，说明缓存有效，则合并网络响应和缓存结果，同时更新缓存</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build();</span><br><span class="line">      networkResponse.body().close();</span><br><span class="line">      <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">      <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">      cache.trackConditionalCacheHit();</span><br><span class="line">      cache.update(cacheResponse, response);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      closeQuietly(cacheResponse.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//9.若没有缓存，则写入缓存</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> networkResponse.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">      <span class="type">CacheRequest</span> <span class="variable">cacheRequest</span> <span class="operator">=</span> cache.put(response);</span><br><span class="line">      <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具流流程如下：</p><p>①如果本地没有缓存，直接发送网络请求；cacheResponse &#x3D;&#x3D; null<br>如果当前请求是Https，而缓存没有TLS握手，则重新发起网络请求；<br>request.isHttps() &amp;&amp; cacheResponse.handshake() &#x3D;&#x3D; null<br>如果当前的缓存策略是不可缓存，直接发送网络请求；<br>!isCacheable(cacheResponse, request)<br>请求头no-cache或者请求头包含If-Modified-Since或者If-None-Match，则需要服务器验证本地缓存是不是还能继续使用，直接网络请求；<br>requestCaching.noCache() || hasConditions(request)<br>可缓存，并且ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis（意味着虽过期，但可用，只是会在响应头添加warning），则使用缓存；<br>缓存已经过期，添加请求头：If-Modified-Since或者If-None-Match，进行网络请求；</p></li><li><p>ConnectInterceptor（核心，连接池）</p><p>（下面有部分内容前面有过了）</p><p>okhttp的一大特点就是通过连接池来减小响应延迟。如果连接池中没有可用的连接，则会与服务器建立连接，并将socket的io封装到HttpStream（发送请求和接收response）中，HttpCodec（Stream）:数据交换的流,对请求的编码以及对响应数据的解码（Stream:基于Connection的逻辑Http请求&#x2F;响应对），RealConnecton（Collection）：Connection实现类，主要实现连接的建立等工作；Http中Stream和Collection关系：Http1（Http1.0）1:1一个连接只能被一个请求流使用Http2（Http1.1）1:n一个连接可被多个请求流同时使用，且keep-alive机制保证连接使用完不关闭，当下一次请求与连接的Host相同时，连接可以直接使用，不用再次创建StreamAllocation（流分配）:会通过ConnectPool获取或者创建一个RealConnection来得到一个连接到Server的Connection连接，同时会生成一个HttpCodec用于下一个CallServerInterceptor，以完成最终的请求；RouteDataBase：这是一个关于路由信息的白名单和黑名单类，处于黑名单的路由信息会被避免不必要的尝试；ConnectionPool:连接池，实现连接的复用；<br><img src="https://img-blog.csdnimg.cn/2019052219223447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p>具体源码不看了，直接看步骤</p><p>1.框架使用URL和配置好的OkHttpClient创建一个address。此地址指定我们将如何连接到网络服务器。<br>2.框架通过address从连接池中取回一个连接。<br>3.如果没有在池中找到连接，ok会选择一个route尝试连接。这通常意味着使用一个DNS请求， 以获取服务器的IP地址。如果需要，ok还会选择一个TLS版本和代理服务器。<br>4.如果获取到一个新的route，它会与服务器建立一个直接的socket连接、使用TLS安全通道（基于HTTP代理的HTTPS），或直接TLS连接。它的TLS握手是必要的。<br>5.开始发送HTTP请求并读取响应。<br>如果有连接出现问题，OkHttp将选择另一条route，然后再试一次。这样的好处是当服务器地址的一个子集不可达时，OkHttp能够自动恢复。而且当连接池过期或者TLS版本不受支持时，这种方式非常有用。<br>一旦响应已经被接收到，该连接将被返回到池中，以便它可以在将来的请求中被重用。连接在池中闲置一段时间后，它会被赶出。</p></li><li><p>CallServerInterceptor</p><p>CallServerInterceptor的intercept()方法里 负责发送请求和获取响应，实际上都是由HttpStream类去完成具体的工作。<br>一个socket连接用来发送HTTP&#x2F;1.1消息，这个类严格按照以下生命周期：<br>1、 writeRequestHeaders()发送request header<br>httpCodec.writeRequestHeaders(request);<br>2、打开一个sink来写request body，然后关闭sink</p><p>Sink requestBodyOut &#x3D; httpCodec.createRequestBody(request, request.body().contentLength());<br>3、readResponseHeaders()读取response头部</p><p>responseBuilder &#x3D; httpCodec.readResponseHeaders(true);<br>4、打开一个source来读取response body，然后关闭source</p></li></ul></li></ul><h5 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h5><p>基于Restful风格推出的基于OkHttp的网络请求框架的二次封装的网络请求框架，本质还是OkHttp，通过Http进行网络请求，网络请求的工作本质是OkHttp完成的，Retrofit仅负责网络请求接口的封装。</p><p>App应用程序通过 Retrofit 请求网络，实际上是使用 Retrofit 接口层封装请求参数、Header、Url 等信息，之后由 OkHttp 完成后续的请求操作。在服务端返回数据之后，OkHttp 将原始的结果交给 Retrofit，Retrofit根据用户的需求对结果进行解析。</p><p><a href="#Retrofit使用">使用</a></p><p><a href="#Retrofit源码分析">源码分析</a></p><p><a href="#Retrofit设计模式">设计模式</a></p><p><strong>特点</strong></p><ul><li><p>基于OKHttp &amp; 遵循Restful API设计风格</p><p>REST，即Representational State Transfer的缩写。直接翻译的意思是”表现层状态转化”。它是一种互联网应用程序的API设计理念：URL定位资源+用HTTP动词描述操作。<br>常用的HTTP动词有下面五个：<br>1.GET（SELECT）：从服务器取出资源（一项或多项）。<br>2.POST（CREATE）：在服务器新建一个资源。<br>3.PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。<br>4.PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。<br>5.DELETE（DELETE）：从服务器删除资源。<br>REST简单来说就是url地址中只包含名词表示资源，使用http动词表示动作进行操作资源</p></li><li><p>功能强大</p><p>支持同步、异步网络请求；</p><p>支持多种数据解析方式，包括Gson、Jackson、Simple XML、Protobuf</p><p>支持多种网络请求适配器方式，包括guava、Java8、rxjava</p><p>RxJava是一个在Java VM上使用可观测的序列来组成异步的、基于事件的程序的库。<br>虽然，在Android中，我们可以使用AsyncTask来完成异步任务操作，但是当任务的梳理比较多的时候，我们要为每个任务定义一个AsyncTask就变得非常繁琐。<br>RxJava能帮助我们在实现异步执行的前提下保持代码的清晰。<br>它的原理就是创建一个Observable来完成异步任务，组合使用各种不同的链式操作，来实现各种复杂的操作，最终将任务的执行结果发射给Observer进行处理。<br>当然，RxJava不仅适用于Android，也适用于服务端等各种场景。<br>简单来说，RxJava2.0是非常好用的一个异步链式库，遵循观察者模式。</p></li><li><p>简介易用</p><p>通过注解配置网络请求参数；采用大量设计模式简化使用</p></li><li><p>可扩展性好</p><p>功能模块高度封装；解耦彻底：如：自定义Converters</p></li></ul><p><a id="Retrofit使用"></a></p><p><strong>使用</strong></p><ul><li><strong>注解类型</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20190711104014181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><ul><li><strong>流程</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20190711190302467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><ul><li><strong>具体步骤</strong></li></ul><ol><li><p>添加Retrofit依赖</p></li><li><p>创建接收服务器返回数据的类（网络请求数据类型）与用于描述网络请求的接口，服务器返回数据的类应根据返回数据的格式和数据解析方式（Json、XML等）定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Translation为根据服务器返回的数据需要解析成的Java Bean类，不定义可以传入ResponseBody</span></span><br><span class="line"><span class="comment">//用于描述网络请求的接口，采用注解描述网络请求参数和配置网络请求参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GetRequest_Interface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(&quot;openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car&quot;)</span></span><br><span class="line">    Call&lt;Translation&gt;  <span class="title function_">getCall</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// @GET注解的作用:采用Get方法发送网络请求</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// getCall() = 接收网络请求数据的方法</span></span><br><span class="line">    <span class="comment">// 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的Translation类）</span></span><br><span class="line">    <span class="comment">// 如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call&lt;ResponseBody&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Retrofit实例，设置数据解析器（Converter）与网络请求适配器（CallAdapter）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">               .baseUrl(<span class="string">&quot;http://fanyi.youdao.com/&quot;</span>) <span class="comment">// 设置网络请求的Url地址</span></span><br><span class="line">               .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// 设置数据解析器</span></span><br><span class="line">               .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) <span class="comment">// 支持RxJava平台</span></span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure></li><li><p>创建网络请求接口实例并配置网络请求参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 网络请求接口 的实例</span></span><br><span class="line"><span class="type">GetRequest_Interface</span> <span class="variable">request</span> <span class="operator">=</span> retrofit.create(GetRequest_Interface.class);</span><br></pre></td></tr></table></figure></li><li><p>调用接口方法返回Call对象，并发送异步或同步的网络请求（封装了数据转换和线程切换的操作）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 发送请求 进行封装</span></span><br><span class="line">Call&lt;Reception&gt; call = request.getCall();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送网络请求(异步)</span></span><br><span class="line">        call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;Translation&gt;() &#123;</span><br><span class="line">            <span class="comment">//请求成功时回调</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;Translation&gt; call, Response&lt;Translation&gt; response)</span> &#123;</span><br><span class="line">                <span class="comment">//请求处理,输出结果</span></span><br><span class="line">                response.body().show();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//请求失败时候的回调</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;Translation&gt; call, Throwable throwable)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送网络请求（同步）</span></span><br><span class="line">Response&lt;Reception&gt; response = call.execute();</span><br></pre></td></tr></table></figure></li><li><p>处理服务器返回的数据（Call&lt;*&gt;指定了返回的数据进行解析返回的具体类型，里面可以写Responsebody来获取Responsebody的内容，这就是请求服务器成功获取到数据后进行数据解析后自己再进行处理的逻辑了）</p></li></ol><ul><li><strong>重要角色</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20190711193645702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p><a id="Retrofit源码分析"></a></p><p><strong>Retrofit源码分析</strong></p><ul><li><p><strong>创建Retrofit实例</strong></p><p>Retrofit实例是使用建造者模式通过Builder类创建的。<br>建造者模式：将一个复杂对象的构建与表示分离，使用户在不知道对象的创建细节情况下就可以直接创建复杂的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;-- Retrofit类 --&gt;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Retrofit</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&gt; serviceMethodCache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 网络请求配置对象（对网络请求接口中方法注解进行解析后得到的对象）</span></span><br><span class="line">  <span class="comment">// 作用：存储网络请求相关的配置，如网络请求的方法、数据转换器、网络请求适配器、网络请求工厂、基地址等</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">  <span class="comment">// 网络请求的url地址</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">  <span class="comment">// 网络请求器的工厂</span></span><br><span class="line">  <span class="comment">// 作用：生产网络请求器（Call）</span></span><br><span class="line">  <span class="comment">// Retrofit是默认使用okhttp</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; adapterFactories;</span><br><span class="line">  <span class="comment">// 网络请求适配器工厂的集合</span></span><br><span class="line">  <span class="comment">// 作用：放置网络请求适配器工厂</span></span><br><span class="line">  <span class="comment">// 网络请求适配器工厂作用：生产网络请求适配器（CallAdapter）</span></span><br><span class="line">  <span class="comment">// 下面会详细说明</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line">  <span class="comment">// 数据转换器工厂的集合</span></span><br><span class="line">  <span class="comment">// 作用：放置数据转换器工厂</span></span><br><span class="line">  <span class="comment">// 数据转换器工厂作用：生产数据转换器（converter）</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">  <span class="comment">// 回调方法执行器，切换线程(子线程-主线程)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> validateEagerly; </span><br><span class="line"><span class="comment">// 标志位</span></span><br><span class="line"><span class="comment">// 作用：是否提前对业务接口中的注解进行验证转换的标志位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;-- Retrofit类的构造函数 --&gt;</span><br><span class="line">Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,  </span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; adapterFactories,  </span><br><span class="line">      Executor callbackExecutor, <span class="type">boolean</span> validateEagerly) &#123;  </span><br><span class="line">    <span class="built_in">this</span>.callFactory = callFactory;  </span><br><span class="line">    <span class="built_in">this</span>.baseUrl = baseUrl;  </span><br><span class="line">    <span class="built_in">this</span>.converterFactories = unmodifiableList(converterFactories); </span><br><span class="line">    <span class="built_in">this</span>.adapterFactories = unmodifiableList(adapterFactories);   </span><br><span class="line">    <span class="comment">// unmodifiableList(list)近似于UnmodifiableList&lt;E&gt;(list)</span></span><br><span class="line">    <span class="comment">// 作用：创建的新对象能够对list数据进行访问，但不可通过该对象对list集合中的元素进行修改</span></span><br><span class="line">    <span class="built_in">this</span>.callbackExecutor = callbackExecutor;  </span><br><span class="line">    <span class="built_in">this</span>.validateEagerly = validateEagerly;  </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 仅贴出关键代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>异步请求</strong></p></li></ul><p><a id="Retrofit设计模式"></a></p><p><strong>设计模式</strong></p><ol><li>Builder模式</li><li>工厂模式</li><li>适配器模式</li><li>代理模式</li><li>外观模式</li><li>策略模式</li><li>观察者模式</li></ol><h5 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h5><p><a href="https://blog.csdn.net/weixin_40387773/article/details/129666097?ops_request_misc=%7B%22request_id%22:%22171068402716800215092213%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171068402716800215092213&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-129666097-null-null.142%5Ev99%5Epc_search_result_base9&utm_term=rxjava&spm=1018.2226.3001.4187">RxJava详解-CSDN博客</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><h4 id="其他部分"><a href="#其他部分" class="headerlink" title="其他部分"></a>其他部分</h4><p>OOM异常：</p><p><a href="https://blog.csdn.net/QYgujingjing/article/details/131564307">Android的 OOM 异常_android读取数据库出现oom-CSDN博客</a></p><p>GC机制</p><p><a href="https://blog.csdn.net/qq_44950283/article/details/133526213">Android—GC回收机制与分代回收策略_androidgc回收机制-CSDN博客</a></p><p><strong>加载大图</strong></p><p>Android对图片的解码是图片大小等于图片总像素数*每个像素大小，图库里面的图片的分辨率比手机屏幕分辨率高的多，应该将图片压缩和用来展示的控件大小相近，否则会占用内存。</p><ul><li><p>按照缩放比解析位图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取手机的分辨率  获取windowmanager 实例</span></span><br><span class="line"><span class="type">WindowManager</span> <span class="variable">wm</span>  <span class="operator">=</span> (WindowManager) getSystemService(WINDOW_SERVICE);     screenWidth = wm.getDefaultDisplay().getWidth();</span><br><span class="line">screenHeight = wm.getDefaultDisplay().getHeight();</span><br><span class="line"><span class="comment">//2.把xxxx.jpg 转换成bitmap</span></span><br><span class="line"><span class="comment">//创建bitmap工厂的配置参数</span></span><br><span class="line">BitmapFactory.<span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Options</span>();          </span><br><span class="line"><span class="comment">//=true返回一个null 没有bitmap:不去为bitmap分配内存 但是能返回图片的一些信息(宽和高)     options.inJustDecodeBounds = true;     BitmapFactory.decodeFile(&quot;/mnt/sdcard/xxxx.jpg&quot;,options);     </span></span><br><span class="line"><span class="comment">//3.获取图片的宽和高       </span></span><br><span class="line"><span class="type">int</span> <span class="variable">imgWidth</span> <span class="operator">=</span> options.outWidth;     </span><br><span class="line"><span class="type">int</span> <span class="variable">imgHeight</span> <span class="operator">=</span> options.outHeight;</span><br><span class="line"> <span class="comment">//4.计算缩放比          </span></span><br><span class="line"><span class="type">int</span> <span class="variable">scalex</span> <span class="operator">=</span>  imgWidth/screenWidth;     </span><br><span class="line"><span class="type">int</span> <span class="variable">scaley</span> <span class="operator">=</span> imgHeight /screenHeight;</span><br><span class="line">scale =min(scalex, scaley,scale);            </span><br><span class="line"><span class="comment">//5.按照缩放比显示图片,inSampleSize给图片赋予缩放比，其值大于1时，会按缩放比返回一个小图片用来节省内存   </span></span><br><span class="line">options.inSampleSize = scale;          </span><br><span class="line"><span class="comment">//6.=false开始真正的解析位图,可显示位图 </span></span><br><span class="line">options.inJustDecodeBounds = <span class="literal">false</span>;     </span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeFile(<span class="string">&quot;/mnt/sdcard/dog.jpg&quot;</span>,options);         </span><br><span class="line"><span class="comment">//7.把bitmap显示到控件上     </span></span><br><span class="line">iv.setImageBitmap(bitmap);   &#125; &#125;</span><br></pre></td></tr></table></figure></li><li><p>图片分块加载</p><p>图片分块加载在地图绘制上的情况最为明显，当想获取一张尺寸很大的图片的某一块区域时，就用到了图片的分块加载，在Android中BitmapRegionDecoder类的功能就是加载一张图片的指定区域。</p></li><li><p>LruCache缓存机制</p></li></ul><p><strong>Android的图片三级缓存机制</strong></p><p><img src="https://img-blog.csdnimg.cn/20190523082606822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><ol><li>第一级：内存LruCache</li></ol><ul><li>相关介绍</li></ul><p>LruCache是android提供的一个缓存工具类，其算法是最近最少使用算法。它把最近使用的对象用“强引用”存储在LinkedHashMap中，并且把最近最少使用的对象在缓存值达到预设定值之前就从内存中移除。<br>LinkedHashMap:HashMap和双向链表合二为一即是LinkedHashMap。它通过维护一个额外的双向链表保证了迭代顺序。特别地，该迭代顺序可以是插入顺序，也可以是访问顺序。</p><p>这里的LinkedHashMap是基于HashMap和双向链表的封装，HashMap是线程不安全的，这里本身是个类，进入put方法会对this指带这个类进行synchronized进行加锁，保证了同步操作</p><p><strong>put方法</strong>中put成功就对size做减操作，put成功就根据缓存大小整理内存，看是否需要移除LinkedHashMap中的元素，移除过程是进行一个while循环，不断移除LinkedHashMap双向链表表头元素，近期最少使用的数据，直到满足当前缓存大小</p><p><strong>get方法</strong>是如果该值在缓存中存在或可被创建便返回，当调用LruCache的get()方法获取集合中的缓存对象时，就代表<strong>访问了一次该元素，将会更新队列，移动到表尾</strong>,这个更新过程就是在LinkedHashMap中的get()方法中完成的。</p><p>由重排序可知，对LinkedHashMap的put和get操作，都会让被操作的Entry移动到双向链表的尾部。而移除是从map.entrySet().iterator().next()开始的，也就是双向链表的表头的header的after开始的，这也就符合了LRU算法的需求。</p><ul><li>具体使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 内存缓存 */</span></span><br><span class="line">    <span class="keyword">private</span> LruCache&lt;String, Bitmap&gt; mMemoryCache = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="comment">//初始化这个cache前需要设定这个cache的大小，这里的大小官方推荐是用当前app可用内存的八分之一</span></span><br><span class="line">    mMemoryCache = <span class="keyword">new</span> <span class="title class_">LruCache</span>&lt;String, Bitmap&gt;(memoryCache) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">sizeOf</span><span class="params">(String key, Bitmap bitmap)</span> &#123;</span><br><span class="line">                <span class="comment">// 重写此方法来衡量每张图片的大小，默认返回图片数量。</span></span><br><span class="line">                <span class="keyword">return</span> bitmap.getByteCount() / <span class="number">1024</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将bitmap添加到内存中去</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBitmapToMemoryCache</span><span class="params">(String key, Bitmap bitmap)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getBitmapFromMemCache(key) == <span class="literal">null</span>) &#123;</span><br><span class="line">            mMemoryCache.put(key, bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过key来从内存缓存中获得bitmap对象</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap <span class="title function_">getBitmapFromMemCache</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mMemoryCache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*模拟从网络下载图片加入缓存*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBitmapToImageView</span><span class="params">(<span class="type">int</span> resId, ImageView imageView)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">imageKey</span> <span class="operator">=</span> String.valueOf(resId);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> getBitmapFromMemCache(imageKey); <span class="comment">// 先看这个资源在不在内存中，如果在直接读取为bitmap，否则返回null</span></span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="literal">null</span>) &#123;</span><br><span class="line">            imageView.setImageBitmap(bitmap);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            imageView.setImageResource(R.drawable.ic_launcher); <span class="comment">// 如果没有在内存中，先显示默认的图片，然后启动线程去下载图片</span></span><br><span class="line">            <span class="type">BitmapWorkerTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapWorkerTask</span>(imageView);</span><br><span class="line">            task.execute(resId); <span class="comment">// 启动线程，模拟从网络下载图片，下载后加入缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存如果没有，则继续</span></span><br></pre></td></tr></table></figure><ol start="2"><li>第二级：文件缓存</li></ol><p>存储的路径首先要考虑SD卡的缓存目录，当SD卡不存在时，就只能存到内部存储的缓存目录了。Android新版本内存改变需要注意，现在都使用内存储存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> File <span class="title function_">getCacheDir</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取缓存路径目录</span></span><br><span class="line">    File file;</span><br><span class="line">    <span class="keyword">if</span> (Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED) &#123;</span><br><span class="line">        file = mContext.getExternalCacheDir();        <span class="comment">// 有SD卡就保存到sd卡</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        file = mContext.getCacheDir();        <span class="comment">// 没有就保存到内部储存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Bitmap <span class="title function_">getBitmapFromFile</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 根据url中获取文件名字，存储文件的文件名截取URL中的名字，并且文件名用md5加密</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> url.substring(url.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getCacheDir(),MD5Util.encodeMd5(fileName));</span><br><span class="line">    <span class="keyword">if</span> (file.exists() &amp;&amp; file.length() &gt; <span class="number">0</span>) &#123; </span><br><span class="line">          diskBitmap  = BitmapFactory.decodeFile(file.getAbsolutePath());</span><br><span class="line"> mImageCache.put(url, <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Bitmap&gt;(diskBitmap)); <span class="comment">// 保存到内存中去</span></span><br><span class="line"><span class="keyword">return</span> diskBitmap;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>第三级：联网加载</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建出5条线程的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">mExecutorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用HttpUrlConnection加载网络图片</span></span><br><span class="line"><span class="type">URL</span> <span class="variable">loadUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url);</span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) loadUrl.openConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存数据到内存和文件</span></span><br><span class="line">mImageCache.put(url, <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(bm));    <span class="comment">//保存到内存</span></span><br><span class="line"><span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> url.substring(url.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>);<span class="comment">//从Url中获取文件名字，保存到磁盘</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getCacheDir(), MD5Util.encodeMd5(fileName));<span class="comment">//获取存储路径</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">bm.compress(Bitmap.CompressFormat.JPEG, <span class="number">100</span>, os);<span class="comment">//将图片转为文件存储</span></span><br></pre></td></tr></table></figure><h4 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h4><p><strong>基本用法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//with（Context/Activity/Fragment）决定Glide加载图片的生命周期</span></span><br><span class="line"><span class="comment">//load（url）url包括网络图片、本地图片、应用资源、二进制流、Uri对象等等（重载）</span></span><br><span class="line"><span class="comment">//into（imageView）</span></span><br><span class="line">Glide.with(<span class="built_in">this</span>).load(url).into(imageView);</span><br><span class="line"><span class="comment">//扩展功能</span></span><br><span class="line">.placeholder(R.drawable.loading)<span class="comment">//加载图片过程占位符，加载完成会替换占位符</span></span><br><span class="line">.error(R.drawable.error)<span class="comment">//加载图片错误占位符</span></span><br><span class="line">.asGif()/.asBitmap()只显示动态图/只显示静态图（不设置时，Glide会自动判断图片格式）</span><br><span class="line">.diskCacheStrategy(DiskCacheStrategy.NONE)<span class="comment">//禁用Glide缓存机制</span></span><br><span class="line">.override(<span class="number">100</span>, <span class="number">100</span>)<span class="comment">//指定图片大小（Glide会自动判断ImageView的大小，然后将对应的图片像素加载本地，节省内存开支）</span></span><br></pre></td></tr></table></figure><p><strong>图片加载源码分析</strong></p><p><img src="https://img-blog.csdnimg.cn/20190523082839721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><ol><li><p>with(Context&#x2F;Activity&#x2F;Fragment)</p><p>得到一个RequestManager对象（实现request和Activity&#x2F;Fragment生命周期的关联），Glide再根据传入的with()方法的参数确定图片加载的生命周期：<br>1、Application类型参数——应用程序生命周期<br>2、非Application类型参数——Activity&#x2F;Fragment生命周期</p></li><li><p>load（url）</p><p>得到一个DrawableTypeRequest对象（extends DrawableRequestBuilder）</p></li><li><p>into（imageView）</p></li></ol><p>直接看博客里面吧，写的好乱</p><p><a href="https://blog.csdn.net/qq_29966203/article/details/90473451">第六章 图片-CSDN博客</a></p><p><strong>缓存机制</strong></p><ol><li>用法开关</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置内存缓存开关</span></span><br><span class="line">skipMemoryCache(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置磁盘缓存模式</span></span><br><span class="line">diskCacheStrategy(DiskCacheStrategy.NONE)   </span><br><span class="line"><span class="comment">/*DiskCacheStrategy.NONE：表示不缓存任何内容。</span></span><br><span class="line"><span class="comment">DiskCacheStrategy.SOURCE：表示只缓存原始图片。</span></span><br><span class="line"><span class="comment">DiskCacheStrategy.RESULT：表示只缓存转换过后的图片（默认选项）。</span></span><br><span class="line"><span class="comment">DiskCacheStrategy.ALL ：表示既缓存原始图片，也缓存转换过后的图片。*/</span></span><br></pre></td></tr></table></figure><p><strong>Glide缓存源码设计思路</strong></p><p>内存缓存的操作应该是在异步处理之前，磁盘缓存是耗时操作应该是在异步处理中完成。Glide的内存缓存的读存都在Engine类中完成。<br>内存缓存使用弱引用（ActiveCache）和LruCache（Cache）结合完成的,弱引用来缓存的是正在使用中的图片。图片封装类Resources内部有个计数器判断是该图片否正在使用。</p><p><a href="https://zhuanlan.zhihu.com/p/645131894">深入理解Glide的三级缓存机制，优化图像加载 - 知乎 (zhihu.com)</a></p><ol start="2"><li>内存缓存源码分析</li></ol><ul><li><p>流程</p><p>读：先从LruCache取，取不到再从弱引用中取</p><p>存；内存缓存取不到，从网络拉取回来先放在弱引用中，渲染图片，图片对象Resources使用计数+1，计数&gt;0表示正在使用；渲染完图片，图片对象Resources使用数-1，如果计数为0表示图片缓存从弱引用中删除，放入LruCache</p></li><li><p>内存缓存源码分析</p><ul><li>Enfine在加载流程中的入口方法是load，生成一个缓存key，从LruCache中获取缓存图片，获取不到就从弱引用中获取缓存图片，内存缓存不到就进入异步处理</li></ul><p>（从内存混存取图片的两个方法loadFromCache()和loadFromActiveResources()。loadFromCache使用的就是LruCache算法，loadFromActiveResources使用的就是弱引用。）</p><ul><li><p>EngineJob是进行异步处理的核心对象，在获取到图片后就会回调Engine的onEngineJobComplete()将正在加载的图片放到弱引用缓存</p></li><li><p>EngineResource是用一个acquired变量用来记录图片被引用的次数，调用acquire()方法会让变量加1，调用release()方法会让变量减1。当引用计数acquired变量为0，即表示图片使用完，应该放入LruCache中。这里调用了listener.onResourceReleased(key, this);这个listener就是Engine对象。</p></li></ul></li></ul><ol start="3"><li>磁盘缓存源码分析</li></ol><ul><li><p>流程</p><p>读：先找处理后（result）的图片，没有的话再找原图。<br>存：先存原图，再存处理后的图。</p></li><li><p>磁盘缓存源码分析</p><ul><li><p>从磁盘缓存读取图片</p><p>EngineRunnable的run()方法-&gt;decode()方法</p></li><li><p>将图片存入磁盘缓存</p><p>获取图片后存入原图（decodeFromSource()）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title function_">decodeFromSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Resource&lt;T&gt; decoded = decodeSource();</span><br><span class="line">    <span class="keyword">return</span> transformEncodeAndTranscode(decoded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>存入原图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Resource&lt;T&gt; <span class="title function_">decodeSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        decoded = decodeFromSourceData(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Resource&lt;T&gt; <span class="title function_">decodeFromSourceData</span><span class="params">(A data)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">final</span> Resource&lt;T&gt; decoded;</span><br><span class="line">    <span class="keyword">if</span> (diskCacheStrategy.cacheSource()) &#123;<span class="comment">//设置是否缓存原图</span></span><br><span class="line">        decoded = cacheAndDecodeSourceData(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decoded = loadProvider.getSourceDecoder().decode(data, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decoded;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Resource&lt;T&gt; <span class="title function_">cacheAndDecodeSourceData</span><span class="params">(A data)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    SourceWriter&lt;A&gt; writer = <span class="keyword">new</span> <span class="title class_">SourceWriter</span>&lt;A&gt;(loadProvider.getSourceEncoder(), data);</span><br><span class="line"><span class="comment">//获取DiskCache工具类并写入缓存</span></span><br><span class="line">    diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer);</span><br><span class="line">    Resource&lt;T&gt; result = loadFromCache(resultKey.getOriginalKey());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 存入处理后的图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Resource&lt;Z&gt; <span class="title function_">transformEncodeAndTranscode</span><span class="params">(Resource&lt;T&gt; decoded)</span> &#123;</span><br><span class="line">    Resource&lt;T&gt; transformed = transform(decoded);</span><br><span class="line">    writeTransformedToCache(transformed);</span><br><span class="line">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeTransformedToCache</span><span class="params">(Resource&lt;T&gt; transformed)</span> &#123;</span><br><span class="line">    SourceWriter&lt;Resource&lt;T&gt;&gt; writer = <span class="keyword">new</span> <span class="title class_">SourceWriter</span>&lt;Resource&lt;T&gt;&gt;(loadProvider.getEncoder(), transformed);</span><br><span class="line">    diskCacheProvider.getDiskCache().put(resultKey, writer); <span class="comment">//获取DiskCache实例并写入缓存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>框架总结</strong></p><p><img src="https://img-blog.csdnimg.cn/20190523083254905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p>构建GenericRequest对象——Glide配置</p><p>构建decodeJob对象——异步处理核心对象</p><h3 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>WebView是一个基于webkit引擎、展现web页面的控件。（Android的Webview在低版本和高版本采用了不同的webkit版本内核，4.4前使用webkit，4.4后直接使用了Chrome。）</p><ul><li>显示和渲染Web页面</li><li>直接使用html文件（网络上或本地assets中）作布局</li><li>可和JavaScript交互调用</li></ul><p>由于H5具备 开发周期短、灵活性好 的特点，所以现在 Android App大多嵌入了 Android Webview 组件进行 Hybrid 开发</p><p>（移动应用开发的3种方式比较：Native App：本地应用程序（原生App），Web App：网页应用程序（移动web），Hybrid App：混生应用程序（混生App））</p><p>Android中的WebView组件，在4.4以前的版本是WebKit的内核，4.4以后才换成chromium的内核，同时鉴于Google版本帝的风格，因此也导致各个版本之间的运行效率参差不齐。而且即使是chromium内核的版本，也因为要考虑兼容以前的版本，而变得不是那么美好。并且内存泄露的问题并没有非常有效的解决方案。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>WebView可以单独使用，也可以和工具类一起使用，简单用法</p><ul><li><p>加载url</p><p><code>  webView.loadUrl(&quot;http://www.google.com/&quot;);</code></p></li><li><p>加载apk包中的html页面</p><p><code>  webView.loadUrl(&quot;file:///android_asset/test.html&quot;);</code></p></li><li><p>加载手机本地的html页面</p><p><code>   webView.loadUrl(&quot;content://com.android.htmlfileprovider/sdcard/test.html&quot;);</code></p></li><li><p>加载html的一小段内容</p><p><code>  WebView.loadData(String data, String mimeType, String encoding)</code></p><p>第一个参数为需要截取展示的内容（内容里不能出现 ’#’, ‘%’, ‘\’ , ‘?’ 这四个字符，若出现了需用 %23, %25, %27, %3f 对应来替代，否则会出现异常）；第二个参数为展示内容的类型；第三个参数为字节码</p></li></ul><p><strong>常用工具类</strong></p><p><img src="https://img-blog.csdnimg.cn/20190525100437289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><ul><li><p><strong>WebSetting类</strong></p><p>这个工具类的作用是对webView进行配置和管理，下面是一些具体的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明WebSettings子类</span></span><br><span class="line"><span class="type">WebSettings</span> <span class="variable">webSettings</span> <span class="operator">=</span> webView.getSettings();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果访问的页面中要与Javascript交互，则webview必须设置支持Javascript</span></span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="literal">true</span>);  </span><br><span class="line"><span class="comment">// 若加载的 html 里有JS 在执行动画等操作，会造成资源浪费（CPU、电量）</span></span><br><span class="line"><span class="comment">// 在 onStop 和 onResume 里分别把 setJavaScriptEnabled() 给设置成 false 和 true 即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//支持插件</span></span><br><span class="line">webSettings.setPluginsEnabled(<span class="literal">true</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//设置自适应屏幕，两者合用</span></span><br><span class="line">webSettings.setUseWideViewPort(<span class="literal">true</span>); <span class="comment">//将图片调整到适合webview的大小 </span></span><br><span class="line">webSettings.setLoadWithOverviewMode(<span class="literal">true</span>); <span class="comment">// 缩放至屏幕的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缩放操作</span></span><br><span class="line">webSettings.setSupportZoom(<span class="literal">true</span>); <span class="comment">//支持缩放，默认为true。是下面那个的前提。</span></span><br><span class="line">webSettings.setBuiltInZoomControls(<span class="literal">true</span>); <span class="comment">//设置内置的缩放控件。若为false，则该WebView不可缩放</span></span><br><span class="line">webSettings.setDisplayZoomControls(<span class="literal">false</span>); <span class="comment">//隐藏原生的缩放控件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他细节操作</span></span><br><span class="line">webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); <span class="comment">//关闭webview中缓存 </span></span><br><span class="line">webSettings.setAllowFileAccess(<span class="literal">true</span>); <span class="comment">//设置可以访问文件 </span></span><br><span class="line">webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>); <span class="comment">//支持通过JS打开新窗口 </span></span><br><span class="line">webSettings.setLoadsImagesAutomatically(<span class="literal">true</span>); <span class="comment">//支持自动加载图片</span></span><br><span class="line">webSettings.setDefaultTextEncodingName(<span class="string">&quot;utf-8&quot;</span>);<span class="comment">//设置编码格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//优先使用缓存: </span></span><br><span class="line">    WebView.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); </span><br><span class="line">        <span class="comment">//缓存模式如下：</span></span><br><span class="line">        <span class="comment">//LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据</span></span><br><span class="line">        <span class="comment">//LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。</span></span><br><span class="line">        <span class="comment">//LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.</span></span><br><span class="line">        <span class="comment">//LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不使用缓存: </span></span><br><span class="line">    WebView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (NetStatusUtil.isConnected(getApplicationContext())) &#123;</span><br><span class="line">    webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);<span class="comment">//联网状态，根据cache-control决定是否从网络上取数据。</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);<span class="comment">//无网状态，则从本地获取，即离线加载</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">webSettings.setDomStorageEnabled(<span class="literal">true</span>); <span class="comment">// 开启 DOM storage API 功能</span></span><br><span class="line">webSettings.setDatabaseEnabled(<span class="literal">true</span>);   <span class="comment">//开启 database storage API 功能</span></span><br><span class="line">webSettings.setAppCacheEnabled(<span class="literal">true</span>);<span class="comment">//开启 Application Caches 功能</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">cacheDirPath</span> <span class="operator">=</span> getFilesDir().getAbsolutePath() + APP_CACAHE_DIRNAME;</span><br><span class="line">webSettings.setAppCachePath(cacheDirPath); <span class="comment">//设置  Application Caches 缓存目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>WebViewClient</strong></p><p>处理各种通知&amp;请求事件</p><ul><li>shouldOverrideUrlLoading</li><li>onPageStarted</li><li>onPageFinished</li><li>onLoadResource</li><li>onReceivedError</li><li>onReceivedSslError</li><li></li></ul></li><li><p><strong>WebChronmeClient</strong></p><p>具体看博客吧，太多了</p><p>辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。</p><ul><li><p>onProgressChanged</p></li><li><p>onReceivedTitle</p></li><li><p>onJsAlert&#x2F;onJsConfirm&#x2F;onJsPrompt</p></li></ul></li></ul><p><strong>WebView与JS交互</strong></p><ul><li><p>Android通过WebView调用JS代码</p><ul><li><p>通过WebView的loadUrl()</p><p>将js代码以.html格式放到assets文件夹中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置与Js交互的权限</span></span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置允许JS弹窗</span></span><br><span class="line">webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先载入JS代码</span></span><br><span class="line"><span class="comment">// 格式规定为:file:///android_asset/文件名.html,这里文件名为javascript.html</span></span><br><span class="line">mWebView.loadUrl(<span class="string">&quot;file:///android_asset/javascript.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意调用的JS方法名要对应上</span></span><br><span class="line"><span class="comment">// 调用javascript的callJS()方法</span></span><br><span class="line">mWebView.loadUrl(<span class="string">&quot;javascript:callJS()&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过WebView的evaluateJavascript()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要将第一种方法的loadUrl()换成下面该方法即可</span></span><br><span class="line">    mWebView.evaluateJavascript（<span class="string">&quot;javascript:callJS()&quot;</span>, <span class="keyword">new</span> <span class="title class_">ValueCallback</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceiveValue</span><span class="params">(String value)</span> &#123;</span><br><span class="line">            <span class="comment">//此处为 js 返回的结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Android 4.4以下使用方法1，Android 4.4以上方法2</strong></p><p><img src="https://img-blog.csdnimg.cn/20190525102118858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p></li><li><p>JS通过WebView调用Android代码</p><p>具体看博客吧，太多</p><ul><li>通过 WebView的addJavascriptInterface（）进行对象映射</li><li>通过 WebViewClient 的方法shouldOverrideUrlLoading ()回调拦截 url</li><li>通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 消息</li></ul></li></ul><p><strong>性能优化</strong></p><ul><li><p><strong>问题</strong></p><ul><li>H5页面加载速度慢，体验跟Native存在很大的差距</li><li>渲染速度慢，因为JS本身解析过程就很复杂，解析速度慢，并且前端涉及到很多的js文件，叠加起来更慢，并且Android的机型很多，导致手机设备的性能不可控，大部分安卓手机无法达到很好的硬件性能</li><li>页面加载缓慢，H5页面一般很多并且请求H5页面会产生许多的网络请求，每个网络请求都是串行的，加载速度更加缓慢</li><li>耗费流量，每次使用H5页面，每加载一个页面都会产生很多的网络请求，很耗费流量</li></ul></li><li><p><strong>解决方案</strong></p><ul><li><p>前端的缓存机制</p><ul><li><p>其实就是离线缓存，这样在没有网络的时候也可以访问，WebView的本质 &#x3D; 在 Android中嵌入 H5页面，所以，Android WebView自带的缓存机制其实就是 H5页面的缓存机制。Android WebView除了新的File System缓存机制还不支持，其他都支持。</p></li><li><p>离线缓存可以让用户在没有网络的时候依然可以对H5页面进行访问；并且这样可以提高网页的加载速度和减少流量的消耗，直接使用已缓存的资源就不需要重新加载</p></li><li><p>在看缓存机制之前先看缓存模式，WebView缓存模式有下面四种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存模式说明: </span></span><br><span class="line">      <span class="comment">// LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据</span></span><br><span class="line">      <span class="comment">// LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.</span></span><br><span class="line">      <span class="comment">// LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。</span></span><br><span class="line">      <span class="comment">// LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体使用</span></span><br><span class="line">WebView.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);</span><br></pre></td></tr></table></figure></li><li><p>①缓存机制：浏览器的缓存机制是在Http协议头里面的Cache-Control（或 Expires）和 Last-Modified（或 Etag）等字段来控制文件缓存的机制。（这里可以看网络的Http相关的部分）这个属于浏览器内核机制，Android WebView内置自动实现，即不需要设置即实现。</p></li><li><p>②上面是浏览器的缓存机制，这里是Application Cache 缓存机制，以文件为单位进行缓存，类似浏览器缓存机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html manifest=<span class="string">&quot;demo_html.appcache&quot;</span>&gt;</span><br><span class="line"><span class="comment">// HTML 在头中通过 manifest 属性引用 manifest 文件</span></span><br><span class="line"><span class="comment">// manifest 文件：就是上面以 appcache 结尾的文件，是一个普通文件文件，列出了需要缓存的文件</span></span><br><span class="line"><span class="comment">// 浏览器在首次加载 HTML 文件时，会解析 manifest 属性，并读取 manifest 文件，获取 Section：CACHE MANIFEST 下要缓存的文件列表，再对文件缓存</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理说明如下：</span></span><br><span class="line"><span class="comment">// AppCache 在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新 manifest 文件</span></span><br><span class="line"><span class="comment">// 因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查 manifest 文件有没有修改（byte by byte)</span></span><br><span class="line">发现有修改，就会重新获取 manifest 文件，对 Section：CACHE MANIFEST 下文件列表检查更新</span><br><span class="line"><span class="comment">// manifest 文件与缓存文件的检查更新也遵守浏览器缓存机制</span></span><br><span class="line"><span class="comment">// 如用户手动清了 AppCache 缓存，下次加载时，浏览器会重新生成缓存，也可算是一种缓存的更新</span></span><br><span class="line"><span class="comment">// AppCache 的缓存文件，与浏览器的缓存文件分开存储的，因为 AppCache 在本地有 5MB（分 HOST）的空间限制</span></span><br></pre></td></tr></table></figure><p>这是专门为web app离线使用而开发的缓存机制，应用场景是存储静态文件，如js、css、字体文件**(AppCache 是对 浏览器缓存机制 的补充，不是替代。)**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体实现</span></span><br><span class="line">        <span class="comment">// 通过设置WebView的settings来实现</span></span><br><span class="line">        <span class="type">WebSettings</span> <span class="variable">settings</span> <span class="operator">=</span> getSettings();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheDirPath</span> <span class="operator">=</span> context.getFilesDir().getAbsolutePath()+<span class="string">&quot;cache/&quot;</span>;</span><br><span class="line">        settings.setAppCachePath(cacheDirPath);</span><br><span class="line">        <span class="comment">// 1. 设置缓存路径</span></span><br><span class="line"></span><br><span class="line">         settings.setAppCacheMaxSize(<span class="number">20</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 2. 设置缓存大小</span></span><br><span class="line"></span><br><span class="line">        settings.setAppCacheEnabled(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 3. 开启Application Cache存储机制</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 特别注意</span></span><br><span class="line"><span class="comment">// 每个 Application 只调用一次 WebSettings.setAppCachePath() 和WebSettings.setAppCacheMaxSize()</span></span><br></pre></td></tr></table></figure></li><li><p>③还有Dom Storage 缓存机制，通过存储字符串的 Key - Value 对来提供，DOM Storage 分为 sessionStorage（具备临时性，存储和页面相关的数据，页面关闭后无法使用） &amp; localStorage（具备持久性，保存的数据在页面关闭后也可以使用），使用方法基本相同，不同浏览器的存储空间大小不同，但是简单数据存储在本地就不需要频繁向浏览器发送网络请求，可替代cookies，存储不需要让服务器知道的消息，这个类似Android的SharedPreference机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过设置 `WebView`的`Settings`类实现</span></span><br><span class="line">      <span class="type">WebSettings</span> <span class="variable">settings</span> <span class="operator">=</span> getSettings();</span><br><span class="line">      <span class="comment">// 开启DOM storage</span></span><br><span class="line">      settings.setDomStorageEnabled(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li><li><p>④IndexedDB 缓存机制，属于 NoSQL （非关系型数据库）数据库，通过存储字符串的 Key - Value 对来提供，类似于 Dom Storage 存储机制 的key-value存储方式，特点是功能强大，通过数据库事物进行存储，默认250M空间，内存空间较大，适用于存储复杂、数据量大的结构化数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过设置WebView的settings实现</span></span><br><span class="line">        <span class="type">WebSettings</span> <span class="variable">settings</span> <span class="operator">=</span> getSettings();</span><br><span class="line"></span><br><span class="line">        settings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 只需设置支持JS就自动打开IndexedDB存储机制</span></span><br><span class="line">        <span class="comment">// Android 在4.4开始加入对 IndexedDB 的支持，只需打开允许 JS 执行的开关就好了。</span></span><br></pre></td></tr></table></figure></li><li><p>⑤Web SQL Database 缓存机制（不再维护）</p></li><li><p>⑥File System，这是H5新加入的缓存机制，android webView不支持</p></li><li><p>缓存机制总结和建议</p><p><img src="https://img-blog.csdnimg.cn/20190525124036537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/2019052512414046.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p></li></ul></li><li><p>资源预加载</p><p>在应用启动、初始化第一个WebView对象时，直接开始网络请求加载H5页面，后续需打开这些H5页面时就直接从该本地对象中获取。<br>a. 从而 事先加载常用的H5页面资源（加载后就有缓存了）<br>b. 此方法虽然不能减小WebView初始化时间，但数据请求和WebView初始化可以并行进行，总体的页面加载时间就缩短了；缩短总体的页面加载时间：<br>具体实现<br>在Android 的BaseApplication里初始化一个WebView对象（用于加载常用的H5页面资源）；当需使用这些页面时再从BaseApplication里取过来直接使用</p></li><li><p>资源拦截（自身构建缓存）</p><ul><li><p>H5页面有一些更新频率低、常用&amp;固定的静态资源文件，如JS、CSS文件、图片等。每次重新加载会浪费很多资源（时间&amp;流量）。可以通过拦截H5页面的资源请求网络，若资源相同，可以直接从本地读取资源而不需发送网络请求到服务器读取。</p></li><li><p>步骤1：事先将更新频率较低、常用 &amp; 固定的H5静态资源 文件（如JS、CSS文件、图片等） 放到本地<br>步骤2：拦截H5页面的资源网络请求 并进行检测。（重写WebViewClient 的 shouldInterceptRequest 方法，当向服务器访问这些静态资源时进行拦截）<br>步骤3：如果检测到本地具有相同的静态资源 就 直接从本地读取进行替换 而 不发送该资源的网络请求 到 服务器获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    </span><br><span class="line">    WebView mWebview;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        </span><br><span class="line">        mWebview = (WebView) findViewById(R.id.webview);</span><br><span class="line">        <span class="comment">// 创建WebView对象</span></span><br><span class="line"></span><br><span class="line">        mWebview.getSettings().setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 支持与JS交互</span></span><br><span class="line"></span><br><span class="line">        mWebview.loadUrl(<span class="string">&quot;http://ip.cn/&quot;</span>);</span><br><span class="line">        <span class="comment">// 加载需要显示的网页</span></span><br><span class="line"></span><br><span class="line">        mWebview.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>() &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 复写shouldInterceptRequest</span></span><br><span class="line">             <span class="comment">//API21以下用shouldInterceptRequest(WebView view, String url)</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> WebResourceResponse <span class="title function_">shouldInterceptRequest</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 步骤1:判断拦截资源的条件，即判断url里的图片资源的文件名</span></span><br><span class="line">                <span class="comment">// 此处网页里图片的url为:http://s.ip-cdn.com/img/logo.gif</span></span><br><span class="line">                <span class="comment">// 图片的资源文件名为:logo.gif</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (url.contains(<span class="string">&quot;logo.gif&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 步骤2:创建一个输入流</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        is =getApplicationContext().getAssets().open(<span class="string">&quot;images/error.png&quot;</span>);</span><br><span class="line">                        <span class="comment">// 步骤3:打开需要替换的资源(存放在assets文件夹里)</span></span><br><span class="line">                        <span class="comment">// 在app/src/main下创建一个assets文件夹</span></span><br><span class="line">                        <span class="comment">// assets文件夹里再创建一个images文件夹,放一个error.png的图片</span></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 步骤4:替换资源</span></span><br><span class="line"></span><br><span class="line">                    <span class="type">WebResourceResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebResourceResponse</span>(<span class="string">&quot;image/png&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;utf-8&quot;</span>, is);</span><br><span class="line">                    <span class="comment">// 参数1:http请求里该图片的Content-Type,此处图片为image/png</span></span><br><span class="line">                    <span class="comment">// 参数2:编码类型</span></span><br><span class="line">                    <span class="comment">// 参数3:替换资源的输入流</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;旧API&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> response;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.shouldInterceptRequest(view, url);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// API21以上用shouldInterceptRequest(WebView view, WebResourceRequest request)</span></span><br><span class="line">            <span class="meta">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> WebResourceResponse <span class="title function_">shouldInterceptRequest</span><span class="params">(WebView view, WebResourceRequest request)</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 步骤1:判断拦截资源的条件，即判断url里的图片资源的文件名</span></span><br><span class="line">                <span class="comment">// 此处图片的url为:http://s.ip-cdn.com/img/logo.gif</span></span><br><span class="line">                <span class="comment">// 图片的资源文件名为:logo.gif</span></span><br><span class="line">                <span class="keyword">if</span> (request.getUrl().toString().contains(<span class="string">&quot;logo.gif&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 步骤2:创建一个输入流</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        is = getApplicationContext().getAssets().open(<span class="string">&quot;images/error.png&quot;</span>);</span><br><span class="line">                        <span class="comment">// 步骤3:打开需要替换的资源(存放在assets文件夹里)</span></span><br><span class="line">                        <span class="comment">// 在app/src/main下创建一个assets文件夹</span></span><br><span class="line">                        <span class="comment">// assets文件夹里再创建一个images文件夹,放一个error.png的图片</span></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//步骤4:替换资源</span></span><br><span class="line">                   </span><br><span class="line">                    <span class="type">WebResourceResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebResourceResponse</span>(<span class="string">&quot;image/png&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;utf-8&quot;</span>, is);</span><br><span class="line">                    <span class="comment">// 参数1：http请求里该图片的Content-Type,此处图片为image/png</span></span><br><span class="line">                    <span class="comment">// 参数2：编码类型</span></span><br><span class="line">                    <span class="comment">// 参数3：存放着替换资源的输入流（上面创建的那个）</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">return</span> response;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.shouldInterceptRequest(view, request);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>总结</strong></p><p>加载速度慢，跟Native相比差很远</p><p>解析速度慢（在BaseApplication预加载）</p><p>消耗流量（缓存，浏览器的缓存机制，不需要手动实现；Application Cache本地文件存储，js，css，字体文件；Dom Storage键值对，存储内容少，Cookice；Index DB非关系型数据库，250M，存储空间大，键值对）（资源拦截，通过回调事件拦截请求的链接中的某些固定资源文件直接从本地替换）</p></li></ul><h4 id="使用漏洞"><a href="#使用漏洞" class="headerlink" title="使用漏洞"></a>使用漏洞</h4><ul><li><p>任意代码执行漏洞</p><ul><li><p>JS调用Android的其中一个方式是通过addJavascriptInterface接口进行对象映射，但是获取到这个对象后就能借助这个对象进行任意代码的运行，可以窃取本地数据，那么就会造成数据的泄密</p><p>解决方案1： Android 4.2版本之后<br>Google 在Android 4.2 版本中规定对被调用的函数以 @JavascriptInterface进行注解从而避免漏洞攻击<br>解决方案2：Android 4.2版本之前<br>在Android 4.2版本之前采用拦截prompt（）进行漏洞修复。<br>步骤1：继承 WebView ，重写 addJavascriptInterface 方法，然后在内部自己维护一个对象映射关系的 Map；将需要添加的 JS 接口放入该Map中<br>步骤2：每次当 WebView 加载页面前加载一段本地的 JS 代码，原理是：<br>（1）让JS调用一Javascript方法：该方法是通过调用prompt（）把JS中的信息（含特定标识，方法名称等）传递到Android端；<br>（2）在Android的onJsPrompt（）中 ，解析传递过来的信息，再通过反射机制调用Java对象的方法，这样实现安全的JS调用Android代码。<br>关于Android返回给JS的值：可通过prompt（）把Java中方法的处理结果返回到Js中<br>具体需加载的JS代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">javascript:(function <span class="title function_">JsAddJavascriptInterface_</span><span class="params">()</span>&#123;  </span><br><span class="line"><span class="comment">// window.jsInterface 表示在window上声明了一个Js对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   jsInterface = 注册的对象名</span></span><br><span class="line"><span class="comment">// 它注册了两个方法，onButtonClick(arg0)和onImageClick(arg0, arg1, arg2)</span></span><br><span class="line"><span class="comment">// 如果有返回值，就添加上return</span></span><br><span class="line">    <span class="keyword">if</span> (typeof(window.jsInterface)!=<span class="string">&#x27;undefined&#x27;</span>) &#123;      </span><br><span class="line">        console.log(<span class="string">&#x27;window.jsInterface_js_interface_name is exist!!&#x27;</span>);&#125;   </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        window.jsInterface = &#123;     </span><br><span class="line"></span><br><span class="line">     <span class="comment">// 声明方法形式：方法名: function(参数)</span></span><br><span class="line">            onButtonClick:function(arg0) &#123;   </span><br><span class="line"><span class="comment">// prompt（）返回约定的字符串</span></span><br><span class="line"><span class="comment">// 该字符串可自己定义</span></span><br><span class="line"><span class="comment">// 包含特定的标识符MyApp和 JSON 字符串（方法名，参数，对象名等）    </span></span><br><span class="line">                <span class="keyword">return</span> prompt(<span class="string">&#x27;MyApp:&#x27;</span>+JSON.stringify(&#123;obj:<span class="string">&#x27;jsInterface&#x27;</span>,func:<span class="string">&#x27;onButtonClick&#x27;</span>,args:[arg0]&#125;));  </span><br><span class="line">            &#125;,  </span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">            onImageClick:function(arg0,arg1,arg2) &#123;   </span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">prompt(<span class="string">&#x27;MyApp:&#x27;</span>+JSON.stringify(&#123;obj:<span class="string">&#x27;jsInterface&#x27;</span>,func:<span class="string">&#x27;onImageClick&#x27;</span>,args:[arg0,arg1,arg2]&#125;));  </span><br><span class="line">            &#125;,  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当JS调用 onButtonClick（） 或 onImageClick（） 时，就会回调到Android中的 onJsPrompt （）</span></span><br><span class="line"><span class="comment">// 我们解析出方法名，参数，对象名</span></span><br><span class="line"><span class="comment">// 再通过反射机制调用Java对象的方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>searchBoxJavaBridge_接口引起远程代码执行漏洞；accessibility和 accessibilityTraversal接口引起远程代码执行漏洞</p><p>在Android 3.0以下，Android系统会默认通过searchBoxJavaBridge_的Js接口给 WebView 添加一个JS映射对象：searchBoxJavaBridge_对象,该接口可能被利用，实现远程任意代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过调用该方法删除接口</span></span><br><span class="line">removeJavascriptInterface（）；</span><br></pre></td></tr></table></figure></li></ul></li><li><p>密码明文存储漏洞</p><p>WebView默认会开启M码保存功能，开启后会提示是否保存密码，但是这个密码是明文保存到本地的数据库中的，就会有密码被窃的风险，只需要关闭这个功能就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView.setSavePassword(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li><li><p>域控制不严格漏洞</p><p>即 A 应用可以通过 B 应用导出的 Activity 让 B 应用加载一个恶意的 file 协议的 url，从而可以获取 B 应用的内部私有文件，从而带来数据泄露威胁.</p><p>对于不需要使用file协议的应用，禁用file协议</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁用 file 协议；</span></span><br><span class="line">setAllowFileAccess(<span class="literal">false</span>); </span><br><span class="line">setAllowFileAccessFromFileURLs(<span class="literal">false</span>);</span><br><span class="line">setAllowUniversalAccessFromFileURLs(<span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于需要使用file协议的应用，禁止file协议加载js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要使用 file 协议</span></span><br><span class="line">setAllowFileAccess(<span class="literal">true</span>); </span><br><span class="line">setAllowFileAccessFromFileURLs(<span class="literal">false</span>);</span><br><span class="line">setAllowUniversalAccessFromFileURLs(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止 file 协议加载 JavaScript</span></span><br><span class="line"><span class="keyword">if</span> (url.startsWith(<span class="string">&quot;file://&quot;</span>) &#123;</span><br><span class="line">    setJavaScriptEnabled(<span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>避免内存泄露</p><ul><li><p>不在xml中定义 WebView ，而是在需要的时候在Activity中创建，并且Context使用 getApplicationgContext()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinearLayout</span>.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">        mWebView = <span class="keyword">new</span> <span class="title class_">WebView</span>(getApplicationContext());</span><br><span class="line">        mWebView.setLayoutParams(params);</span><br><span class="line">        mLayout.addView(mWebView);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空。</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mWebView != <span class="literal">null</span>) &#123;</span><br><span class="line">            mWebView.loadDataWithBaseURL(<span class="literal">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">            mWebView.clearHistory();</span><br><span class="line"></span><br><span class="line">            ((ViewGroup) mWebView.getParent()).removeView(mWebView);</span><br><span class="line">            mWebView.destroy();</span><br><span class="line">            mWebView = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ul><li><p>webView.onResume() ；</p><p>激活WebView为活跃状态，能正常执行网页的响应</p></li><li><p>webView.onPause()；</p><p>当页面被失去焦点，被切换到后台不可见状态，需要执行onPause，通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。</p></li><li><p>webView.pauseTimers()；</p><p>当应用程序(存在webview)被切换到后台时，这个方法不仅仅针对当前的webview而是全局的全应用程序的webview，它会暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。</p></li><li><p>webView.resumeTimers()；</p><p>恢复pauseTimers状态。</p></li><li><p>rootLayout.removeView(webView);以及webView.destroy();</p><p>销毁Webview。在关闭了Activity时，如果Webview的音乐或视频，还在播放。就必须销毁Webview，但是注意：webview调用destory时,webview仍绑定在Activity上，这是由于自定义webview构建时传入了该Activity的context对象。因此需要先从父容器中移除webview,然后再销毁webview。</p></li></ul><p><strong>一些相关的方法</strong></p><ul><li><strong>关于前进&#x2F;后退网页</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否可以后退</span></span><br><span class="line">Webview.canGoBack() </span><br><span class="line"><span class="comment">//后退网页</span></span><br><span class="line">Webview.goBack()</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否可以前进                     </span></span><br><span class="line">Webview.canGoForward()</span><br><span class="line"><span class="comment">//前进网页</span></span><br><span class="line">Webview.goForward()</span><br><span class="line"></span><br><span class="line"><span class="comment">//以当前的index为起始点前进或者后退到历史记录中指定的steps</span></span><br><span class="line"><span class="comment">//如果steps为负数则为后退，正数则为前进</span></span><br><span class="line">Webview.goBackOrForward(intsteps) </span><br></pre></td></tr></table></figure><ul><li><strong>清除缓存数据</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除网页访问留下的缓存</span></span><br><span class="line"><span class="comment">//由于内核缓存是全局的因此这个方法不仅仅针对webview而是针对整个应用程序.</span></span><br><span class="line">Webview.clearCache(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除当前webview访问的历史记录</span></span><br><span class="line"><span class="comment">//只会webview访问历史记录里的所有记录除了当前访问记录</span></span><br><span class="line">Webview.clearHistory()；</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个api仅仅清除自动完成填充的表单数据，并不会清除WebView存储到本地的数据</span></span><br><span class="line">Webview.clearFormData()；</span><br></pre></td></tr></table></figure><h3 id="多线程、进程间通信"><a href="#多线程、进程间通信" class="headerlink" title="多线程、进程间通信"></a>多线程、进程间通信</h3><h4 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h4><ul><li><strong>基础使用</strong></li></ul><p>这里主要讲在Android部分的多线程运用，基础看前面的Java部分</p><p><img src="https://img-blog.csdnimg.cn/2019052321160290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p>继承Thread和实现Runnable接口的方式前面Java部分有，使用方式一样，这里不写了</p><p><img src="https://img-blog.csdnimg.cn/20190523212450563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p><strong><a href="#Handler">Handler</a></strong></p><p>这部分看后面的内容，下面设计到Handler，需要先了解Handler</p><ul><li><p><strong>复合使用</strong></p><ul><li><p>AsyncTask</p><p>（已经弃用，Android给出的替代建议是使用java.util.concurrent包下的相关类，如Executor，ThreadPoolExecutor，FutureTask或kotlin并发工具中的协程-Coroutines）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AsyncTask</span>&lt;Params, Progress, Result&gt; &#123; </span><br><span class="line"> ... </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不需使用”任务线程（如Thread类）+Handler”复杂组合，方便实现异步通信<br>采用线程池的缓存线程+复用线程，避免频繁创建&amp;销毁线程所带来的系统资源开销</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建AsyncTask子类  </span></span><br><span class="line"><span class="comment">//这里接收三个范型，不使用就用void替代</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">AsyncTask</span>&lt;String, Integer, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法1：onPreExecute（）</span></span><br><span class="line">        <span class="comment">// 作用：执行 线程任务前的操作</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPreExecute</span><span class="params">()</span> &#123;</span><br><span class="line">            text.setText(<span class="string">&quot;加载中&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行前显示提示</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法2：doInBackground（）</span></span><br><span class="line">        <span class="comment">// 作用：接收输入参数、执行任务中的耗时操作、返回 线程任务执行的结果</span></span><br><span class="line">        <span class="comment">// 此处通过计算从而模拟“加载进度”的情况</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> String <span class="title function_">doInBackground</span><span class="params">(String... params)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (count&lt;<span class="number">99</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    count += length;</span><br><span class="line">                    <span class="comment">// 可调用publishProgress（）显示进度, 之后将执行onProgressUpdate（）</span></span><br><span class="line">                    publishProgress(count);</span><br><span class="line">                    <span class="comment">// 模拟耗时任务</span></span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法3：onProgressUpdate（）</span></span><br><span class="line">        <span class="comment">// 作用：在主线程 显示线程任务执行的进度</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onProgressUpdate</span><span class="params">(Integer... progresses)</span> &#123;</span><br><span class="line"></span><br><span class="line">            progressBar.setProgress(progresses[<span class="number">0</span>]);</span><br><span class="line">            text.setText(<span class="string">&quot;loading...&quot;</span> + progresses[<span class="number">0</span>] + <span class="string">&quot;%&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法4：onPostExecute（）</span></span><br><span class="line">        <span class="comment">// 作用：接收线程任务执行结果、将执行结果显示到UI组件</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPostExecute</span><span class="params">(String result)</span> &#123;</span><br><span class="line">            <span class="comment">// 执行完毕后，则更新UI</span></span><br><span class="line">            text.setText(<span class="string">&quot;加载完毕&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法5：onCancelled()</span></span><br><span class="line">        <span class="comment">// 作用：将异步任务设置为：取消状态</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCancelled</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            text.setText(<span class="string">&quot;已取消&quot;</span>);</span><br><span class="line">            progressBar.setProgress(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//必须在UI线程创建</span></span><br><span class="line"><span class="type">MyTask</span> <span class="variable">mTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动调用execute()执行异步线程任务</span></span><br><span class="line">mTask.execute()；</span><br></pre></td></tr></table></figure><p>AsyncTask不与任何组件绑定生命周期，cancel需要在Activity或Fragment销毁时调用；需要声明为Activity的静态内部类，否则Activity无法回收最后会引起内存泄露；Activity重建时重写onPostExecute()不生效，即无法更新UI操作，在Activity恢复时要重启任务线程</p><p><strong>原理</strong></p><p><img src="https://img-blog.csdnimg.cn/20190523213558337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p></li><li><p>HandlerThread</p><p>HandlerThread是一个Android已封装好的轻量级异步类，用于实现多线程（在工作线程中执行耗时任务）及异步通信、消息传递（工作线程&amp;主线程之间通信）从而保证线程安全<br>HandlerThread本质上是通过继承Thread类和封装Handler类的使用，从而使得创建新线程和与其他线程进行通信变得更加方便易用（不需要使用”任务线程（如继承Thread类）+Handler”复杂组合）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    Handler mainHandler,workHandler;</span><br><span class="line">    HandlerThread mHandlerThread;</span><br><span class="line">    TextView text;</span><br><span class="line">    Button button1,button2,button3;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示文本</span></span><br><span class="line">        text = (TextView) findViewById(R.id.text1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建与主线程关联的Handler</span></span><br><span class="line">        mainHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 步骤1：创建HandlerThread实例对象</span></span><br><span class="line"><span class="comment">          * 传入参数 = 线程名字，作用 = 标记该线程</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        mHandlerThread = <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;handlerThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 步骤2：启动线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mHandlerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 步骤3：创建工作线程Handler &amp; 复写handleMessage（）</span></span><br><span class="line"><span class="comment">         * 作用：关联HandlerThread的Looper对象、实现消息处理操作 &amp; 与其他线程进行通信</span></span><br><span class="line"><span class="comment">         * 注：消息处理操作（HandlerMessage（））的执行线程 = mHandlerThread所创建的工作线程中执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        workHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mHandlerThread.getLooper())&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// 消息处理的操作</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//设置了两种消息处理操作,通过msg来进行识别</span></span><br><span class="line">                <span class="keyword">switch</span>(msg.what)&#123;</span><br><span class="line">                    <span class="comment">// 消息1</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//延时操作</span></span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 通过主线程Handler.post方法进行在主线程的UI更新操作</span></span><br><span class="line">                        mainHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">                                text.setText(<span class="string">&quot;我爱学习&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 消息2</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        mainHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">                                text.setText(<span class="string">&quot;我不喜欢学习&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 步骤4：使用工作线程Handler向工作线程的消息队列发送消息</span></span><br><span class="line"><span class="comment">         * 在工作线程中，当消息循环时取出对应消息 &amp; 在工作线程执行相关操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 点击Button1</span></span><br><span class="line">        button1 = (Button) findViewById(R.id.button1);</span><br><span class="line">        button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过sendMessage（）发送</span></span><br><span class="line">                <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">                msg.what = <span class="number">1</span>; <span class="comment">//消息的标识</span></span><br><span class="line">                msg.obj = <span class="string">&quot;A&quot;</span>; <span class="comment">// 消息的存放</span></span><br><span class="line">                <span class="comment">// b. 通过Handler发送消息到其绑定的消息队列</span></span><br><span class="line">                workHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 点击Button2</span></span><br><span class="line">        button2 = (Button) findViewById(R.id.button2);</span><br><span class="line">        button2.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过sendMessage（）发送</span></span><br><span class="line">                <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">                msg.what = <span class="number">2</span>; <span class="comment">//消息的标识</span></span><br><span class="line">                msg.obj = <span class="string">&quot;B&quot;</span>; <span class="comment">// 消息的存放</span></span><br><span class="line">                <span class="comment">// b. 通过Handler发送消息到其绑定的消息队列</span></span><br><span class="line">                workHandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 点击Button3</span></span><br><span class="line">        <span class="comment">// 作用：退出消息循环</span></span><br><span class="line">        button3 = (Button) findViewById(R.id.button3);</span><br><span class="line">        button3.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                mHandlerThread.quit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理</strong></p><p>内部原理 &#x3D; Thread类 + Handler类机制<br>（1）通过继承Thread类，快速创建1个带有Looper对象的新工作线程<br>（2）通过封装Handler类，快速创建Handler&amp;与其他线程进行通信</p><p><img src="https://img-blog.csdnimg.cn/2019052321452484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p><strong>源码分析看博客，有些部分在后面享学课堂多线程里面有</strong></p><p><strong>问题和解决</strong></p><ul><li><p>连续发消息，点击三下按钮但是不是显示最新的一次操作，而是所有的操作都会进行排队，一个个显示出来，只是因为只开了一个工作线程；</p></li><li><p>Handler导致内存泄露：当Handler消息队列 还有未处理的消息 &#x2F; 正在处理消息时，存在引用关系： “未被处理 &#x2F; 正处理的消息 -&gt; Handler实例 -&gt; 外部类”</p><p>若出现 Handler的生命周期 &gt; 外部类的生命周期 时（即 Handler消息队列 还有未处理的消息 &#x2F; 正在处理消息 而 外部类需销毁时），将使得外部类无法被垃圾回收器（GC）回收，从而造成 内存泄露</p><p>解决是：将Handler子类设置为静态内部类+使用weakReference弱引用（<strong>如果一个对象只具有弱引用（就是说弱引用指向了某个对象，但只要该对象不是强引用或没有被强引用指向），那么在垃圾回收器线程扫描的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</strong>）持有Activity实例</p></li></ul></li><li><p>IntentService</p><p>Android里的一个封装类，继承四大组件之一Service，用于处理异步请求&amp;实现多线程。线程任务需按顺序、在后台执行。适用于离线下载，不符合多个数据同时请求的场景（所有任务都在同一个Thread looper里执行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myIntentService</span> <span class="keyword">extends</span> <span class="title class_">IntentService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 在构造函数中传入线程名字</span></span><br><span class="line"><span class="comment">    **/</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">myIntentService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">        <span class="comment">// 参数 = 工作线程的名字</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;myIntentService&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 复写onHandleIntent()方法</span></span><br><span class="line"><span class="comment">     * 根据 Intent实现 耗时任务 操作</span></span><br><span class="line"><span class="comment">     **/</span>  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onHandleIntent</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 Intent的不同，进行不同的事务处理</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">taskName</span> <span class="operator">=</span> intent.getExtras().getString(<span class="string">&quot;taskName&quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span> (taskName) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;task1&quot;</span>:</span><br><span class="line">                Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;do task1&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;task2&quot;</span>:</span><br><span class="line">                Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;do task2&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;onCreate&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 复写onStartCommand()方法</span></span><br><span class="line"><span class="comment">     * 默认实现 = 将请求的Intent添加到工作队列里</span></span><br><span class="line"><span class="comment">     **/</span>  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;onStartCommand&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;myIntentService&quot;</span>, <span class="string">&quot;onDestroy&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同一服务只会开启1个工作线程</span></span><br><span class="line">            <span class="comment">// 在onHandleIntent（）函数里，依次处理传入的Intent请求</span></span><br><span class="line">            <span class="comment">// 将请求通过Bundle对象传入到Intent，再传入到服务里</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求1</span></span><br><span class="line">            <span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;cn.scu.finch&quot;</span>);</span><br><span class="line">            <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">            bundle.putString(<span class="string">&quot;taskName&quot;</span>, <span class="string">&quot;task1&quot;</span>);</span><br><span class="line">            i.putExtras(bundle);</span><br><span class="line">            startService(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求2</span></span><br><span class="line">            <span class="type">Intent</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;cn.scu.finch&quot;</span>);</span><br><span class="line">            <span class="type">Bundle</span> <span class="variable">bundle2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">            bundle2.putString(<span class="string">&quot;taskName&quot;</span>, <span class="string">&quot;task2&quot;</span>);</span><br><span class="line">            i2.putExtras(bundle2);</span><br><span class="line">            startService(i2);</span><br><span class="line"></span><br><span class="line">            startService(i);  <span class="comment">//多次启动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190523214849211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p><strong>源码分析直接看博客</strong></p><p>Handler+HandlerThread</p></li></ul></li><li><p><strong>高级使用</strong></p><p>线程池部分跟前面Java部分的线程池使用方式一样</p><p>synchronized和ThreadLocal直接看博客吧，内容跟前面Java部分使用基本一样的</p><p><img src="https://img-blog.csdnimg.cn/20190524080446834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p></li></ul><p><a href="https://www.bilibili.com/video/BV12j421R726/?spm_id_from=333.337.search-card.all.click&vd_source=3a564c36ba4399f31a8a0656197bd2a3">Java多线程夺命连环60问，逼自己2小时啃完并发多线程面试核心知识点！（JMM、线程池、ThreadLocal、并发锁）_哔哩哔哩_bilibili</a></p><h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>Handler机制是一套Android消息传递机制。在Android开发多线程的应用场景中，将工作线程中需更新UI的操作信息 传递到 UI主线程，从而实现 工作线程对UI的更新处理，最终实现异步消息的处理。<br>在Android开发中，为了UI操作是线程安全的，规定了只允许主线程更新Activity里的UI组件。但在实际开发中，存在多个线程并发操作UI组件的情况，导致UI操作线程不安全。故采用Handler消息传递机制，是工作线程需更新UI时，通过Handler通知主线程，从而在主线程中更新UI操作。</p><ul><li><p><strong>一些概念（前面内容涉及过的就不列出来了）</strong></p><p>Android 的消息机制是基于Handler实现的。Handler 采用的是一种生产者-消费者模型，Handler 就是生产者，通过它可以生产需要执行的任务。而 Looper 则是消费者，不断从 MessageQueue 中取出Message 对这些消息进行消费。</p><ul><li><p>消息（Message）：线程间通讯的数据单元（即Handler接受和处理的消息对象），用于存储需要操作的通信信息</p><p>下面是获取Message的方法，obtain（效率更高）或直接new</p><p>下面是从Message池中取得Message去复用，Message是一个链表结构，默认大小为50，并且永远保存第一个节点就行，然后可以通过Message的next获取到下一个节点</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403252132625.png" alt="image-20240325213233073"></p></li></ul><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403252137591.png" alt="image-20240325213657451"></p><ul><li>消息队列（Message Queue）：先进先出的数据结构，存储Handler发过来的Message</li><li>处理者（Handler）：Handler为主线程和子线程的通信媒介，是线程消息都主要处理者，用于添加Message到Message Queue，处理Looper分派过来的Message</li><li>循环器（Looper）：Message Queue和Handler的通信媒介，用于消息循环，分为消息获取（循环取出Message Queue中的Message）和消息分发（将取出的Message发送给Handler）</li></ul></li><li><p><strong>使用方式</strong></p><ul><li><p>Handler.sendMessage()</p><ul><li><p>继承Handler重写handleMessage方法（在该方法内部执行需要操作的UI操作，这里面的方法是在主线程中运行的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：自定义Handler子类（继承Handler类） &amp; 复写handleMessage（）方法</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">mHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 通过复写handlerMessage() 从而确定更新UI的操作</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">       ...<span class="comment">// 需执行的UI操作</span></span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 步骤2：在主线程中创建Handler实例</span></span><br><span class="line">      <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">mhandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mHandler</span>();</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 步骤3：创建所需的消息对象</span></span><br><span class="line">      <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(); <span class="comment">// 实例化消息对象</span></span><br><span class="line">      msg.what = <span class="number">1</span>; <span class="comment">// 消息标识</span></span><br><span class="line">      msg.obj = <span class="string">&quot;AA&quot;</span>; <span class="comment">// 消息内容存放</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 步骤4：在工作线程中 通过Handler发送消息到消息队列中</span></span><br><span class="line">  <span class="comment">// 可通过sendMessage（） / post（）</span></span><br><span class="line">  <span class="comment">// 多线程可采用AsyncTask、继承Thread类、实现Runnable</span></span><br><span class="line">      mHandler.sendMessage(msg);</span><br><span class="line">      </span><br><span class="line">  <span class="comment">// 步骤5：开启工作线程（同时启动了Handler）</span></span><br><span class="line">  <span class="comment">// 多线程可采用AsyncTask、继承Thread类、实现Runnable</span></span><br><span class="line">      </span><br><span class="line">      </span><br></pre></td></tr></table></figure></li><li><p>匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：在主线程中 通过匿名内部类 创建Handler类对象</span></span><br><span class="line">           <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">mhandler</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Handler</span>()&#123;</span><br><span class="line">               <span class="comment">// 通过复写handlerMessage()从而确定更新UI的操作</span></span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                       ...<span class="comment">// 需执行的UI操作</span></span><br><span class="line">                   &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">      </span><br><span class="line"> <span class="comment">// 步骤2：创建消息对象</span></span><br><span class="line">   <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(); <span class="comment">// 实例化消息对象</span></span><br><span class="line"> msg.what = <span class="number">1</span>; <span class="comment">// 消息标识</span></span><br><span class="line"> msg.obj = <span class="string">&quot;AA&quot;</span>; <span class="comment">// 消息内容存放</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 步骤3：在工作线程中 通过Handler发送消息到消息队列中</span></span><br><span class="line"> <span class="comment">// 多线程可采用AsyncTask、继承Thread类、实现Runnable</span></span><br><span class="line">  mHandler.sendMessage(msg);</span><br><span class="line">      </span><br><span class="line"> <span class="comment">// 步骤4：开启工作线程（同时启动了Handler）</span></span><br><span class="line"> <span class="comment">// 多线程可采用AsyncTask、继承Thread类、实现Runnable</span></span><br><span class="line">      </span><br></pre></td></tr></table></figure></li></ul></li><li><p>Handler.post()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：在主线程中创建Handler实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">mhandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mHandler</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2：在工作线程中 发送消息到消息队列中 &amp; 指定操作UI内容</span></span><br><span class="line">    <span class="comment">// 需传入1个Runnable对象</span></span><br><span class="line">    mHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                ... <span class="comment">// 需执行的UI操作 </span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤3：开启工作线程（同时启动了Handler）</span></span><br><span class="line">    <span class="comment">// 多线程可采用AsyncTask、继承Thread类、实现Runnable</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>工作原理</strong></p><p>步骤一：异步通信准备<br>在主线程中创建<br>（1）循环器 对象（Looper）<br>（2）消息队列 对象（Message Queue）<br>（3）Handler对象<br>Looper、Message Queue均属于主线程，创建Message Queue后，Looper自动进入消息循环。此时，Handler自动绑定了主线程的Looper、Message Queue</p><p>步骤二：消息入队<br>工作线程通过Handler发送消息（Message）到消息队列（Message Queue）中，该消息内容&#x3D;工作线程对UI的操作</p><p>步骤三：消息循环<br>消息出队：Looper循环取出消息队列（Message Queue）中的消息（Message）<br>消息分发：Looper将去除的消息（Message）发送给创建该消息的处理者（Handler）<br>在消息循环过程中，若消息队列为空，则线程阻塞。</p><p>步骤四：消息处理<br>处理者Handler接受循环器Looper发送过来的消息（Message）<br>处理者Handler根据消息（Message）进行UI操作</p><p><img src="https://img-blog.csdnimg.cn/20190524154818732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p><strong>1个线程（Thread）只能绑定1个循环器（Looper），但可以有多个处理者；1个循环器（Looper）可绑定多个处理者（Handler）；1个处理者（Handler）只能绑定1个循环器（Looper）</strong></p></li><li><p><strong>源码分析</strong></p><p><img src="https://img-blog.csdnimg.cn/20190524154907984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><ul><li><p>Handler.sendMessage()</p><ul><li><p>创建Looper和MessageQueue</p><p><strong>Looper.prepareMainLooper()<strong>会为主线程创建一个Looper，同时也会自动创建一个消息队列MessageQueue，</strong>这个方法会在主线程创建的时候自动调用，不需要手动生成</strong>。</p><p><strong>并且在应用进程启动的时候会创建一个主线程（ActivityThread），创建的时候会自动调用ActivityThread的静态的main方法（也就是应用程序的入口），在这个main方法内部会调用Looper.prepareMainLooper()</strong></p><p>要为<strong>子线程</strong>创建一个Looper对象并同时创建一个对应的消息队列（这两一起），就需使用**Looper.prepare()**，在生成Looper和MessageQueue对象后，则会自动进入消息循环，Looper.loop()</p></li><li><p>消息循环（Looper.loop()）</p><p>需要注意的是主线程的循环不运行退出，即无限循环；子线程的循环允许退出，调用MessageQueue的quit（）方法就可以退出</p><p><strong>具体源码直接看博客对应部分</strong></p><p><strong>总结</strong></p><p>（1）消息循环的操作 &#x3D; 消息出队 + 分发给对应的Handler实例<br>（2）分发给对应的Handler的过程：根据出队消息的归属者通过dispatchMessage(msg)进行分发，最终回调复写的handleMessage(Message msg)，从而实现 消息处理 的操作<br>（3）特别注意：在进行消息分发时（dispatchMessage(msg)），会进行1次发送方式的判断：<br><strong>若msg.callback属性不为空，则代表使用了post（Runnable r）发送消息，则直接回调Runnable对象里复写的run（）若msg.callback属性为空，则代表使用了sendMessage（Message msg）发送消息，则回调复写的handleMessage(msg)</strong></p><p>具体使用过程中如果是使用匿名内部类的方式去使用的，<strong>在Handler内部会调用Looper.myLooper();获取当前线程的Looper，</strong>并在获取不到Looper的时候抛出异常，<strong>当然也可以通过Loop.getMainLooper()获取当前线程的主线程的Looper对象，并绑定获取到Looper的消息队列对象，</strong>就是在新new的这个内部类中的成员变量引用获取到的消息队列对象</p><p>在<strong>sendMessage的背后</strong>会先<strong>获取消息队列对象</strong>，调用enqueueMessage方法<strong>将msg.target值赋值为this，后面的msg.target.dispatchMessage(msg)去处理信息</strong>，实际则是将该消息派发给对应的Handler执行，<strong>之后调用消息队列的enqueueMessage（）进行入队（这个队列就是消息队列，内部是使用单链表实现的），有信息就按照创建时间when属性插入，无消息就将其作为对头</strong></p><p><strong>总结</strong></p><p>Handler发送消息的本质 &#x3D;<br>将消息对象的target属性设置为当前Handler实例（将Message绑定到Handler，使执行消息循环时将消息派发给对应的Handler实例）<br>获取对应的消息队列对象MessageQueue，调用MessageQueue.enqueueMessage()，将Handler需发送消息入队到绑定线程的消息队列中。</p><p>之后，随着Looper对象的无限消息循环，不断从消息队列中取出Handler发送的消息&amp;根据target分发到对应Handler，最终回调Handler.handleMessage()处理消息</p></li></ul></li><li><p>Handler.post()</p><ul><li><p>创建Handler对象</p><p>在此之前主线程已经隐式创建Looper对象和MessageQueue对象了，在新建的这个Handler的源码跟前面使用方式的源码类似</p></li><li><p>在工作线程中发送消息到消息队列</p><p>Runnable并无创建新线程，而是发送 消息 到消息队列中，这里的run方法内就可以直接把UI操作写在里面，post方法里面进来就直接执行<code>return  sendMessageDelayed(getPostMessage(r), 0);</code>，这里的getPostMessage(r)是将Runable对象封装成一个消息对象，调用的代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title function_">getPostMessage</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                        <span class="comment">// 1. 创建1个消息对象（Message）</span></span><br><span class="line">                        <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">                            <span class="comment">// 注：创建Message对象可用关键字new 或 Message.obtain()</span></span><br><span class="line">                            <span class="comment">// 建议：使用Message.obtain()创建，</span></span><br><span class="line">                            <span class="comment">// 原因：因为Message内部维护了1个Message池，用于Message的复用，使用obtain（）直接从池内获取，从而避免使用new重新分配内存</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 2. 将 Runable对象 赋值给消息对象（message）的callback属性</span></span><br><span class="line">                        m.callback = r;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 3. 返回该消息对象</span></span><br><span class="line">                        <span class="keyword">return</span> m;</span><br><span class="line">                    &#125; </span><br></pre></td></tr></table></figure><p>而sendMessageDelayed(msg, 0)方法的内容为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(Message msg, <span class="type">long</span> delayMillis)</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                     delayMillis = <span class="number">0</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">      </span><br><span class="line">                 <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">               </span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure><p>其实调用的就是sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);，内部先获取了消息队列，然后调用enqueueMessage方法，同样将 将msg.target赋值为this，之后调用queue.enqueueMessage(msg, uptimeMillis）;保存到消息队列，这部分代码的逻辑跟前面的使用方式的源码很像，只不过这里是对Runable的封装对象进行处理，前面是对Message对象直接进行处理。</p></li></ul></li></ul></li><li><p><strong>内存泄露问题</strong></p><p>上述的Handler实例的消息队列有2个分别来自线程1、2的消息（分别 为延迟1s、6s）在Handler消息队列 还有未处理的消息 &#x2F; 正在处理消息时，消息队列中的Message持有Handler实例的引用，由于Handler &#x3D; 非静态内部类 &#x2F; 匿名内部类（2种使用方式），故又默认持有外部类的引用（即MainActivity实例）,即 Handler消息队列 还有未处理的消息 &#x2F; 正在处理消息 而 外部类需销毁时，但是因为引用关系存在，外部类无法呗GC回收，从而造成内存泄露</p><p><strong>解决方案就是静态内部类+弱引用或在外部类（Activity）生命周期结束时清空Handler内消息队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler showhandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程创建时便自动创建Looper &amp; 对应的MessageQueue</span></span><br><span class="line">    <span class="comment">// 之后执行Loop()进入消息循环</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 实例化自定义的Handler类对象-&gt;&gt;分析1</span></span><br><span class="line">        <span class="comment">//注：</span></span><br><span class="line">            <span class="comment">// a. 此处并无指定Looper，故自动绑定当前线程(主线程)的Looper、MessageQueue；</span></span><br><span class="line">            <span class="comment">// b. 定义时需传入持有的Activity实例（弱引用）</span></span><br><span class="line">        showhandler = <span class="keyword">new</span> <span class="title class_">FHandler</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 启动子线程1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">                msg.what = <span class="number">1</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                msg.obj = <span class="string">&quot;AA&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                showhandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 启动子线程2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">                msg.what = <span class="number">2</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                msg.obj = <span class="string">&quot;BB&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                showhandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分析1：自定义Handler子类</span></span><br><span class="line">    <span class="comment">// 设置为：静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义 弱引用实例</span></span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Activity&gt; reference;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在构造方法中传入需持有的Activity实例</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FHandler</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">            <span class="comment">// 使用WeakReference弱引用持有Activity实例</span></span><br><span class="line">            reference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Activity&gt;(activity); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过复写handlerMessage() 从而确定更新UI的操作</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;收到线程1的消息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot; 收到线程2的消息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        mHandler.removeCallbacksAndMessages(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 外部类Activity生命周期结束时，同时清空消息队列 &amp; 结束Handler生命周期</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>对于线程安全，通过创建Handler子类的对象，并且每个Activity只需要一个Handler对象，Handler获取信息会判断如何处理，而Runnable则是直接给出处理的方法，队列是依次执行的，Handler会在处理完一个消息或执行完某个处理才会进行下一步，这样不会出现多个线程同时完球进行UI处理而引发混乱现象。</p></li></ul><p><a href="https://blog.csdn.net/Sh_12345/article/details/131327178">Android 之 Handler_android handler-CSDN博客</a></p><p><a href="https://www.bilibili.com/video/BV1VE411Z7Ay?p=3&spm_id_from=pageDriver&vd_source=3a564c36ba4399f31a8a0656197bd2a3">3_源码分析_Handler_哔哩哔哩_bilibili</a></p><h6 id="详细进阶"><a href="#详细进阶" class="headerlink" title="详细进阶"></a>详细进阶</h6><ul><li><p><strong>消息机制原理</strong></p></li><li><p><strong>Message源码分析</strong></p></li><li><p><strong>Handler源码分析</strong></p><p>Handler有三个作用，分别是发送消息、处理消息、移除消息</p><ul><li>发送消息</li></ul><p><code>sendMessage(Message msg)</code>,会调用<code>sendMessageDelayed(msg,0)</code>；</p><p><code>sendEmptyMessage(int what)</code>，会调用<code>sendEmptyMessageDelayed(what,0)//发送不带数据的消息</code></p><p>内部都是使用<code>Message.obtain()</code>之后调用<code>sendMessageDelayed(msg, delayMillis)</code>，延迟时间小于0也会设为0</p><p>这内部又是调用<code>sendMessageAtTime(msg,SystemClock.uptimeMillis()+delayMillis)</code>当前时间+延迟时间</p><p>这内部就调用<code>enqueueMessage(queue,msg,uptimeMillis)</code>消息入队，并且保存发送Message的Handler（Message.target&#x3D;this）</p><ul><li>移除消息</li></ul><p><code>removeMessage(int what)</code>内部调用消息队列的移除方法</p><ul><li>处理消息</li></ul><p><code>handleMessage(Message msg)</code>处理消息的回调方法</p></li><li><p><strong>MessageQueue源码分析</strong></p><p>存储消息以message的when排序优先级队列，插入的时候进行比较，看插入到哪个位置</p><p>之后调用nativeWake()方法通过本地方法实现对处理等待状态的底层线程，去通知Looper，唤醒</p><p>next()方法返回Message，里面也是一个无限循环，nativePollOnce本地方法，会导致可能处于等待状态，这是调用底层方法去完成的，这样不会导致主线程的阻塞</p></li><li><p><strong>Looper源码分析</strong></p><p>主线程的Looper是由Android环境创建的，不需要我们关心</p><p>(从MessageQueue中获取当前需要处理的消息，并交给Handler处理)</p><p>loop()是核心方法，通过myLooper()得到Looper对象，之后可以通过Looper对象得到Queue对象，内部无限循环for(;;)，并没有break，里面调用的是queue.next()来取消息，这就是MessageQueue内部的方法</p><p>之后调用msg.target.dispatchMessage(msg)方法调用Handler去分发消息，回到Handler首先判断message的callback是否是空，如果消息可以处理自己就自己处理自己，如果Handler的callback不为空就让回调Handler处理，最后都没有就让Handler的handleMessage来处理</p><p>最后调用msg.recycle()回收</p></li><li><p><strong>消息机制与异步任务</strong></p></li></ul><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>一个应用运行系统会默认创建一个进程，并且一个应用默认只有一个进程，这个进程就是包名，为了彻底解决主进程占用内存超过内存限制的问题，Android引入多进程的概念，允许同一个应用内，为了分担主进程的压力，将占用内存的某些页面单独开一个进程，比如Flash、视频播放页面、频繁绘制的页面等。</p><p><strong>进程等级（下面是按照进程的优先级高低进行排序的）</strong></p><ul><li><p>前台进程Foreground Processes</p><p>onResume状态前台可见，正在与用户交互；有BroadcastReceiver正在执行代码；有Service在回调方法中执行代码（这种进程较少，一般作为最后的手段回收内存）</p></li><li><p>可见进程Visible Processes</p><p>没有正在与用户交互但是可以被看见</p><p>Activity的onPause状态；调用Service.startForeground()作为前台服务；含有用户意识到特定服务，输入法等等</p></li><li><p>服务进程Service Processes</p><p>进程正在执行后台操作，用户不直接可见的服务组件，比如播放音乐的Service，后台做很多处理（如加载数据）而没有成为前台的应用</p></li><li><p>缓存&#x2F;后台进程Background Processes、</p><p>该进程包含的组件没有与用户交互，用户也看不到 Service。在一般操作场景下，设备上的许多内存就是用在这上面的，使可以重新回到之前打开过的某个 activity 。</p></li><li><p>空进程Empty Processes</p><p>只是为了缓存的目的而保存，只要Android需要随时可以杀死它</p></li></ul><p><strong>创建线程</strong></p><p>Android多进程创建很简单，只需要在AndroidManifest.xml的声明四大组件的标签中增加”android:process”属性即可。命名之后，就成了一个单独的进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//私有进程</span></span><br><span class="line">&lt;service android:name=<span class="string">&quot;.MusicService&quot;</span>   </span><br><span class="line">           android:process=<span class="string">&quot;:musicservice&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局进程</span></span><br><span class="line">&lt;service android:name=<span class="string">&quot;.MusicService&quot;</span>   </span><br><span class="line">           android:process=<span class="string">&quot;com.trampcr.musicdemo.service&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>多进程创建好，应用运行时会对进程进行初始化，如果一个application中有多个进程，进行全局初始化时，进程会被初始化多次。此时应该判断当前进程，做相应的初始化操作。</p><p><strong>UID机制和共享进程</strong></p><ul><li>UID机制</li></ul><p>Pid是进程ID，Uid是用户ID，Android中每个程序都有一个Uid，默认情况下，Android会给每个程序分配一个普通级别互不相同的Uid，如果用互相调用，只能是Uid相同才行，这就使得共享数据具有了一定安全性，每个软件之间是不能随意获得数据的。而同一个application只有一个Uid，所以application下的Activity之间不存在访问权限的问题。</p><ul><li><p>共享进程</p><ul><li><p>一个application中共享service,provider或者activity等数据</p><p>1、完全暴露，这就是android:exported&#x3D;”true”的作用，而一旦设置了intentFilter之后，exported就默认被设置为true了，除非再强制设为false。当然，对那些没有intentFilter的程序体，它的exported属性默认仍然是false，也就不能共享出去。</p><p><a href="https://blog.csdn.net/qq_38350635/article/details/109755586">【Android Activity】IntentFilter的匹配规则_intent-filter data可以有两个么-CSDN博客</a></p><p>2、权限提示暴露，这就是为什么经常要设置usePermission的原因，如果人家设置了android:permission&#x3D;”xxx.xxx.xx”那么，你就必须在你的application的Manufest中usepermission xxx.xxx.xx才能访问人家的东西。<br>3、私有暴露，假如说一个公司做了两个产品，只想这两个产品之间可互相调用，那么这个时候就必须使用shareUserID将两个软件的Uid强制设置为一样的。这种情况下必须使用具有该公司签名的签名文档才能，如果使用一个系统自带软件的ShareUID，例如Contact，那么无须第三方签名。</p></li><li><p>通过共享UID，使拥有同一个UID的多个APK可以配置成运行在同一进程中</p><p>1、在Manifest节点中增加android:sharedUserId属性。<br>2、在Android.mk中增加LOCAL_CERTIFICATE的定义。<br>如果增加了上面的属性但没有定义与之对应的LOCAL_CERTIFICATE的话，APK是安装不上去的。提示错误是：Package com.test.MyTest has no signatures that match those in shared user android.uid.system; ignoring!也就是说，仅有相同签名和相同sharedUserID标签的两个应用程序签名都会被分配相同的用户ID。例如所有和media&#x2F;download相关的APK都使用android.media作为sharedUserId的话，那么它们必须有相同的签名media。<br>3、把APK的源码放到packages&#x2F;apps&#x2F;目录下，用mm进行编译。</p><p><a href="https://codeleading.com/article/74684541754/">Android通过共享Uid实现两个应用间的数据库资源共享 - 代码先锋网 (codeleading.com)</a></p></li></ul></li></ul><h4 id="多进程通信IPC"><a href="#多进程通信IPC" class="headerlink" title="多进程通信IPC"></a>多进程通信IPC</h4><p>IPC就是进程间通信</p><h5 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h5><ul><li><p><strong>定义</strong></p><ul><li><p>Linux内核基础知识</p><p>（1）用户空间&#x2F;内核空间</p><p>用户空间指的是用户程序所运行的空间，内核空间是 Linux 内核的运行空间，为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p><p>（2）系统调用——用户空间访问内核空间</p><p>用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。</p><p>（3）Binder驱动——用户空间A访问用户空间B</p><p>在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动。</p></li><li><p>Binder的定义</p><p>（1）用户空间&#x2F;内核空间</p><p>用户空间指的是用户程序所运行的空间，内核空间是 Linux 内核的运行空间，为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p><p>（2）系统调用——用户空间访问内核空间</p><p>用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。</p><p>（3）Binder驱动——用户空间A访问用户空间B</p><p>在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动。</p></li><li><p>优势</p><p>1）性能方面<br>在移动设备上（性能受限制的设备，比如要省电），广泛地使用跨进程通信对通信机制的性能有严格的要求，Binder相对于传统的Socket方式，传输效率高、开销小。<strong>Binder数据拷贝只需要一次</strong>，而管道、消息队列、Socket都需要2次；共享内存方式虽然一次内存拷贝都不需要，但控制复杂，难以使用。</p></li></ul><p>（2）安全方面传统的进程通信方式对于通信双方的身份并没有做出严格的验证，使用<strong>传统IPC只能由用户在数据包里填入UID&#x2F;PID，这样不可靠，容易被恶意程序利用</strong>。可靠的身份标记只有由IPC机制本身在内核中添加。比如Socket通信ip地址是客户端手动填入，很容易进行伪造，而<strong>Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性</strong>。</p><p>（3）实现面象对象的调用方式<br>  在使用Binder时就和调用一个本地实例一样。</p></li><li><p><strong>C&#x2F;S通信方式</strong></p></li></ul><p>Binder使用Client-Server通信方式：一个进程作为Server提供诸如视频&#x2F;音频解码，视频捕获，地址本查询，网络连接等服务；多个进程作为Client向Server发起服务请求，获得所需要的服务。<br>要想实现Client-Server通信据必须实现以下两点：<br>一是server必须有确定的访问接入点或者说地址来接受Client的请求，并且Client可以通过某种途径获知Server的地址；<br>二是制定Command-Reply协议来传输数据。Binder可以看成Server提供的实现某个特定服务的访问接入点， Client通过这个‘地址’向Server发送请求来使用该服务；对Client而言，Binder可以看成是通向Server的管道入口，要想和某个Server通信首先必须建立这个管道并获得管道入口。遍布于Client中的入口可以看成指向这个Binder对象的‘指针’，一旦获得了这个‘指针’就可以调用该对象的方法访问Server。</p><ul><li><p><strong>通信模型</strong></p><p>Binder框架定义了四个角色：Server，Client，ServiceManager（以后简称SMgr）以及Binder驱动。其中Server，Client，SMgr运行于用户空间，驱动运行于内核空间。<br>理解：这四个角色和互联网类似：Server是服务器，Client是客户终端，SMgr是域名服务器（DNS），Binder驱动是路由器。和电话类似：Client给Server打电话，SMgr是通讯录，Binder是电话基站。</p><ul><li><p>Binder驱动</p><p>驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p></li><li><p>ServiceManager进程（守护进程，用来管理Server）</p><p><strong>ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。</strong></p></li><li><p>Sever进程</p><p>Server创建了Binder实体，为其取一个字符形式，可读易记的名字，将这个Binder连同名字以数据包的形式通过Binder驱动发送给SMgr，通知SMgr注册一个名叫张三的Binder，它位于某个Server中。驱动为这个穿过进程边界的Binder创建位于内核中的实体节点以及SMgr对实体的引用，将名字及新建的引用打包传递给SMgr。SMgr收数据包后，从中取出名字和引用填入一张查找表中。</p></li><li><p>Client进程</p><p>Server向SMgr注册了Binder实体及其名字后，Client就可以通过名字获得该Binder的引用了。Client也利用保留的0号引用向SMgr请求访问某个Binder：我申请获得名字叫张三的Binder的引用。SMgr收到这个连接请求，从请求数据包里获得Binder的名字，在查找表里找到该名字对应的条目，从条目中取出Binder的引用，将该引用作为回复发送给发起请求的Client。</p></li></ul></li><li><p><strong>工作流程</strong></p><p>步骤1:ServiceManager内维护了一张表，表存储着向他注册过的进程信息<br>在通信之初，首先需要有一个进程向驱动申请成为ServerManager，当内核驱动同意之后，这个成为ServerManager的进程就负责管理所有需要通信的进程信息</p><p>步骤2:服务端进程向ServerManager注册信息<br>服务端进程首先会向ServerManager注册一张表，这个表中就存储了相关信息，告诉ServerManager我这里有一个返回值为Object的add方法，</p><p>步骤3:客户端进程向ServerManager取得信息，通过Binder驱动与服务端进程通信<br>当ServerManger保存完毕后，客户端进程就会通过Binder驱动向ServerManger查询服务端进程的信息，ServerManage就会将服务端进程的信息返回给客户端进程，客户端与服务端进程之间就可以通过这些信息，利用Binder驱动来进行通信</p></li></ul><h5 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h5><p>AIDL(Android Interface Define Language) 是IPC进程间通信方式的一种.用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码.</p><p><a href="https://blog.csdn.net/amynn/article/details/107042981">Binder 与AIDL_aidl与binder的区别-CSDN博客</a></p><p><strong>其他的先空着，后面再看</strong></p><ul><li><p><strong>使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IRemoteService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端绑定service时会执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">IBinder</span> <span class="variable">iBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IImoocAIDL</span>.Stub()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>,<span class="string">&quot;收到了来自客户端的请求&quot;</span> + num1 + <span class="string">&quot;+&quot;</span> + num2 );</span><br><span class="line">            <span class="keyword">return</span> num1 + num2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AndroidMainfest.xml</span></span><br><span class="line">&lt;service android:name=<span class="string">&quot;.IRemoteService&quot;</span></span><br><span class="line">            android:process=<span class="string">&quot;:remote&quot;</span></span><br><span class="line">            android:exported=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">&quot;com.mecury.aidltest.IRomoteService&quot;</span>/&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client 客户端绑定服务并调用服务端的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText num1;</span><br><span class="line">    <span class="keyword">private</span> EditText num2;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="keyword">private</span> TextView text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IImoocAIDL iImoocAIDL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定服务，回调onBind()方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">            iImoocAIDL = IImoocAIDL.Stub.asInterface(service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span> &#123;</span><br><span class="line">            iImoocAIDL = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        bindService();</span><br><span class="line">        initView();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initView</span><span class="params">()</span> &#123;</span><br><span class="line">        num1 = (EditText) findViewById(R.id.num1);</span><br><span class="line">        num2 = (EditText) findViewById(R.id.num2);</span><br><span class="line">        button = (Button) findViewById(R.id.button);</span><br><span class="line">        text = (TextView) findViewById(R.id.text);</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num11</span> <span class="operator">=</span> Integer.parseInt(num1.getText().toString());</span><br><span class="line">        <span class="type">int</span> <span class="variable">num22</span> <span class="operator">=</span> Integer.parseInt(num2.getText().toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> iImoocAIDL.add(num11,num22);</span><br><span class="line">            text.setText(num11 +<span class="string">&quot;+&quot;</span>+ num22 +<span class="string">&quot;=&quot;</span>+ res);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindService</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">        <span class="comment">//绑定服务端的service</span></span><br><span class="line">        intent.setAction(<span class="string">&quot;com.mecury.aidltest.IRomoteService&quot;</span>);</span><br><span class="line">        <span class="comment">//新版本（5.0后）必须显式intent启动 绑定服务</span></span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="string">&quot;com.mecury.aidltest&quot;</span>,<span class="string">&quot;com.mecury.aidltest.IRemoteService&quot;</span>));</span><br><span class="line">        <span class="comment">//绑定的时候服务端自动创建</span></span><br><span class="line">        bindService(intent,conn, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        unbindService(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h5><p>使用Messenger为服务提供接口，让服务与远程进程通信。利用Handler实现。（适用于多进程、单线程，不需要考虑线程安全），其底层基于AIDL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessengerService</span> <span class="keyword">extends</span> <span class="title class_">Service</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">IncomingHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">            <span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    Toast.makeText(getApplicationContext(), <span class="string">&quot;hello, trampcr&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Messenger</span> <span class="variable">mMessenger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Messenger</span>(<span class="keyword">new</span> <span class="title class_">IncomingHandler</span>());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        Toast.makeText(getApplicationContext(), <span class="string">&quot;binding&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AndroidManifest.xml</span></span><br><span class="line">&lt;service android:name=<span class="string">&quot;.MessengerService&quot;</span>  </span><br><span class="line">         android:process=<span class="string">&quot;com.trampcr.messenger.service&quot;</span>/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessengerActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mBound;</span><br><span class="line">    <span class="keyword">private</span> Messenger mMessenger;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">mServiceConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">            mMessenger = <span class="keyword">new</span> <span class="title class_">Messenger</span>(service);</span><br><span class="line">            mBound = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span> &#123;</span><br><span class="line">            mMessenger = <span class="literal">null</span>;</span><br><span class="line">            mBound = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(View v)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mBound)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(<span class="literal">null</span>, <span class="number">0</span> , <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mMessenger.send(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_messenger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MessengerActivity.<span class="built_in">this</span>, MessengerService.class);</span><br><span class="line">        bindService(intent, mServiceConnection, BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStop();</span><br><span class="line">        <span class="keyword">if</span>(mBound)&#123;</span><br><span class="line">            unbindService(mServiceConnection);</span><br><span class="line">            mBound = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AIDL与Messenger、Binder区别</strong><br>Using AIDL is necessary only if you allow clients from different applications to access your service for IPC and want to handle multithreading in your service. If you do not need to perform concurrent IPC across different applications, you should create your interface by implementing a Binder or, if you want to perform IPC, but do not need to handle multithreading, implement your interface using a Messenger. Regardless, be sure that you understand Bound Services before implementing an AIDL.<br>（1）只有当你允许来自不同的客户端访问你的服务并且需要处理多线程问题时你才必须使用AIDL<br>（2）如果进程间的通信来自同一应用，应该使用Binder<br>（3）如果进程间的通信不需要处理多线程，应该使用Messenger<br>a.Messenger不适用大量并发的请求：Messenger以串行的方式来处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍然只能一个个的去处理。<br>b.Messenger主要是为了传递消息：对于需要跨进程调用服务端的方法，这种情景不适用Messenger。<br>c.Messenger的底层实现是AIDL，系统为我们做了封装从而方便上层的调用。<br>d.AIDL适用于大量并发的请求，以及涉及到服务端端方法调用的情况</p><h5 id="详细进阶-1"><a href="#详细进阶-1" class="headerlink" title="详细进阶"></a>详细进阶</h5><ul><li><strong>为什么要问Binder</strong></li></ul><p>Android的进程间通信使用的就是Binder，Binder就是Android中的血管，在Android中我们使用到的Activity，Service等组件都需要和AMS（system_server）通信（Activity和AMS服务其实是在不同进程的），这种跨进程都是通过Binder完成的。</p><p>机制：Binder是一种进程间通信机制；驱动：Binder是一个虚拟物理设备驱动；应用层：Binder是一个能发起通信的Java类 （那么一个Java类要能够进行进程间通信就需要继承自Binder）</p><p><img src="C:\Users\GTR\AppData\Roaming\Typora\typora-user-images\image-20240325122249892.png" alt="image-20240325122249892"></p><p>小项目是一个进程打天下的，但是多进程是有很多使用场景和优势的，微信、QQ、微博等都是多进程在运行，那么稍微大一点的公司面试就很看重这里，因为只使用单进程的应用性能是比较差劲的</p><p>虚拟机分配给各个进程的运行内存是有限制的、LMK也会优先回收对系统资源占用多的进程，那么使用多进程就可以：①突破进程的内存限制，如图库占用内存过多；②在功能稳定性方面，独立的通信进程保持长连接的稳定性；③可以规避系统内存的泄露，独立的WebView进程阻隔内存泄露导致的问题（推送、WebView）；④隔离风险，对于不稳定功能放如独立进程，避免导致主进程崩溃。。。 </p><ul><li><strong>Binder优势</strong></li></ul><p>首先需要了解一个Linux的机制，有管道、信号量、共享内存、socket； Binder是android创造使用的，现在被Linux接受，现在Linux自带Binder机制</p><p><img src="C:\Users\GTR\AppData\Roaming\Typora\typora-user-images\image-20240325130702417.png" alt="image-20240325130702417"></p><p>共享内存的性能是最好的，Binder次之，其他IPC更慢；共享内存共享同一块内存和变量，需要考虑很多问题，如死锁、数据不同步等等，使用是很不方便的；传统IPC如何知道进程的身份，就需要服务发送id给系统，这个id是自己发的，不安全，而Binder会为每个App分配一个UID（唯一），传统IPC接入点是开放的，那么谁都可以进行访问，而Binder支持实名和匿名（正常情况下，系统服务是实名的，个人服务是匿名的，在ServiceManager注册的就是实名的，那么如果个人服务也去注册就是实名的）</p><ul><li><strong>Binder一次拷贝</strong></li></ul><p> 进程间通信和线程间通信不同，主要就是内存机制不同，线程通信是共享内存的，但是进程间的内存是隔离的</p><p>（内存划分：内存被操作系统划分成两块，为用户空间和内核空间，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，他们是隔离的，即使用户的程序崩溃了，内核也不受影响；不同进程之间的用户空间也是隔离的）</p><p>（平时所说的内存都是虚拟内存，物理内存就是硬件）</p><p>那么在内核空间是需要将虚拟内存的内容映射到物理内存，所有内核空间是映射在同一块物理内存上的，其实就是内存共享（内核空间可以理解成地球仪，但是物理内存就可以看成是地球）</p><p>看到这里就知道怎么共享内存了。进程1的内容要共享给进程2，那么就可以将内容放到自己的内核空间就行，内核空间自己会映射到物理内存，那么其他进程的内核空间也可以访问到，进程2就可以通过自己的内核空间访问到进程2的内容了（数据传递的原理，进程间通信达原理）</p><p>下面就是以前的数据传输（传统 ）</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403251401694.png" alt="image-20240325134925579"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403251401482.png" alt="image-20240325135025371"></p><p>结合上面的现代快递（丰巢）机制，理解Binder机制，就不需要进行两次拷贝，只需要接收方的内核空间和用户空间指向同一块物理内存即可，那么就不需要内核空间拷贝到接收方的具体进程地址空间<strong>（而这个公共的物理内存就是由Binder驱动提供的）</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403251401553.png" alt="image-20240325135108450"> </p><ul><li><strong>MMAP的原理讲解</strong></li></ul><p>上面接收方如何进行映射同一块内存空间的就需要MMAP，MMAP原理</p><p>在 Android 中，Binder 通信机制中使用了 mmap（Memory Map）技术，用于实现进程间的共享内存。mmap 是一种内存映射文件的方式，可以将一个文件或者设备映射到进程地址空间的一段连续的地址区域中，这样就能够让多个进程共享同一块物理内存。</p><p>在 Binder 通信中，服务端和客户端通过 mmap 映射同一块物理内存来传递数据。具体来说，当客户端请求服务端获取数据时，服务端将需要传递的数据复制到共享内存区域，并返回共享内存区域的描述符给客户端。客户端接收到该描述符后可以通过 mmap 将其映射到自己的地址空间中，从而访问共享内存中的数据。</p><p>使用 mmap 技术的好处是，避免了数据的多次拷贝，提高了数据传输的效率，同时也避免了由于多次复制数据引起的内存浪费和性能损耗。</p><p>需要注意的是，mmap 机制只能用于 Linux 系统下的进程通信，而对于跨平台通信，需要使用其他的机制来进行实现。</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403251401142.png" alt="image-20240325140125789"></p><p>原本用户空间访问磁盘和写入的逻辑如下</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403251403857.png" alt="image-20240325140344834"></p><p>（那么共享内存的无需拷贝就是减少发送方的拷贝，减少的机制是一样的）</p><p>在客户端向服务端发送数据时，需要进行数据拷贝的操作如下：</p><p>1.客户端将需要传递的数据（比如字符串 “Hello, world!”）存储到自己的内存空间中。</p><p>2.客户端将自己的内存空间中的数据拷贝到该共享内存区域中。</p><p>3.客户端获取共享内存区域的描述符，并将该描述符通过 Binder 传递给服务端。</p><p>在第二步中，客户端需要将自己内存空间中的数据拷贝到共享内存区域中，这一过程需要进行一次数据的拷贝。具体来说，客户端会调用类似于 memcpy 这样的函数，将自己内存空间中的数据拷贝到共享内存区域中。这个过程类似于文件拷贝或者网络传输等操作，都涉及到数据的拷贝操作。</p><p>而在服务端接收到共享内存描述符之后，无需再进行数据的拷贝。服务端可以直接通过 mmap 函数将共享内存区域映射到自己的地址空间中，从而可以直接访问共享内存中的数据。因为共享内存区域已经与客户端进程、服务端进程进行了关联，所以服务端可以直接访问共享内存区域中的数据，而不需要进行数据的拷贝。</p><p>- </p><ul><li><strong>Binder机制如何跨进程的</strong></li></ul><p>这部分就是归纳总结前面的部分，Binder一次拷贝和MMAP</p><p> copy_from_user()拷贝数据到内核地址空间，映射同一块物理内存就可以访问同一块内容</p><ul><li><strong>AIDL生成Java类的细节</strong></li></ul><p><a href="https://zhuanlan.zhihu.com/p/475497774?utm_id=0">一文分析Binder机制和AIDL的理解 - 知乎 (zhihu.com)</a></p><p>AIDL是Android接口描述语言（跨进程通信有自己的规则，当然我们也可以按照这个规则自己去写，但是很麻烦，AIDL就是简化这个流程并且防止出错，具体写法可以看上面博客，AIDL就可以理解为一个工具）</p><p>stub asinterface proxy（同进程不需要使用，不同进程需要使用）</p><p>那么AIDL生成的代码是怎么进行处理具体逻辑的，stub的asinterface会判断是否是当前当前进程的服务，不是就会封装一层proxy再返回（而proxy继承Binder，最后也是获取到Binder，之后asInterface封装成接口），是就直接返回接口，那么就可以直接通过接口进行数据传输和各种操作，proxy中就是AIDL自动生成的代码，这里以一个接口的一个操作具体讲怎么实现，首先会准备两个Parcel对象，命名为data和reply，data就是客户端给服务端的数据，reply就是服务端给客户端的数据，通过Remote（就是Binder，那这里就不需要手动去写这里了，proxy自动去完成具体的了）的transact（可以设置同步和异步的），之后就是framework和kernel层的事情了<strong>（transact执行后客户端会挂起，可以通过flags参数是同步还是异步）</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403251514666.png" alt="image-20240325151447354"></p><p>服务端需要new Stub()并重写里面的方法，将内容返回给客户端</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403251521064.png" alt="image-20240325152146358"></p><p>这里的onTransact会按照code的不同判断调用哪个方法，是客户端给服务端传数据还是服务端给客户端传数据。。。</p><ul><li><strong>四大组件底层的通信机制</strong></li></ul><p>可以联想到Service，但是bindService后回调到ServiceConnection，这之间做了什么事情</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403251638711.png" alt="image-20240325163857918"></p><p>那么就需要找到AMS服务，需要用到服务管理类，ServiceManager，这个看前面就行，有写，就是把服务的名字和id进行关联，只需要知道名字就能找到对应的服务，ServiceManager的id固定为0，（请求ServiceManager这里也是跨进程的）</p><p><img src="C:\Users\GTR\AppData\Roaming\Typora\typora-user-images\image-20240325165106291.png" alt="image-20240325165106291"></p><p>没看完，有空再看了</p><p><a href="https://www.bilibili.com/video/BV1zf4y1373j?p=8&spm_id_from=pageDriver&vd_source=3a564c36ba4399f31a8a0656197bd2a3">8.为什么Intent不能传递大数据_batch_哔哩哔哩_bilibili</a></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><a href="https://blog.csdn.net/bugyinyin/article/details/128932821">一篇文章讲清楚Android中的MVC、MVP、MVVM架构 （附实现代码）_android mvc mvp mvvm-CSDN博客</a></p><h4 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h4><ul><li>View: 视图层，对应xml文件</li><li>Controller: 控制层，对应Activity和Fragme nt层，进行数据处理</li><li>Model：实体层，负责获取实体数据</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2099414-0b00d62ff232ac93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567/format/webp"></p><p>在Android语境下，这里的Controller一般特指Activity和Fragment。而Model可以是 Java 类、数据库、网络请求或其他数据源，就是负责数据的读取操作的。而View的话一般来说是指XML布局文件。</p><h4 id="MVP架构"><a href="#MVP架构" class="headerlink" title="MVP架构"></a>MVP架构</h4><ul><li>Model: 数据提供层，负责向Presenter提供数据或者提供数据处理入口</li><li>View: 视图层，负责接收Presenter通知，进行界面更新</li><li>Presenter: View与Model的枢纽层，负责接收View层的命令，从Model层读取并处理好数据后，通知View进行界面更新。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2099414-32d31352426ed512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/508/format/webp"></p><p><strong>优势</strong></p><ul><li>把业务逻辑抽离到Presenter层中，View层专注于UI的处理。</li><li>分离视图逻辑与业务逻辑，达到解耦的目的。</li><li>提高代码的阅读性。</li><li>Presenter被抽象成接口，可以根据Presenter的实现方式进行单元测试。</li><li>可拓展性强。</li></ul><p><strong>缺点</strong></p><ul><li>项目结构会对后期的开发和维护有一定的影响。具体视APP的体量而定。</li><li>代码量会增多，如何避免编写过多功能相似的重复代码是使用MVP开发的一个重点要处理的问题。</li><li>有一定的学习成本。</li></ul><h5 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h5><p><strong>简单实现这里就是基本地使用接口进行通信</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403122130527.png" alt="image-20240312210955292"></p><ul><li><p><strong>依赖</strong></p><p><strong>个人开发习惯使用的一些类</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">maven &#123; url <span class="string">&#x27;https://www.jitpack.io&#x27;</span> &#125;<span class="comment">//settings.gradle添加仓库</span></span><br><span class="line"></span><br><span class="line">implementation <span class="string">&#x27;com.github.zhpanvip:bannerviewpager:3.5.12&#x27;</span><span class="comment">//Banner</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;</span><span class="comment">//retrofit</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:converter-gson:2.7.0&#x27;</span><span class="comment">//gson</span></span><br><span class="line">implementation <span class="string">&#x27;com.github.bumptech.glide:glide:4.14.2&#x27;</span>;<span class="comment">//Glide</span></span><br></pre></td></tr></table></figure></li><li><p><strong>HomepageBannerAdapter</strong></p><p><strong>Banner的适配器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomepageBannerAdapter</span> <span class="keyword">extends</span> <span class="title class_">BaseBannerAdapter</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">bindData</span><span class="params">(BaseViewHolder&lt;String&gt; holder, String data, <span class="type">int</span> position, <span class="type">int</span> pageSize)</span> &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> holder.findViewById(R.id.img);</span><br><span class="line">        Glide.with(holder.itemView).load(data).error(R.mipmap.ic_launcher).placeholder(R.mipmap.ic_launcher).into((ImageView) view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLayoutId</span><span class="params">(<span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.layout.item_homepage_banner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>BaseActivity</strong></p><p><strong>这个就是抽取Activity必须做的事情成一个Base基类，这个类中必须实现createPresenter去自定义自己的Presenter，并需要调用presenter的attachView去持有view的弱引用（绑定），并在onDestory阶段进行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseActivity</span>&lt;T <span class="keyword">extends</span> <span class="title class_">BasePresenter</span>,V <span class="keyword">extends</span> <span class="title class_">IBaseView</span>&gt; <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> T presenter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择自己的表示层</span></span><br><span class="line">        presenter = createPresenter();</span><br><span class="line">        presenter.attachView((V)<span class="built_in">this</span>);</span><br><span class="line">        registerSDK();</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里就要求用户去自己createPresenter选择一个Presenter</span></span><br><span class="line"><span class="comment">     * SDK初始化。。。操作也而已定义在Base类中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">createPresenter</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerSDK</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">unRegisterSDK</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        presenter.deatchView();</span><br><span class="line">        unRegisterSDK();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>BasePresenter</strong></p><p><strong>这个就是将每个Presenter必须做的事情抽取成一个Base类，也就是持有View的弱引用，防止内存泄露</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasePresenter</span>&lt;T <span class="keyword">extends</span> <span class="title class_">IBaseView</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> WeakReference&lt;T&gt; mView;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachView</span><span class="params">(T view)</span>&#123;</span><br><span class="line">        mView = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解绑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deatchView</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mView!=<span class="literal">null</span>)&#123;</span><br><span class="line">            mView.clear();</span><br><span class="line">            mView = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>IBaseView</strong></p><p><strong>这个类没有去做什么事情，单纯就是假设BaseView还有一些基本公共事件就抽取到这里面来</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBaseView</span> &#123;</span><br><span class="line">    <span class="comment">//BaseView写一些View的一些通用的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>HomepageBannerModel</strong></p><p>这是IHomepageBannerModel的具体实现，进行数据的加载，并告知IHomepageBannerPresenter数据加载完成，然后由IHomepageBannerPresenter告诉View更新View</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomepageBannerModel</span> <span class="keyword">implements</span> <span class="title class_">IHomepageBannerModel</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IHomepageBannerPresenter mIHomepageBannerPresenter;<span class="comment">//告诉Presenter加载数据完成</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HomepageBannerModel</span><span class="params">(IHomepageBannerPresenter IHomepageBannerPresenter)</span> &#123;</span><br><span class="line">        mIHomepageBannerPresenter = IHomepageBannerPresenter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getBanner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder().baseUrl(<span class="string">&quot;https://www.wanandroid.com/&quot;</span>)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">IWanAndroid</span> <span class="variable">wanAndroid</span> <span class="operator">=</span> retrofit.create(IWanAndroid.class);</span><br><span class="line">        Call&lt;HomepageBannerResponseBean&gt; call = wanAndroid.getHomePagerBanner();</span><br><span class="line">        call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;HomepageBannerResponseBean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;HomepageBannerResponseBean&gt; call, Response&lt;HomepageBannerResponseBean&gt; response)</span> &#123;</span><br><span class="line">                <span class="type">HomepageBannerResponseBean</span> <span class="variable">responseBean</span> <span class="operator">=</span> response.body();</span><br><span class="line">                <span class="keyword">if</span> (responseBean!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    Log.i(<span class="string">&quot;TAGG&quot;</span>,responseBean.getData().toString());</span><br><span class="line">                    List&lt;HomepageBannerResponseDataBean&gt; beanData = responseBean.getData();</span><br><span class="line">                    List&lt;String&gt;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (HomepageBannerResponseDataBean bean:beanData) &#123;</span><br><span class="line">                        list.add(bean.getImagePath());</span><br><span class="line">                    &#125;</span><br><span class="line">                    mIHomepageBannerPresenter.loadBannerPicSuccess(list);<span class="comment">//告诉Presenter数据加载完成</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;HomepageBannerResponseBean&gt; call, Throwable t)</span> &#123;</span><br><span class="line">                Log.i(<span class="string">&quot;TAGG&quot;</span>,t.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>IHomepageBannerModel</strong></p><p><strong>Model接口，谁调用接口的getBanner就是通过具体实现类去完成数据获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHomepageBannerModel</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向服务器请求数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getBanner</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>HomepageBannerPresenter</strong></p><p><strong>Presenter的接口的具体实现，在View调用fetch方法就会调用持有的Model进行数据的获取，然后再获取到数据后调用持有的View去通知View进行页面的更新</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomepageBannerPresenter</span> <span class="keyword">extends</span> <span class="title class_">BasePresenter</span>&lt;IHomepageBannerView&gt; <span class="keyword">implements</span> <span class="title class_">IHomepageBannerPresenter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IHomepageBannerModel mIHomepageBannerModel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HomepageBannerPresenter</span><span class="params">()</span> &#123;</span><br><span class="line">        mIHomepageBannerModel = <span class="keyword">new</span> <span class="title class_">HomepageBannerModel</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行业务逻辑</span></span><br><span class="line"><span class="comment">     * 一般会把业务逻辑统一放在fetch方法中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fetch</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mView!=<span class="literal">null</span>&amp;&amp;mIHomepageBannerModel!=<span class="literal">null</span>)&#123;</span><br><span class="line">            loadBannerPic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBannerPic</span><span class="params">()</span> &#123;</span><br><span class="line">        mIHomepageBannerModel.getBanner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBannerPicSuccess</span><span class="params">(List&lt;String&gt; data)</span> &#123;</span><br><span class="line">        mView.get().showBannerPic(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>IHomepageBannerPresenter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHomepageBannerPresenter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始加载图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">loadBannerPic</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成功加载图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">loadBannerPicSuccess</span><span class="params">(List&lt;String&gt; data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>IWanAndroid</strong></p><p><strong>Retrofit进行网络请求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IWanAndroid</span> &#123;</span><br><span class="line">    <span class="meta">@GET(&quot;banner/json&quot;)</span></span><br><span class="line">    Call&lt;HomepageBannerResponseBean&gt; <span class="title function_">getHomePagerBanner</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>HomepageBannerResponseBean</strong></p><p><strong>网络请求Bean类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomepageBannerResponseBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HomepageBannerResponseDataBean&gt; data;</span><br><span class="line">    <span class="keyword">private</span> Integer errorCode;</span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;HomepageBannerResponseDataBean&gt; <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getErrorCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getErrorMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>HomepageBannerResponseDataBean</strong></p><p><strong>网络请求Bean类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomepageBannerResponseDataBean</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String imagePath;</span><br><span class="line">    <span class="keyword">private</span> Integer isVisible;</span><br><span class="line">    <span class="keyword">private</span> Integer order;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getImagePath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> imagePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getIsVisible</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isVisible;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>IHomepageBannerView</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHomepageBannerView</span> <span class="keyword">extends</span> <span class="title class_">IBaseView</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载Banner图片成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showBannerPic</span><span class="params">(List&lt;String&gt; data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>MainActivity</strong></p><p><strong>这里当然还可以新建一个UI包，并将activity和Fragment等分别存放到这个包，具体的可以自己做，这里就是简单展示MVP</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">BaseActivity</span>&lt;HomepageBannerPresenter,IHomepageBannerView&gt; <span class="keyword">implements</span> <span class="title class_">IHomepageBannerView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BannerViewPager bvp;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        initView();</span><br><span class="line">        presenter.fetch();<span class="comment">//执行presenter的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> HomepageBannerPresenter <span class="title function_">createPresenter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HomepageBannerPresenter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBannerPic</span><span class="params">(List&lt;String&gt; data)</span> &#123;</span><br><span class="line">        bvp.refreshData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initView</span><span class="params">()</span> &#123;</span><br><span class="line">        bvp = findViewById(R.id.bvp);</span><br><span class="line">        <span class="comment">//异步同步</span></span><br><span class="line">        bvp.setLifecycleRegistry(getLifecycle())</span><br><span class="line">                .setAdapter(<span class="keyword">new</span> <span class="title class_">HomepageBannerAdapter</span>())</span><br><span class="line">                .create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>activity_main.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.zhpan.bannerview.BannerViewPager</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/bvp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>item_homepage_banner.xml</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/img&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h5><p>不使用接口，将接口链接转成总线，让presenter和model通过总线进行数据传输，如RxBus，并且解决了model和presenter接口爆炸的问题</p><p>dagger2注入型框架（依赖注入）</p><p>dagger android</p><p>hilt</p><p>Jetpack出现的Lifecycle</p><p>MVP融入Lifecycle</p><h4 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用androidx作为支持库</span></span><br><span class="line"><span class="attr">android.useAndroidX</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">android.enableJetifier</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p><strong>出现如下报错解决方案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Duplicate class kotlin.collections.jdk8.CollectionsJDK8Kt found in modules kotlin-stdlib-1.8.10</span></span><br><span class="line"><span class="comment">//原因是之前下载的kotlin版本与现在这个项目下载的版本包发生了冲突， 有重复类，解决办法就是给app指明要加载哪个包类</span></span><br><span class="line"><span class="comment">//在build.gradle(:app)中</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">   ... ... ...</span><br><span class="line">   implementation(platform(<span class="string">&quot;org.jetbrains.kotlin:kotlin-bom:1.8.0&quot;</span>))</span><br><span class="line">   ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h5><h5 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h5><h5 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h5><h5 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h5><h5 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h5><h5 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h5><h5 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h5><p>观察者和被观察者，Activity&#x2F;Fragment相当于被观察者，而观察者可以为其他任何的类</p><p>AppCompatActivity继承FragmentActivity，FragmentActivity继承ComponentActivity</p><p>通过getLifecycle().addObserver(observer);去绑定观察者</p><p>addObserver()需要传入LifecycleObserver类型的对象，在addObserver内部用ObserverWithState类对LifecycleObserver类的对象进行了包装，并将初始状态存入（初始状态有几个值）</p><p>ObserverWithState类初始化的时候会调用Lifecycling.lifecycleEventObserver(observer)得到lifecycleEventObserver对象，lifecycleEventObserver方法需要传入一个Object对象（所以说什么对象都可以监听生命周期的变化）</p><h4 id="MVVM架构"><a href="#MVVM架构" class="headerlink" title="MVVM架构"></a>MVVM架构</h4><p>这里学完JetPack中的组件</p><p><a href="https://www.jianshu.com/p/4565fa04b21a">Android 业务架构 · 基础篇 · Jetpack - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/qq_38436214/article/details/120820238?ops_request_misc=%7B%22request_id%22:%22171048850416800225573519%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=171048850416800225573519&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-120820238-null-null.nonecase&utm_term=mvvm&spm=1018.2226.3001.4450">Android MVVM框架搭建（一）ViewModel + LiveData + DataBinding-CSDN博客</a></p><p><strong>单向绑定就是数据发生改变就通知视图发生相应改变，但是视图发生改变并不会通知数据发生变化</strong></p><p><strong>而双向绑定就是数据发生改变时会通知视图发生相应的改变，视图发生改变也会通知数据发生变化</strong></p><p><img src="C:\Users\GTR\AppData\Roaming\Typora\typora-user-images\image-20240315225555949.png" alt="image-20240315225555949"></p><h2 id="享学课堂视频"><a href="#享学课堂视频" class="headerlink" title="享学课堂视频"></a>享学课堂视频</h2><p>已看</p><p>Glide</p><p>12（看完觉得自己捞）23 24 25 27</p><p>55 56 57 58 59</p><p>60  61 62 63 64 </p><p>65 66 67 68</p><p>85 86</p><p>88  89  90  92</p><p>93</p><h3 id="学习过程记录"><a href="#学习过程记录" class="headerlink" title="学习过程记录"></a>学习过程记录</h3><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><ul><li><p><strong>Android设备启动流程</strong></p><p><a href="https://www.zhihu.com/tardis/bd/art/660860992?source_id=1001">三分钟带你了解Android 系统启动流程详解 (zhihu.com)</a></p><ul><li><p>BootLoader进程（相当于电脑主板的bios，引导程序）</p><p>安装在硬件上的固定进程，从Rom加载到Ram内存后就会拉起操作系统，也就是内核会启动</p></li><li><p>Linux Kernel</p><p>内核会运行init.cpp文件去读取init.rc，根据init.rc配置文件中的配置信息启动相关的服务，之后开启 一个Zygote进程</p></li><li><p>Zygote进程（init在Native层，Zygote走到C++FrameWork层了）</p><p>这个可以看成是Android的第一个进程，进程中会开启JVM（java虚拟机）和JNI方法注册，这个进程还会去孵化一个SystemServer的进程</p></li><li><p>SystemServer（SystemServer在Java Framework层）</p><p>启动过程中会启动80多种的服务，包括Binder线程池、SystemServiceManager等等，之后Zygote、SystemServer、SustemServiceManager会一起启动多种服务（如AMS、WMS、PMS。。。），接下来AMS就会开启Launch（Launcher.java），那么系统的桌面其实就是Launch，这也是系统中的一个应用，之后就可以看App启动流程了</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403171517331.png" alt="image-20240317151745918"></p></li></ul></li><li><p><strong>APP启动流程</strong></p></li></ul><p><a href="https://blog.csdn.net/zzw0221/article/details/106716620">Android App 启动流程梳理（基于 Android 10）_android app启动流程-CSDN博客</a></p><p>Launch.java文件</p><ol><li>首先肯定有一个onclick方法（点击事件），点击桌面的图标后会有一个tag标记</li><li>然后调用<code>startActivitysafely(view, intent, tag);</code>，在这里面又会调用<code>startActivity(view,intent,tag)</code></li><li>在<code>startActivity()</code>中根据是否使用动画进行不同处理，但是都会调用一个<code>startActivity()</code>（这个是进行冷启动，使用动画的冷启动传入参数为intent和opts.toBundle()，不使用动画的冷启动传入的参数是intent）和<code>launcherApps.startMainActivity()</code>（这个是进行热启动）</li><li>冷启动方法的内部：冷启动内部会根据传入的option（这个是根据上面是否传入第二个参数来确定是否为null）是否为null，进行不同处理，都是调用<code>startActivityForResult()</code>，不为null就把intent和options都传入，为null就不传入</li><li>startActivityForResult内部会通过Instrumentation.execStartActivity()<strong>（Instrumentation是Activity和AMS通信的核心对象，为了做自动化测试而设计的 ）</strong>，看到这里就找到了冷启动是借助Instrumentation去和黑盒（也就是上图的所有部分，AMS）沟通</li><li>热启动说直接点就是使用了Binder通信</li><li>那么在黑盒里面就会根据不同的启动方式，<strong>zygote</strong>进程会<code>fork()</code>一个<code>ActivityThread.java</code></li></ol><p>ActivityThread.java文件</p><ol><li>首先直接看到main方法，很多是看不懂的，但是有Handler通信和Looper的内容，直接看到<code>thread.attach()</code><strong>（这里的thread就是ActivityThread对象）</strong></li><li>在attach方法中，会通过ActivityManager.getService()获取一个IActivityManager类型的对象mgr，mgr会执行，这里也是使用Binder通信，这里调用<code>mgr.attachApplication(mAppThreaad,startSeq)</code>去让黑盒调用<code>handlerBindApplication</code>方法</li><li>在handlerBindApplication方法中，就会根据一系列数据生产出application对象，也就是<code>app = data.info.makeApplication()</code>这个就是平时项目中的application，之后就<strong>通过Instrumentation去管理生命周期</strong>，也就是调用<code>mInstrumentation.callApplicationOnCreate(app)</code>，之后<code>application的onCreate()</code>就执行了</li><li>之后就是平时项目中的activity的onCreate了，黑盒子会调用<code>performLaunchActivity()</code>生产Activity，然后Instrumentation类会<code>newActivity()</code>生产Activity，之后就会绑定到窗口，<code>activity.attach()</code>,又会进入黑盒（FrameWork层）会将Activity绑定到窗口，又调用<code>mInstrumentation.callActivityOnCreate()</code></li></ol><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403171445841.png" alt="Snipaste_2024-02-28_22-55-17"></p><p><strong>hash</strong></p><ul><li><p>存放所有拼音和对应地址的表可以看做是 「哈希表」。</p></li><li><p>赞字的拼音索引可以看做是哈希表中的 「关键字 key」。</p></li><li><p>根据拼音索引来确定字对应页码的过程可以看做是哈希表中的 「哈希函数 Hash(key)」。</p></li><li><p>查找到的对应页码可以看做是哈希表中的 「哈希地址 value」。</p></li></ul><p><strong>插入节点流程Put</strong></p><p>key就是为了能快速查找</p><p>key.hashCode()转变为hashcode，是一个int值（无符号右移 16 位然后做异或运算）（还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移 16 位异或运算效率是最高的），之后进行位运算，也就是取模，得到的结果在0到length-1，得到index就存储即可，<strong>jdk1.7链表是前插</strong></p><p>得到下标后需要创建一个节点，之后构建链表</p><p><strong>在第一次用的时候才会去初始化，一开始虽然说是分配16长度的空间，但不使用也分配会浪费空间（懒加载）</strong> <strong>创建长度为Node[] table （jdk1.8 之前是 Entry[] table）用来存储键值对数据</strong></p><p><strong>插入过程中会出现哈希碰撞</strong></p><p>就是计算下标的过程会出现哈希碰撞，链表法解决碰撞，但本质是需要避免哈希冲突</p><p>极端情况就是一直哈希碰撞，那么就变成一个单链表，那么效率就会非常低，这就需要优化</p><p>（大牛设计为）16个节点（why？）  </p><p>二进制中16就为10000， 减1就为1111（从0开始），进行与计算哈希冲突就少，假设与0进行，结果为0，与1进行，结果为1，其他的如1100进行与计算更容易冲突，设计者明文规定初始值哈希表的size为2的n次幂（list的长度）<strong>与操作就是两个同时为1结果才为1，否则结果为0</strong></p><p><strong>之后改进，不使用单链表，在Java8（JDK1.8）中HashMap改进为使用红黑树，解决极端情况出现长的单链表的问题</strong></p><p>Hash冲突不再使用链表保存相同Index的节点，使用<a href="#红黑树">红黑树（高性能的平衡树）</a>来保存冲突节点，节点查询优先级别从O(n)提高到了O(log n)</p><p>不是什么情况都是使用红黑树，构建过程很复杂，在<strong>Java8中如果链表长度大于8并且数组长度大于64才会考虑将链表转换为一个红黑树</strong></p><p><strong>查找过程</strong>  </p><p>就是相反，先进行hash计算得到index，然后遍历链表得到需要的value即可</p><p><strong>线程安全问题</strong></p><p>在线程中是不安全的</p><p>简单情况，一边正在插入节点，一边正在删除节点就会出现问题，如扩容过程中插入节点也会有问题。。。</p><p>引入<a href="#HashTable">HashTable</a></p><p><strong>后面都是在HashMap基础上不断优化演变过来的</strong></p><p><strong>产生死锁的原因，都是在访问同一个链表的过程中产生死锁的</strong></p><p><strong>为什么key喜欢用String类型</strong></p><p>改写了hashcode函数去计算hash值，与String的每一位字符去计算hash值，这是为了避免哈希冲突</p><p><strong>解决哈希冲突的办法</strong></p><p>扩容也是一种解决办法，使数组变的更大，那么取模的时候容纳的值更多，阈值&#x3D;长度*填充因子，两倍两倍扩容</p><p>加载因子最优是0.6到0.75，这个值是根据空间和时间，通过泊松分布算法得到的一个折中的值</p><p><strong>可以认为，当我们明确知道 HashMap 中元素的个数的时候，把默认容量设置成 initialCapacity&#x2F; 0.75F + 1.0F 是一个在性能上相对好的选择，但是，同时也会牺牲些内存。</strong></p><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p> <a id="HashTable"></a></p><p><strong>Put过程</strong></p><p>跟HashMap数据结构一样，<strong>但是在put方法加锁，synchronized（同步锁，保证并发安全）</strong><code>public synchornized v put </code>，其他跟HashMap一样<strong>（所有方法都加了一个锁，那么效率就会非常低，频繁等锁）</strong></p><p><strong>为了解决效率低的问题，又出现了<a href="#ConcurrentHashMap">ConcurrentHashMap</a></strong></p><p><strong>与HashMap区别</strong></p><p>都是基于hash表实现的KV结构的集合，HashMap是JDK1.0引入的线性安全的集合类，所有数据访问的方法都加了一个Synchronized同步锁，内部采用数组+链表来实现，链表主要是实现hash表的一个hash冲突的问题，HashMap是JDK1.2引入的线程不安全的集合类，内部使用数据结构相同，但在JDK1.8使用红黑树进行了优化，链表长度大于等于8并且数组长度大于64的时候就会把链表转换成红黑树，提高数据查找的性能。</p><p><strong>高手回答（对比回答）</strong></p><p>功能特性：</p><p>HashTable是线程安全的，HashMap不是</p><p>HashMap的性能要比HashTable更好，因为HashTable采用了全局同步锁来保证安全性，对性能的影响较大</p><p>内部实现角度：</p><p>HashTable内部使用数组+链表，HashMap采用数组+链表+红黑树</p><p>HashMap初始容量为16，每次扩充为2倍；HashTable初始容量为11，每次扩充为2n+1</p><p>HashMap可以使用null作为key，会转换为0，HashTable不允许</p><p>最后</p><p>他们使用的key的散列算法不同，HashTable直接使用key的hashcode对数组长度取模，HashMap对hashcode做了二次散列，从而避免了key分布不均匀影响到查询性能</p><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p><a href="https://blog.csdn.net/weixin_45864705/article/details/127145695?ops_request_misc=%7B%22request_id%22:%22170919022416800222820457%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170919022416800222820457&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-127145695-null-null.142%5Ev99%5Epc_search_result_base9&utm_term=LinkedHashMap&spm=1018.2226.3001.4187">Java基础汇总（十六）——LinkedHashMap-CSDN博客</a></p><ul><li><p>LinkedHashMap&#x3D;HashMap + 双向链表</p></li><li><p>LinkedHashMap是HashMap的子类（拥有HashMap的所有特性）</p></li><li><p>HashMap是无序的，LinkedHashMap通过维护一个额外的双向链表保证了迭代顺序</p></li><li><p>迭代顺序可以是插入顺序，也可以是访问顺序（即根据链表中元素的顺序可以将LinkedHashMap分为：保持插入顺序的LinkedHashMap和保持访问顺序的LinkedHashMap，其中LinkedHashMap的默认实现是按插入顺序排序的）</p></li></ul><p><a href="https://www.jianshu.com/p/8f4f58b4b8ab">图解LinkedHashMap原理 - 简书 (jianshu.com)</a></p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>基于HashMap的封装</p><p><a id="ConcurrentHashMap"></a></p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p><strong>解决HashTable效率低的方法其实就是对当前需要访问的链表加锁即可，保证无多个线程对同一个链表进行操作即可</strong></p><ul><li>JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry。</li><li>JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了。</li><li>JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表。</li></ul><p><strong>Put操作</strong></p><p>对f进行加锁，也就是table数组index下标为i的值，也就是一个链表，而不是对整个方法进行加锁</p><p><strong>remove操作</strong></p><p>一样的，也是对f进行加锁</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树（Red Black Tree）是一种自平衡的二叉查找树，是一种高效的查找树。在当时被称为平衡二叉 B 树(symmetric binary B-trees)。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的红黑树。红黑树具有良好的效率，它可在 <strong>O(logN) 时间内完成查找、增加、删除等操作</strong>。所谓的平衡树是指一种改进的二叉查找树，顾名思义平衡树就是<strong>将二叉查找树平衡均匀地分布</strong>，这样的好处就是可以减少二叉查找树的深度。</p><p><a href="https://www.bilibili.com/video/BV18L411c76j/?spm_id_from=333.337.search-card.all.click&vd_source=3a564c36ba4399f31a8a0656197bd2a3">红黑树建立_哔哩哔哩_bilibili</a></p><p><strong>特征</strong></p><p>红黑树除了<strong>具备二叉查找树的基本特性</strong>之外，还<strong>具备以下特性</strong></p><ul><li>节点是红色或黑色；</li><li>根节点是黑色；</li><li>所有叶子都是黑色的空节点（NIL 节点）；</li><li>每个红色节点必须有两个黑色的子节点，也就是说从每个叶子到根的所有路径上，不能有两个连续的红色节点；</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑色节点</li></ul><p><strong>平衡二叉树为了维护树的平衡，在一旦不满足平衡的情况就要进行自旋，但是自旋会造成一定的系统开销，因此红黑树在自旋造成的系统开销和减少查询次数之间做了权衡。因此红黑树有时候并不是一颗平衡二叉树</strong></p><p><strong>一个n个节点的红黑树的高度最高为2log(n+1)</strong></p><p><strong>平衡二叉树与红黑树的区别</strong></p><ul><li>平衡二叉树的左右子树的高度差绝对值不超过1，但是红黑树在某些时刻可能会超过1，只要符合红黑树的五个条件即可。</li><li>二叉树只要不平衡就会进行旋转，而红黑树不符合规则时，有些情况只用改变颜色不用旋转，就能达到平衡。</li></ul><p><strong>红黑树的原理</strong></p><p>红黑树能够实现<strong>自平衡和保持红黑树特征的主要手段是：变色、左旋和右旋。</strong></p><p><strong>左旋：</strong>指的是围绕某个节点向左旋转，也就是逆时针旋转某个节点，使得父节点被自己的右子节点所替代</p><p><strong><img src="https://img2022.cnblogs.com/blog/1650518/202211/1650518-20221125100317360-959884815.png" alt="img"></strong></p><p><strong>右旋：</strong>指的是围绕某个节点向右旋转，也就是顺时针旋转某个节点，此时父节点会被自己的左子节点取代</p><p><strong><img src="https://img2022.cnblogs.com/blog/1650518/202211/1650518-20221125100406951-1614099187.png" alt="img"></strong></p><p> <strong>变色：</strong>如果当前节点的左、右子节点均为红色时，因为需要满足红黑树定义的第四条特征</p><p><strong><img src="https://img2022.cnblogs.com/blog/1650518/202211/1650518-20221125100552255-848151519.png" alt="img"></strong></p><p> <a id="二叉查找树"></a></p><p><strong>二叉查找树</strong></p><p><strong>二叉查找树(Binary Search Tree，BST)，又叫做二叉排序树、二叉搜索树</strong>，是一种对查找和排序都有用的特殊二叉树；红黑树，AVL树都是特殊的二叉查找树（自平衡二叉搜索树）</p><p>二叉查找树或是空树，或是满足如下三个性质的二叉树：</p><ul><li>若其左子树非空，则左子树上所有节点的值都小于根节点的值</li><li>若其右子树非空，则右子树上所有节点的值都大于根节点的值</li><li><strong>其左右子树都是一棵二叉查找树</strong></li></ul><p><strong>平衡二叉树</strong></p><p><strong>平衡二叉树，又称AVL树，它是一种特殊的<a href="#二叉查找树">二叉排序树</a>。</strong>AVL树或者是一棵空树，或者是具有以下性质的二叉树：</p><p>（1）左子树和右子树都是平衡二叉树；</p><p>（2）左子树和右子树的深度（高度）之差的绝对值不超过1。</p><p><strong>满二叉树</strong></p><p><strong>度：树节点的度就是该节点孩子的个数</strong></p><p>一棵高度为h，并且含有2的h次方减1的二叉树称为满二叉树，即树中的每一层都含有最多的结点。满二叉树的叶子节点都集中在二叉树的最下一层，并且除叶子结点之外的<strong>每个结点度数均为2</strong>.(二叉树结点的度即为结点的孩子个数)。</p><p>特点：</p><ul><li>只有最后一层有叶子结点。</li><li>不存在度为1的结点。</li><li>按层序从1开始编号，自上而下，自左向右。这样每个结点对应一个编号，对于编号为i的结点，如果有双亲，其双亲为[i &#x2F; 2]，如果有左孩子，则左孩子为2i，如果有右孩子，则有孩子为2i+1。</li></ul><p><img src="https://img-blog.csdnimg.cn/fdb71471d7934c008c19fe21667c9cc5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGlnaHQtaW5r,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>完全二叉树</strong></p><p>设一个高度为h， 有n个结点的二叉树，当且仅当其每一个结点都与高度为h的满二叉树中编号为1… n 1 … n1…n的节点一一对应时，称为完全二叉树。</p><p>特点：</p><ul><li>只有最后两层可能有叶子结点。</li><li><strong>最多只有一个度为1的结点，且该节点只有左孩子没有右孩子。</strong></li><li>若i &lt; &#x3D; ⌊ n &#x2F; 2 ⌋，则节点i为分支结点，否则为叶子节点。</li><li>按层序编号之后，一旦出现某节点（其编号为i）为叶子结点或只有左孩子，那么编号大于i的节点均为叶子结点。</li><li>若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点（编号为n&#x2F;2）只有左孩子没有右孩子，其余分支结点左右孩子都有。</li></ul><p><img src="https://img-blog.csdnimg.cn/3a4eca286df949b9a04fc7e3f80a5b6f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGlnaHQtaW5r,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h4 id="Glide-1"><a href="#Glide-1" class="headerlink" title="Glide"></a>Glide</h4><p>Glide三部曲</p><p>with：空白的Fragment管理生命周期机制 </p><ul><li><p>为什么监听Fragment&#x2F;Activity生命周期</p><p>Glide会监听传入的对象的生命周期，内部会自动进行回收，可以自己再手动在onDestory去回收，也可以不写，Glide会自动去做</p><p>（不把生命周期的管理交给用户去做可以避免发生人为的失误）</p></li><li><p>怎么监听生命周期的变化的</p><p>创建了一个空白的Fragment，连接Activity，就能监听到Activity的生命周期变化了，在Glide有一个RequestManager（这是监听生命周期变化的接口的实现类）去管理图片的请求，这个类可以根据Activity生命周期的变化而变化</p></li><li><p>源码分析</p><p>由一个get方法去获取RequestManager，如果是子线程不需要管什么，没有生命周期需要管理，主线程就需要先添加一个空白的Fragment，最终with会返回一个RequestManager对象</p></li></ul><p>load：最终构建RequestBuilder对象</p><p>最终会返回一个RequestBuilder对象</p><p>into：等待队列，执行队列；活动缓存；内存缓存；HttpUrlConnection</p><ul><li><p>源码分析</p><p>首先要得到ImageViewTarget</p><p>构建Request，是一个接口，实现类是SingleRequest，并且在上一个请求没有请求完就先完成上一个请求</p><p>维护两个队列，正在运行队列和等待队列，一进来都添加到运行队列中，运行队列暂停了就直接添加到运行队列运行（begin），运行队列还在运行就添加到等待队列</p><p>这里都是直接调用接口方法的，实现在SingleRequest</p><p>begin方法：onSizeReady，再会调用Engine.load，之后从内存获取（生成key，从弱引用获取），然后再通过jobs.get检测有没有真正执行的缓存可用（与磁盘缓存有关），实在没有就进行网络请求</p><p>EngineJob维护线程池</p><p>DecodeJob给EngineJob进行执行，相当于一个任务Runnable和run函数</p><p>后面具体请求部分太乱了，看视频吧！！！</p></li></ul><h4 id="OKHttp"><a href="#OKHttp" class="headerlink" title="OKHttp"></a>OKHttp</h4><p><strong>使用方法</strong></p><p>调用流程</p><p>代码部分前面了</p><p>OkHttp请求过程解除最多的是OkHttpClient、Request、Call、Response，但是框架内部进行了大量的逻辑处理，所有逻辑处理大部分集中在拦截器中，但是进入拦截器之前还需要依靠分发器来调配请求任务</p><p>分发器：内部维护队列和线程池，完成请求调配</p><p>拦截器：完成整个请求过程（完成一次完整的http请求的过程，DNS解析-&gt;三次握手建立TCP连接(socket)-&gt;发送http报文）（当然这里还完成了许多的优化的功能，包括连接池等等）</p><p><strong>分发器Dispatcher</strong></p><p><strong>下面这部分就相当于是OkHttp进行网络请求的具体流程，源码分析就分析其中一些具体部分</strong></p><ul><li><p>构建OkHttpClient对象构造者模式可以使用自己的分发器对象</p></li><li><p>OkHttpClient的newCall方法传入Request对象得到一个Call对象（Call是一个接口，实现类是RealCall类，将OkHttpClient对象、Request对象都交给RealCall去处理，然后返回对象）</p></li><li><p>然后调用RealCall对象的同步和异步请求的方法发起请求</p></li><li><p>然后看到enqueue异步请求方法（进入这个方法一进来就synchronized(this)，加锁保证RealCall并限制只能进行同步请求或异步请求，不能同时进行，否则抛出异常，可以使用clone方法，克隆一个对象出来进行请求）（OkHttpClient还可以设置EventListener对象，可以监听请求的开始。。。）</p></li><li><p>然后enqueue内部就调用OkHttpClient的dispatcher方法去获取DisPatcher对象去执行enqueue方法，之后传入一个AsyncCall对象（可以看作请求任务），这个对象传入CallBack回调</p></li><li><p>进入分发器的enqueue方法，有RunningAsyncCalls（正在执行异步请求队列）、RunningSyncCalls（正在执行的同步请求队列）、ReadyAsyncCalls（等待异步请求队列）队列<strong>（ArrayDeque类型，内部循环数组，作者解释，如果把这个类型当做stack栈来使用，它比栈快，如果把它当做queue来使用，它比LinkedList快）</strong></p></li><li><p>接下来就是分发器分发任务的过程，对于异步请求有两种方式，进入等待队列，进入执行队列</p></li><li><p>进入Running队列的请求任务就会加入线程池执行，也是在enqueue方法中的，在加入执行队列代码下一行就是让ExecutorService对象（其实就是线程池）的execute执行这个Call对象任务（线程池需要接收Runnable，Call也就是AsyncCall其实就是Runnable）</p></li><li><p>接下来就是执行AsyncCall这个里面的execute方法（AsyncCall继承的类中的run执行了一个抽象方法execute），下面其实就是通过<strong>getResponseWithInterceptorChain方法去走拦截器，返回Response</strong>，这里异常机制，finally代码块一定执行，执行client.dispatcher().finished(this)，finish方法传入running队列，AsyncCall对象和true，然后从Running队列移除已经完成的Call对象，然后就循环根据下面提到的从Ready队列拿对象放到Running队列</p></li></ul><p>离并发任务分发</p><ul><li><p>异步请求 </p><ul><li><p>分发器怎么决定放入ready还是running队列？</p><p>是一个判断语句</p><p>第一个条件根据正在执行异步请求队列的个数决定的，分发器默认定义这个值为64，小于这个值直接加入Running队列，大于这个值就加入Ready队列（可以修改）</p><p>第二个条件是同一个域名的请求最大数不大于5个，默认值为5个</p></li><li><p>从Ready移动到Running的条件是什么？</p><p>任务结束判断，Running队列数量少于分发器规定的最大同时异步请求对象的数量，并且请求队列不为空，而且对于同一域名的请求数量少于定义的数量（多于的对象就找下一个），就移动到Running队列中</p></li><li><p>分发器线程池怎么定义的？</p><p>executorService其实就是线程池，new了一个ThreadPoolExecutor对象（这个就是最基本的线程池类，不是那几个特别的，可以看前面的部分，下面讲一下它构造这个对象传入的内容），这里传入的等待队列传入的类型是synchronousQueue（因为LinkedBlockingQueue和ArrayBlockingQueue不合适，如果使用ArrayBlockingQueue设定值为1，核心线程数为1，那么如果有一个线程一直在跑，又进来一个任务就会进入队列，再进来一个任务就又要入队，但是队列满了按照这个类型的等待队列就需要额外新建一个线程，但是会先跑任务3再跑任务2，就很有问题，因为我们需要线程进来就开始跑，并且按顺序来），那么如果达到线程池定义的最大线程数怎么办呢，就会需要使用线程池传入的拒绝策略的参数来进行处理</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403062342157.png" alt="image-20240306234243536"></p></li></ul></li><li><p>同步请求</p><p>同样是先一个判断语句一个call只能用一次，然后执行分发器的同步请求方法（这里面就是直接把这个call放入running队列，直接执行），最后使用分发器的finished方法（将完成同步请求的call从队列remove）</p><p><strong>前面异步的具体流程直接看分发器的部分就可以了</strong></p></li></ul><p>线程池排队</p><p>OKHttp传入的工作队列类型决定了他的工作行为为无等待，最大并发的，这个就是具体的排队机制，这很符合OkHttp的使用场景，高并发的网络请求场景，但是并不会很容易OOM，因为前面分发器中定义的等待队列和</p><p>执行队列就是为了限制所有的异步请求的数量，避免了OOM</p><p><strong>拦截器</strong></p><p>责任链模式</p><p>（避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。）</p><p><strong>请求从上往下去执行，响应再从下往上去回传</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403071244326.png" alt="image-20240307124450739"></p><p>五大拦截器</p><ul><li><p>RetryAndFollowUpInterceptor（重试和重定向拦截器）</p><p>第一个接触到请求，最后接触到响应;负责判断是否需要重新发起整个请求</p></li><li><p>BridgeInterceptor（桥接拦截器）</p><p>补全请求（如补全请求头，gzip解压or设置cookie），并对响应进行额外处理</p></li><li><p>CacheInterceptor（缓存拦截器）</p><p>请求前查询缓存，获得响应并判断是否需要缓存（需要使用就需要手动去开启缓存，就是在构建OkHttpClient的时候在Builder.cache(new Cache(存储路径，最大长度))）</p><p>HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类可以分为强制缓存和对比缓存</p><ul><li><p>强制缓存</p><p><img src="https://img-blog.csdnimg.cn/20190712194525612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p>http1.1的head中Cache-Control字段标明失效规则，private客户端可以缓存；public客户端和代理服务器都可以缓存；max-age&#x3D;xxx:缓存的内容将在 xxx 秒后失效；no-cache:需要使用对比缓存来验证缓存数据；no-store:所有内容都不会缓存，强制缓存，对比缓存都不会触发</p></li><li><p>对比缓存</p><p><img src="https://img-blog.csdnimg.cn/20190712194541903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p>对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。</p><p>最重要的就是在header中的传递的两种标识，Last-Modified &#x2F; If-Modified-Since，Last-Modified：<br>服务器在响应请求时，告诉浏览器资源的最后修改时间；If-Modified-Since：再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。<br>服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。<br>若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</p><p>还有Etag &#x2F; If-None-Match（<strong>优先级高于Last-Modified &#x2F; If-Modified-Since</strong>），Etag：<br>服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定），If-None-Match：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</p></li></ul></li><li><p>ConnectInterceptor（链接拦截器）</p><p>与服务器完成TCP连接 （Socket）</p></li><li><p>CallServerInterceptor（请求服务拦截器）</p><p>与服务器通信;封装请求数据与解析响应数据(如:HTTP报文)</p></li></ul><p><strong>还可以自定义拦截器</strong></p><p>在Builder的addInterceptor和addNetworkInterceptor可以传入自定义的拦截器，这两者的区别体现在添加到list的顺序不同，添加拦截器是在RealCall中完成的，getResponseWithInterceptorChain中完成的，addInterceptor添加到拦截器会在list的最前面，也就是在重试和重定向拦截器的前面，而addNetworkInterceptor添加的拦截器在最后一个请求连接器的前面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());<span class="comment">//用户自定义拦截器</span></span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor); <span class="comment">//重试和重定向拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));<span class="comment">//负责添加交易请求头</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));<span class="comment">//缓存拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client)); <span class="comment">//网络连接拦截器</span></span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket)); <span class="comment">//负责发送网络请求和读取网络响应</span></span><br><span class="line"></span><br><span class="line">  Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">      interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器中的ConnectionPool（连接池）看前面的OkHttp部分有提到原理</p><p>网络代理</p><p>这是网络通信必备基础中的socket通信原则中的内容，socket通信原则中有SOCKS代理和HTTP普通代理与隧道代理</p><h4 id="Retrofit-1"><a href="#Retrofit-1" class="headerlink" title="Retrofit"></a>Retrofit</h4><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403171439151.png" alt="image-20240317143912729"></p><p>本身就是一个<strong>（外观设计模式）</strong>，本身不具备新的功能，本身就是对其他东西的封装，但是所有网络请求都走这里就形成了一个类似接口的东西</p><p>Retrofit是不具备拦截器的，但是可以在OkHttpClient中添加然后传入给Retrofit</p><ul><li><p><strong>Retrofit实例创建过程（构建者设计模式：构造函数参数大于5个，存在可选参数就可以使用构造者设计模式）</strong></p><p>baseUrl主域名；callFactory网络请求工厂；addConverterFactory数据转换器；addCallAdapterFactory这个就是添加到下面的adapterFactories中，这些其实就是通过构造者模式的builder往retrofit对象去添加不同的参数</p><p><strong>里面参数</strong></p><ul><li><p>baseUrl（网络请求的url地址）</p></li><li><p>callFactory（网络请求工厂）参数如果不指定，为null的话默认构建一个OKHttpClient（默认只支持okhttp），那么这里可以自定义一个OKHttpClident，自定义自己的需求然后传入</p></li><li><p>callbackExecutor（回调方法执行器）线程池，默认会创建一个线程池</p></li><li><p>adapterFactories（网络请求适配器工厂）<strong>（工厂设计模式）</strong>是一个ArrayList，会把多个adapter加入list，本身还会加入一个默认的adapter，adapter其实就是要将okhttp的call转换成retrofit的call，这个封装其实就是适配的过程<strong>（适配器设计模式）</strong></p></li><li><p>converterFactory（数据转换器工厂）也是一个ArrayList，会把多个数据转换器（序列化工具）加入到List中</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403171139324.png" alt="image-20240317113922056"></p></li></ul></li><li><p><strong>代理实例创建过程</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403171143731.png" alt="image-20240317114258525"></p><p>上面蓝色部分就是retrofit的核心部分，返回一个create传入的接口的对象（内部new了一个接口类型的对象，虽然是接口类型），这就是<strong>动态代理（JDK的动态代理，后面再看吧，有反射的内容在里面，在内存中生成一个动态的类）</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403171206228.png" alt="image-20240317120654636"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403171208572.png" alt="image-20240317120814076"></p><p><strong>静态代理</strong>：学习动态代理之前需要先学习静态代理，了解代理的思想，可以看下面的图，假设要找明星拍视频，那么明星其实只需要进行拍视频即可，那么其他的谈合作和收尾部分其实只需要经纪人代理去完成即可；但是如果要换个明星那就很复杂了，但是对于用户来说谈价格和收尾内容一样的，应该可以让一个人来做就可以了，但是代理找不到具体的明星了，因为一个经纪人就负责一个明星，所以说代理对象只有一个并且代理类的接口比较稳定的时候就可以使用静态代理</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403171149486.png" alt="image-20240317114955851"></p><p>这里回到retrofit部分，那么<strong>使用动态代理就可以让所有接口都走invoke函数，通过invoke函数就可以拦截调用函数的执行，就获取到接口上注解的参数，那么就可以构建request请求动态变化对象，动态构建URL，从而将网络接口的参数配置归一化，这就解决了OkHttp使用中的缺陷（用户网络接口配置繁琐，尤其是需要配置复杂请求的body，请求头，参数的时候</strong>；数据解析过程需要用户手动拿到reponseBody进行解析，不能复用；无法适配自动进行线程的切换；万一我们存在嵌套网络就会陷入回调陷阱）</p><p>其实根本不用管在接口那里定义的方法名是什么，因为重要信息其实是注解的参数，那么接口定义的方法拿到后在invoke中拿到参数即可，那么就可以拿到参数进行处理，返回其他对象，那么这里最后返回的其实是一个call对象</p></li><li><p><strong>ServiceMethod设计理念</strong></p><p>这个类是出现在动态代理内部的类，这里面会包含大量的反射和大量的解析（那么这个过程是比较耗时间和耗性能的），这个类的内部使用了缓存，为了来提高性能，那么只要Retrofit不退出，那么访问过的接口就在缓存中存在了，就不需要重新进行创建；那么在这个内部获取到了接口注解定义的参数，也知道了具体需要返回的类型，那么就可以<strong>从retrofit对象中确认（前面arrayList中放的对象就用一个for循环去找需要的内容即可）</strong>访问的完整的URL，适配器的种类和需要使用到的数据转换器，并确认具体的回调方法的执行器</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403171244929.png" alt="image-20240317124417177"></p><p>在前面构建retrofit的过程中就是单纯的准备了各种所需要的东西，那么在serviceMethod中就是要并且具体使用哪些东西了，包括baseUrl（网络请求的url地址），callFactory，callAdapter，responseType（call返回值类型），responseConverter（明确对应的数据转化器），parameterHandlers（对接口中的注解参数进行解析配置）；那么一个接口就是对应一个serviceMethod</p></li><li><p><strong>RxJavaCallAdapterFactory设计模式和理念</strong></p></li></ul><p>  之后可以由serviceMethod获取到call对象，之后就由call对象进行异步请求，这个就是OkHttp发起请求而已，之后就只需要关注response返回是怎么样进行处理的，也就是解析的过程以及适配器的工作过程即可。</p><p>  <strong>适配器</strong></p><p>  （CallAdapter适配器的作用就是将Call<T>转换成Java对象）</p><p>  在builder中会默认添加一个适配器工厂，rxjava是解决回调嵌套的（链式调度），实际开发中不存在嵌套访问的情况那么就可以不使用rxjava（在这里并不是说rxjava能完成线程切换而使用的，不使用rxjava也是可以进行线程的切换到），那么就会自动用到了默认的适配器工厂，那么下面看一下默认适配器工厂怎么进行线程切换的：</p><p>  在创建默认的适配器工厂defaultCallAdapterFactory的时候会传入callbackExecutor（这个其实就是一个Handler），那么在获取到response后就会通过callbackExecutor的异步方法去进行回调，会在主线程完成（callbackExecutor异步请求就是将需要执行的内容通过handler.post(runnable)让主线程执行内容），那么也就是说这样就已经能够完成线程的切换了</p><p>  <img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403171414782.png" alt="image-20240317141359280"></p><p>  下面看一下RxJavaCallAdapterFactory的设计模式， 抽象工厂设计模式，</p><p>  内部是先选择适配器工厂，再由工厂选择适配器，两个get方法，存在多个工厂和多种适配器（ResponseAdapter、ResultAdapter、SimpleCallAdapter），根据不同的返回内容选择不同的适配器（最终是需要把请求得到的内容转化成Obserable类型的对象的）</p><p>  <strong>解析过程</strong></p><p>  转换器就是转换请求体和响应体</p><h4 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h4><p><strong>Synchronized锁机制和wait notify原理</strong></p><p>联系前面多线程知识和这里，觉悟！！！</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403031641448.png" alt="image-20240303162236618"></p><p>为什么是while，这个锁可能被其他地方唤醒等待，这里使用while哪怕被唤醒也会继续循环，有对象了就结束循环，没有就继续等待</p><p><strong>volatile</strong></p><ul><li>现代计算机缓存架构，Cache，CPU和主内存的速度差异</li></ul><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403031641614.png" alt="image-20240303163921595"></p><ul><li>Java内存模型</li></ul><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403031641687.png" alt="image-20240303164134108"></p><p><a href="https://www.cnblogs.com/radish40/p/16345493.html">Java内存模型(JMM)及8种原子操作 - 萝卜不会抛异常 - 博客园 (cnblogs.com)</a></p><p>为什么加volatile就能解决线程之间变量不可见的问题</p><ul><li><p>MESI缓存一致性协议<a id="MESI缓存一致性协议"></a></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403031650527.png" alt="image-20240303165008736"></p></li></ul><p>多了一条总线，多个线程将值取到工作内存中，只有在修改的时候并且写入内存的时候会经过总线（写回住内存的过程中是加了锁的），总线嗅探到就会清空副本，需要的时候再重新从主内存拿进来</p><p>只需要有一个子线程执行了store和write操作就会触发总线嗅探机制，每个线程池上就会有一个总线嗅探器，</p><p>使用了volatile就会激活总线嗅探器，就是类似一个监听器（或者说观察者），就会把自己的flag副本清除掉，继续使用就重新从主线程去读取，总线嗅探机制+总线就是缓存一致性协议，就是为了使变量在线程之间是可见的状态</p><ul><li><p>指令重排</p><ul><li><p>这里需要先了解Java中对象的半初始化</p><p><a href="https://blog.csdn.net/wangshuai6707/article/details/132989866">java对象半初始化问题是怎么回事_java 对象部分初始化问题-CSDN博客</a></p><p><img src="C:\Users\GTR\AppData\Roaming\Typora\typora-user-images\image-20240303171802648.png" alt="image-20240303171802648"></p><p>上面这里如果是单线程当然没什么问题，但是如果是多线程，执行下面的检测部分的代码的时候如果new对象的过程没有完全执行完，但是instance对象已经建立联系，只是后面i的赋值还没有执行，那么当另外一个线程进来就会直接获取instance对象，但是这时i还没有赋值，里面的i还是0，这时候就会出现问题，那么解决这个问题就是通过volatile的指令重排的方式实现的，这涉及到内存屏障，内容很多</p><p><strong>局部单例，只对一个Activity有效，后面看</strong></p></li></ul></li><li><p>作用</p><p>直接看前面的特性吧，有提到，前面2点就是</p></li></ul><p><strong>移动端常用的锁方法</strong></p><p>这里主要介绍了Android中经常用到的锁的使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">synchronized</span>(object)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 乐观锁,速度比上面快挺多的，但是也存在问题，一些操作直接调用api可以直接操作，但是复杂的操作就很难完成</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">60000</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span>&#123;</span><br><span class="line">    i.decrementAndGet();<span class="comment">//原子性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 显示锁</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">60000</span>;</span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="comment">//jdk1.5后提供的一个接口，可以手写相关功能</span></span><br><span class="line"></span><br><span class="line">lock.lock();<span class="comment">//加锁</span></span><br><span class="line">lock.unlock();<span class="comment">//解锁</span></span><br><span class="line"><span class="comment">//规范要求使用try catch finally进行书写，最后需要释放锁</span></span><br></pre></td></tr></table></figure><ul><li><p>AtomicInteger</p><p>首先将需要加锁的值赋给自己内部的一个成员变量，然后通过反射的方式获取偏移量去读取数据，后面value读取数据是直接从共享内存去读取数据的，下面是从C和C++底层去操作了，是获取偏移地址的过程</p><p>看i–的那部分方法怎么实现的，执行decrementAndGet方法进行原子操作，这里面使用的是一个U.getAndAddInt方法，之后直接调用api通过起始地址和偏移量去获取变量，这里面有一个while循环包围在外面，这个while循环里面的compareAndSwapInt就是CAS机制，代码图片放CAS机制下面</p><p>正常情况下使用对象.属性获取值是没有什么问题的，但是在多线程中这样使用就会有问题，正常使用过程这样就会先复制一个副本到栈内存，之后读取是从栈内存去读取的（即时生效效果很快）</p></li></ul><p><strong>CAS机制原理分析</strong></p><p>CAS,全称Compare And Swap(比较与交换),解决多线程并行情况下使用锁造成性能损耗的一种机制。</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403041308554.png" alt="image-20240304130841698"></p><p>上面这里的compareAndSwapInt就是先将var5+var4存一份下来，也就是var-1，然后再根据传入的this和偏移量取数据和上面api取得的数据做一个比较，如果比较相等返回，否则一直循环直到满足条件。</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403041312809.png" alt="image-20240304131240166"></p><p>直接看代码看不懂，这里的具体运行步骤其实就是：</p><p>在单线程情况下这里是没什么意义的，多线程情况下就有意义了，A线程先进来读取数据，读到数据后想要减1进行保存，但是还没保存时间片就到了，需要停止运行，让其他线程先运行，B线程这时取的是A还没有更新的值，但是他执行的比较快，就取更新了共享内存中的值，A线程这时可以继续运行了，会走到取值进行比较的时候，发现原本取到的值和现在共享内存的值不一样，就得重新循环上面的事情，重新取值然后重新运行。这样就保证了所有线程只进行一次减的操作</p><p>CAS原理：<br>   通过查看AtomicInteger的源码可知， </p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123; </span><br><span class="line">          <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update); </span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure></code></pre><p>通过申明一个volatile （内存锁定，同一时刻只有一个线程可以修改内存值）类型的变量，再加上unsafe.compareAndSwapInt的方法，来保证实现线程同步的。</p><p><strong>这时候比较懵的其实，前面内容有点乱，可以看下面的博客就知道具体关系了，里面有CAS和ABA相关</strong></p><p><a href="https://blog.csdn.net/zpzkitt/article/details/96490515">CAS与volatile关系以及如何保证原子性_cas和volatile-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_41899026/article/details/118652720">volatile与CAS的比较_cas和volatile的区别-CSDN博客</a></p><p><strong>CAS的好处就是没有执行阻塞操作，运行过程是很快的，但是问题就是如果访问的线程过多，CPU占用率就很高，高吞吐量和高并发就不太适合，3-5个线程使用CAS机制就是锁机制比不了的，可能会有ABA问题，循环时间开销大和只能保证一个共享变量的原子操作</strong></p><p><strong>可以用CAS在无锁的情况下实现原子操作，但要明确应用场合，非常简单的操作且又不想引入锁可以考虑使用CAS操作，当想要非阻塞地完成某一操作也可以考虑CAS。不推荐在复杂操作中引入CAS，会使程序可读性变差，且难以测试，同时会出现ABA问题</strong></p><p><strong>ABA问题</strong></p><p>这个是CAS机制中会出现的问题，就是其他线程获取一个值后进行了多次修改，最后的值和原来的值一样，（过程发生了修改但是被告知没有修改）</p><p>这时当前线程认为是可以执行的，其实是发生了不一致现象，如果这种不一致对程序有影响(真正有这种影响的场景很少，除非是在变量操作过程中以此变量为标识位做一些其他的事，比如初始化配置)，则需要使用AtomicStampedReference(除了对更新前的原值进行比较，也需要用更新前的 stamp标志位来进行比较)。</p><p><strong>AQS</strong></p><p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。</p><p><a href="https://zhuanlan.zhihu.com/p/378219920">AQS 详细介绍 - 知乎 (zhihu.com)</a></p><p><strong>synchronized锁升级过程</strong></p><p>重量级和轻量级</p><p>synchronized线程阻塞是依赖于操作系统的，依赖性强，所以是重量锁（对外依赖性强就是重量级）</p><p>（略：任何一个对象大小必须为8的倍数，如16bytes，不够是会进行内存填充的，创建一个对象的时候包含三部分信息，对象头、实例数据、填充数据，创建对象时会存储锁相关的信息，包括指向轻量级锁指针、指向重量级锁指针、偏向线程ID 等。）</p><p> <img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403041357584.png" alt="image-20240304135710981"></p><p>对一个对象，只有单线程访问就会上一个偏向锁，偏向锁其实就是上面的CAS机制的while循环判断是否有值相等改变成if，就是偏向锁（性能高）</p><p>如果出现多线程访问，也就是轻度竞争，那么就会升级为轻量级锁，也叫自旋锁（底层就是CAS）</p><p>轻量级锁如果3-5ms还抢不到就会自动转换为重量级锁（基于线程原地等待，但是一直获取不到锁这个问题，我们必须给线程空循环设置一个次数，当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。）</p><p>偏向锁如果调用wait等操作，也就是重度竞争就会转换成重量级锁</p><p>（重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。这就是说为什么重量级线程开销很大的。互斥锁(重量级锁)也称为阻塞同步、悲观锁）</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403041405472.png" alt="image-20240304140522104"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202403041406496.png" alt="image-20240304140612329"></p><h4 id="四大引用"><a href="#四大引用" class="headerlink" title="四大引用"></a>四大引用</h4><ul><li><p>软引用（SoftReference）：内存不足的时候进行释放</p><p>（举一个例子：如果把用户需要访问的图片都加载进来内存，那么访问的时候速度就会很快，但是内存的消耗是非常大的；但是所有图片都不加载进来内存，每次都从磁盘去访问获取用户需要的图片，那么访问的速度是非常慢的；这时候就可以使用弱引用构建一个空间来进行使用，在内存不足的时候就回收空间内的内容）</p></li><li><p>强引用：引用链不断就不会释放</p><p>就是正常的<code>new Object()</code></p></li><li><p>弱引用（WeakReference）：GC回收的时候就会回收</p><p>一些对App运行没有影响的对象就可以使用弱引用，弱引用对处理内存泄露很有用，比如持有Activity解决内存泄露</p></li><li><p>虚引用（PhantomReference）：GC回收的时候会得到一个通知</p><p>虚引用也叫幽灵引用，虚拟机开发可能会用到，日常开发极少用到</p><p>虚引用不会单独去使用，构架PhantomReference虚引用对象的时候需要传入一个对象和一个引用队列（ReferenceQueue对象），构建好对象后使用Queue.poll()对传入虚引用对象的对象访问并不会获取到数据，也就是为null，但是如果在GC到来后休眠线程然后在poll访问一下队列里面的这个对象就会发现可以访问到，说明对象存在了，但是并不能获得对象的引用，只能知道这个对象被GC的时间</p></li></ul><h4 id="单例的实现方式"><a href="#单例的实现方式" class="headerlink" title="单例的实现方式"></a>单例的实现方式</h4><h3 id="个人记录"><a href="#个人记录" class="headerlink" title="个人记录"></a>个人记录</h3><h4 id="HashMap和SparseArray原理，相对有什么优缺点"><a href="#HashMap和SparseArray原理，相对有什么优缺点" class="headerlink" title="HashMap和SparseArray原理，相对有什么优缺点"></a>HashMap和SparseArray原理，相对有什么优缺点</h4><p><strong>HashMap</strong> 数组+链表的思想，使用容量为16的数组进行存储，并且每个数组是链表的表头，即使没有内容进行存储，在对象存在时会分配一块固定的内存空间供其使用，但不断往HashMap中put内容的时候如果超出它的阈值，也就是存储空间，那么就需要进行扩容操作。put操作在hashcode()函数后得到一个hash值之后进行取模映射到正确的位置（index），如果当前下标下面后面的链表为空，那么直接构建链表往后面放就可以了，如果不为空就往后放并更改最后的一个的指向下一个值的index信息，空间不够就需要进行扩容操作，Get过程计算hash过程相同，查找具体的值还需要进行遍历去从链表中进行查找</p><p><strong>SparseArray</strong>的key和value都是数组，key为一个int类型的数组，value为一个Object类型的数组，双数组进行保存，对于put进来的值，对于一个key进行哈希操作得到一个hash值，之后通过二分查找去查找其需要放入的位置，对于get操作就直接根据hash值进行二分查找确定位置返回值即可。特别的，如果有值需要进行删除，先进行查找，找到需要删除的值后不是直接进行删除，而是直接将值赋值为DELETE，一个标识，之后需要存值如果key小于原本的值并且value为DELETE就直接赋值即可，不需要整体移动，耗时短。</p><p><strong>它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间</strong></p><p>这两者都是存储&lt;key,value&gt;键值对数组的数据结构，但具体数据结构不同，HashMap为数组+链表的结构，SparseArray为双数组的结构，性能方面：HashMap对于int类型的Key自动装箱为Integer，但是它的key为任何类型都可以，所以虽然性能不够好但是直到现在都没有被淘汰，SparseArray的key限制为int类型。</p><p><strong>数据量小于1k。如果key不是int小于1000的话。可以用Arraymap。</strong></p><p>虽说SparseArray性能比较好，但是由于其<strong>添加、查找、删除数据都需要先进行一次二分查找，所以在数据量大的情况下性能并不明显，将降低至少50%<strong>。满足下面两个条件我们可以使用SparseArray代替HashMap：</strong>数据量不大，最好在千级以内；key必须为int类型，这中情况下的HashMap可以用SparseArray代替。</strong></p><h4 id="ConcurrentHashMap基本原理"><a href="#ConcurrentHashMap基本原理" class="headerlink" title="ConcurrentHashMap基本原理"></a>ConcurrentHashMap基本原理</h4><p>ConcurrentHashMap是一个支持高并发更新和查询的哈希表</p><h4 id="Glide-2"><a href="#Glide-2" class="headerlink" title="Glide"></a>Glide</h4><ol><li><p>Glide缓存机制</p><p><strong>引入缓存的目的：</strong>可以减少流量的消耗，加快响应速度；Bitmap的加载和销毁比较占内存，可能会导致频繁GC，使用缓存可以更加高效地加载Bitmap</p><p><strong>缓存过程：</strong>Glide的缓存分为内存缓存和磁盘缓存，内存缓存是由弱引用+LruCache组成的。取的顺序是：弱引用-&gt;LruCache-&gt;磁盘；存的顺序是磁盘-&gt;弱引用-&gt;LruCache</p><p><strong>内存缓存原理：</strong>弱引用是由一个HashMap维护，key是缓存的key（这个key由图片url、width、heigjt等10来个参数组成）value是图片资源对象的弱引用类型<code>Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = new HashMap&lt;&gt;();</code> ,LruCache是由一个LinkedHashMap维护，根据Lru算法来管理图片。大致的原理就是利用LinkedHashMap链表的特性，把最近使用过的文件插入到列表头部，没使用过的放在尾部；然后当图片大小达到预设的一个阈值的时候，按照算法删除列表的尾部的数据。</p><p><a href="https://www.jianshu.com/p/8f4f58b4b8ab">图解LinkedHashMap原理 - 简书 (jianshu.com)</a></p><p>看了图，是头插，往header的before去插入Entry</p><p> <strong>内存缓存下的存取原理：</strong>（取数据）内存缓存中有一个概念为图片引用计数器，具体来说就是在EngineResource中定义了一个acquired变量用来记录图片被引用的次数，调用<code>acquire()</code>方法会让变量+1，调用<code>release()</code>方法会让变量-1，获取图片资源是先从弱引用获取，拿到的话引用数+1，没有就从LruCache中拿缓存，拿到的话，引用数也+1，同时把图片从LruCache缓存移动到弱应用缓存池中；再没有的话就通过<code>EngineJob</code>开启线程池去加载图片，拿到的话引用数+1，会把图片放到弱引用中。（存数据）存数据是在加载图片之后的事情，通过<code>EngineJob</code>开启线程池去加载图片，拿到数据后就回调到主线程，把图片存到弱引用中，当图片不再使用或者暂停使用，也就EngineResource中的acquire为0的时候就会将弱引用中的图片放到LruCache中进行缓存，同一张图片只会出现在LruCache中的一个</p><p><strong>磁盘缓存原理（DiskLruCache）：</strong>Glide的磁盘缓存策略有多种，</p><p>DiskCacheStrategy.DATA : 只缓存原始图片；<br>DiskCacheStrategy.RESOURCE :只缓存转换过后的图片；<br>DiskCacheStrategy.ALL :既缓存原始图片，也缓存转换过后的图片；对于远程图片，缓存 DATA<br>和 RESOURCE；对于本地图片，只缓存 RESOURCE；<br>DiskCacheStrategy.NONE ：不缓存任何内容；<br>DiskCacheStrategy.AUTOMATIC ：默认策略，尝试对本地和远程图片使用最佳的策略。当下载网<br>络图片时，使用 DATA (原因很简单，对本地图片的处理可比网络要容易得多)；对于本地图片，使<br>用 RESOURCE 。</p><p>同样的如果在磁盘缓存中没有获取到就通过EngineJob开启线程池去加载图片，这里有两个关键类，DecodeJob和EngineJob，EngineJob内部维护了线程池，DecodeJob是线程池中的一个任务</p><p>磁盘缓存是通过 DiskLruCache 来管理的,根据缓存策略，会有2种类型的图片， DATA (原始图片)和<br>RESOURCE （转换后的图片）。磁盘缓存依次通过 ResourcesCacheGenerator 、 SourceGenerator 、<br>DataCacheGenerator 来获取缓存数据。 ResourcesCacheGenerator 获取的是转换过的缓存数据；<br>SourceGenerator 获取的是未经转换的原始的缓存数据； DataCacheGenerator 是通过网络获取图片<br>数据再按照按照缓存策略的不同去缓存不同的图片到磁盘上。</p><p><strong>为什么引入弱引用？</strong>（提高效率）弱引用使用的是HashMap，而LruCache采用的是LinkedHashMap，从访问效率而言，肯定是HashMap更高；（分压策略）减少LruCache中的trimToSize的概率，同一张图片不会同时出现在弱引用和LruCache中，正在引用的放到弱引用中，减少了LruCache中存放的数量</p><p><strong>总结</strong></p><p>Glide缓存分为 弱引用+ LruCache+ DiskLruCache ，其中读取数据的顺序是：弱引用 &gt; LruCache &gt;<br>DiskLruCache&gt;网络；写入缓存的顺序是：网络 –&gt; DiskLruCache–&gt; LruCache–&gt;弱引用<br>内存缓存分为弱引用的和 LruCache ，其中正在使用的图片使用弱引用缓存，暂时不使用的图片用<br>LruCache缓存，这一点是通过 图片引用计数器（acquired变量）来实现的，详情可以看内存缓存的小<br>结。<br>磁盘缓存就是通过DiskLruCache实现的，根据缓存策略的不同会获取到不同类型的缓存图片。它的逻辑<br>是：先从转换后的缓存中取；没有的话再从原始的（没有转换过的）缓存中拿数据；再没有的话就从网<br>络加载图片数据，获取到数据之后，再依次缓存到磁盘和弱引用。</p></li><li><p>Glide生命周期</p><p>在Glide加载图片时内部会创建一个无UI的Fragment，也就是RequestManagerFragment</p><p>（获取过程）</p><p>它在RequestManagerRetriever类的getRequestManagerFragment()被调用，这里通过findFragmentByTag去获取Fragment，如果为null就从pendingRequestManagerFragments这个Map集合去获取，如果还为null就直接new一个Fragment并保存到pendingRequestManagerFragments以及添加到Activity中（因为无UI，直接add进去也没事，事物动态添加），这样这个Fragment就和当前Activity生命周期关联起来了</p><p>（具体内部对于生命周期处理）</p><p>里面主要有ActivityFragmentLifecycle类，这个类调用了LifecycleListener的相关方法，LifecycleListener是一个接口，这个接口的作用是监听生命周期的作用，具体实现在RequestManager类。</p></li><li><p>项目中使用Glide框架出现内存溢出，应该是什么原因？</p><p>Glide在with中传入的是具有生命周期的作用域（非Application作用域），尽量避免使用Application作用域，因为Application作用域不会对页面绑定生命周期机制，就会回收不及时释放操作等</p><p>Glide作用域，一种作用域是Application，它的生命周期是全局的，不绑定空白Fragment就绑定Activity；第二种作用域是非Application，它的生命周期。。。（就是前面的部分）(这里就是对应子线程和主线程调用的区别了)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小白个人面试算法准备</title>
      <link href="/2024/02/28/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%87%86%E5%A4%87/"/>
      <url>/2024/02/28/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="面试算法准备-Java"><a href="#面试算法准备-Java" class="headerlink" title="面试算法准备(Java)"></a>面试算法准备(Java)</h1><h2 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h2><p><strong>经典的十大排序算法可以大致分为两类：</strong></p><ol><li>比较类排序：</li></ol><ul><li>冒泡排序 &#x3D;》快速排序（冒泡排序优化）</li><li>插入排序&#x3D;》希尔排序（插入排序优化）</li><li>选择排序&#x3D;》堆排序（选择排序优化）</li><li>归并排序（二路、多路）</li></ul><ol start="2"><li>非比较类排序：</li></ol><ul><li><p>计数排序 &#x3D; 》桶排序</p></li><li><p>基数排序</p></li></ul><p><img src="https://img-blog.csdnimg.cn/2266c2b20af044fa805ec535908c39e2.png"></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2343</span>, <span class="number">234</span>, <span class="number">765</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        bubbleSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    从第一个元素开始一个一个的比较相邻的元素，如果第一个比第二个大即a[1]&gt;a[2]，就彼此交换。</span></span><br><span class="line"><span class="comment">    从第一对到最后一对，对每一对相邻元素做一样的操作。此时在最后的元素应该会是最大的数，我们也称呼一遍这样的操作为一趟冒泡排序。</span></span><br><span class="line"><span class="comment">    针对所有的元素重复以上的步骤，每一趟得到的最大值已放在最后，下一次操作则不需要将此最大值纳入计算。</span></span><br><span class="line"><span class="comment">    持续对每次对越来越少的元素，重复上面的步骤。</span></span><br><span class="line"><span class="comment">    直到所有的数字都比较完成符合a[i]&lt;a[i+1]，即完成冒泡排序。*/</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     * 空间复杂度:S(n) = O(1)</span></span><br><span class="line"><span class="comment">     * 时间复杂度:最坏O(n^2)，最好O(n)，平均O(n^2)</span></span><br><span class="line"><span class="comment">     * 稳定排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints 无序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] ints)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isChange</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//优化，如果某一轮发现没有能交换的说明当前升序，无需继续遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ints.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[j] &gt; ints[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">//交换，每轮循环把当前相较最大的放到最后</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">swap</span> <span class="operator">=</span> ints[j];</span><br><span class="line">                    ints[j] = ints[j + <span class="number">1</span>];</span><br><span class="line">                    ints[j + <span class="number">1</span>] = swap;<span class="comment">//基本数据类型直接复制，而不是引用</span></span><br><span class="line">                    isChange = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isChange) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2343</span>, <span class="number">234</span>, <span class="number">765</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        quickSort(ints, <span class="number">0</span>, ints.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*    在数组中选择一个基准点</span></span><br><span class="line"><span class="comment">    分别从数组的两端扫描数组，设两个指示标志</span></span><br><span class="line"><span class="comment">    从后半部分开始，如果发现有元素比该基准点的值小，就交换位置</span></span><br><span class="line"><span class="comment">    然后从前半部分开始扫描，发现有元素大于基准点的值，继续交换位置</span></span><br><span class="line"><span class="comment">    如此往复循环，然后把基准点的值放到high这个位置,排序完成</span></span><br><span class="line"><span class="comment">    以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序</span></span><br><span class="line"><span class="comment">     * 空间复杂度:S(n) = O(nlog2n)</span></span><br><span class="line"><span class="comment">     * 时间复杂度:最好O(nlogn) 最坏O(n^2) 平均O(nlogn)</span></span><br><span class="line"><span class="comment">     * 不稳定排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints  数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  开始的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 结束的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//递归退出条件</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="comment">//每次递归把第一个元素放到正确位置</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="comment">//易错，一定要start&lt;end，因为在循环里面出现等于的情况的时候就会发生越界的可能，并且如果以第一个数为基准就需要先比较后面的再比较前面的，反之</span></span><br><span class="line">            <span class="comment">//每轮把遍历到的位置左边都&lt;=第一个元素，右边都&gt;=第一个元素</span></span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; ints[end] &gt;= ints[left]) &#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; ints[start] &lt;= ints[left]) &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//前面while里面的start &lt; end保证了最后start要么&lt;end要么=end</span></span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[left];</span><br><span class="line">                ints[left] = ints[end];</span><br><span class="line">                ints[end] = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[start];</span><br><span class="line">                ints[start] = ints[end];</span><br><span class="line">                ints[end] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后start一定=end</span></span><br><span class="line">        quickSort(ints, left, start - <span class="number">1</span>);</span><br><span class="line">        quickSort(ints, start + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2343</span>, <span class="number">234</span>, <span class="number">765</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        insertionSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。</span></span><br><span class="line"><span class="comment">    第一趟比较前两个数，然后把第二个数按大小插入到有序表中；</span></span><br><span class="line"><span class="comment">    第二趟把第三个数据与前两个数从后向前扫描，把第三个数按大小插入到有序表中；</span></span><br><span class="line"><span class="comment">    依次进行下去，进行了(n-1)趟扫描以后就完成了整个排序过程。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入排序</span></span><br><span class="line"><span class="comment">     * 空间复杂度:S(n) = O(1)</span></span><br><span class="line"><span class="comment">     * 时间复杂度:最好情况O(n^2) 最坏情况O(n^2) 平均情况O(n^2)</span></span><br><span class="line"><span class="comment">     * 稳定排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] ints)</span> &#123;</span><br><span class="line">        <span class="comment">//每次把当前遍历到的数放到正确的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;<span class="comment">//最终value需要插入的正确的下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> ints[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//个人更喜欢的思路，但while更简洁</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[j] &gt; value) &#123;</span><br><span class="line">                    ints[j + <span class="number">1</span>] = ints[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ints[j + <span class="number">1</span>] = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//走到这里说明到最后一个都比需要归位的值大，如果有比他小的已经放到位置并且break</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    ints[j] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//往前比较直到发现比某个数小,否则就把比这个数大的数往后移动一位</span></span><br><span class="line">            <span class="comment">//按照后面希尔排序往前看，index&gt;0可以写成index-1&gt;=0</span></span><br><span class="line">            <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; ints[index - <span class="number">1</span>] &gt; value) &#123;</span><br><span class="line">                ints[index] = ints[index - <span class="number">1</span>];</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到比需要归位的数字小的数字，就把需要归位的数字插在其后面一位</span></span><br><span class="line">            ints[index] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2343</span>, <span class="number">234</span>, <span class="number">765</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        shellSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</span></span><br><span class="line"><span class="comment">    按增量序列个数 k，对序列进行 k 趟排序；</span></span><br><span class="line"><span class="comment">    每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。</span></span><br><span class="line"><span class="comment">    仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 希尔排序</span></span><br><span class="line"><span class="comment">     * 希尔排序是基于插入排序的，简单插入排序就是步长为1的希尔排序</span></span><br><span class="line"><span class="comment">     * 空间复杂度:S(n) = O(1)</span></span><br><span class="line"><span class="comment">     * 时间复杂度:最好情况:O(n) 最坏情况O(n^2) 平均情况O(n^2)</span></span><br><span class="line"><span class="comment">     * 不稳定排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] ints)</span> &#123;</span><br><span class="line">        <span class="comment">//步长，一般这样规定步长，决定进行多少次插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ints.length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//之后就是插入排序的模板</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; ints.length; j++) &#123;</span><br><span class="line">                <span class="comment">//这里是j++，易错，每轮每个跳步中符合跳步的组合都进行排序，故j++</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> j;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> ints[j];</span><br><span class="line">                <span class="comment">//index-i &gt;= 0也就是防超界，前面的一个值跟需要插入正确的位置比，距离当前遍历到的数的步长为i的数字的下标&gt;=0</span></span><br><span class="line">                <span class="keyword">while</span> (index - i &gt;= <span class="number">0</span> &amp;&amp; ints[index - i] &gt; value) &#123;</span><br><span class="line">                    ints[index] = ints[index - i];</span><br><span class="line">                    index -= i;</span><br><span class="line">                &#125;</span><br><span class="line">                ints[index] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2343</span>, <span class="number">234</span>, <span class="number">765</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        selectSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    首先设置两个记录i和j，i从数组第一个元素开始，j从(i+1)个元素开始。</span></span><br><span class="line"><span class="comment">    接着j遍历整个数组，选出整个数组最小的值，并让这个最小的值和i的位置交换。</span></span><br><span class="line"><span class="comment">    i选中下一个元素(i++)，重复进行每一趟选择排序。</span></span><br><span class="line"><span class="comment">    持续上述步骤，使得i到达(n-1)处，即完成排序 。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择排序</span></span><br><span class="line"><span class="comment">     * 空间复杂度:S(n) = O(1)</span></span><br><span class="line"><span class="comment">     * 时间复杂度:最好O(1) 最坏O(n^2) 平均O(n^2)</span></span><br><span class="line"><span class="comment">     * 不稳定排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] ints)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ints.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max_index</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">//每轮把最大的归位，从后往前遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[j] &gt; ints[max_index]) &#123;</span><br><span class="line">                    max_index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前的不是最大的</span></span><br><span class="line">            <span class="keyword">if</span> (max_index != i) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[i];</span><br><span class="line">                ints[i] = ints[max_index];</span><br><span class="line">                ints[max_index] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        for (int i = 0; i &lt; ints.length; i++) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            int min_index = i;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            //每轮把当前相对最小的归位</span></span><br><span class="line"><span class="comment">            for (int j = i + 1; j &lt; ints.length; j++) &#123;</span></span><br><span class="line"><span class="comment">                if (ints[j] &lt; ints[min_index]) &#123;</span></span><br><span class="line"><span class="comment">                    min_index = j;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            if (min_index != i) &#123;</span></span><br><span class="line"><span class="comment">                //需要把最小的归位</span></span><br><span class="line"><span class="comment">                int temp = ints[i];</span></span><br><span class="line"><span class="comment">                ints[i] = ints[min_index];</span></span><br><span class="line"><span class="comment">                ints[min_index] = temp;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2343</span>, <span class="number">234</span>, <span class="number">765</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        heapSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*堆是一种非线性的数据结构，其实就是利用完全二叉树的结构来维护的一维数组，利用这种结构可以快速访问到需要的值，堆可以分为大顶堆和小顶堆。</span></span><br><span class="line"><span class="comment">    大顶堆：每个结点的值都大于或等于其左右孩子结点的值</span></span><br><span class="line"><span class="comment">    小顶堆：每个结点的值都小于或等于其左右孩子结点的值*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*首先把待排序的元素按照大小在二叉树位置上排列，且要满足堆的特性，如果根节点存放的是最大的数，则叫做大根堆，反之就叫做小根堆了。</span></span><br><span class="line"><span class="comment">    根据这个特性就可以把根节点拿出来，然后再堆化下，即用父节点和他的孩子节点进行比较，取最大的孩子节点和其进行交换，再把根节点拿出来，一直循环到最后一个节点，就排序好了。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序</span></span><br><span class="line"><span class="comment">     * 空间复杂度:S(n) = O(1)</span></span><br><span class="line"><span class="comment">     * 时间复杂度:最好O(n) 最坏O(n^2) 平均O(nlogn)</span></span><br><span class="line"><span class="comment">     * 不稳定排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] ints)</span> &#123;</span><br><span class="line">        <span class="comment">//建堆，一开始就把堆建好，后面递归就行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ints.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapSortStart(ints, ints.length, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ints.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(ints, i, <span class="number">0</span>);<span class="comment">//第一次已经完成建堆，交换最后一个和第一个，相当于最大的交换到最后，第一次建堆最大的在0下标</span></span><br><span class="line">            heapSortStart(ints, i, <span class="number">0</span>);<span class="comment">//易错，注意长度发生了变化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序虽然是要维护堆，但是以象征来看确实是堆，但原本还是一个数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints   数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 需要维护的数组长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i      维护的目标节点位置，当前维护的父节点的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSortStart</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> length, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//要把最大的数值放到父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lson</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, rson = i * <span class="number">2</span> + <span class="number">2</span>;<span class="comment">//树对应一维数组的下标</span></span><br><span class="line">        <span class="keyword">if</span> (lson &lt; length &amp;&amp; ints[lson] &gt; ints[largest]) &#123;</span><br><span class="line">            largest = lson;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rson &lt; length &amp;&amp; ints[rson] &gt; ints[largest]) &#123;</span><br><span class="line">            largest = rson;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(ints, largest, i);<span class="comment">//把最大的交换到i位置并维护交换后的位置的堆</span></span><br><span class="line">            heapSortStart(ints, length, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints  数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  要交换位置的第一个数的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 要交换位置的第二个数的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[left];</span><br><span class="line">        ints[left] = ints[right];</span><br><span class="line">        ints[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2343</span>, <span class="number">234</span>, <span class="number">765</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        mergeSort(ints, <span class="number">0</span>, ints.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*    申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</span></span><br><span class="line"><span class="comment">    设定两个指针，最初位置分别为两个已经排序序列的起始位置</span></span><br><span class="line"><span class="comment">    比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</span></span><br><span class="line"><span class="comment">            重复步骤c直到某一指针超出序列尾</span></span><br><span class="line"><span class="comment">    将另一序列剩下的所有元素直接复制到合并序列尾*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序</span></span><br><span class="line"><span class="comment">     * 这里先进行划分，之后进行归并</span></span><br><span class="line"><span class="comment">     * 空间复杂度:S(n)=O(n)</span></span><br><span class="line"><span class="comment">     * 时间复杂度:最好O(nlogn) 最好O(nlogn) 平均O(nlogn)</span></span><br><span class="line"><span class="comment">     * 稳定排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints  需要排序的原本数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  开始排序的最左边的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 开始排序的最右边的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//进行划分</span></span><br><span class="line">        <span class="comment">//只有一个数字就没必要划分了</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//这样划分其实就是不断分成很多子集进行处理，最小的就是只剩两个数字进行比较</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            mergeSort(ints, left, mid);</span><br><span class="line">            mergeSort(ints, mid + <span class="number">1</span>, right);</span><br><span class="line">            <span class="comment">//进行归并，两个相对有序的数组进行合并</span></span><br><span class="line">            merge(ints, left, mid, right, <span class="keyword">new</span> <span class="title class_">int</span>[ints.length]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并过程，合并两个相对有序的数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints  需要排序的原本数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  开始排序的最左边的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid   排序段的中间坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 开始排序的最右边的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  临时数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left_start</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right_start</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//即将要放入temp数组的位置下标，也就是temp的长度</span></span><br><span class="line">        <span class="comment">//两边进行比较，较小的放入temp数组并进行移动，之后进行下一轮比较</span></span><br><span class="line">        <span class="keyword">while</span> (left_start &lt;= mid &amp;&amp; right_start &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ints[left_start] &lt;= ints[right_start]) &#123;</span><br><span class="line">                temp[index++] = ints[left_start++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index++] = ints[right_start++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左边还有没比较完的</span></span><br><span class="line">        <span class="keyword">while</span> (left_start &lt;= mid) &#123;</span><br><span class="line">            temp[index++] = ints[left_start++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右边还有没比较完的</span></span><br><span class="line">        <span class="keyword">while</span> (right_start &lt;= right) &#123;</span><br><span class="line">            temp[index++] = ints[right_start++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放回原本的数组，进行复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            ints[left++] = temp[i];<span class="comment">//易错，注意是从开始进行排序的位置进行原本数组的赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2343</span>, <span class="number">234</span>, <span class="number">765</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        countingSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    找出待排序的数组中最大和最小的元素</span></span><br><span class="line"><span class="comment">    统计数组中每个值为i的元素出现的次数，存入数组C的第i项</span></span><br><span class="line"><span class="comment">    对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</span></span><br><span class="line"><span class="comment">    反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数排序</span></span><br><span class="line"><span class="comment">     * 缺点很明显，就是不能处理小数</span></span><br><span class="line"><span class="comment">     * 空间复杂度S(n) = O(n+k)</span></span><br><span class="line"><span class="comment">     * 时间复杂度:最好O(n+k) 最坏O(n+k) 平均O(n+k)</span></span><br><span class="line"><span class="comment">     * 稳定排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] ints)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ints == <span class="literal">null</span> || ints.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> ints[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ints[i] &gt; max) &#123;</span><br><span class="line">                max = ints[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建一个长度为max+1的数组，最后一个的下标要为max</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">            temp[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照下标统计temp数组中元素的值，就知道原本数组中有多少个当前下标的值，直接填入即可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; temp[i]; j++) &#123;</span><br><span class="line">                    ints[t++] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2343</span>, <span class="number">234</span>, <span class="number">765</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        bucketSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 桶排序</span></span><br><span class="line"><span class="comment">     * 在计数排序的基础上来的，有个思路就行，里面还用了其他排序</span></span><br><span class="line"><span class="comment">     * 就是按照不同的范围分成多个桶，不同的数放到不同范围的桶内，桶内进行排序然后拼接起来即可</span></span><br><span class="line"><span class="comment">     * 空间复杂度:S(n) = O(n+k)</span></span><br><span class="line"><span class="comment">     * 时间复杂度:最好O(n+k) 最坏O(n^2) 平均O(n+k)</span></span><br><span class="line"><span class="comment">     * 稳定排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span>[] ints)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ints == <span class="literal">null</span> || ints.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> ints[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> ints[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//找出最大和最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ints[i] &gt; max) &#123;</span><br><span class="line">                max = ints[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ints[i] &lt; min) &#123;</span><br><span class="line">                min = ints[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分桶</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">buketNum</span> <span class="operator">=</span> (max - min) / ints.length + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//借助list去完成存储</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(buketNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buketNum; i++) &#123;</span><br><span class="line">            bucketList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//往桶中填充数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">            bucketList.get((i - min) / ints.length).add(i);<span class="comment">//相同商的也就是满足范围放到桶中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每个桶内数据自动进行排序，这里就需要使用其他排序函数，这里用api了，可以用快排、选择排序。。。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buketNum; i++) &#123;</span><br><span class="line">            Collections.sort(bucketList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计桶中数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buketNum; i++) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = bucketList.get(i);</span><br><span class="line">            <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">                ints[t++] = integer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2343</span>, <span class="number">234</span>, <span class="number">765</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        radixSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 假设存在一个序列&#123;50, 123, 543, 187, 49, 30, 0, 2, 11, 100&#125;</span></span><br><span class="line"><span class="comment">    任何一个阿拉伯数，它的各个位数上的基数都是以0~9来表示的。所以我们不妨把0~9视为10个桶。</span></span><br><span class="line"><span class="comment">    我们先根据序列的个位数的数字来进行分类，将其分到指定的桶中。</span></span><br><span class="line"><span class="comment">    分类后，我们在从各个桶中，将这些数按照从编号0到编号9的顺序依次将所有数取出来。</span></span><br><span class="line"><span class="comment">    得到的序列就是个位数上呈递增趋势的序列。</span></span><br><span class="line"><span class="comment">    按照上图个位数排序：&#123;50, 30, 0, 100, 11, 2, 123, 543, 187, 49&#125;。</span></span><br><span class="line"><span class="comment">    接下来对十位数、百位数也按照这种方法进行排序，最后就能得到排序完成的序列。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基数排序</span></span><br><span class="line"><span class="comment">     * 按照数位，个位到十位到百位。。。进行桶排序</span></span><br><span class="line"><span class="comment">     * 空间复杂度:S(n) = O(n+k)</span></span><br><span class="line"><span class="comment">     * 时间复杂度:最好O(n*k) 最坏O(n*k) 平均O(n*k)</span></span><br><span class="line"><span class="comment">     * 稳定排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] ints)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ints == <span class="literal">null</span> || ints.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] save = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][ints.length];<span class="comment">//保存具体的值的临时数组</span></span><br><span class="line">        <span class="type">int</span>[] bucket_num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];<span class="comment">//保存每个桶中现在的数字个数</span></span><br><span class="line">        <span class="comment">//寻找最大的数字，确定最大的数字的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> ints[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ints[i] &gt; max) &#123;</span><br><span class="line">                max = ints.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//控制进行数位桶排序的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (max + <span class="string">&quot;&quot;</span>).length(); i++) &#123;</span><br><span class="line">            <span class="comment">//控制进行排序遍历的顺序</span></span><br><span class="line">            <span class="comment">//把数放到桶中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ints.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[j] / (<span class="type">int</span>) Math.pow(<span class="number">10</span>, i) % <span class="number">10</span>;</span><br><span class="line">                save[temp][bucket_num[temp]++] = ints[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将数从桶中读出放回原数组</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucket_num.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucket_num[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucket_num[j]; k++) &#123;</span><br><span class="line">                        ints[t++] = save[j][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//还原bucket_num，把每个桶内保存的内容清空</span></span><br><span class="line">                bucket_num[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Leecode面试经典150题"><a href="#Leecode面试经典150题" class="headerlink" title="Leecode面试经典150题"></a>Leecode面试经典150题</h2><h3 id="数组-字符串"><a href="#数组-字符串" class="headerlink" title="数组 &#x2F; 字符串"></a>数组 &#x2F; 字符串</h3><h4 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h4><p><strong>一开始个人写法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[m + n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>, t1 = <span class="number">0</span>, t2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t1 &lt; m &amp;&amp; t2 &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[t1] &lt; nums2[t2]) &#123;</span><br><span class="line">                ints[t++] = nums1[t1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ints[t++] = nums2[t2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t1 &lt; m) &#123;</span><br><span class="line">            ints[t++] = nums1[t1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t2 &lt; n) &#123;</span><br><span class="line">            ints[t++] = nums2[t2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m + n; i++) &#123;</span><br><span class="line">            nums1[i] = ints[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>倒序双指针就可以做到不开辟空间，直接插入即可，不会出现重叠的情况，可以验证，可以优化如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> m + n - <span class="number">1</span>, t1 = m - <span class="number">1</span>, t2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t1 &gt;= <span class="number">0</span> &amp;&amp; t2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[t1] &gt; nums2[t2]) &#123;</span><br><span class="line">                nums1[t--] = nums1[t1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[t--] = nums2[t2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[t--] = nums1[t1--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[t--] = nums2[t2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val) &#123;</span><br><span class="line">                nums[t++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1</span>, last = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != last) &#123;</span><br><span class="line">                last = nums[i];</span><br><span class="line">                nums[t++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="80-删除有序数组中的重复项-II"><a href="#80-删除有序数组中的重复项-II" class="headerlink" title="80. 删除有序数组中的重复项 II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">80. 删除有序数组中的重复项 II</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1</span>, last = nums[<span class="number">0</span>], count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != last) &#123;</span><br><span class="line">                last = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                nums[t++] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    nums[t++] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[<span class="number">0</span>], t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != temp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--t == <span class="number">0</span>) &#123;</span><br><span class="line">                    temp = nums[i];</span><br><span class="line">                    t = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] isSolve = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSolve[i]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i], t = i;</span><br><span class="line">                <span class="keyword">while</span> (!isSolve[t]) &#123;</span><br><span class="line">                    isSolve[t] = <span class="literal">true</span>;</span><br><span class="line">                    t = (t + k) % nums.length;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> nums[t];</span><br><span class="line">                    nums[t] = temp;</span><br><span class="line">                    temp = temp1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0</span>, min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; prices[i - <span class="number">1</span>] &amp;&amp; prices[i] &lt; min) &#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                price = (prices[i] - min &gt; price) ? (prices[i] - min) : price;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其实prices[i] &lt; prices[i - 1]用不上，prices[i] &lt; prices[i - 1]不成立那么prices[i] &lt; min一定不成立，反之</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0</span>, min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; min) &#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                price = (prices[i] - min &gt; price) ? (prices[i] - min) : price;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0</span>, min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                price += (prices[i - <span class="number">1</span>] - min);</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == prices.length - <span class="number">1</span>) &#123;</span><br><span class="line">                price += (prices[i] - min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h4><p><strong>没想出贪心策略，具体解法如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCanGo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= maxCanGo) &#123;</span><br><span class="line">                maxCanGo = Math.max(maxCanGo, nums[i] + i);</span><br><span class="line">                <span class="keyword">if</span> (maxCanGo &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h4><p><strong>没想出贪心策略，具体解法如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxPosition</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            maxPosition = Math.max(maxPosition, i + nums[i]); </span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = maxPosition;</span><br><span class="line">                steps++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="274-H-指数"><a href="#274-H-指数" class="headerlink" title="274. H 指数"></a><a href="https://leetcode.cn/problems/h-index/">274. H 指数</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= citations.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; citations.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (citations[j] &gt;= i) &#123;</span><br><span class="line">                    temp++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= i) &#123;</span><br><span class="line">                max = Math.max(max, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分搜索</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = citations.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// int mid=(left+right+1)&gt;&gt;1; //加1防止陷入死循环，如[0]情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; citations.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (citations[i] &gt;= mid) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= mid) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="380-O-1-时间插入、删除和获取随机元素"><a href="#380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="380. O(1) 时间插入、删除和获取随机元素"></a><a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a></h4><h4 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h4><p><strong>超时，GG</strong></p><p><strong>左右乘积</strong></p><p><img src="C:\Users\GTR\AppData\Roaming\Typora\typora-user-images\image-20240311143153499.png" alt="image-20240311143153499"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] L = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span>[] R = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            L[i] = L[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        R[nums.length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            R[i] = R[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            result[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>空间复杂度 O(1)O(1)O(1) 的方法</strong></p><p>动态构建R，并把答案直接保存到L</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] L = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            L[i] = L[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            L[i] *= R;</span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h4><p><strong>爆时间，GG</strong></p><p><img src="C:\Users\GTR\AppData\Roaming\Typora\typora-user-images\image-20240311150327548.png" alt="image-20240311150327548"></p><p>直观理解，不用公式推导。可以这样想：假设从x加油站出发经过z加油站最远能到达y加油站，那么从z加油站直接出发，不可能到达y下一个加油站。因为从x出发到z加油站时肯定还有存储的油，这都到不了y的下一站，而直接从z出发刚开始是没有存储的油的，所以更不可能到达y的下一站。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sumOfGas</span> <span class="operator">=</span> <span class="number">0</span>, sumOfCost = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; n) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (i + cnt) % n;</span><br><span class="line">                sumOfGas += gas[j];</span><br><span class="line">                sumOfCost += cost[j];</span><br><span class="line">                <span class="keyword">if</span> (sumOfCost &gt; sumOfGas) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i + cnt + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其他人思路</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, index = <span class="number">0</span>, min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class="line">            sum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; min) &#123;</span><br><span class="line">                min = sum;</span><br><span class="line">                index = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &lt; <span class="number">0</span> ? -<span class="number">1</span> : index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h4><h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h4><h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode.cn/problems/roman-to-integer/">13. 罗马数字转整数</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> map.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; s.length() &amp;&amp; temp &lt; map.get(s.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">                sum -= temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a><a href="https://leetcode.cn/problems/integer-to-roman/">12. 整数转罗马数字</a></h4><h4 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a><a href="https://leetcode.cn/problems/length-of-last-word/">58. 最后一个单词的长度</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] s1 = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1[s1.length - <span class="number">1</span>].length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>会有空格情况，排除掉空格就好做了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (end &gt;= <span class="number">0</span> &amp;&amp; s.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            t++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode.cn/problems/longest-common-prefix/">14. 最长公共前缀</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i].length() &lt; min) &#123;</span><br><span class="line">                min = strs[i].length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; min; j++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> strs[<span class="number">0</span>].charAt(j);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[i].charAt(j) != temp) &#123;</span><br><span class="line">                    <span class="keyword">return</span> s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == strs.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    s += temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i].length() &lt; min) &#123;</span><br><span class="line">                min = strs[i].length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = min;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isCommon(strs, mid)) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCommon</span><span class="params">(String[] strs, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp.charAt(j) != strs[i].charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        String[] ss = s.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ss.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            builder.append(ss[i]);</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                builder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 除去开头和末尾的空白字符</span></span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="comment">// 正则匹配连续的空白字符作为分隔符分割</span></span><br><span class="line">        List&lt;String&gt; wordList = Arrays.asList(s.split(<span class="string">&quot;\\s+&quot;</span>));</span><br><span class="line">        Collections.reverse(wordList);</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>, wordList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim();                                    <span class="comment">// 删除首尾空格</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, i = j;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) i--;     <span class="comment">// 搜索首个空格</span></span><br><span class="line">            res.append(s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">&quot; &quot;</span>); <span class="comment">// 添加单词</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) i--;     <span class="comment">// 跳过单词间空格</span></span><br><span class="line">            j = i;                                       <span class="comment">// j 指向下个单词的尾字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();                    <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a><a href="https://leetcode.cn/problems/zigzag-conversion/">6. Z 字形变换</a></h4><p><strong>GG</strong></p><p><a href="https://leetcode.cn/problems/zigzag-conversion/solutions/21610/zzi-xing-bian-huan-by-jyd/?envType=study-plan-v2&envId=top-interview-150">6. Z 字形变换 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;StringBuilder&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;StringBuilder&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>, flag = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            list.get(t).append(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">0</span> || t == numRows - <span class="number">1</span>) &#123;</span><br><span class="line">                flag = -flag;</span><br><span class="line">            &#125;</span><br><span class="line">            t += flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (StringBuilder stringBuilder : list) &#123;</span><br><span class="line">            ss.append(stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ss.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.length() &gt; haystack.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= haystack.length() - needle.length(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> haystack.substring(i, i + needle.length());</span><br><span class="line">            <span class="keyword">if</span> (temp.equals(needle)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h5><p>KMP 算法是一个快速查找匹配串的算法，它的作用其实就是本题问题：如何快速在「原字符串」中找到「匹配字符串」。</p><p>KMP 算法的应用范围要比 Manacher 算法广，Manacher 算法只能应用于「回文串」问题，相对比较局限，而「子串匹配」问题还是十分常见的。</p><p>背过这样的算法的意义在于：相当于大脑里有了一个时间复杂度为O(n) 的 api 可以使用，这个 api 传入一个原串和匹配串，返回匹配串在原串的位置。</p><p><strong>模式匹配，寻找最长子串</strong></p><p>前缀：前缀是包含首字母但不包含尾字母的所有子串</p><p>后缀：后缀是包含尾字母但不包含首字母的所有子串</p><p><img src="C:\Users\GTR\AppData\Roaming\Typora\typora-user-images\image-20240311222644615.png" alt="image-20240311222644615"></p><p>注意i初始为1，也就是开头的两个进行比较，不然一个比较不了</p><p><img src="C:\Users\GTR\AppData\Roaming\Typora\typora-user-images\image-20240311223208514.png" alt="image-20240311223208514"></p><h2 id="牛客网面试必刷Top101"><a href="#牛客网面试必刷Top101" class="headerlink" title="牛客网面试必刷Top101"></a>牛客网面试必刷Top101</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li><a href="#BM1 反转链表"><strong>BM1 反转链表</strong></a></li><li><a href="#BM2 链表内指定区间反转"><strong>BM2 链表内指定区间反转</strong></a></li><li><a href="#BM4 合并两个排序的链表"><strong>BM4 合并两个排序的链表</strong></a></li><li><a href="#BM5 合并k个已排序的链表"><strong>BM5 合并k个已排序的链表</strong></a></li><li><a href="#BM6 判断链表中是否有环"><strong>BM6 判断链表中是否有环</strong></a></li><li><a href="#BM7 链表中环的入口结点"><strong>BM7 链表中环的入口结点</strong></a></li><li><a href="#BM8 链表中倒数最后k个结点"><strong>BM8 链表中倒数最后k个结点</strong></a></li><li><a href="#BM10 两个链表的第一个公共结点"><strong>BM10 两个链表的第一个公共结点</strong></a></li><li><a href="#BM11 链表相加(二)"><strong>BM11 链表相加(二)</strong></a></li><li><a href="#BM12 单链表的排序"><strong>BM12 单链表的排序</strong></a></li><li><a href="#BM13 判断一个链表是否为回文结构"><strong>BM13 判断一个链表是否为回文结构</strong></a></li><li><a href="#BM14 链表的奇偶重排"><strong>BM14 链表的奇偶重排</strong></a></li><li><a href="#BM15 删除有序链表中重复的元素-I"><strong>BM15 删除有序链表中重复的元素-I</strong></a></li><li><a href="#BM16 删除有序链表中重复的元素-II"><strong>BM16 删除有序链表中重复的元素-II</strong></a></li></ul><p><a id="BM1 反转链表"></a></p><p><strong>BM1 反转链表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">lastNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span></span><br><span class="line">                head.next;<span class="comment">//保存当前节点的下一个，这样在修改当前节点的next指针后还能将下一个复制给当前对象进行遍历</span></span><br><span class="line">            head.next =</span><br><span class="line">                lastNode;<span class="comment">//当前的next就是上轮的结果，每次都还需要保存上轮的访问的节点，并且一开始为空</span></span><br><span class="line">            lastNode = head;</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM2 链表内指定区间反转"></a></p><p><strong>BM2 链表内指定区间反转</strong></p><p><strong>懵逼，细看</strong></p><p>时间复杂度O(n)，空间复杂度O(1)，一次遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span> <span class="params">(ListNode head, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//加个表头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        start.next = head;</span><br><span class="line">        <span class="comment">//前序节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="comment">//当前节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//找到m</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            last = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从m反转到n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;<span class="comment">//先保存原本这个节点的next再更改</span></span><br><span class="line">            cur.next =</span><br><span class="line">                temp.next;<span class="comment">//不断更改cur的下一个，直到到达n，这样最后会接到一起</span></span><br><span class="line">            temp.next = last.next;<span class="comment">//原本节点的next为last</span></span><br><span class="line">            last.next =</span><br><span class="line">                temp;<span class="comment">//last是保存上一个，cur.next = temp.next那么last.next = temp</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM4 合并两个排序的链表"></a></p><p><strong>BM4 合并两个排序的链表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">Merge</span> <span class="params">(ListNode pHead1, ListNode pHead2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>,first = pHead1,second = pHead2,tmp = <span class="literal">null</span>,last = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(first!=<span class="literal">null</span>&amp;&amp;second!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first.val&lt;second.val)&#123;</span><br><span class="line">                tmp = first;</span><br><span class="line">                first = first.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp = second;</span><br><span class="line">                second = second.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(tmp.val);</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="literal">null</span>)&#123;</span><br><span class="line">                result = newNode;</span><br><span class="line">                last = result;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                last.next = newNode;</span><br><span class="line">                last = last.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(first!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(first.val);    </span><br><span class="line">            <span class="keyword">if</span>(result==<span class="literal">null</span>)&#123;</span><br><span class="line">                result = newNode;</span><br><span class="line">                last = result;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                last.next = newNode;</span><br><span class="line">                last = last.next;</span><br><span class="line">            &#125;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(second!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(second.val);    </span><br><span class="line">            <span class="keyword">if</span>(result==<span class="literal">null</span>)&#123;</span><br><span class="line">                result = newNode;</span><br><span class="line">                last = result;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                last.next = newNode;</span><br><span class="line">                last = last.next;</span><br><span class="line">            &#125;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list2==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2.val&gt;list1.val)&#123;</span><br><span class="line">            list1.next = Merge(list1.next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list2.next = Merge(list1,list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a id="BM5 合并k个已排序的链表"></a></p><p><strong>BM5 合并k个已排序的链表</strong></p><p>时间复杂度要为O(nlogn)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;a id=<span class="string">&quot;BM6 判断链表中是否有环&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">**BM6 判断链表中是否有环**</span><br><span class="line"></span><br><span class="line">快慢指针，如果有环会碰到一起</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM7 链表中环的入口结点"></a></p><p><strong>BM7 链表中环的入口结点</strong></p><p>空间复杂度 O(1)，时间复杂度 O(n)</p><p>据题干，不说别的，我们能发现这道题需要完成两个任务：</p><ul><li>判断链表是否有环。（这个前面有）</li><li>在有环的链表中找到环的入口。</li></ul><p>具体做法：（证明不看了，从链表头经过环入口到达相遇地方经过的距离等于整数倍环的大小，那我们从头开始遍历到相遇位置，和从相遇位置开始在环中遍历，会使用相同的步数，而双方最后都会经过入口到相遇位置这y个节点）</p><p>step 1：使用BM6.判断链表中是否有环中的方法判断链表是否有环，并找到相遇的节点。<br>step 2：慢指针继续在相遇节点，快指针回到链表头，两个指针同步逐个元素逐个元素开始遍历链表。<br>step 3：再次相遇的地方就是环的入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">        <span class="comment">//寻找是否有环</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> pHead, slow = pHead, slow_real = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                slow_real = slow;<span class="comment">//相交点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slow_real == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//没有环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找进入环东第一个节点</span></span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow_real) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow_real = slow_real.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow_real;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#BM8 链表中倒数最后k个结点"></a></p><p><strong>BM8 链表中倒数最后k个结点</strong></p><p>最简单的思路就是借助栈，但是空间复杂度为O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead ListNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;ListNode&gt;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list.size()&lt;k||k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(list.size()-k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有简单的思路就是先遍历一遍到最后，这样就知道链表的长度，这样就可以再遍历一次看遍历多少个节点就找到正确的节点了</p><p>进阶思路为空间复杂度为O(1)，快慢指针，学习这种思路</p><p>（双指针指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个指针（特殊情况甚至可以多个），两个指针或是同方向访问两个链表、或是同方向访问一个链表（快慢指针）、或是相反方向扫描（对撞指针），从而达到我们需要的目的。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead ListNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//快慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> pHead;</span><br><span class="line">        <span class="comment">//快指针先移动k步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明链表过短</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//之后保持着fast比slow快k步的方式移动</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM10 两个链表的第一个公共结点"></a></p><p><strong>BM10 两个链表的第一个公共结点</strong></p><p>要求空间复杂度为O(1)</p><p>使用两个指针N1,N2，一个从链表1的头节点开始遍历，我们记为N1，一个从链表2的头节点开始遍历，我们记为N2。</p><p>让N1和N2一起遍历，当N1先走完链表1的尽头（为null）的时候，则从链表2的头节点继续遍历，同样，如果N2先走完了链表2的尽头，则从链表1的头节点继续遍历，也就是说，N1和N2都会遍历链表1和链表2。</p><p>因为两个指针，同样的速度，走完同样长度（链表1+链表2），不管两条链表有无相同节点，都能够到达同时到达终点。</p><p>（N1最后肯定能到达链表2的终点，N2肯定能到达链表1的终点）。</p><p>所以，如何得到公共节点：</p><p>有公共节点的时候，N1和N2必会相遇，因为长度一样嘛，速度也一定，必会走到相同的地方的，所以当两者相等的时候，则会第一个公共的节点<br>无公共节点的时候，此时N1和N2则都会走到终点，那么他们此时都是null，所以也算是相等了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t1</span> <span class="operator">=</span> pHead1, t2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span> (t1 != t2) &#123;</span><br><span class="line">            t1 = (t1 == <span class="literal">null</span>) ? pHead2 : t1.next;</span><br><span class="line">            t2 = (t2 == <span class="literal">null</span>) ? pHead1 : t2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM11 链表相加(二)"></a></p><p><strong>BM11 链表相加(二)</strong></p><p>step 1：任意一个链表为空，返回另一个链表就行了，因为链表为空相当于0，0加任何数为0，包括另一个加数为0的情况。<br>step 2：相继反转两个待相加的链表，反转过程可以参考反转链表。<br>step 3：设置返回链表的链表头，设置进位carry&#x3D;0.<br>step 4：从头开始遍历两个链表，直到两个链表节点都为空且carry也不为1. 每次取出不为空的链表节点值，为空就设置为0，将两个数字与carry相加，然后查看是否进位，将进位后的结果（对10取模）加入新的链表节点，连接在返回链表后面，并继续往后遍历。<br>step 5：返回前将结果链表再反转回来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">        <span class="comment">//任何一个链表为空就返回另外一个</span></span><br><span class="line">        <span class="keyword">if</span>(head1==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head2==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//翻转完成</span></span><br><span class="line">        head1 = reverseList(head1);</span><br><span class="line">        head2 = reverseList(head2);</span><br><span class="line">        <span class="comment">//进行正常的计算，链表取巧就是加一个表头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//进位符号</span></span><br><span class="line">        <span class="comment">//只要某个链表还有或者进位还有</span></span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="literal">null</span> || head2 != <span class="literal">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> val1, val2;</span><br><span class="line">            <span class="keyword">if</span> (head1 == <span class="literal">null</span>) &#123;</span><br><span class="line">                val1 = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                val1 = head1.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                val2 = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                val2 = head2.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//插入新链表</span></span><br><span class="line">            head.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>((val1 + val2 + carry) % <span class="number">10</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">            carry = (val1 + val2 + carry) / <span class="number">10</span>; <span class="comment">//更新进位</span></span><br><span class="line">            <span class="comment">//head1和head2移动到下一个</span></span><br><span class="line">            <span class="keyword">if</span> (head1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseList(start.next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照常规的加法计算就需要先翻转链表，翻转链表前面有</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = last;</span><br><span class="line">            last = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM12 单链表的排序"></a></p><p><strong>BM12 单链表的排序</strong></p><p>简单的思路就是遍历单链表转换成数组进行排序，这里学基于链表的归并排序</p><p>step 1：首先判断链表为空或者只有一个元素，直接就是有序的。<br>step 2：准备三个指针，快指针right每次走两步，慢指针mid每次走一步，前序指针left每次跟在mid前一个位置。三个指针遍历链表，当快指针到达链表尾部的时候，慢指针mid刚好走了链表的一半，正好是中间位置。<br>step 3：从left位置将链表断开，刚好分成两个子问题开始递归。<br>step 4：将子问题得到的链表合并，参考合并两个有序链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortInList</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 分治，归并排序</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> head, mid = head.next, right = head.next.next;</span><br><span class="line">        <span class="comment">//右边指针到达末尾的时候,中间的指针指向该段链表的中间</span></span><br><span class="line">        <span class="keyword">while</span> (right != <span class="literal">null</span> &amp;&amp; right.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            left = left.next;</span><br><span class="line">            mid = mid.next;</span><br><span class="line">            right = right.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左指针指向左段的左右一个节点，从这里断开</span></span><br><span class="line">        left.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//分成两段，合并排序好的两段</span></span><br><span class="line">        <span class="keyword">return</span> merge(sortInList(head), sortInList(mid));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个有序链表的合并</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">        <span class="comment">//其中一个为空就返回另外一个</span></span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经典加一个表头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="comment">//两个链表都不为空</span></span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="literal">null</span> &amp;&amp; head2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head1.val &lt;= head2.val) &#123;</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = head2;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//哪个链表还有内容就直接接到后面</span></span><br><span class="line">        <span class="keyword">if</span> (head1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.next = head1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.next = head2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回值去掉表头</span></span><br><span class="line">        <span class="keyword">return</span>  start.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM13 判断一个链表是否为回文结构"></a></p><p><strong>BM13 判断一个链表是否为回文结构</strong></p><p>借助List实现很容易，就先遍历链表然后将链表的所有值都放到List中，然后双指针对碰即可，如果在碰撞之前某个值不一样就返回fasle即可</p><p>学习双指针找中点的方法，空间复杂度为O(1)，快慢指针</p><p>我们首先来看看中点的特征，一个链表的中点，距离链表开头是一半的长度，距离链表结尾也是一半的长度，那如果从链表首遍历到链表中点位置，另一个每次遍历两个节点的指针是不是就到了链表尾，那这时候我们的快慢双指针就登场了：</p><p>具体做法：</p><p>step 1：慢指针每次走一个节点，快指针每次走两个节点，快指针到达链表尾的时候，慢指针刚好到了链表中点。<br>step 2：从中点的位置，开始往后将后半段链表反转。<br>step 3：按照方法三的思路，左右双指针，左指针从链表头往后遍历，右指针从链表尾往反转后的前遍历，依次比较遇到的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPail</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//空链表为回文</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//快慢指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="comment">//快指针移动两步，慢指针移动一步</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到中点位置,从中点处，也就是慢指针处开始翻转后面的元素，快指针回到开头进行遍历，看是否是回文，翻转其实就是第一题</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> slow, last = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (start != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> start.next;</span><br><span class="line">            start.next = last;</span><br><span class="line">            last = start;</span><br><span class="line">            start = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = last;</span><br><span class="line">        <span class="comment">//翻转后slow指针继续遍历</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slow.val != fast.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM14 链表的奇偶重排"></a></p><p><strong>BM14 链表的奇偶重排</strong></p><p>空间复杂度O(1)，时间复杂度O(n)</p><p>step 1：判断空链表的情况，如果链表为空，不用重排。<br>step 2：使用双指针odd和even分别遍历奇数节点和偶数节点，并给偶数节点链表一个头。<br>step 3：上述过程，每次遍历两个节点，且even在后面，因此每轮循环用even检查后两个元素是否为NULL，如果不为再进入循环进行上述连接过程。<br>step 4：将偶数节点头接在奇数最后一个节点后，再返回头部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//为空就不需要奇偶重排</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">even</span> <span class="operator">=</span> head.next, odd = head; <span class="comment">//odd为奇数位，even为偶数位</span></span><br><span class="line">        <span class="comment">//even是后行的，那么判断even和even.next为不为空就可以了</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> even;</span><br><span class="line">        <span class="keyword">while</span> (even != <span class="literal">null</span> &amp;&amp; even.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            odd.next = even.next;<span class="comment">//odd连接even的后一个，即奇数位</span></span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = odd.next;<span class="comment">//even连接后一个奇数的后一位，即偶数位</span></span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//even整体接在odd后面</span></span><br><span class="line">        odd.next = start;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM15 删除有序链表中重复的元素-I"></a></p><p><strong>BM15 删除有序链表中重复的元素-I</strong></p><p>要求空间复杂度为O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> head, result = head;</span><br><span class="line">        <span class="comment">//从第二个开始</span></span><br><span class="line">        <span class="keyword">while</span> (head.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span> (last.val == head.val) &#123;</span><br><span class="line">                last.next = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last.next = head;</span><br><span class="line">                last = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM16 删除有序链表中重复的元素-II"></a></p><p><strong>BM16 删除有序链表中重复的元素-II</strong></p><p>进阶要求空间复杂度为O(1)</p><p>step 1：给链表前加上表头，方便可能的话删除第一个节点。<br>step 2：遍历链表，每次比较相邻两个节点，如果遇到了两个相邻节点相同，则新开内循环将这一段所有的相同都遍历过去。<br>step 3：在step 2中这一连串相同的节点前的节点直接连上后续第一个不相同值的节点。<br>step 4：返回时去掉添加的表头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> *   public ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新加表头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        node.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="comment">//每次比较两个节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                <span class="comment">//将所有相同的都去掉</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == temp) &#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.next;<span class="comment">//去掉表头返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li><a href="#BM17 二分查找-I"><strong>BM17 二分查找-I</strong></a></li><li><a href="#BM19 寻找峰值"><strong>BM19 寻找峰值</strong></a></li><li><a href="#BM20 数组中的逆序对"><strong>BM20 数组中的逆序对</strong></a></li><li><a href="#BM21 旋转数组的最小数字"><strong>BM21 旋转数组的最小数字</strong></a></li><li><a href="#BM22 比较版本号"><strong>BM22 比较版本号</strong></a></li></ul><p><a id="BM17 二分查找-I"></a></p><p><strong>BM17 二分查找-I</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span> <span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                result = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM19 寻找峰值"></a></p><p><strong>BM19 寻找峰值</strong></p><p>直接去寻找最大值，那么最大值一定就是峰值，这个简单，这里学习使用二分法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span> <span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) /</span><br><span class="line">                      <span class="number">2</span>; <span class="comment">//这种写法可以防止left+right大于int的取值范围的情况出现</span></span><br><span class="line">            <span class="comment">//说明右边是下坡路，不一定有峰值</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;<span class="comment">//最后返回left和right都可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM20 数组中的逆序对"></a></p><p><strong>BM20 数组中的逆序对</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">InversePairs</span> <span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先写一个归并排序，归并就是分治的思想，然后统计过程中前面比后面大的情况即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span>  mergeSort(nums, left, mid, temp) + mergeSort(nums, mid + <span class="number">1</span>, right,</span><br><span class="line">                      temp);<span class="comment">//划分</span></span><br><span class="line">        result %= <span class="number">1000000007</span>;<span class="comment">//防止越界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left, r = mid + <span class="number">1</span>, t = left;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &gt; nums[r]) &#123;</span><br><span class="line">                result += mid - l + <span class="number">1</span>; <span class="comment">//比后面的多少个都大就是mid-l</span></span><br><span class="line">                temp[t++] = nums[r++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = nums[l++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">            temp[t++] = nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= right) &#123;</span><br><span class="line">            temp[t++] = nums[r++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (t = left; t &lt;= right; t++) &#123;</span><br><span class="line">            nums[t] = temp[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM21 旋转数组的最小数字"></a></p><p><strong>BM21 旋转数组的最小数字</strong></p><p>最简单方法就是维护最小值以O(n)的时间复杂度去找最小值呗，看下面二分法，也有双指针思想</p><p>step 1：双指针指向旋转后数组的首尾，作为区间端点。<br>step 2：若是区间中点值大于区间右界值，则最小的数字一定在中点右边。<br>step 3：若是区间中点值等于区间右界值，则是不容易分辨最小数字在哪半个区间，比如[1,1,1,0,1]，应该逐个缩减右界。<br>step 4：若是区间中点值小于区间右界值，则最小的数字一定在中点左边。<br>step 5：通过调整区间最后即可锁定最小值所在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberInRotateArray</span> <span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>,right = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//小的数字偏向右边，mid跟right指向的值相等就把right--再比较</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;nums[right]) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;nums[right]) right = mid;</span><br><span class="line">            <span class="keyword">else</span> right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM22 比较版本号"></a></p><p><strong>BM22 比较版本号</strong></p><p>直接spilt转字符串数组，之后较短的数组不能取到内容就是为0，然后将当前需要判断的值转数字（这里易错的就是”0.226”,”0.38”比较那么0.38更大）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span> <span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">                <span class="comment">/*split() 方法根据匹配给定的正则表达式来拆分字符串。</span></span><br><span class="line"><span class="comment">注意： . 、 $、 | 和 * 等转义字符，必须得加 \\。</span></span><br><span class="line"><span class="comment">注意：多个分隔符，可以用 | 作为连字符。*/</span></span><br><span class="line">        <span class="comment">//按照.划分</span></span><br><span class="line">        String[] nums1 = version1.split(<span class="string">&quot;\\.&quot;</span>); </span><br><span class="line">        String[] nums2 = version2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length || i &lt; nums2.length; i++)&#123;</span><br><span class="line">            <span class="comment">//较短的版本号后续都取0</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i &lt; nums1.length ? nums1[i] : <span class="string">&quot;0&quot;</span>; </span><br><span class="line">            <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> i &lt; nums2.length ? nums2[i] : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//字符串转数字</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; str1.length(); j++) </span><br><span class="line">                num1 = num1 * <span class="number">10</span> + (str1.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; str2.length(); j++)</span><br><span class="line">                num2 = num2 * <span class="number">10</span> + (str2.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="comment">//比较数字大小</span></span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num1 &lt; num2)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//版本相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>学下面的方法，主要就是转换为数字的思想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比较版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version1 string字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version2 string字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span> <span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//直到某个字符串结束</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; version1.length() | j &lt; version2.length()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从第一个字符串取出当前要判断的</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; version1.length() &amp;&amp; version1.charAt(i) != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                num1 = num1 * <span class="number">10</span> + (version1.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;<span class="comment">//跳过点</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从第二个字符串取出当前要判断的</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; version2.length() &amp;&amp; version2.charAt(j) != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                num2 = num2 * <span class="number">10</span> + (version2.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;<span class="comment">//跳过点</span></span><br><span class="line">            <span class="comment">//比较</span></span><br><span class="line">            <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//字符串相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li><a href="#BM23 二叉树的前序遍历"><strong>BM23 二叉树的前序遍历</strong></a></li><li><a href="#BM24 二叉树的中序遍历"><strong>BM24 二叉树的中序遍历</strong></a></li><li><a href="#BM25 二叉树的后序遍历"><strong>BM25 二叉树的后序遍历</strong></a></li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li></ul><p><a id="BM23 二叉树的前序遍历"></a></p><p><strong>BM23 二叉树的前序遍历</strong></p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt;tmp = pre(root);</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[tmp.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii : tmp) &#123;</span><br><span class="line">            ints[i++] = ii;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; <span class="title function_">pre</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        pre(node.left);</span><br><span class="line">        pre(node.right);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt;stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);<span class="comment">//根节点入栈</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            list.add(temp.val);</span><br><span class="line">            <span class="comment">//先进后出，这里就需要先放右再放左，这样就可以先拿到左节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ints[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM24 二叉树的中序遍历"></a></p><p><a id="BM25 二叉树的后序遍历"></a></p><p><strong>BM25 二叉树的后序遍历</strong></p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> *   public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] postorderTraversal (TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt;tmp = last(root);</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[tmp.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii : tmp) &#123;</span><br><span class="line">            ints[i++] = ii;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; <span class="title function_">last</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        last(node.left);</span><br><span class="line">        last(node.right);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆-栈-队列"><a href="#堆-栈-队列" class="headerlink" title="堆&#x2F;栈&#x2F;队列"></a>堆&#x2F;栈&#x2F;队列</h3><ul><li><a href="#BM42 用两个栈实现队列"><strong>BM42 用两个栈实现队列</strong></a></li><li><a href="#BM43 包含min函数的栈"><strong>BM43 包含min函数的栈</strong></a></li><li><a href="#BM44 有效括号序列"><strong>BM44 有效括号序列</strong></a></li><li><a href="#BM46 最小的K个数"><strong>BM46 最小的K个数</strong></a></li></ul><p><a id="BM42 用两个栈实现队列"></a></p><p><strong>BM42 用两个栈实现队列</strong></p><p>插入直接插入stack1，需要读取的时候需要看stack2有没有内容，没有就需要将stack1的值放到stack2中，这样stack2的顶就是队列的头，也就是stack1保存新插入的值倒序，stack2保存正序的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stack1.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM43 包含min函数的栈"></a></p><p><strong>BM43 包含min函数的栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BM43 包含min函数的栈</span><br></pre></td></tr></table></figure><p><a id="BM44 有效括号序列"></a></p><p><strong>BM44 有效括号序列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (!((tmp == <span class="string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="string">&#x27;)&#x27;</span>) || (tmp == <span class="string">&#x27;[&#x27;</span> &amp;&amp; c == <span class="string">&#x27;]&#x27;</span>) || (tmp == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp;</span><br><span class="line">                        c == <span class="string">&#x27;&#125;&#x27;</span>))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM46 最小的K个数"></a></p><p><strong>BM46 最小的K个数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 哈希</span><br><span class="line"></span><br><span class="line">- &lt;<span class="type">a</span> <span class="variable">href</span> <span class="operator">=</span> <span class="string">&quot;#BM51 数组中出现次数超过一半的数字&quot;</span>&gt;**BM51 数组中出现次数超过一半的数字**&lt;/a&gt;</span><br><span class="line">- &lt;a href=<span class="string">&quot;BM52 数组中只出现一次的两个数字&quot;</span>&gt;**BM52 数组中只出现一次的两个数字**&lt;/a&gt;</span><br><span class="line">- &lt;a href= <span class="string">&quot;#BM53 缺失的第一个正整数&quot;</span>&gt;**BM53 缺失的第一个正整数**&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;a id=<span class="string">&quot;BM51 数组中出现次数超过一半的数字&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">**BM51 数组中出现次数超过一半的数字**</span><br><span class="line"></span><br><span class="line">其实不用哈希，摩尔投票即可</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numbers int整型一维数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">MoreThanHalfNum_Solution</span> <span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> numbers[<span class="number">0</span>], power = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] != result) &#123;</span><br><span class="line">                power--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                power++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (power == <span class="number">0</span>) &#123;</span><br><span class="line">                result = numbers[i];</span><br><span class="line">                power = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM52 数组中只出现一次的两个数字"></a></p><p><strong>BM52 数组中只出现一次的两个数字</strong></p><p>借助哈希表的方式很简单，哈希表中存在这个键就移除，不存在就往里面放，这样只出现一次的键最后一定会存在于哈希表中，出现两次的就会再加入后被移除掉了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] FindNumsAppearOnce (<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        HashMap&lt;Integer, Object&gt;map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Object&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(i)) &#123;</span><br><span class="line">                map.remove(i, <span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(i, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : map.keySet()) &#123;</span><br><span class="line">            result[t++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM53 缺失的第一个正整数"></a></p><p><strong>BM53 缺失的第一个正整数</strong></p><p>空间为O(n)的方法，借助哈希表往里面插值，按照正整数从小到大查看hashmap中是否存在在哈希表中，找到最小的不在哈希表中返回即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNumberDisappeared</span> <span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt;map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            map.put(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (map.containsKey(result)) &#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希表是一种根据关键码（key）直接访问值（value）的一种数据结构。而这种直接访问意味着只要知道key就能在O(1)时间内得到value，因此哈希表常用来统计频率、快速检验某个元素是否出现过等。</p><p>进阶（学这种），原地哈希，时间复杂度为O(n)，多次遍历数组，都是单层循环；空间复杂度为O(1)，原地哈希，以索引为指向，没有额外空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 递归/回溯</span><br><span class="line"></span><br><span class="line">### 动态规划</span><br><span class="line"></span><br><span class="line">### 字符串</span><br><span class="line"></span><br><span class="line">- &lt;a href=<span class="string">&quot;#BM83 字符串变形&quot;</span>&gt;**BM83 字符串变形**&lt;/a&gt;</span><br><span class="line">- &lt;a href=<span class="string">&quot;#BM84 最长公共前缀&quot;</span>&gt;**BM84 最长公共前缀**&lt;/a&gt;</span><br><span class="line">- &lt;a href=<span class="string">&quot;#BM85 验证IP地址&quot;</span>&gt;**BM85 验证IP地址**&lt;/a&gt;</span><br><span class="line">- &lt;a href=<span class="string">&quot;#BM86 大数加法&quot;</span>&gt;**BM86 大数加法**&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;a id=<span class="string">&quot;BM83 字符串变形&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">**BM83 字符串变形**</span><br><span class="line"></span><br><span class="line">用内置函数的reverse()翻转也可以</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">trans</span> <span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] result = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;<span class="comment">//j为当前检索的单词的前面</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(j) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s.substring(j + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; temp.length(); k++) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> temp.charAt(k);</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                    c = ((<span class="type">char</span>)(c - <span class="string">&#x27;A&#x27;</span> + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = ((<span class="type">char</span>)(c + <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                result[count++] = c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; result.length) &#123;</span><br><span class="line">                result[count++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM84 最长公共前缀"></a></p><p><strong>BM84 最长公共前缀</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs string字符串一维数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span> <span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> <span class="number">0</span>, target = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到最长的字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i].length() &gt; largest) &#123;</span><br><span class="line">                largest = strs[i].length();</span><br><span class="line">                target = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; largest; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> strs[target].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((strs[j].length() &gt; i &amp;&amp; strs[j].charAt(i) == c) || j == target) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> strs[target].substring(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[target].substring(<span class="number">0</span>, strs[target].length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM85 验证IP地址"></a></p><p><strong>BM85 验证IP地址</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;a id=<span class="string">&quot;BM86 大数加法&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">**BM86 大数加法**</span><br><span class="line"></span><br><span class="line">```java</span><br></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><ul><li><a href="#BM88 判断是否为回文字符串"><strong>BM88 判断是否为回文字符串</strong></a></li><li><a href="#BM89 合并区间"><strong>BM89 合并区间</strong></a></li><li><a href="#BM91 反转字符串"><strong>BM91 反转字符串</strong></a></li><li><a href="#BM92 最长无重复子数组"><strong>BM92 最长无重复子数组</strong></a></li><li><a href="#BM93 盛水最多的容器"><strong>BM93 盛水最多的容器</strong></a></li></ul><p><a id="BM88 判断是否为回文字符串"></a></p><p><strong>BM88 判断是否为回文字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 待判断的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span> <span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(left++) != str.charAt(right--)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM89 合并区间"></a></p><p><strong>BM89 合并区间</strong></p><p>跟主持人调度很像，排序+贪心，下面是个人想法</p><p>其实就是找交叉区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *   int start;</span></span><br><span class="line"><span class="comment"> *   int end;</span></span><br><span class="line"><span class="comment"> *   public Interval(int start, int end) &#123;</span></span><br><span class="line"><span class="comment"> *     this.start = start;</span></span><br><span class="line"><span class="comment"> *     this.end = end;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intervals Interval类ArrayList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Interval类ArrayList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Interval&gt; <span class="title function_">merge</span> <span class="params">(ArrayList&lt;Interval&gt; intervals)</span> &#123;</span><br><span class="line">        ArrayList&lt;Interval&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!intervals.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] start = <span class="keyword">new</span> <span class="title class_">int</span>[intervals.size()];</span><br><span class="line">            <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[intervals.size()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">                start[i] = intervals.get(i).start;</span><br><span class="line">                end[i] = intervals.get(i).end;</span><br><span class="line">            &#125;</span><br><span class="line">            Arrays.sort(start, <span class="number">0</span>, start.length);</span><br><span class="line">            Arrays.sort(end, <span class="number">0</span>, end.length);</span><br><span class="line">            <span class="type">int</span> <span class="variable">left_value</span> <span class="operator">=</span> start[<span class="number">0</span>], right_value = end[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = <span class="number">1</span>; left &lt; start.length; left++, right++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (start[left] &gt; right_value) &#123;</span><br><span class="line">                    result.add(<span class="keyword">new</span> <span class="title class_">Interval</span>(left_value, right_value));</span><br><span class="line">                    left_value = start[left];</span><br><span class="line">                    right_value = end[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (end[right] &gt; right_value) &#123;</span><br><span class="line">                        right_value = end[right];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">Interval</span>(left_value, right_value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM91 反转字符串"></a></p><p><strong>BM91 反转字符串</strong></p><p>直接复制一个数组然后逆序放到新数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 反转字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">solve</span> <span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] result = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            result[len - <span class="number">1</span> - i] = str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减少操作时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 反转字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">solve</span> <span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] result = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            result[i] = result[len-<span class="number">1</span>-i];</span><br><span class="line">            result[len-<span class="number">1</span>-i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM92 最长无重复子数组"></a></p><p><strong>BM92 最长无重复子数组</strong></p><p>我们使用两个指针，一个i一个j，最开始的时候i和j指向第一个元素，然后i往后移，把扫描过的元素都放到map中，如果i扫描过的元素没有重复的就一直往后移，顺便记录一下最大值max，如果i扫描过的元素有重复的，就改变j的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxLength</span> <span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//可以用hashMap，queue，set，反正思路都是一样的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt;set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; arr.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(arr[right])) &#123;</span><br><span class="line">                set.remove(arr[left++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(arr[right++]);</span><br><span class="line">                max = Math.max(max, set.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id= "BM93 盛水最多的容器"></a></p><p><strong>BM93 盛水最多的容器</strong></p><p>双指针指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个指针（特殊情况甚至可以多个），两个指针或是同方向访问两个链表、或是同方向访问一个链表（快慢指针）、或是相反方向扫描（对撞指针），从而达到我们需要的目的。</p><p>这里还有贪心思想，贪心策略是每次移动的指针是移动指针指向的高度较短的那个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height int整型一维数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span> <span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">//优先排除特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (height.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((right - left) * Math.min(height[right], height[left]) &gt; max) &#123;</span><br><span class="line">                max = (right - left) * Math.min(height[right], height[left]) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//贪心，移动较短的那个</span></span><br><span class="line">            <span class="keyword">if</span> (height[right] &gt; height[left]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul><li><a href="#BM96 主持人调度（二）"><strong>BM96 主持人调度（二）</strong></a></li></ul><p><a id="BM96 主持人调度（二）"></a></p><p><strong>BM96 主持人调度（二）</strong></p><p>贪心思想属于动态规划思想中的一种，其基本原理是找出整体当中给的每个局部子结构的最优解，并且最终将所有的这些局部最优解结合起来形成整体上的一个最优解。</p><p>我们利用贪心思想，什么时候需要的主持人最少？那肯定是所有的区间没有重叠，每个区间首和上一个的区间尾都没有相交的情况，我们就可以让同一位主持人不辞辛劳，一直主持了。但是题目肯定不是这种理想的情况，那我们需要<strong>对交叉部分，判断需要增加多少位主持人</strong>。</p><p>step 1: 利用辅助数组获取单独各个活动开始的时间和结束时间，然后分别开始时间和结束时间进行排序，方便后面判断是否相交。<br>step 2: 遍历n个活动，如果某个活动开始的时间大于之前活动结束的时候，当前主持人就够了，活动结束时间往后一个。<br>step 3: 若是出现之前活动结束时间晚于当前活动开始时间的，则需要增加主持人。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 计算成功举办活动需要多少名主持人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 有n个活动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startEnd int整型二维数组 startEnd[i][0]用于表示第i个活动的开始时间，startEnd[i][1]表示第i个活动的结束时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minmumNumberOfHost</span> <span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] startEnd)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">need_people</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] start = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">//分别得到活动起始时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            start[i] = startEnd[i][<span class="number">0</span>];</span><br><span class="line">            end[i] = startEnd[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单独排序</span></span><br><span class="line">        Arrays.sort(start, <span class="number">0</span>, start.length);</span><br><span class="line">        Arrays.sort(end, <span class="number">0</span>, end.length);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//新开始的节目大于上一轮结束的时间，主持人不变</span></span><br><span class="line">            <span class="keyword">if</span> (start[i] &gt;= end[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//增加主持人</span></span><br><span class="line">                need_people++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> need_people;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><ul><li><a href="#BM97旋转数组"><strong>BM97旋转数组</strong></a></li><li><a href="#BM99 顺时针旋转矩阵"><strong>BM99 顺时针旋转矩阵</strong></a></li><li><a href="#BM100 设计LRU缓存结构"><strong>BM100 设计LRU缓存结构</strong></a></li><li><a href="#BM101 设计LFU缓存结构"><strong>BM101 设计LFU缓存结构</strong></a></li></ul><p><a id = "BM97旋转数组"></a></p><p><strong>BM97旋转数组</strong></p><p>方法一：使用额外数组，然后遍历每个数字放到正确位置后返回数组</p><p>方法二：三次翻转（推荐使用）</p><p>循环右移相当于从第m个位置开始，左右两部分视作整体翻转。即abcdefg右移3位efgabcd可以看成AB翻转成BA（这里小写字母看成数组元素，大写字母看成整体）。既然是翻转我们就可以用到reverse函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 旋转数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 数组长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 右移距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a int整型一维数组 给定数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] solve (<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[] a) &#123;</span><br><span class="line">        <span class="comment">//取模，比n长有n是没有作用的移动</span></span><br><span class="line">        m = m % n;</span><br><span class="line">        <span class="comment">//第一次全部逆转</span></span><br><span class="line">        reverse(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//第二次逆转开头m个</span></span><br><span class="line">        reverse(a, <span class="number">0</span>, m - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//第三次逆转m后所有元素</span></span><br><span class="line">        reverse(a, m, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[start];</span><br><span class="line">            a[start] = a[end];</span><br><span class="line">            a[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM99 顺时针旋转矩阵"></a></p><p><strong>BM99 顺时针旋转矩阵</strong></p><p>方法一：直接复制一个二维数组填入返回即可，第i行换到第n-i列(关系是初始位置的横坐标+换后的纵坐标&#x3D;n)，换之前的纵坐标和换之后的横坐标相等</p><p>方法二：沿右下对角线翻转，再左右翻转；也可以沿左上对角线翻转，再上下翻转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mat int整型二维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型二维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] rotateMatrix (<span class="type">int</span>[][] mat, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            diagonalReverse(mat,n);</span><br><span class="line">            leftRightReverse(mat,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上下翻转，用不上，顺便写出来了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upDownReverse</span><span class="params">(<span class="type">int</span>[][]mat,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> mat[i][j];</span><br><span class="line">                mat[i][j] = mat[n-<span class="number">1</span>-i][j];</span><br><span class="line">                mat[n-<span class="number">1</span>-i][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左右翻转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRightReverse</span><span class="params">(<span class="type">int</span>[][]mat,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> mat[i][j];</span><br><span class="line">                mat[i][j] = mat[i][n-<span class="number">1</span>-j];</span><br><span class="line">                mat[i][n-<span class="number">1</span>-j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//沿右下对角线翻转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">diagonalReverse</span><span class="params">(<span class="type">int</span>[][]mat,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> mat[i][j];</span><br><span class="line">                mat[i][j] = mat[j][i];</span><br><span class="line">                mat[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="BM100 设计LRU缓存结构"></a></p><p><strong>BM100 设计LRU缓存结构</strong></p><p><a id="BM101 设计LFU缓存结构"></a></p><p><strong>BM101 设计LFU缓存结构</strong></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin学习笔记</title>
      <link href="/2024/02/24/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/02/24/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin学习笔记"><a href="#Kotlin学习笔记" class="headerlink" title="Kotlin学习笔记"></a>Kotlin学习笔记</h1><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p><strong>基本介绍</strong></p><p>Kotlin成为Android的第一语言</p><p>Kotlin语言编译后产生字节码，JVM产生指令对，操作系统进行命令式的执行</p><p>Kotlin集聚各个语言的精华于一身，走全栈语言之路</p><p><strong>val只读变量</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a:String = <span class="string">&quot;111&quot;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * val只读，不可以改变</span></span><br><span class="line"><span class="comment"> * 下面一行加上错误</span></span><br><span class="line"><span class="comment"> * a = &quot;222&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">println(a)</span><br></pre></td></tr></table></figure><p><strong>var可变变量</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * var可变变量，下面写法正确</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> a:String = <span class="string">&quot;111&quot;</span><span class="comment">//这里的:String可以省略，kotlin会自动进行类型的推断</span></span><br><span class="line">a = <span class="string">&quot;222&quot;</span></span><br><span class="line">println(a)<span class="comment">//println打印</span></span><br></pre></td></tr></table></figure><p>Java语言有两种数据类型，基本数据类型(int，double等等)和引用类型(String)</p><p>Kotlin语言只有一种数据类型，看起来都是引用类型，实际上，编译器会在Java字节码中修改为基本类型</p><p><strong>查看字节码</strong></p><p><strong>range表达式</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> number = <span class="number">80</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * number in 10..100表示number大于等于10并且小于等于100</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (number <span class="keyword">in</span> <span class="number">10.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;在10到100&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (number <span class="keyword">in</span> <span class="number">0.</span><span class="number">.9</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;在0到9&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;大于100&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还有!in表示不在。。。范围内</span></span><br></pre></td></tr></table></figure><p><strong>when表达式</strong></p><p>相当于Java中的switch</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java的if是语句</span></span><br><span class="line"><span class="comment"> * Kotlin的if是表达式，有返回值的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">val</span> week = <span class="number">7</span></span><br><span class="line"><span class="keyword">val</span> info = <span class="keyword">when</span> (week) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; <span class="string">&quot;今天是星期一&quot;</span></span><br><span class="line">    <span class="number">2</span> -&gt; <span class="string">&quot;今天是星期一&quot;</span></span><br><span class="line">    <span class="number">3</span> -&gt; <span class="string">&quot;今天是星期一&quot;</span></span><br><span class="line">    <span class="number">4</span> -&gt; <span class="string">&quot;今天是星期一&quot;</span></span><br><span class="line">    <span class="number">5</span> -&gt; <span class="string">&quot;今天是星期一&quot;</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *这里如果直接用括号括起来会执行里面的语句，单行可以不写括号，多行才需要，但有括号并且有正常的String赋值给info，</span></span><br><span class="line"><span class="comment">         *那么info为Any也就相当于Java中的Object（任何类型的父类）</span></span><br><span class="line"><span class="comment">         *Unit代替了Java中的void关键字，是一个类</span></span><br><span class="line"><span class="comment">         *println(&quot;今天是周末&quot;)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="string">&quot;今天是周末&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">println(info)</span><br></pre></td></tr></table></figure><p><strong>String模板</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> time = <span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> garden = <span class="string">&quot;中山公园&quot;</span></span><br><span class="line">println(<span class="string">&quot;今天天气晴朗，是星期<span class="variable">$time</span>，去<span class="subst">$&#123;garden&#125;</span>玩&quot;</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * $&#123;变量&#125;后面可以再跟相同内容，也就是不造成误解，相当于分隔开，$变量后面不可以直接跟具有误解的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> isLogin = <span class="literal">true</span></span><br><span class="line">println(<span class="string">&quot;用户登录结果为：<span class="subst">$&#123;if (isLogin) <span class="string">&quot;登录成功&quot;</span> else <span class="string">&quot;登录失败&quot;</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Kotlin的if是表达式，可以更加灵活</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>函数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 其中private为修饰符，不写则默认为public</span></span><br><span class="line"><span class="comment"> * fun为函数声明关键字</span></span><br><span class="line"><span class="comment"> * method为函数名</span></span><br><span class="line"><span class="comment"> * age: Int, name: String为函数参数</span></span><br><span class="line"><span class="comment"> * 括号后冒号后跟的Int为返回类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(age: <span class="type">Int</span>, name: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;年龄为<span class="variable">$age</span>,姓名为<span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面代码转换成为java如下</span></span><br><span class="line"><span class="comment"> * private static final int method(int age,String name)&#123;</span></span><br><span class="line"><span class="comment"> *     String var = &quot;年龄为&quot; + age + &quot;,姓名为&quot; + name;</span></span><br><span class="line"><span class="comment"> *     System.out.println(var);</span></span><br><span class="line"><span class="comment"> *     return 200;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>函数参数的默认参数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    action01(<span class="string">&quot;wangwu&quot;</span>,<span class="number">30</span>)</span><br><span class="line">    action02(<span class="string">&quot;wangwu&quot;</span>)</span><br><span class="line">    action03()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">action01</span><span class="params">(name:<span class="type">String</span>,age: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;名字为<span class="variable">$name</span>，年龄为<span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里可以固定一个默认值，age不传入就为77，当然也可以传值进来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">action02</span><span class="params">(name:<span class="type">String</span>,age: <span class="type">Int</span>=<span class="number">77</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;名字为<span class="variable">$name</span>，年龄为<span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">action03</span><span class="params">(name:<span class="type">String</span>=<span class="string">&quot;Wangwu&quot;</span>,age: <span class="type">Int</span>=<span class="number">77</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;名字为<span class="variable">$name</span>，年龄为<span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具名函数参数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    login(username = <span class="string">&quot;111&quot;</span>, password = <span class="string">&quot;222&quot;</span>, age = <span class="number">22</span>, phoneNumber = <span class="string">&quot;12345&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认返回类型为Unit，可以不加，相当于Java的void关键字（无参数返回），但Unit是Kotlin中的一个类</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(username:<span class="type">String</span>,password:<span class="type">String</span>,phoneNumber:<span class="type">String</span>,age:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Nothing类型特点</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    show(-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抛出异常，TODO()不是注释提示，会终止程序</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">(number: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (number) &#123;</span><br><span class="line">        -<span class="number">1</span> -&gt; TODO(<span class="string">&quot;没有这个分数&quot;</span>)</span><br><span class="line">        <span class="keyword">in</span> <span class="number">0.</span><span class="number">.59</span> -&gt; println(<span class="string">&quot;不及格&quot;</span>)</span><br><span class="line">        <span class="keyword">in</span> <span class="number">60.</span><span class="number">.70</span> -&gt; println(<span class="string">&quot;成绩还可以&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反引号中函数名的特点</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//第一种情况</span></span><br><span class="line">    测试环境测试(<span class="string">&quot;111&quot;</span>,<span class="string">&quot;222&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种情况</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有一个Java类中有两个方法为in和is，方法名在Java中不是关键字，但是在Kotlin中是关键字，按照下面调用会出问题</span></span><br><span class="line"><span class="comment">     *     Test.in()</span></span><br><span class="line"><span class="comment">     *     Test.is()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Test.`<span class="keyword">in</span>`()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种情况，很少发生，作用写在下面</span></span><br><span class="line">     `<span class="number">5553343</span>`()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> `测试环境测试`<span class="params">(username:<span class="type">String</span>,password:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;username:<span class="variable">$username</span>,password:<span class="variable">$password</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> `5553343`<span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//写了很复制的功能，核心功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公司加密私有的文档，对5553343函数进行了说明，说明函数的作用，外人就是反编译出代码，看到这个数字也不知道具体的含义</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p><strong>匿名函数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*    val len = &quot;Test&quot;.count()//获取字符串长度</span></span><br><span class="line"><span class="comment">        println(len)*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面这个括号的部分就是函数，匿名函数</span></span><br><span class="line">    <span class="keyword">val</span> len = <span class="string">&quot;Test&quot;</span>.count &#123;</span><br><span class="line">        it == <span class="string">&#x27;e&#x27;</span><span class="comment">//这里count拿到每个字符，并把它给it，这里字符为e才计算长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(len)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数类型和隐式返回</strong></p><p>匿名函数的声明和实现以及调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   //1.函数输入输出的声明</span><br><span class="line">   val test: () -&gt; String</span><br><span class="line">   </span><br><span class="line">   //2.对上面函数的实现</span><br><span class="line">   test = &#123;</span><br><span class="line">       //这里的括号内的内容相当于下面的return部分的内容</span><br><span class="line">       //注意匿名函数不要写return，最后一行就是返回值</span><br><span class="line">       val tt = &quot;66&quot;</span><br><span class="line">       &quot;test$tt&quot;</span><br><span class="line">       //这里隐式返回，并且自动推断返回类型是否正确，这里返回int类型就会报错</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //3.调用函数</span><br><span class="line">   println(test())</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">* 上面大致等价于下面</span><br><span class="line">* fun test():String&#123;</span><br><span class="line">*     return &quot;test&quot;</span><br><span class="line">* &#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><strong>函数参数</strong></p><p>匿名函数简洁写法，并且需要传入参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面内容是拆解的写法，这里把上面的第一步和第二步进行合并书写，并且进行传参</span></span><br><span class="line"><span class="keyword">val</span> test: (<span class="built_in">Int</span>, <span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; String = &#123;</span><br><span class="line">    <span class="comment">//按照正常的函数书写的方法，这里的三个Int后面应该跟变量名的，但是这里没有，就需要按照下面写法</span></span><br><span class="line">        num1, num2, num3 -&gt;</span><br><span class="line">    <span class="keyword">val</span> tt = <span class="string">&quot;传入参数内容如下：&quot;</span></span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;tt&#125;</span>num1:<span class="subst">$&#123;num1&#125;</span>,num2:<span class="subst">$&#123;num2&#125;</span>,num3:<span class="subst">$&#123;num3&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="string">&quot;<span class="subst">$&#123;tt&#125;</span>num1:<span class="subst">$&#123;num1&#125;</span>,num2:<span class="subst">$&#123;num2&#125;</span>,num3:<span class="subst">$&#123;num3&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">test.invoke(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="comment">//等价于下面那行代码</span></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><strong>it关键字的特点</strong></p><p>匿名函数中的it关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//匿名函数是只有一个入参，就有一个it</span><br><span class="line">val test2: (String) -&gt; String = &#123;</span><br><span class="line">    &quot;自带一个it，为传入的内容，为$it&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(test2(&quot;111&quot;))</span><br></pre></td></tr></table></figure><p><strong>匿名函数的类型推断</strong></p><p>如果不能推断出唯一的类型，那么就推断为Any</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的写法还需要手动指定返回值的类型，其实可以自动推断，需要按照下面的写法，传参的前面加冒号需要指定返回值类型</span></span><br><span class="line"><span class="comment">//这里写一个匿名函数，类型推断为String</span></span><br><span class="line"><span class="keyword">val</span> method1 = &#123; val1: <span class="built_in">Double</span>, val2: <span class="built_in">Float</span>, val3: String -&gt;</span><br><span class="line">    <span class="comment">//上面的val1，val2，val3相当于入参</span></span><br><span class="line">    <span class="comment">/*5555//自动推断为Int类型返回值*/</span></span><br><span class="line">    <span class="string">&quot;传入参数分别为:<span class="variable">$val1</span>,<span class="variable">$val2</span>,<span class="variable">$val3</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(method1(<span class="number">1.34</span>,<span class="number">123f</span>,<span class="string">&quot;1da&quot;</span>))</span><br></pre></td></tr></table></figure><p><strong>lambda</strong></p><p>匿名函数其实就是lambda表达式</p><p><strong>函数定义参数是函数的函数</strong></p><p>在Java中可以通过接口来实现，在kotlin可以更加简单地实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里模拟登录为例</span></span><br><span class="line">    <span class="comment">//最后一个参数可以写到外面去</span></span><br><span class="line">    loginAction(<span class="string">&quot;wuleizhenshang&quot;</span>, <span class="string">&quot;10086&quot;</span>) &#123; msg: String, code: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        println(<span class="string">&quot;登录情况如下:<span class="variable">$msg</span>,<span class="variable">$code</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面写法等价于下面这种写法</span></span><br><span class="line">    loginAction(<span class="string">&quot;wuleizhenshang&quot;</span>, <span class="string">&quot;10086&quot;</span>,&#123; msg: String, code: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        println(<span class="string">&quot;登录情况如下:<span class="variable">$msg</span>,<span class="variable">$code</span>&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//还可以等价为</span></span><br><span class="line">    loginAction(<span class="string">&quot;wuleizhenshang&quot;</span>, <span class="string">&quot;10086&quot;</span>, responseResult = &#123; msg: String, code: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        println(<span class="string">&quot;登录情况如下:<span class="variable">$msg</span>,<span class="variable">$code</span>&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟：数据库为SQLServer</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> USER_NAME_DB = <span class="string">&quot;wuleizhenshang&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> USER_PWD_DB = <span class="string">&quot;10086&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//登录API</span></span><br><span class="line"><span class="comment">//这里responseResult:(String,Int)-&gt;Unit相当于Java的回调接口，回调给用户登录成功与否的状态</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loginAction</span><span class="params">(username: <span class="type">String</span>, password: <span class="type">String</span>, responseResult: (<span class="type">String</span>, <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (username == <span class="literal">null</span> || password == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的==相当于java中的equals()</span></span><br><span class="line">        TODO(<span class="string">&quot;用户名或密码为空&quot;</span>)<span class="comment">//出现问题，终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//做更多的前端校验</span></span><br><span class="line">    <span class="keyword">if</span> (username.length &gt; <span class="number">3</span> &amp;&amp; password.length &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (webServiceLoginApi(username, password)) &#123;</span><br><span class="line">            <span class="comment">//登录成功，还可以做更多事情</span></span><br><span class="line">            responseResult(<span class="string">&quot;login success&quot;</span>, <span class="number">200</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//登录失败的逻辑处理</span></span><br><span class="line">            responseResult(<span class="string">&quot;login fail&quot;</span>, <span class="number">404</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TODO(<span class="string">&quot;用户名或密码不合格&quot;</span>)<span class="comment">//出现问题，终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//登录的API暴露,模拟服务器</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">webServiceLoginApi</span><span class="params">(username: <span class="type">String</span>, password: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">//kt的if是表达式，java的if是语句</span></span><br><span class="line">    <span class="keyword">return</span> username == USER_NAME_DB &amp;&amp; password == USER_PWD_DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>内联学习</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> s2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里模拟登录为例</span></span><br><span class="line">    <span class="comment">//最后一个参数可以写到外面去</span></span><br><span class="line">    loginAction(<span class="string">&quot;wuleizhenshang&quot;</span>, <span class="string">&quot;10086&quot;</span>) &#123; msg: String, code: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        println(<span class="string">&quot;登录情况如下:<span class="variable">$msg</span>,<span class="variable">$code</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面写法等价于下面这种写法</span></span><br><span class="line">    loginAction(<span class="string">&quot;wuleizhenshang&quot;</span>, <span class="string">&quot;10086&quot;</span>, &#123; msg: String, code: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        println(<span class="string">&quot;登录情况如下:<span class="variable">$msg</span>,<span class="variable">$code</span>&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还可以等价为</span></span><br><span class="line">    loginAction(<span class="string">&quot;wuleizhenshang&quot;</span>, <span class="string">&quot;10086&quot;</span>, responseResult = &#123; msg: String, code: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        println(<span class="string">&quot;登录情况如下:<span class="variable">$msg</span>,<span class="variable">$code</span>&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟：数据库为SQLServer</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> USER_NAME_DB = <span class="string">&quot;wuleizhenshang&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> USER_PWD_DB = <span class="string">&quot;10086&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//登录API</span></span><br><span class="line"><span class="comment">//这里responseResult:(String,Int)-&gt;Unit相当于Java的回调接口，回调给用户登录成功与否的状态</span></span><br><span class="line"><span class="comment">//此函数使用lambda作为参数，就需要声明为内联</span></span><br><span class="line"><span class="comment">//如果此函数没有使用内联，那么在调用端会生成多个对象来完成lambda调用，会造成性能损耗（内部java会这么做）</span></span><br><span class="line"><span class="comment">//这里的inline就是使用内联，相当于转换成C++的#define，会自动替换为直接调用，而不是不断创建对象进行调用，没有函数开辟损耗</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">loginAction</span><span class="params">(username: <span class="type">String</span>, password: <span class="type">String</span>, responseResult: (<span class="type">String</span>, <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (username == <span class="literal">null</span> || password == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//这里的==相当于java中的equals()</span></span><br><span class="line">        TODO(<span class="string">&quot;用户名或密码为空&quot;</span>)<span class="comment">//出现问题，终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//做更多的前端校验</span></span><br><span class="line">    <span class="keyword">if</span> (username.length &gt; <span class="number">3</span> &amp;&amp; password.length &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (webServiceLoginApi(username, password)) &#123;</span><br><span class="line">            <span class="comment">//登录成功，还可以做更多事情</span></span><br><span class="line">            responseResult(<span class="string">&quot;login success&quot;</span>, <span class="number">200</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//登录失败的逻辑处理</span></span><br><span class="line">            responseResult(<span class="string">&quot;login fail&quot;</span>, <span class="number">404</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TODO(<span class="string">&quot;用户名或密码不合格&quot;</span>)<span class="comment">//出现问题，终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//登录的API暴露,模拟服务器</span></span><br><span class="line"><span class="comment">//此函数没有使用lambda作为参数，就不需要声明为内联</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">webServiceLoginApi</span><span class="params">(username: <span class="type">String</span>, password: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">//kt的if是表达式，java的if是语句</span></span><br><span class="line">    <span class="keyword">return</span> username == USER_NAME_DB &amp;&amp; password == USER_PWD_DB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不使用内联转换成Java如下</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202402242147842.png" alt="image-20240224214102272"></p><p>使用内联转换成Java如下</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202402242058558.png"></p><p><strong>函数引用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> USER_NAME = <span class="string">&quot;wuleizhenshang&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> USER_PWD = <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数引用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//lambda属于函数类型的对象，需要把methodResponseResult普通函数变成函数类型的对象（函数引用）</span></span><br><span class="line">    login(<span class="string">&quot;wuleizhenshang&quot;</span>, <span class="string">&quot;123456&quot;</span>, ::methodResponseResult)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">methodResponseResult</span><span class="params">(msg: <span class="type">String</span>, code: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;最终登录结果为:<span class="variable">$code</span>,<span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里原本是一个lambda</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(name: <span class="type">String</span>, pwd: <span class="type">String</span>, responseResult: (<span class="type">String</span>, <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (USER_NAME == name &amp;&amp; USER_PWD == pwd) &#123;</span><br><span class="line">        <span class="comment">//登录成功</span></span><br><span class="line">        responseResult(<span class="string">&quot;登录成功&quot;</span>, <span class="number">200</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//登录失败</span></span><br><span class="line">        responseResult(<span class="string">&quot;登录失败&quot;</span>, <span class="number">404</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数类型作为返回类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main() &#123;</span><br><span class="line">    val show1 = show(&quot;tt&quot;)//这里返回一个匿名函数</span><br><span class="line">    println(show1(&quot;wuleizhenshang&quot;, 20))//然后调用show1的返回的函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里再返回一个匿名函数，需要定义好入参和出参，不能直接使用类型推断完成</span><br><span class="line">fun show(info: String): (String, Int) -&gt; String &#123;</span><br><span class="line">    println(&quot;我是show函数，info:$info&quot;)</span><br><span class="line"></span><br><span class="line">    //这里return一个函数类型，是一个匿名函数</span><br><span class="line">    //这里不能</span><br><span class="line">    return &#123; name: String, age: Int -&gt;</span><br><span class="line">        &quot;name:$name,age:$age&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匿名函数和具名函数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//匿名函数</span></span><br><span class="line">    showPersonInfo(<span class="string">&quot;wuleizhenshang&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具名函数</span></span><br><span class="line">    showPersonInfo(<span class="string">&quot;wuleizhenshang&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>, ::showResultImpl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的函数，需要把函数转成对象，::转成对象</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showResultImpl</span><span class="params">(result: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;显示结果:<span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">showPersonInfo</span><span class="params">(name: <span class="type">String</span>, age: <span class="type">Int</span>, sex: <span class="type">Char</span>, showResult: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = <span class="string">&quot;name<span class="variable">$name</span>,age:<span class="variable">$age</span>,sex:<span class="variable">$sex</span>&quot;</span></span><br><span class="line">    showResult(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java完成匿名和具名，其实就是内部类直接实现接口和让一个类去继承接口并实现方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p><strong>可空性特点</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//第一种情况，默认不可空类型，不能随意赋值为null</span></span><br><span class="line">    */</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下面这两行代码会报错</span></span><br><span class="line"><span class="comment"> *     var name:String = &quot;wuleizhenshang&quot;</span></span><br><span class="line"><span class="comment"> *     name = null</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //第二种情况，声明时指定为可空类型</span></span><br><span class="line"><span class="comment">    //下面代码就不会报错</span></span><br><span class="line"><span class="comment">    var name2: String?</span></span><br><span class="line"><span class="comment">    name2 = null</span></span><br><span class="line"><span class="comment">    println(name2)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>安全调用操作符</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    name = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//name.capitalize() name是可空类型，想要使用name，必须给出补救措施</span></span><br><span class="line">    name?.capitalize()<span class="comment">//如果name是null，那么?后面的内容就不会执行</span></span><br><span class="line">    println(name)</span><br><span class="line">    name = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带let的安全调用</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//name = &quot;&quot;</span></span><br><span class="line">    <span class="comment">//name = &quot;wueleizhenshang&quot;</span></span><br><span class="line">    <span class="keyword">val</span> r = name?.let &#123;</span><br><span class="line">        <span class="comment">//可以将name拿到括号内进行使用，默认有it参数，并且name为null那么后面不执行，如果能够执行，那么括号里面it不为null</span></span><br><span class="line">        <span class="keyword">if</span> (it.isBlank())&#123;</span><br><span class="line">            <span class="comment">//如果name为空值，也就是&quot;&quot;，没有内容，那么返回</span></span><br><span class="line">            <span class="string">&quot;Default&quot;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非空断言操作符</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    name = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//name.capitalize() name是可空类型，想要使用name，必须给出补救措施</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.这里已经学习了一种补救措施了，还有就是断言进行补救</span></span><br><span class="line">    name?.capitalize()<span class="comment">//如果name是null，那么?后面的内容就不会执行</span></span><br><span class="line">    println(name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">val</span> r = name!!.capitalize()<span class="comment">//两个感叹号的意思就是不管name是不是null都执行，就和Java一样，这里会出现空指针异常，不为null当然没什么问题</span></span><br><span class="line">    <span class="comment">//如果百分百能保证name不为null，那么就可以使用断言!!，否则有空指针异常的风险</span></span><br><span class="line">    println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用if判断null情况</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//编译器自动通过</span></span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (name!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> r = name.capitalize()</span><br><span class="line">        println(r)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        println(<span class="string">&quot;name为null&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>空合并操作符</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> info: String? = <span class="string">&quot;wuleizhenshang&quot;</span></span><br><span class="line">    info = <span class="literal">null</span></span><br><span class="line">    println(info ?: <span class="string">&quot;原来你是null&quot;</span>)</span><br><span class="line">    <span class="comment">//如果为null就执行?:后面的内容，不为null就正常操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用前面的let函数+空合并操作符完成下面的内容</span></span><br><span class="line">    println(info?.let &#123; <span class="string">&quot;&#123;<span class="variable">$it</span>&#125;&quot;</span> &#125; ?: <span class="string">&quot;原来你是null&quot;</span>)</span><br><span class="line">    <span class="comment">//不为null就执行let里面的内容，为null原本会直接输出null，后面使用?:让为null输出原来你是null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异常处理与自定义异常</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> info: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查异常</span></span><br><span class="line">        checkException(info)</span><br><span class="line"></span><br><span class="line">        println(info!!.length)<span class="comment">//这里肯定会出错的，断言执行但为null</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        println(<span class="string">&quot;有问题<span class="variable">$e</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查异常</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkException</span><span class="params">(info: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里info可能为null</span></span><br><span class="line">    info ?: <span class="keyword">throw</span> CustomException()<span class="comment">//为null抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomException</span> : <span class="type">IllegalArgumentException</span>(<span class="string">&quot;你的代码不严谨&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>先决条件函数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//checkNotNull(value)//自带，为null抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//requireNotNull(value)//自带，为null抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断布尔类型也可以，使用下面方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> bool :<span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">    require(bool)<span class="comment">//自带，为false抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>KT中的substring</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//截取函数，需要一个范围</span></span><br><span class="line">    <span class="keyword">val</span> index1 = INFO.indexOf(<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    println(INFO.substring(<span class="number">0</span>, index1))<span class="comment">//左闭右开</span></span><br><span class="line">    println(INFO.substring(<span class="number">0</span> until index1))<span class="comment">//跟上面等价，KT基本用这种方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>KT中的split</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//自动类型推断 list == List&lt;String&gt;</span></span><br><span class="line">    <span class="keyword">val</span> list = INFO.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C++结构</span></span><br><span class="line">    <span class="keyword">val</span> (v1, v2, v3, v4) = list<span class="comment">//这里能分成4个元素</span></span><br><span class="line">    println(<span class="string">&quot;v1:<span class="variable">$v1</span>,v2:<span class="variable">$v2</span>,v3:<span class="variable">$v3</span>,v4:<span class="variable">$v4</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>KT中的replace</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sourcePwd = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line">    println(<span class="string">&quot;原本密码是:<span class="variable">$sourcePwd</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> r1 = sourcePwd.replace(Regex(<span class="string">&quot;[AKMNO]&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">when</span> (it.value) &#123;</span><br><span class="line">            <span class="comment">//这里的每一个字符 A B C D</span></span><br><span class="line">            <span class="string">&quot;A&quot;</span> -&gt; <span class="string">&quot;9&quot;</span></span><br><span class="line">            <span class="string">&quot;K&quot;</span> -&gt; <span class="string">&quot;7&quot;</span></span><br><span class="line">            <span class="string">&quot;M&quot;</span> -&gt; <span class="string">&quot;5&quot;</span></span><br><span class="line">            <span class="string">&quot;N&quot;</span> -&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line">            <span class="string">&quot;O&quot;</span> -&gt; <span class="string">&quot;6&quot;</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; it.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;加密后的密码是:<span class="variable">$r1</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;比较操作</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//kotlin中的==比较的值就是数值是否相等，===比较的是两个对象地址是否相等</span></span><br><span class="line">    <span class="comment">//==相当于Java中的equals</span></span><br><span class="line">    <span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">999</span></span><br><span class="line">    <span class="keyword">val</span> b: <span class="built_in">Int</span>? = a</span><br><span class="line">    <span class="keyword">val</span> c: <span class="built_in">Int</span>? = a</span><br><span class="line">    println(b == c)    <span class="comment">//true</span></span><br><span class="line">    println(b === c)   <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串遍历操作</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> pwd = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line">    pwd.forEach &#123;</span><br><span class="line">        println(<span class="string">&quot;所有字符:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数字类型的安全转换函数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> number: <span class="built_in">Int</span> = <span class="string">&quot;666&quot;</span>.toInt()</span><br><span class="line">    println(number)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面的字符串是double类型，转换成Int类型会报错</span></span><br><span class="line"><span class="comment">     * val number2: Int = &quot;666.66&quot;.toInt()</span></span><br><span class="line"><span class="comment">     * println(number2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> number3: <span class="built_in">Int</span>? = <span class="string">&quot;666.66&quot;</span>.toIntOrNull()<span class="comment">//转换成功就返回，不成功返回null</span></span><br><span class="line">    println(number3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Double转Int</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="number">65.4353</span>.toInt())<span class="comment">//65 四舍五入</span></span><br><span class="line">    println(<span class="number">65.4353</span>.roundToInt())<span class="comment">//65 四舍五入</span></span><br><span class="line">    println(<span class="number">65.8353</span>.roundToInt())<span class="comment">//66 四舍五入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//roundToInt()函数保证double转Int，保持四舍五入效果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> r = <span class="string">&quot;%.3f&quot;</span>.format(<span class="number">64.5732</span>)<span class="comment">//返回字符串类型,但保留3位小数</span></span><br><span class="line">    println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>apply内置函数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> info = <span class="string">&quot;name is Wuleizhenshang&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通方式</span></span><br><span class="line">    println(<span class="string">&quot;info字符串的长度是:<span class="subst">$&#123;info.length&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;info最后一个字符是:<span class="subst">$&#123;info[info.length - <span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;info全部转换成小写:<span class="subst">$&#123;info.toLowerCase()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//apply内置函数的方式,apply始终返回info本身的String类型</span></span><br><span class="line">    <span class="keyword">val</span> infoNew: String = info.apply &#123;</span><br><span class="line">        println(<span class="string">&quot;info字符串的长度是:<span class="subst">$&#123;length&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;info最后一个字符是:<span class="subst">$&#123;this[length - <span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;info全部转换成小写:<span class="subst">$&#123;toLowerCase()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(infoNew)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正使用apply函数的写法规则如下：</span></span><br><span class="line">    <span class="comment">//info.apply特点：因为始终返回info本身，所以可以链式调用</span></span><br><span class="line">    info.apply &#123;</span><br><span class="line">        println(<span class="string">&quot;info长度为：<span class="variable">$length</span>&quot;</span>)</span><br><span class="line">    &#125;.apply &#123;</span><br><span class="line">        println(<span class="string">&quot;最后一个字符为<span class="subst">$&#123;this[length - <span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;.apply &#123;</span><br><span class="line">        println(<span class="string">&quot;全部转成小写是<span class="subst">$&#123;toLowerCase()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通写法</span></span><br><span class="line">    <span class="keyword">val</span> file = File(<span class="string">&quot;D:\\a.txt&quot;</span>)</span><br><span class="line">    file.setExecutable(<span class="literal">true</span>)</span><br><span class="line">    file.setReadable(<span class="literal">true</span>)</span><br><span class="line">    println(file.readLines())</span><br><span class="line"></span><br><span class="line">    <span class="comment">//apply写法</span></span><br><span class="line">    file.apply &#123;</span><br><span class="line">        setExecutable(<span class="literal">true</span>)</span><br><span class="line">    &#125;.apply &#123;</span><br><span class="line">        setReadable(<span class="literal">true</span>)</span><br><span class="line">    &#125;.apply &#123;</span><br><span class="line">        println(file.readLines())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发常用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git（B站学习笔记）</title>
      <link href="/2024/02/24/Git%EF%BC%88B%E7%AB%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%89/"/>
      <url>/2024/02/24/Git%EF%BC%88B%E7%AB%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Git（B站学习笔记）"><a href="#Git（B站学习笔记）" class="headerlink" title="Git（B站学习笔记）"></a>Git（B站学习笔记）</h1><h2 id="版本控制系统简介"><a href="#版本控制系统简介" class="headerlink" title="版本控制系统简介"></a>版本控制系统简介</h2><p>版本控制系统是一种记录文件或代码变化的软件工具，用于管理多个版本的文件和代码。它可以追踪文件或代码的修改历史，保存每个版本的快照，使得用户可以轻松地回滚到之前的版本，也可以比较和合并不同版本之间的差异，同时还可以协作开发，多人同时修改同一个文件，版本控制系统可以确保每个人的修改都被记录下来，避免冲突和丢失数据。</p><p>版本控制系统分为<a href = "#vcs1">集中式版本控制系统</a>和<a href = "#vcs2">分布式版本控制系统</a></p><ul><li><p><strong>集中式版本控制系统</strong> <a name ="vcs1"></a> </p><p>集中式版本控制系统是把代码的管理和同步放在同一个服务器端来进行，如CVS、SVN(Subversion)，其中SVN的设计目标是取代CVS，现在互联网上很多版本控制服务从CVS迁移到了SVN</p><p><em>优点：</em></p><ul><li>权限系统完善</li><li>提交修改操作简便</li></ul><p><em>缺点：</em></p><ul><li>打分支需要联网到服务端</li><li>依赖服务器的稳定性</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4129120-fc356cb4b97e5aa2.png"></p></li><li><p><strong>分布式版本控制系统DVCS(Distributed Version Control System)</strong>  <a name ="vcs2"></a> </p><p>分布式版本控制系统相当于把集中式版本控制系统的服务端和客户端都交给参与开发的客户端来保管，只要需要不同开发者合并代码时，才需要一个中转站来完成。如Git</p><p><em>优点：</em></p><ul><li>打分支不需要联网，客户端本地保存着所有历史记录</li><li>不依赖服务器的稳定性，风险分散</li></ul><p><em>缺点：</em></p><ul><li>同步多人的修改稍繁</li><li>本地代码管理需要十分谨慎</li><li>缺少权限管理系统</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/4129120-0333b83bb376b3bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp"></p></li></ul><h2 id="Git安装和初始化配置"><a href="#Git安装和初始化配置" class="headerlink" title="Git安装和初始化配置"></a>Git安装和初始化配置</h2><p><a href="https://git-scm.com/">Git官网 (git-scm.com)</a></p><p>进入官网进行安装，安装完成git会自动安装git bash，鼠标右键可以看到出现git bash here或者终端terminal打开都可以，安装完成后可以通过<code>git -v</code>来查看版本信息，git命令都是以git开头</p><h3 id="Git使用方式"><a href="#Git使用方式" class="headerlink" title="Git使用方式"></a>Git使用方式</h3><p>Git的使用方式有三中，分别是命令行、图形化界面GUI、IDE插件或扩展</p><ul><li><p>命令行</p></li><li><p>图像化界面(GUI)</p><p>在Git的官网上的下载中也可以找到许多图形化界面，如 GitHub Desktop、SourceTree等等</p></li><li><p>IDE插件&#x2F;扩展</p><p>在常见的IDE工具中通过插件或扩展来使用Git</p></li></ul><h3 id="工作区域和文件状态"><a href="#工作区域和文件状态" class="headerlink" title="工作区域和文件状态"></a>工作区域和文件状态</h3><p><img src="https://pic.ikafan.com/imgp/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTcuY25ibG9ncy5jb20vYmxvZy8xNTM0NzUvMjAxNzEwLzE1MzQ3NS0yMDE3MTAxMzE4MzYwMjI5My04MjIyMzQwMzYucG5n.jpg"></p><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="设置上传者姓名"><a href="#设置上传者姓名" class="headerlink" title="设置上传者姓名"></a>设置上传者姓名</h4><p><code>git config --global user.name 名字</code></p><p>这里的名字如果是有空格的需要用引号引起来，没有则不用，如<code>git config --global user.name &quot;wuleizhenshang wl&quot;</code>和<code>git config --global user.name wuleizhenshang</code></p><p><strong>注</strong></p><p>这里的global参数可以设置为3个值</p><ul><li>省略(Local)：本地配置，只对本地仓库有效</li><li>–global：全局配置，所有仓库生效</li><li>–system：系统配置，对所有用户生效</li></ul><h4 id="设置上传者邮箱"><a href="#设置上传者邮箱" class="headerlink" title="设置上传者邮箱"></a>设置上传者邮箱</h4><p><code>git config --global user.email 邮箱</code></p><p> 邮箱无空格可以不加双引号</p><p><code>git config --global user.email wuleizhenshang@163.com</code></p><h4 id="设置保存用户名和密码"><a href="#设置保存用户名和密码" class="headerlink" title="设置保存用户名和密码"></a>设置保存用户名和密码</h4><p><code>git config --global credential.helper store</code></p><h4 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h4><p><code>git config --global --list</code></p><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>版本库Repository，简称Repo，又叫仓库，在计算机中可以理解为一个文件夹</p><p><strong>注</strong></p><p>可以通过mkdir创建文件夹</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310282211639.png" alt="image-20231028221102548"></p><h4 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h4><p><code>git init 仓库名</code></p><p>仓库名为空就是在当前文件夹下直接创建仓库，该文件夹为仓库，在一个想要作为仓库的文件夹下输入命令即可，后面加仓库名的话就是在该路径下新建一个名为仓库名的文件夹作为仓库</p><ul><li>windows系统</li></ul><p><code>dir</code>查看所有文件，无隐藏文件</p><p><code>dir /a</code>查看所有文件，包括隐藏文件，<code>.git</code>为隐藏文件</p><ul><li>Linux系统</li></ul><p><code>ls</code>查看所有文件，无隐藏文件</p><p><code>ls -a</code>查看所有文件，包括隐藏文件</p><h4 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h4><p><code>git clone 远程仓库地址</code></p><p>如<code>git clone https://gitee.com/wuleizhenshang/csdnBlogShareImg.git</code></p><h3 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h3><h4 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h4><p><code>git status</code></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310282234575.png" alt="image-20231028223435528"></p><p><code>git status -s</code></p><p>这个命令是查看仓库状态的简略模式，使用这个命令对于一个文件其文件名前面会有两个问号，第一个问号表示暂存区状态，第二个问号表示工作区状态 ，m就表示被修改过</p><p><strong>注</strong></p><p>如果新建了一个文件夹，但是文件夹里面没有文件，也就是为空，那么使用<code>git status</code>命令不会显示该文件夹，也就是不会纳入版本控制，如果该文件夹下有文件，那么就会纳入版本控制中</p><h4 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h4><p><code>git add 文件名</code></p><p><code>git add *.后缀名</code>  如<code>git add *.txt</code>，这里就表示全部以txt结尾的文件</p><p><code>git add .</code>  这个表示把当前文件夹所有文件添加到暂存区</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310282243398.png" alt="image-20231028224310350"></p><h4 id="查看暂存区内容"><a href="#查看暂存区内容" class="headerlink" title="查看暂存区内容"></a>查看暂存区内容</h4><p><code>git ls-files</code></p><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p><code>git commit -m &quot; 信息 &quot;</code> </p><p>如<code>git commit -m &quot;第一次提交&quot;</code></p><p><strong>这个命令后面需要跟一个<code>-m</code>参数，这个参数是用来指定提交的信息的，会被记录到仓库中，不使用此命令会进入到git的交互式界面</strong></p><p>提交命令只会提交暂存区中的文件而不会提交工作区的文件</p><p>同时保存和提交可以写为<code>git commit -a -m </code> 或 <code>git commit -am</code></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>对于分支的理解可以形象地理解成一棵大树的枝干，分支在协同开发中可以把不同成员开发的代码保存在不同的分支，之后将代码合并到主分支，也可以新开分支进行bug的处理然后合并到主分支，这样可以保持主分支一直可以使用，减少冲突和错误的影响。 项目经理在实际开发中会分配不同的功能给我们，我们就可以创建一个分支来进行开发</p><h4 id="查看、创建、删除分支"><a href="#查看、创建、删除分支" class="headerlink" title="查看、创建、删除分支"></a>查看、创建、删除分支</h4><p><code>git branch</code> 可以查看仓库分支，分支名前带<code>*</code>就是表示当前所处在的分支</p><p><code>git branch 分支名</code> 可以使用该命令创建一个分支，<strong>新建一个分支后不会直接切换到分支，需要输入命令进行切换</strong></p><p><code>git branch -d 分支名</code> 删除指定的分支，<strong>合并后的分支才能使用该命令删除分支，否则不可以</strong></p><p><code>git branch -D 分支名 </code> 强制删除没有合并的分支 </p><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><p><code>git checkout 分支名</code> 或 <code>git switch 分支名</code></p><p>切换分支，<strong>注意<code>git checkout</code>这个命令还有恢复状态的作用，比如删除了一个文件想要恢复也需要使用该命令，但是如果这个文件名和分支名相同的话使用该命令就会出现歧义，该命令默认切换分支而不是恢复文件，后面官方专门推出了<code>git switch</code>命令</strong></p><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p><code>git merge 将要合并分支名</code></p><p>该命令表示将一个分支合并到当前分支，当前分支就是合并后的目标分支</p><p><code>git merge --abort</code> 出现冲突时可以使用该命令中断合并</p><p><strong>注：分支合并完分支并不会消失，合并冲突需手动解决，如main分支和其他分支对同一个文件进行的修改发生冲突</strong></p><p><em>优点</em></p><p>不会破坏原分支的提交历史，方便回溯和查看</p><p><em>缺点</em></p><p>产生额外的提交节点，分支图比较复杂</p><p><code>git rebase 合并分支  </code></p><p>在Git中每个分支都有一个指针指向当前分支的最新提交的节点，使用该命令会找当前所处分支和合并的分支交叉的共同祖先节点，然后从祖先节点开始，把当前分支祖先节点开始到最新节点移动到合并分支的最新节点上面</p><p><em>优点</em></p><p>不会新增额外的提交记录，形成线性历史，比较直观和干净</p><p><em>缺点</em> </p><p>会改变提交历史，改变了当前分支branch out的节点。避免在共享分支时使用</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310302348527.png" alt="image-20231030234823309"></p><h4 id="查看分支图"><a href="#查看分支图" class="headerlink" title="查看分支图"></a>查看分支图</h4><p><code>git log --graph</code></p><h4 id="分支工作流模型"><a href="#分支工作流模型" class="headerlink" title="分支工作流模型"></a>分支工作流模型</h4><p>就是比较好的规范和流程，可以让工作更加高效，更加有条理</p><p>GitFlow模型</p><p>GitHub Flow</p><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><h4 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h4><p><code>git log</code></p><p><code>git log --online</code>  查看简洁的提交记录</p><h4 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h4><p>reset有三种模式，分别为hard、soft和mixed（默认）</p><ul><li><p>hard</p><p>回退某个版本并且丢弃工作区和暂存区的所有修改内容</p></li><li><p>soft</p><p>回退某个版本并且保留工作区和暂存区的所有修改内容</p></li><li><p>mixed</p><p>回退某个版本并且保留工作区的修改内容而丢弃暂存区的所有修改内容</p></li></ul><p><code>git reset --hard</code></p><p><code>git reset --soft</code></p><p><code>git reset --mixed</code></p><h4 id="命令回溯"><a href="#命令回溯" class="headerlink" title="命令回溯"></a>命令回溯</h4><p><code>git reflog</code></p><p>在执行此命令后可以找到<strong>误操作</strong>之前的版本号，然后<code>resaet</code>命令回退版本</p><p>如<code>git reset --hard b270efb</code></p><h3 id="查看差异"><a href="#查看差异" class="headerlink" title="查看差异"></a>查看差异</h3><p><code>git diff</code></p><p>后面不跟参数默认查看工作区和暂存区的差异内容</p><p> <code>git diff HEAD</code></p><p>查看工作区和版本库之间的差异</p><p><strong>注：HEAD表示当前分支中的最新提交节点</strong></p><p><code>git diff --cached</code></p><p>查看暂存区和版本库之间的差异</p><p><code>git diff 第一个版本ID 第二个版本ID</code></p><p>比较两个版本的差异，如<code>git diff 5af90b8 b270efb</code></p><p><code>git diff 另外一个版本ID HEAD</code></p><p>比较当前版本和另外一个版本的差异，如<code>git diff b270efb HEAD</code></p><p><code>git diff HEAD~数字 HEAD</code></p><p>查看当前版本和HEAD相差多少个版本的差异，如<code>git diff HEAD~ HEAD</code>以及<code>git diff HEAD~3 HEAD</code></p><p><strong>注：查看差异命令后面还可以接文件名，表示查看的两个区域的指定文件的差异</strong></p><p><code>git diff 第一个分支名 第二个分支名</code></p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>Linux可以使用<code>rm 文件名</code>命令删除文件，windows可以直接删除或者命令<code>del /s/q 文件名</code> 删除文件， <code>rmdir /s /q 文件夹路径</code>进行删除文件夹，s表示删除文件夹下所有子文件，q表示删除不进行提示</p><p>再删除掉文件后需要使用<code>git add</code>命令同步暂存区，虽然是进行删除操作，但是还是使用添加命令，如<code>git add first.txt</code>表示删除掉first.txt文件后同步暂存区，或者直接<code>git add .</code></p><p><code>git rm 文件名 </code></p><p>把文件从工作区、暂存区中删除，查看仓库状态可以发现是删除状态</p><p><code>git rm --cached 文件名</code></p><p>把文件从版本库中删除，不删除本地文件</p><p><strong>删除文件后记得提交，不然版本库还是存在</strong>   </p><h3 id="gitignore忽略文件"><a href="#gitignore忽略文件" class="headerlink" title="gitignore忽略文件"></a>gitignore忽略文件</h3><p>忽略文件可以使我们的仓库体积更小、更加干净</p><p><em>应该忽略的文件</em></p><ul><li><p>系统或系统自动生成的文件</p><p>编译生成的中间文件和结果文件</p></li><li><p>如Java生成的<code>.class</code>文件或C语言生成的<code>.o</code>文件</p></li><li><p>运行时生成的日志文件、缓存文件、临时文件</p></li><li><p>涉及身份、密码、口令、密钥等敏感信息文件</p></li></ul><p>在命令行中可以通过<code>echo 内容 &gt; 文件名</code>将内容覆盖输入到一个指定的文件，如果要用通配符忽略log文件，就可以输入<code>echo *.log &gt; .gitignore</code></p><p>在命令行中可以通过<code>echo 内容 &gt;&gt; 文件名</code>将内容追加输入到指定文件，如<code>echo temp/ &gt;&gt; .gitignore</code>忽略temp文件夹，添加文件夹的时候需要以<code>/</code>结尾</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310292152651.png"></p><p><strong>注</strong></p><p>.ignore忽略的文件（如使用了通配符忽略.log文件）生效的情况就是要在添加内容到.ignore文件之前未添加到版本库中</p><p>在github上的gitignore中提供了常用语言的忽略文件的模板，在新建仓库时可以直接使用，有需要再进行修改</p><h2 id="远程仓库托管代码"><a href="#远程仓库托管代码" class="headerlink" title="远程仓库托管代码"></a>远程仓库托管代码</h2><h3 id="HTTPS协议和SSH协议"><a href="#HTTPS协议和SSH协议" class="headerlink" title="HTTPS协议和SSH协议"></a>HTTPS协议和SSH协议</h3><p>HTTPS协议使用443端口，传输速度相较快点，通过用户名&#x2F;密码授权，可用性较高；SSH协议使用22端口，传输速度相较慢点，先生成SSH密钥对，再把公钥上传到服务器（推荐使用SSH）</p><h4 id="配置SSH密钥"><a href="#配置SSH密钥" class="headerlink" title="配置SSH密钥"></a>配置SSH密钥</h4><ol><li><p>首先要进入用户根目录，windows一打开<code>cmd</code>窗口就是默认根目录</p></li><li><p>然后通过 <code>cd .ssh</code> 命令进入<code>.ssh</code>目录</p></li><li><p><code>ssh-keygen -t rsa -b 4096</code> 生成SSH密钥，其中<code>-t</code>指定协议，这里指定为<code>rsa</code>协议，<code>-b</code>指定生成大小，这里大小为4096</p></li><li><p>之后输入密钥文件名和输入密码并确定密码，之后生成一个私钥文件（就是以前面密钥文件名生成的文件，不要给别人）和公钥文件（<code>·pub</code>文件）</p></li><li><p>打开并复制公钥文件的内容，之后在远程仓库如github中个人设置中的SSH中新建SSH keys把公钥内容输入其中新建</p></li><li><p>如果前面是指定了一个密钥文件名，那么就还需要进行下面的配置，在<code>.ssh</code>下新建config文件（无后缀名），输入下面的内容，表示访问github.com就使用<code>.ssh</code>下的first密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/first</span><br></pre></td></tr></table></figure></li></ol><p>​<strong>注</strong></p><p>​使用生成SSH密钥的命令后会要求输入密钥对文件名称，第一次使用生成SSH密钥的命令可以直接回车，第一次会自动在<code>.ssh</code>目录下生成<code>id_rsa</code>密钥文件，第二次使用就不要直接回车，不然会直接默认生成覆盖原本同名字的密钥文件，并且该操作不可逆</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310292317481.png" alt="image-20231029231722381"></p><h3 id="关联本地仓库和远程仓库"><a href="#关联本地仓库和远程仓库" class="headerlink" title="关联本地仓库和远程仓库"></a>关联本地仓库和远程仓库</h3><p>本地已拥有一个本地仓库，现在需要将本地仓库放到远程仓库，这里的操作在GitHub上新建完仓库后会有提示，可以按照提示走，不同就修改一下  </p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310302156657.png" alt="image-20231030215607528"></p><ol><li>首先创建一个远程仓库，如在GitHub上创建一个仓库</li><li>使用 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 命令，<code>shortname</code>指的是别名，GitHub的默认别名是origin，也可以自己指定别名，在GitHub的仓库创建完成后会有提示命令，复制即可，里面包含URL，这个URL其实就是仓库最上面的SSH地址，如<code>git remote add origin git@github.com:wuleizhenshang/gitTest.git</code></li><li>之后可以使用 <code>git remote -v</code> 查看当前仓库对应的远程仓库的别名和地址</li><li>之后可以输入 <code>git branch -M main</code> 将本地分支重命名为main，为了让本地分支和远程分支保持一致，本地仓库分支默认名称为main的话这里可以进行省略，但是Git默认初始为master，GitHub更改后默认为main</li><li>使用 <code>git push -u origin main</code> 把远程origin仓库的main分支和本地仓库的main分支关联起来，该命令非省略写法为 <code>git push -u origin main:main</code>，前一个表示本地仓库main，后一个表示远程仓库的main，其中<code>-u</code>是upstream缩写</li></ol><h3 id="拉取和推送"><a href="#拉取和推送" class="headerlink" title="拉取和推送"></a>拉取和推送</h3><p><strong>注：拉取推送需要先关联远程仓库</strong></p><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p>远程仓库有内容发生变化时，可以拉取到本地仓库</p><p><code>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; &lt;本地分支名&gt; </code>   </p><p>仓库名称和分支名称省略的话就是默认拉取别名为origin的仓库的main分支，命令作用就是把远程仓库的指定分支拉取到本地再进行合并，这里的远程分支名和本地分支名相同可省略</p><p><strong>注：执行完成pull操作后Git会自动执行一次合并操作，远程仓库中修改的内容和本地仓库修改内容没有冲突的话，合并操作就会成功，否则就会失败，这时候需要手动解决冲突</strong></p><p>git fetch</p><p>这个命令和pull命令区别就是此命令只会获取远程仓库的修改，并不会自动合并到本地仓库中，需要手动合并</p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p><code>git push &lt;remote&gt; &lt;branch&gt;</code> 推送  </p><h3 id="不同代码托管平台"><a href="#不同代码托管平台" class="headerlink" title="不同代码托管平台"></a>不同代码托管平台</h3><p>GitHub</p><p>Gitee也叫码云，国内平台</p><p>GitLab也叫极狐，特色：私有化部署，可以搭建自己的GitLab服务器，然后项目可以在这个服务器上进行管理</p><p><a href="https://blog.csdn.net/qq_43358469/article/details/124997420">【Android Studio】Git可视化基本操作_安卓studio 可视化编程_我又来搬代码了的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/Life_s/article/details/124492636">Android Studio 控制Git 代码回退提交版本_android studio git回滚-CSDN博客</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://blog.csdn.net/LG_15011399296/article/details/134181272">git代码行统计_git统计代码行数-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发常用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven的使用</title>
      <link href="/2023/11/18/maven/"/>
      <url>/2023/11/18/maven/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven的使用"><a href="#Maven的使用" class="headerlink" title="Maven的使用"></a>Maven的使用</h1><ul><li><strong>进入maven官网<a href="https://maven.apache.org/download.cgi">下载</a>maven</strong></li></ul><p>如Windows系统下载压缩包解压即可<a href="https://dlcdn.apache.org/maven/maven-3/3.9.5/binaries/apache-maven-3.9.5-bin.zip">apache-maven-3.9.5-bin.zip</a></p><ul><li><strong>配置环境变量</strong></li></ul><ol><li>新建一个系统变量，变量名为<code>MAVEN_HOME</code>，对应值为maven压缩包解压位置，如<code>D:\maven\apache-maven-3.9.5</code></li><li>在Path中编辑并新建填入<code>%MAVEN_HOME%\bin</code></li><li>在cmd命令窗口输入 <code>mvn -v</code> 有输出对应版本号即可</li></ol><ul><li><strong>修改maven压缩包解压路径下<code>conf</code>中的<code>setting.xml</code>配置</strong></li></ul><ol><li>自己定义本地仓库路径，maven在本地找不到依赖才会去中央仓库寻找</li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311022235187.png" alt="image-20231102223541110"></p><ol start="2"><li>配置国内镜像</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 中央仓库在中国的镜像 --&gt;</span><br><span class="line">       &lt;mirror&gt;</span><br><span class="line">           &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">           &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">           &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">           &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">       &lt;/mirror&gt;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311022240487.png" alt="image-20231102224004439"></p><ul><li><strong>idea中配置maven</strong></li></ul><p><strong>注意：下面的配置只会在本项目生效，若想要以后每个项目都使用相同的配置参考最后第3步配置</strong></p><ol><li>对maven有进行修改就进行相应的路径更改，如setting配置等</li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311022244903.png" alt="image-20231102224432847"></p><ol start="2"><li>配置Runner，输入属性<code>-DarchetypeCatalog=internal</code>，DarchetypeCatalog的值为internal的是让Maven配置项目时首先从本地仓库加载依赖从而加快配置速度</li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311022250474.png" alt="image-20231102225010415"></p><ol start="3"><li><p>设置成为默认配置</p><p>进入settings for new projects，<strong>不同版本进入方式不一样</strong></p></li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311022313947.png" alt="image-20231102231346897"></p><p>在Compiler中勾选图中选项，之后在maven配置和runner中做相同配置，<strong>勾选选项和maven配置一定要在settings for new projects的界面修改，这样才能成为idea的全局配置</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311022313787.png" alt="image-20231102231320723"></p>]]></content>
      
      
      <categories>
          
          <category> 开发常用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发常用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络与深度学习速成</title>
      <link href="/2023/11/18/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%80%9F%E6%88%90/"/>
      <url>/2023/11/18/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%80%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="神经网络与深度学习速成"><a href="#神经网络与深度学习速成" class="headerlink" title="神经网络与深度学习速成"></a>神经网络与深度学习速成</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><strong>神经网络和深度学习</strong>的整体架构包括了各种组件和层次，用于构建、训练和应用复杂的深度学习模型。下面是它们的<strong>一般架构</strong>：</p><ol><li><p><strong>输入层（Input Layer）</strong>：</p><p>输入层接受原始数据，例如图像、文本、声音等，将其转换为神经网络可处理的格式。对于图像数据，可以是像素值；对于文本数据，可以是单词嵌入向量；对于声音数据，可以是声谱图等。输入层通常具有与输入数据的特征数量相对应的节点。</p></li><li><p><strong>隐藏层（Hidden Layers）</strong>：</p><p>隐藏层是神经网络的核心组成部分，它包含多个神经元（或节点），并通过权重连接到前一层的神经元。深度学习中的深度来自于具有多个隐藏层。隐藏层的任务是学习数据的特征表示。常见的隐藏层类型包括全连接层、卷积层、循环层等。</p></li><li><p><strong>激活函数层（Activation Function Layer）</strong>：</p><p>激活函数层用于引入非线性性质到神经网络中，允许网络学习复杂的函数。常见的激活函数包括ReLU（Rectified Linear Unit）、Sigmoid、Tanh等。激活函数在每个神经元上应用，将线性加权和映射到非线性输出。</p></li><li><p><strong>输出层（Output Layer）</strong>：</p><p>输出层产生模型的最终预测结果，其结构和激活函数取决于具体任务。例如，对于二元分类任务，输出层可能包括一个Sigmoid激活函数；对于<strong>多类分类任务</strong>，可能使用Softmax激活函数；对于<strong>回归任务</strong>，输出层通常是一个线性层。</p></li><li><p><strong>损失函数（Loss Function）</strong>：</p><p>损失函数用于度量模型的性能，它比较模型的预测结果和实际标签，并计算损失值。训练过程的目标是最小化损失函数。不同的任务（分类、回归等）和网络架构可能需要不同的损失函数。</p></li><li><p><strong>优化器（Optimizer）</strong>：</p><p>优化器是用于调整模型参数以减小损失的算法。常见的优化算法包括梯度下降（Gradient Descent）、Adam、RMSprop等。优化器在反向传播过程中更新模型的权重和偏差。</p></li><li><p><strong>反向传播（Backpropagation）</strong>：</p><p>反向传播是训练神经网络的<strong>核心算法</strong>。它通过计算损失函数相对于模型参数的梯度，然后<strong>使用优化器来更新参数</strong>。这一过程通过前向传播（计算预测值）和反向传播（计算梯度和参数更新）迭代执行，直到损失最小化。</p></li><li><p><strong>批处理（Batching）</strong>：</p><p>在训练中，通常不是一次处理整个数据集，而是将数据分为小批次进行处理。批处理有助于加速训练过程和提高计算效率。</p></li><li><p><strong>正则化（Regularization）</strong>：</p><p>正则化技术，如L1和L2正则化，可用于减小模型的过拟合风险。正则化项通常添加到损失函数中。</p></li><li><p><strong>超参数调整（Hyperparameter Tuning）</strong>：</p><p>超参数是在训练前需要设置的参数，如学习率、批处理大小、隐藏层节点数等。调整超参数是优化模型性能的重要步骤。</p></li><li><p><strong>模型评估（Model Evaluation）</strong>：</p><p>训练完成后，需要使用验证集或测试集来评估模型的性能。评估指标根据具体任务选择，如准确度、损失值、F1分数等。</p></li><li><p><strong>应用（Deployment）</strong>：</p><p>训练完成的模型可以部署到生产环境中，用于实际应用，如图像识别、自然语言处理、推荐系统等。</p></li></ol><p>整体架构包括了从数据准备和模型构建到训练和部署的完整流程。不同的深度学习任务和模型类型会有不同的变体和组件，但上述架构提供了一般指导。</p><h3 id="简单简介"><a href="#简单简介" class="headerlink" title="简单简介"></a>简单简介</h3><ol><li>数据准备通常是项目的起点，但可以在整个项目周期中多次迭代。你可能需要清理、标记、分割和标准化数据。</li><li>构建模型的顺序通常是定义输入和输出层，选择合适的隐藏层和激活函数，然后初始化模型权重。</li><li>训练模型的过程是迭代的，它包括前向传播、计算损失、反向传播、参数更新等步骤。训练通常会持续多个周期，其中模型参数逐渐收敛。</li><li>模型评估可以在任何时候进行，但通常在训练后进行，用于评估模型的性能。</li><li>超参数调整可能需要多次进行，以找到最佳的超参数设置。</li><li>部署模型通常是在模型训练和评估之后的最后步骤，将模型应用于实际场景。</li></ol><p>学习+个人理解，不一定正确！</p><h3 id="前向传播（完成计算损失）"><a href="#前向传播（完成计算损失）" class="headerlink" title="前向传播（完成计算损失）"></a>前向传播（完成计算损失）</h3><h4 id="得分函数"><a href="#得分函数" class="headerlink" title="得分函数"></a>得分函数</h4><p>W为权重，x在下面例子中表示每个像素点的值，b表示微调，最终得到得分</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310152305186.png" alt="Snipaste_2023-10-14_23-13-30"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310152307665.png" alt="Snipaste_2023-10-14_23-34-13"></p><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>损失函数有许多，这个以一个举例</p><p>数据损失为通过得分函数得到得分值后计算损失，max中<strong>相减的两项</strong>中<strong>第一项</strong>为判断图片<strong>不是正确类得分</strong>（如图片是猫，那么这一项就是判断为狗的得分），<strong>第二项</strong>为判断图片<strong>是正确类得分</strong>；<strong>max运算完之后求和</strong>（如有三个分类，就有三个得分，那么两个错误类的得分分别与正确类得分做同样操作并相加），后面的<strong>正则化惩罚项</strong>是<strong>权重参数带来的损失</strong>，正则化惩罚项的第一个参数表示容忍程度<strong>（防止过拟合）</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310152251073.png" alt="Snipaste_2023-10-14_23-45-11"></p><h4 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h4><p>参数初始化设计到初始化神经网络的权重的偏重参数</p><p>通常使用随机策略来进行参数初始化</p><p>如<code>W = 0.01 * np.random.randn(D, H)</code></p><h4 id="正则化（通常添加在损失函数中）"><a href="#正则化（通常添加在损失函数中）" class="headerlink" title="正则化（通常添加在损失函数中）"></a>正则化（通常添加在损失函数中）</h4><p>正则化的<strong>本质作用</strong>是防止过拟合、提高模型泛化能力，有助于简化模型。</p><p>常见的正则化技术包括L1正则化、L2正则化、Dropout、权重共享等。</p><p>如上面解释一样，<strong>惩罚力度是正则化项的系数</strong>，决定了正则化在模型训练中的强度，它是一个超参数（超参数（Hyperparameters）是一种特殊的参数，它们不是由模型自动学习而是由人为设置的。超参数控制了模型的训练和学习过程，包括模型的结构、学习率、迭代次数、批处理大小等。），较大的惩罚力度会增加正则化的影响，使模型更倾向于简单的参数设置，从而减小过拟合的风险，但可能损害模型的性能。较小的惩罚力度允许模型更复杂，但可能增加过拟合的风险。</p><h4 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h4><p>过拟合是神经网络非常头疼的一个大问题</p><p>前面提到了可以通过正则化解决，就是加一个正则化惩罚项，这里还有一个解决方法，就是<strong>DROP-OUT</strong>（传说中的七伤拳）</p><p>Dropout是一种随机丢弃部分神经元的方法，可以降低神经网络的复杂性，减轻过拟合。（在训练过程中迭代的过程中随机丢弃一部分神经元）</p><p><strong>整体流程</strong></p><p>回归任务：得分值计算损失</p><p>分类任务：概率值计算损失</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310152318794.png" alt="Snipaste_2023-10-15_00-06-46"></p><h3 id="反向传播（更新W权重）"><a href="#反向传播（更新W权重）" class="headerlink" title="反向传播（更新W权重）"></a>反向传播（更新W权重）</h3><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310161914984.png" alt="Snipaste_2023-10-15_23-39-28"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310161914884.png" alt="Snipaste_2023-10-15_23-42-42"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310161915892.png" alt="Snipaste_2023-10-15_23-45-19"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310161916647.png" alt="Snipaste_2023-10-15_23-47-13"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310161916720.png" alt="Snipaste_2023-10-15_23-47-39"></p><h3 id="输入层、输出层、隐藏层"><a href="#输入层、输出层、隐藏层" class="headerlink" title="输入层、输出层、隐藏层"></a>输入层、输出层、隐藏层</h3><p><strong>神经网络架构</strong></p><p>这里的input layer其实就是数据，也就是得分函数中的x，这里可以理解为3个特征（粉色框中3个圆圈），经过一系列的变化，就是乘以W（权重）就可以得到hidden layer1（隐层1），这里变化得到hidden layer1是为了让计算机能更好的理解数据特征，但是这个为什么要这么变化是很难解释的，但是反向传播得出的结果就是这样能够更好地让计算机理解这个特征（计算得到），hidden layer2就是hidden layer1得到的特征再加工、再利用、再转换</p><p>全连接：其实就是图片中展示的一样每个点和下一层的每个点都有连接，当然这是展示出来的，真实就是经过某种变化罢了，不会存在实体的这个线（也就是权重参数矩阵就相当于连接）</p><p>非线性：就是在得到每层后都需要使用非线性函数去映射一个值，如max()就是一个非线性变换，然后再进行运算得到下一个隐层</p><p>神经元：神经元通常位于神经网络的隐藏层，在图中的表示其实就是每个层的圆圈，输入层的神经元数量等于数据的特征数量（正常情况神经元个数越多越好，但是需要考虑过拟合的问题， 神经元个数会导致过拟合问题，过拟合会使效果不好）</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310161920434.png" alt="Snipaste_2023-10-15_23-52-51"></p><h4 id="Softmax分类器"><a href="#Softmax分类器" class="headerlink" title="Softmax分类器"></a>Softmax分类器</h4><p>Softmax函数（归一化）常用于多类别分类问题，常用于多层感知器和深度神经网络的输出层，<strong>（上一层的输出层就是下一层的输入层）</strong></p><p>这里的归一化是根据得分计算得到一个概率值，这个概率值就是根据这个权重值计算得到<strong>当前图片是某个分类的概率</strong>，后面是根据计算值计算损失值（应该理解为另一种计算损失值的函数），这里log取对数，传入的值是0到1的（因为归一化得到的值是0到1），加负号把负值转为正值</p><p><strong>基本都是用对数去做损失函数（用工具包也需要手写损失函数）</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310152307593.png" alt="Snipaste_2023-10-14_23-48-34"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310152308647.png" alt="Snipaste_2023-10-14_23-58-36"></p><h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p>激活函数（Activation Function）是神经网络中的一个关键组成部分，它用来确定神经元的输出是否应该被激活（激活值为1）还是不激活（激活值为0），以及在一定程度上控制神经元的输出范围。激活函数的作用是引入非线性性，使神经网络能够学习和表示更加复杂的函数。<strong>（就是前面提到的每层得到的结果进行非线性变换）</strong></p><p>激活函数通常应用于神经元的输入（加权和）上，然后将结果传递给下一层神经元或输出层。不同的激活函数具有不同的数学形式和性质，以下是一些常见的激活函数：</p><ol><li><strong>阶跃函数（Step Function）</strong>：阶跃函数是一种最简单的激活函数，当输入大于某个阈值时激活，否则不激活。它将输入分为两个类别（0和1），通常用于二元分类问题。然而，阶跃函数在神经网络中的应用有限，因为它不是连续可导的。</li><li><strong>Sigmoid函数</strong>：Sigmoid函数是一种常用的激活函数，将实数输入映射到 (0, 1) 之间。它具有S形曲线，用于二元分类和输出概率估计。Sigmoid函数是连续可导的，但在深度神经网络中<strong>可能存在梯度消失问题</strong>。（可以从它的函数图像看出，当x的负值过小或者正值过大，图像基本就是平的了，计算为0那么在反向传播过程中继续往后传也为0，这个就是梯度消失）</li><li><strong>Tanh函数</strong>：Tanh函数是双曲正切函数，将实数输入映射到 (-1, 1) 之间。与Sigmoid函数相似，Tanh函数具有S形曲线，但它的输出范围在 -1 到 1 之间，使其可以处理正负权重的输入。</li><li><strong>ReLU函数（Rectified Linear Unit）</strong>：ReLU函数是一种非常常见的激活函数，将负数输入置为零，而对正数输入则保持不变。它具有线性关系<strong>（具有线性关系但是整体是非线性的）</strong>，使得训练神经网络更加高效，并减轻了梯度消失问题。<strong>（当前主体）</strong></li><li><strong>Leaky ReLU函数</strong>：Leaky ReLU是ReLU的变种，它在负数输入时不是完全置为零，而是乘以一个小正数。这有助于解决ReLU可能导致的神经元“死亡”问题。</li><li><strong>Softmax函数</strong>：Softmax函数常用于多类别分类问题，将多个输入映射到一个概率分布上，确保所有输出的和为1。它通常用于神经网络的输出层，用于将原始得分转化为类</li></ol><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310162151910.png" alt="Snipaste_2023-10-16_21-50-39"></p><p>标准化操作（图中例子）</p><p>第一步（中心化）：实际坐标值减去均值，得到原点为中心对称的效果</p><p>第二步（各个维度的放缩或者扩充）：实际坐标值除以标准差</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然语言处理（选修课）</title>
      <link href="/2023/11/18/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88%E9%80%89%E4%BF%AE%E8%AF%BE%EF%BC%89/"/>
      <url>/2023/11/18/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88%E9%80%89%E4%BF%AE%E8%AF%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="自然语言处理（选修课）"><a href="#自然语言处理（选修课）" class="headerlink" title="自然语言处理（选修课）"></a>自然语言处理（选修课）</h1><p><strong>写在前面</strong></p><p>个人代码水平并不高，文中代码也是按照老师讲解和个人思路纯手打和debug出来的，许多代码也只是解决了test测试中的问题，需要更高深的代码可以绕道了，文章仅用于记录个人学习经历。</p><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>NLP</strong>分析技术大致分为三个层面：<strong>词法分析、句法分析和语义分析</strong>。</p><ol><li><p>词法分析</p><p>词法分析是为了分析文本中的词汇和标记，主要任务包括分词、词性标注、命名实体识别。</p><ul><li>分词：将文本分割成单词、标记或短语的过程。<strong>分词是NLP任务的基础</strong>。</li><li>词性标注：词性标注是为文本中的每个单词或标记分配一个词性（名词、动词、形容词等）的过程。</li><li>命名实体识别：命名实体识别是用于识别文本中的命名实体，如人名、地名、组织名、日期等的任务。</li></ul></li><li><p>句法分析</p><p>句法分析涉及理解句子的结构和语法关系，以便对文本进行更深入的分析和理解。两种<strong>主流</strong>的句法分析方法为<strong>短语结构句法体系、依存结构句法体系（后者为当前热点）</strong>。</p><ul><li>依存句法分析：依存句法分析研究词汇之间的依存关系，即一个词与句子中其他词之间的语法依赖关系。这些依赖关系通常表示为有向图中的弧，其中一个词是另一个词的依赖项。依存句法分析有助于理解词与词之间的语法关系，如主谓关系、修饰关系等。</li><li>短语结构句法分析：短语结构句法分析关注句子中短语的结构，包括短语的组成和嵌套关系。这种分析将句子分解为短语和子句，以揭示句子的语法结构。</li></ul></li><li><p>语义分析</p><p>语义分析涉及理解文本的语义含义和关系，以便深入理解文本内容。</p><ul><li>词义消歧</li><li>命名实体链接</li><li>情感分析</li><li>语义角色标注</li><li>语义关系抽取</li><li>问答系统</li><li>自然语言生成</li><li>语义相似度计算</li><li>知识图谱</li></ul></li></ol><h3 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h3><h4 id="概率论基础"><a href="#概率论基础" class="headerlink" title="概率论基础"></a>概率论基础</h4><ul><li><strong>样本空间(Sample Space)</strong></li></ul><p>通常把随机试验的每一个可能结果称为一个<strong>样本点</strong>，样本点的全体称为<strong>样本空间</strong>用Ω表示</p><p>样本空间的子集称为<strong>事件</strong>,常用A,B,…表示</p><p><strong>概率函数</strong>是从随机试验中的事件到实数域[0,1]的映射函数，用以表示事件发生的可能性，通常：P(A) 表示事件A的概率函数，概率函数具有以下公理性质：</p><p>0≤ P(A) ≤1，对每个属于 Ω 的事件A</p><p>P(Ω)&#x3D;1</p><p>A∩B&#x3D; , P(A ∪ B)&#x3D;P(A)+P(B)</p><ul><li><strong>条件概率和独立性(Conditional Probability independence)</strong></li></ul><p>两个事件A,B同时发生的概率为事件A,B的交集的概率，P(A∩B)<br>两个事件A，B<strong>独立</strong>，则满足：P(A∩B)&#x3D;P(A)·P(B)</p><p>P(A|B) 在已知事件B发生的基础上，判断事件A发生的概率，这个叫<strong>条件概率</strong></p><p>𝑃(𝐴 ∩ 𝐵) &#x3D; 𝑃(𝐵)𝑃(𝐴|𝐵) &#x3D; 𝑃(𝐴)𝑃(𝐵|𝐴)</p><p>若事件A1，A2，…,An<strong>互相独立</strong>，则：<br> 𝑃(𝐴1 ∩ ⋯ ∩ 𝐴𝑛)&#x3D; 𝑃(𝐴1)𝑃(𝐴2) ⋯ 𝑃(𝐴𝑛)</p><ul><li><strong>贝叶斯定理 (Bayesan theorem)</strong></li></ul><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310102149798.png" alt="image-20231010214956681"></p><p>贝叶斯定理实际是概率转换公式，求P(A|B)可以转换为计算P(B|A)</p><h4 id="信息论"><a href="#信息论" class="headerlink" title="信息论"></a>信息论</h4><ul><li><strong>熵 (entropy)</strong></li></ul><p>熵表示单个随机变量的不确定性的均值，随机变量的熵越大，它的不确定性越大，即能正确估计其值得概率越小</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310102152759.png" alt="image-20231010215210715"></p><p><strong>熵的一些属性</strong></p><p>H(X)&gt;&#x3D;0</p><p>H(X)&#x3D;0, 当且仅当随机变量X的值是确定的，没有任何信息量可言</p><p>熵值随着信息长度的增加而增加</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310102157205.png" alt="image-20231010215707135"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310102157758.png" alt="image-20231010215727688"></p><ul><li><strong>联合熵和条件熵(Joint entropy and conditional entropy)</strong></li></ul><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310102159546.png" alt="image-20231010215949489"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310102200379.png" alt="image-20231010220043319"></p><p>熵是对不确定性的度量，我们知道的越多，熵越小。<br>如果一个语言模型可以捕获的语言结构信息越多，那么，熵越小。<br>因此，我们可以使用熵作为对语言模型的一个度量。</p><ul><li><strong>互信息 (mutual information)</strong></li></ul><h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><hr><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><p><strong>主要任务</strong></p><ol><li><strong>分词（Tokenization）</strong>：将文本拆分成单词或标记。单词是语言中的最小单位，可以是单个词汇或符号。分词是文本处理的基础，它将连续的字符序列切分成离散的单词。</li><li><strong>去除停用词（Stop Word Removal）</strong>：停用词是在文本中频繁出现但通常不携带重要信息的词汇，例如“的”、“是”、“在”等。在词法分析中，通常需要去除这些停用词，以减少文本的噪音和提高处理效率。</li><li><strong>词干提取（Stemming）</strong>：词干提取是将词语转换为它们的基本形式或词干的过程。例如，将单词的不同时态或复数形式转换为其原始形式，如将“running”转换为“run”。</li><li><strong>词性标注（Part-of-Speech Tagging）</strong>：词性标注是为文本中的每个词语分配其词性或语法角色的任务。词性标记可以帮助理解句子的结构和含义。</li><li><strong>命名实体识别（Named Entity Recognition）</strong>：命名实体识别是识别文本中特定类型的实体，如人名、地名、组织名等。它有助于从文本中提取重要信息。</li><li><strong>拼写检查（Spell Checking）</strong>：拼写检查是检测文本中的拼写错误并提供纠正建议的过程。它可以帮助提高文本质量和可读性。</li><li><strong>标点符号处理</strong>：在词法分析中，通常需要处理文本中的标点符号，包括分句和分段。</li><li><strong>数字处理</strong>：处理文本中的数字，包括数字的规范化、转换和提取。</li></ol><p><strong>（这里主要讲了中文相关的分词、词性标注）</strong></p><p><strong>语言的分类</strong></p><p>传统语言学根据词的形态结构通常把语言分为三大类：</p><ul><li><p>分析型语言（ 如：汉语、藏语）</p><ul><li>词没有专门表示语法意义的附加成分</li><li>形态变化少</li><li>语法关系靠词序、虚词来表示</li></ul></li><li><p>黏着性语言（如：日语、朝鲜语）</p><ul><li>词前中后有专门表示语法意义的附加成分，一个附加成分表达一种或多种语法意义</li><li>词根或词干跟附加成分的结合不紧密</li></ul></li><li><p>屈折型语言（如：英语、德语、法语、西班牙语等）</p><ul><li>用词的形态变化来表示语法关系，一个形态成分可以表示若干种不同的语法意义</li><li>词根或词干跟词的附加成分结合得很紧密，往往不容易截然分开</li></ul></li></ul><p><strong>不同的语种本身的结构差异很大，语种之间的语料资源也差异很大，所以，面对不同的语种在自然语言处理方法上会有所差异</strong></p><h4 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h4><h5 id="相关知识-1"><a href="#相关知识-1" class="headerlink" title="相关知识"></a>相关知识</h5><p><strong>分词的必要性</strong></p><p>分词可以初步帮助我们理解文本的语义信息</p><p><strong>分词算法评测标准</strong></p><p>通常的评测指标包括：</p><ul><li><p>正确率P</p><p>正确率通常指测试结果中正确切分的个数占系统所有输出结果的比例</p></li><li><p>召回率R</p><p>召回率是指测试结果中正确结果的个数占标准答案总数的比例</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202309201933240.png"></p></li><li><p>F度量值</p><p>正确率和召回率的综合值</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202309201935821.png"></p></li></ul><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311011833235.png" alt="image-20231101183347111"></p><p><strong>汉语自动分词主要方法</strong></p><ul><li>基于规则的中文分词方法</li><li>基于统计的中文分词方法</li><li>基于神经网络的中文分词方法</li></ul><h5 id="基于规则的中文分词方法"><a href="#基于规则的中文分词方法" class="headerlink" title="基于规则的中文分词方法"></a>基于规则的中文分词方法</h5><p><strong>基本思路和特点</strong></p><p>事先人工建立好分词词典；<br>基于字符串匹配进行分词，通常需要足够大的词表；<br>经典算法包括：正向最大匹配法、逆向最大匹配法、双向匹配法等。<br>优缺点：受限于分词词典的覆盖面。</p><p><strong>优缺点</strong></p><p>优点：容易实现</p><p>缺点：①参数MaxLen不好取：太大，匹配所花时间多，算法时间复杂度提高，太短，不能切分长度超过它的词，导致切分正确率降低。②很多歧义无法处理，例如：幼儿园&#x2F;地&#x2F;节目&#x2F;  以及  幼儿&#x2F;园地&#x2F;节目&#x2F;③最重要一点，准确率不高。</p><h6 id="正向最大匹配法"><a href="#正向最大匹配法" class="headerlink" title="正向最大匹配法"></a>正向最大匹配法</h6><p><strong>算法描述</strong></p><p>输入：分词词典、待切分语料<br>参数：最大词长maxLen，读取字符串长度len，读取字符串的指针起始位置pos<br>伪代码：<br>（1）初始化定义一个maxLen，令len&#x3D;maxLen，pos&#x3D;0；<br>（2）从待切分语料中从字符串下标0的位置开始正向向后取maxLen的字符串str(取不够则全部取完)；<br>（3）将str与词典进行匹配：<br>①若匹配成功，则认为字符串str为词，pos向后移动len长度，返回步骤（1）<br>②若匹配失败：如果len&gt;1，则len减1，从待切分语料中从pos往后取长度为len的字符串str，返回步骤（3）；否则，得到长度为1的单字词，pos向后移动1长度，返回步骤（1）</p><p><strong>代码（个人书写）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursionMatch</span>(<span class="params">maxLen, dic, target</span>):</span><br><span class="line">    result = []</span><br><span class="line">    recursionMatchSolve(maxLen, dic, target, <span class="number">0</span>, maxLen, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># maxLen表示每次取词最大长度，dic是字典，str是待切分语料，start是当前开始切分位置，tempLen是当前切分长度，result保存结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursionMatchSolve</span>(<span class="params">maxLen, dic, target, start, tempLen, result</span>):</span><br><span class="line">    <span class="comment"># 先添加终止条件</span></span><br><span class="line">    <span class="comment"># start&gt;=len(str)表示已经匹配完成了，返回</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= <span class="built_in">len</span>(target):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 先把当前需要比较字符获取出来</span></span><br><span class="line">    <span class="keyword">if</span> start + tempLen &lt;= <span class="built_in">len</span>(target):</span><br><span class="line">        temp = target[start:start + tempLen]  <span class="comment"># 切片左闭右开</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp = target[start:<span class="built_in">len</span>(target)]</span><br><span class="line">    <span class="comment"># len=1表示当前取的字段只剩一个字，不管是否匹配成功都加入结果</span></span><br><span class="line">    <span class="keyword">if</span> tempLen == <span class="number">1</span>:</span><br><span class="line">        result.append(temp)</span><br><span class="line">        recursionMatchSolve(maxLen, dic, target, start + <span class="number">1</span>, maxLen, result)</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 记得return</span></span><br><span class="line">    <span class="comment"># 比较词典中的词</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">        <span class="keyword">if</span> i == temp:</span><br><span class="line">            result.append(i)</span><br><span class="line">            recursionMatchSolve(maxLen, dic, target, start + tempLen, maxLen, result)  <span class="comment"># 匹配成功就重置len</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="comment"># 记得return</span></span><br><span class="line">    recursionMatchSolve(maxLen, dic, target, start, tempLen - <span class="number">1</span>, result)  <span class="comment"># 匹配失败</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterationMatch</span>(<span class="params">maxLen, dic, target</span>):</span><br><span class="line">    result = []</span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 循环中写终止条件</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; <span class="built_in">len</span>(target):</span><br><span class="line">        tempLen = maxLen</span><br><span class="line">        found = <span class="literal">False</span>  <span class="comment"># 记录本次是否匹配成功，匹配成功则退出下面循环，不然就会一直找到tempLen=0，中途找到结果会出问题</span></span><br><span class="line">        <span class="keyword">while</span> tempLen &gt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> start + tempLen &lt;= <span class="built_in">len</span>(target):</span><br><span class="line">                temp = target[start:start + tempLen]  <span class="comment"># 切片左闭右开</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = target[start:<span class="built_in">len</span>(target)]  <span class="comment"># 切片左闭右开</span></span><br><span class="line">            <span class="keyword">if</span> tempLen == <span class="number">1</span>:</span><br><span class="line">                result.append(temp)</span><br><span class="line">                start = start + <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="comment"># 匹配成功就跳出本次循环</span></span><br><span class="line">                <span class="keyword">if</span> i == temp:</span><br><span class="line">                    result.append(temp)</span><br><span class="line">                    start = start + tempLen</span><br><span class="line">                    found = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 找到结果退出循环</span></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 暂时找不到</span></span><br><span class="line">            tempLen = tempLen - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h6 id="反向最大匹配法"><a href="#反向最大匹配法" class="headerlink" title="反向最大匹配法"></a>反向最大匹配法</h6><p><strong>算法描述</strong></p><p>输入：分词词典、待切分语料<br>参数：最大词长maxLen，读取字符串长度len，读取字符串的指针起始位置pos<br>伪代码：<br>（4）初始化定义一个maxLen，令len&#x3D;maxLen，pos&#x3D;待切分长度-1；<br>（5）从待切分语料中从字符串最后一个下标的位置开始反向向前取maxLen的字符串str(取不够则全部取完)；<br>（6）将str与词典进行匹配：<br>①若匹配成功，则认为字符串str为词，pos向前移动len长度，返回步骤（1）<br>②若匹配失败：如果len&gt;1，则len减1，从待切分语料中从pos往前取长度为len的字符串str，返回步骤（3）；否则，得到长度为1的单字词，pos向前移动1长度，返回步骤（1）</p><p><strong>代码（个人书写）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursionMatch</span>(<span class="params">maxLen, dic, target</span>):</span><br><span class="line">    result = []</span><br><span class="line">    recursionMatchSolve(maxLen, dic, target, <span class="built_in">len</span>(target) - <span class="number">1</span>, maxLen, result)</span><br><span class="line">    <span class="comment"># 翻转list</span></span><br><span class="line">    result.reverse()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># maxLen表示每次取词最大长度，dic是字典，str是待切分语料，end是当前最后的切分位置（下标），tempLen是当前切分长度，result保存结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursionMatchSolve</span>(<span class="params">maxLen, dic, target, end, tempLen, result</span>):</span><br><span class="line">    <span class="comment"># 先添加终止条件</span></span><br><span class="line">    <span class="comment"># end &lt; 0表示已经匹配完成了，返回</span></span><br><span class="line">    <span class="keyword">if</span> end &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 先把当前需要比较字符获取出来</span></span><br><span class="line">    <span class="keyword">if</span> end - tempLen + <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">        temp = target[end - tempLen + <span class="number">1</span>:end + <span class="number">1</span>]  <span class="comment"># 切片左闭右开</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        temp = target[<span class="number">0</span>:end + <span class="number">1</span>]  <span class="comment"># 切片左闭右开</span></span><br><span class="line">    <span class="comment"># len=1表示当前取的字段只剩一个字，不管是否匹配成功都加入结果</span></span><br><span class="line">    <span class="keyword">if</span> tempLen == <span class="number">1</span>:</span><br><span class="line">        result.append(temp)</span><br><span class="line">        recursionMatchSolve(maxLen, dic, target, end - <span class="number">1</span>, maxLen, result)</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment"># 记得return</span></span><br><span class="line">    <span class="comment"># 比较词典中的词</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">        <span class="keyword">if</span> i == temp:</span><br><span class="line">            result.append(i)</span><br><span class="line">            recursionMatchSolve(maxLen, dic, target, end - tempLen, maxLen, result)  <span class="comment"># 匹配成功就重置len</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="comment"># 记得return</span></span><br><span class="line">    recursionMatchSolve(maxLen, dic, target, end, tempLen - <span class="number">1</span>, result)  <span class="comment"># 匹配失败</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterationMatch</span>(<span class="params">maxLen, dic, target</span>):</span><br><span class="line">    result = []</span><br><span class="line">    end = <span class="built_in">len</span>(target) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 循环中写终止条件</span></span><br><span class="line">    <span class="keyword">while</span> end &gt;= <span class="number">0</span>:</span><br><span class="line">        tempLen = maxLen</span><br><span class="line">        found = <span class="literal">False</span>  <span class="comment"># 记录本次是否匹配成功，匹配成功则退出下面循环，不然就会一直找到tempLen=0，中途找到结果会出问题</span></span><br><span class="line">        <span class="keyword">while</span> tempLen &gt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> end - tempLen + <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                temp = target[end - tempLen + <span class="number">1</span>:end + <span class="number">1</span>]  <span class="comment"># 切片左闭右开</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = target[<span class="number">0</span>:end + <span class="number">1</span>]  <span class="comment"># 切片左闭右开</span></span><br><span class="line">            <span class="keyword">if</span> tempLen == <span class="number">1</span>:</span><br><span class="line">                result.append(temp)</span><br><span class="line">                end = end - <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="comment"># 匹配成功就跳出本次循环</span></span><br><span class="line">                <span class="keyword">if</span> i == temp:</span><br><span class="line">                    result.append(temp)</span><br><span class="line">                    end = end - tempLen</span><br><span class="line">                    found = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 找到结果退出循环</span></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 暂时找不到</span></span><br><span class="line">            tempLen = tempLen - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 翻转列表</span></span><br><span class="line">    result.reverse()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h5 id="基于统计的中文分词方法"><a href="#基于统计的中文分词方法" class="headerlink" title="基于统计的中文分词方法"></a>基于统计的中文分词方法</h5><p><strong>基本思路和特点</strong></p><p>利用字与字间、词与词间的同现频率作为分词的依据；<br>需要大规模的训练文本, 用来训练模型参数；<br>优点：不受应用领域的限制；<br>缺点：训练文本的选择影响分词结果。</p><h6 id="概率最大分词法（n元语法模型）"><a href="#概率最大分词法（n元语法模型）" class="headerlink" title="概率最大分词法（n元语法模型）"></a>概率最大分词法（n元语法模型）</h6><p><strong>概率最大分词法可以通过不同的语法模型完成，这里分别给出不同语法模型的介绍（下面也给出了因为数据缺乏而必需采取平滑算法），同时给出基于二元语法模型的概率最大分词的代码</strong></p><ul><li><strong>采用一元语法模型（独立性假设）</strong></li></ul><p>每个词的出现是独立的，与其他词的出现无关</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310111118921.png" alt="image-20231011111829845"></p><p><strong>手算展示例子</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310112137328.png" alt="image-20231011213715214"></p><ul><li><strong>采用二元语法模型（马尔可夫假设）（代码）</strong></li></ul><p>每个词的发生概率取决于前一个词</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310111119922.png" alt="image-20231011111903875"></p><p><strong>举例</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310172301038.png" alt="image-20231017230128865"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310172301971.png" alt="image-20231017230155902"></p><p><strong>手算展示例子</strong></p><ol><li><p>对一个待分词的字串S,按照从左到右的顺序取出全部候选词𝑤𝟏, 𝑤2, … , 𝑤𝒏;（这里例子为”结合成分子时“）</p><table><thead><tr><th>序号</th><th>候选词</th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>结</td><td></td><td></td></tr><tr><td>0</td><td>结合</td><td></td><td></td></tr><tr><td>1</td><td>合</td><td></td><td></td></tr><tr><td>1</td><td>合成</td><td></td><td></td></tr><tr><td>2</td><td>成</td><td></td><td></td></tr><tr><td>2</td><td>成分</td><td></td><td></td></tr><tr><td>3</td><td>分</td><td></td><td></td></tr><tr><td>3</td><td>分子</td><td></td><td></td></tr><tr><td>4</td><td>子</td><td></td><td></td></tr><tr><td>5</td><td>时</td><td></td><td></td></tr></tbody></table></li><li><p>计算每个候选词的概率值𝒑 (𝑤𝒊), 记录每个候选词的全部左邻词</p><p>（候选词的概率可以从语料库中获得，从左往右寻找到达当前编码的前一个位置的所有词）</p><p><strong>（左邻词就是左边相邻的一个词）</strong></p><table><thead><tr><th>序号</th><th>候选词</th><th>候选词概率</th><th>左邻词</th></tr></thead><tbody><tr><td>0</td><td>结</td><td>0.0037</td><td>&#x2F;</td></tr><tr><td>0</td><td>结合</td><td>0.0353</td><td>&#x2F;</td></tr><tr><td>1</td><td>合</td><td>0.0049</td><td>结</td></tr><tr><td>1</td><td>合成</td><td>0.0006</td><td>结</td></tr><tr><td>2</td><td>成</td><td>0.0423</td><td>合，结合</td></tr><tr><td>2</td><td>成分</td><td>0.0023</td><td>合，结合</td></tr><tr><td>3</td><td>分</td><td>0.0312</td><td>合成，成</td></tr><tr><td>3</td><td>分子</td><td>0.0038</td><td>合成，成</td></tr><tr><td>4</td><td>子</td><td>0.001</td><td>分，成分</td></tr><tr><td>5</td><td>时</td><td>0.1043</td><td>子，分子</td></tr></tbody></table></li><li><p>计算每个候选词的累积概率，并找出每个词的最佳左邻词</p><p>（累积概率最大的候选词为最佳左邻词）</p></li></ol><table><thead><tr><th>序号</th><th>候选词</th><th>候选词概率</th><th>左邻词</th><th>累积概率</th><th>最佳左邻词</th></tr></thead><tbody><tr><td>0</td><td>结</td><td>0.0037</td><td>&#x2F;</td><td>0.0037</td><td>&#x2F;</td></tr><tr><td>0</td><td>结合</td><td>0.0353</td><td>&#x2F;</td><td>0.0353</td><td>&#x2F;</td></tr><tr><td>1</td><td>合</td><td>0.0049</td><td>结</td><td>0.00001813</td><td>结</td></tr><tr><td>1</td><td>合成</td><td>0.0006</td><td>结</td><td>0.00000222</td><td>结</td></tr><tr><td>2</td><td>成</td><td>0.0423</td><td>合，结合</td><td>0.00149319</td><td>结合</td></tr><tr><td>2</td><td>成分</td><td>0.0023</td><td>合，结合</td><td>0.00008119</td><td>结合</td></tr><tr><td>3</td><td>分</td><td>0.0312</td><td>合成，成</td><td>0.000046587528</td><td>成</td></tr><tr><td>3</td><td>分子</td><td>0.0038</td><td>合成，成</td><td>0.000005674122</td><td>成</td></tr><tr><td>4</td><td>子</td><td>0.001</td><td>分，成分</td><td>0.00000008119</td><td>成分</td></tr><tr><td>5</td><td>时</td><td>0.1043</td><td>子，分子</td><td>0.0000005918109246</td><td>分子</td></tr></tbody></table><p>结：没有左邻词，累积概率为自己的概率0.0037</p><p>结合：没有左邻词，累积概率为自己的概率0.0353</p><p>合：有一个左邻词是结，概率为0.0049×0.0037&#x3D;0.00001813</p><p>合成：有一个左邻词是结，概率为0.0006×0.0037&#x3D;0.00000222</p><p>成：有两个左邻词，首先看合，概率为0.0423×0.00001813&#x3D;0.000000766899；再看结合，概率为0.0423×0.0353&#x3D;0.00149319，选最大累积概率确定最优左邻词为结合</p><p>成分：有两个左邻词，首先看合，概率为0.0023×0.00001813&#x3D;0.000000041699；再看结合，概率为0.0023×0.0353&#x3D;0.00008119，选最大累积概率确定最优左邻词为结合</p><p>分：有两个左邻词，首先看合成，概率为0.0312×0.00000222&#x3D;0.000000069264；再看成，概率为0.0312×0.00149319&#x3D;0.000046587528，选最大累积概率确定最优左邻词为成</p><p>分子：有两个左邻词，首先看合成，概率为  0.0038×0.00000222&#x3D;0.000000008436；再看成，概率为  0.0038×0.00149319&#x3D;0.000005674122，选最大累积概率确定最优左邻词为成</p><p>子：有两个左邻词，首先看分，概率为0.001×0.000046587528&#x3D;0.000000046587528；再看成分，概率为0.001×  0.00008119&#x3D;0.00000008119，选最大累积概率确定最优左邻词为成分</p><p>时：有两个左邻词，首先看子，概率为0.1043×0.00000008119&#x3D;0.000000008468117；再看分子，概率为0.1043×0.000005674122&#x3D;0.0000005918109246，选最大累积概率确定最优左邻词为分子</p><ol start="4"><li><p>找终点词</p><p><strong>这句话最后一个字为时，这里只有一种结果，如果有两种情况，如子时和时出现的时候，就看哪个累积概率大就选哪个</strong></p></li><li><p>输出分词结果</p><p>选时，它的最佳左邻词为分子，选分子，分子最佳左邻词为成，选成，成的最佳左邻词为结合，选结合</p><p>最后得出结果为结合&#x2F;成&#x2F;分子&#x2F;时</p></li></ol><p><strong>算法描述</strong></p><p>（从上方的手算过程可以看出，这个算法思想是使用动态规划算法来实现，即最优路径中的第i个词wi的累计概率等于它的左相邻词wi-1的累积概率乘以wi自身的概率）</p><ol><li>对一个待分词的字串S,按照从左到右的顺序取出全部<br>候选词𝑤𝟏, 𝑤2, … , 𝑤𝒏;</li><li>计算每个候选词的概率值𝒑 𝑤𝒊 记录每个候选词的全部<br>左邻词;</li><li>计算每个候选词的累计概率，累计概率最大的候选词<br>为最佳左邻词;</li><li>如果当前词𝑤𝒏是字串的尾词,且累计概率𝒑 𝑤𝒏 最大，<br>则𝑤𝒏是S的终点词；</li><li>从𝑤𝒏开始，按照从右到左顺序，依次将每个词的最佳<br>左邻词输出，即S的分词结果.</li></ol><p><strong>代码（个人书写）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先要有候选词和候选词的概率字典，这个外部传进来，规定字典样式，字典第一列为正确词语，第二列为概率</span></span><br><span class="line"><span class="comment"># dic为字典，target为待切分语料</span></span><br><span class="line"><span class="comment"># 基于二元语法模型的概率最大分词方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">match</span>(<span class="params">dic, target</span>):</span><br><span class="line">    result = []</span><br><span class="line">    recordList = initList(dic, target)</span><br><span class="line"></span><br><span class="line">    dp(target, recordList)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 逆着找最大值，找到当前列的最大值，最大值说明当前这种情况是出现概率最大的，添加进结果列表，然后得到截断的行坐标，继续往前找即可</span></span><br><span class="line">    j = <span class="built_in">len</span>(target) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        tempMax = <span class="number">0</span></span><br><span class="line">        tempMaxRow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> recordList[i][j] &gt;= tempMax:</span><br><span class="line">                tempMax = recordList[i][j]</span><br><span class="line">                tempMaxRow = i</span><br><span class="line">        result.append(target[tempMaxRow:j + <span class="number">1</span>])</span><br><span class="line">        j = tempMaxRow - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    result.reverse()  <span class="comment"># 翻转list</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个记录列表，targetLen为字符串长度，生成targetLen*targetLen的列表，然后根据字典填充记录列表并返回</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initList</span>(<span class="params">dic, target</span>):</span><br><span class="line">    targetLen = <span class="built_in">len</span>(target)</span><br><span class="line">    recordList = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(targetLen)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(targetLen)]  <span class="comment"># 创建一个二维列表，初始化为0</span></span><br><span class="line">    dicLen = <span class="built_in">len</span>(dic)  <span class="comment"># 字典行数，列数为len(dic[0])</span></span><br><span class="line">    <span class="comment"># 不断切分语料并匹配词典概率</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(targetLen):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(targetLen):</span><br><span class="line">            temp = target[i:j + <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 查看字典有没有切分的这个情况的词，有就把概率填充进记录列表</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(dicLen):</span><br><span class="line">                <span class="keyword">if</span> temp == dic[k][<span class="number">0</span>]:</span><br><span class="line">                    recordList[i][j] = dic[k][<span class="number">1</span>]  <span class="comment"># 第二列为对应词的概率</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> recordList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态规划填充记录列表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">target, recordList</span>):</span><br><span class="line">    targetLen = <span class="built_in">len</span>(target)</span><br><span class="line">    <span class="comment"># 自左往右，自下往上填表</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(targetLen):</span><br><span class="line">        <span class="comment"># i+1是因为当独切分一个字符的概率要么给出要么为0，不用计算了</span></span><br><span class="line">        <span class="comment"># range左闭右开</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, j):</span><br><span class="line">                <span class="keyword">if</span> recordList[i][k] * recordList[k + <span class="number">1</span>][j] &gt; recordList[i][j]:</span><br><span class="line">                    recordList[i][j] = recordList[i][k] * recordList[k + <span class="number">1</span>][j]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ProbabilisticMaximumWordSegmentationMethod <span class="keyword">as</span> Method</span><br><span class="line"></span><br><span class="line">dic = [[<span class="string">&#x27;结&#x27;</span>, <span class="number">0.0037</span>],</span><br><span class="line">       [<span class="string">&#x27;结合&#x27;</span>, <span class="number">0.0353</span>],</span><br><span class="line">       [<span class="string">&#x27;合&#x27;</span>, <span class="number">0.0049</span>],</span><br><span class="line">       [<span class="string">&#x27;合成&#x27;</span>, <span class="number">0.0006</span>],</span><br><span class="line">       [<span class="string">&#x27;成&#x27;</span>, <span class="number">0.0423</span>],</span><br><span class="line">       [<span class="string">&#x27;成分&#x27;</span>, <span class="number">0.0023</span>],</span><br><span class="line">       [<span class="string">&#x27;分&#x27;</span>, <span class="number">0.0312</span>],</span><br><span class="line">       [<span class="string">&#x27;分子&#x27;</span>, <span class="number">0.0038</span>],</span><br><span class="line">       [<span class="string">&#x27;子&#x27;</span>, <span class="number">0.001</span>],</span><br><span class="line">       [<span class="string">&#x27;时&#x27;</span>, <span class="number">0.1043</span>]]</span><br><span class="line">target = <span class="string">&#x27;结合成分子时&#x27;</span></span><br><span class="line"></span><br><span class="line">result = Method.<span class="keyword">match</span>(dic, target)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot;|&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>n元语法模型</strong></li></ul><p>每个词的发生概率取决于前n-1个词</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310111119740.png" alt="image-20231011111958695"></p><p>事实上绝大多数历史根本不可能在训练数据中出现，为此，可以通过划分等价类的方法降低历史的数目，等价划分降低参数后的语言模型称为n元语法或n元文法**(n-gram)**，通常n不会太大，否则等价类太多，无法具体实现！</p><h6 id="数据平滑"><a href="#数据平滑" class="headerlink" title="数据平滑"></a>数据平滑</h6><p>平滑技术就是用来解决0概率问题，其基本思想是“劫富济贫”，提高低概率，降低高概率，尽量使得概率分布趋于均匀！（当分子为0的时候就会出现0概率问题，但这时候整块结果就会为0，影响整体结果）</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310172306061.png" alt="image-20231017230643007"></p><p><strong>例子</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310172307625.png" alt="image-20231017230731563"></p><h5 id="基于神经网络的中文分词方法"><a href="#基于神经网络的中文分词方法" class="headerlink" title="基于神经网络的中文分词方法"></a>基于神经网络的中文分词方法</h5><p><strong>基本思路和特点</strong></p><p>参数量大、模型训练时间相对较长等。</p><hr><h4 id="词性标注"><a href="#词性标注" class="headerlink" title="词性标注"></a>词性标注</h4><h5 id="相关知识-2"><a href="#相关知识-2" class="headerlink" title="相关知识"></a>相关知识</h5><p><strong>MM（马尔可夫链）</strong></p><p><a href = "#MM">马尔可夫</a>链有显马尔可夫链（VMM）和<a href = "#HMM">隐马尔可夫链（HMM）</a></p><ul><li><p><strong>马尔可夫</strong><a name = "MM"></a></p><p>假设某系统有N个有限状态 S&#x3D;{s1,s2,…,sN} ，随着时间的推移，系统将从某一个状态转移到另一个状态。</p><p>X&#x3D;{x1,x2,…,xT}是一个<strong>取值于有限状态集合S</strong>的随机变量序列，随机变量的取值为状态集S的某个状态，假定在时间t的状态记为 xt ，xt∈S,t&#x3D;1,2,…,T。那么这里X称为一阶马尔可夫链，或称具有马尔可夫性质，则系统在时间t处于状态sj的概率取决于它在时间1,2,3,…,t−1的状态，其概率为</p></li></ul><p>$$<br>P（xt &#x3D; sj | x(t-1) &#x3D; sj,x(t-2) &#x3D; sk）<br>$$</p><p>即在特定情况下，系统在时间t的状态下只与其在时间t-1的状态相关（二元语法模型），该随机过程称为一阶马尔可夫过程。</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271032493.png" alt="image-20231027103216239"></p><p>​<strong>注：状态转移矩阵的每一行所有列元素的概率和为1</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271033701.png" alt="image-20231027103324549"></p><p><em>例2</em></p><p>假设有如下转移矩阵</p><p>​vnp</p><p>v0.10.80.1</p><p>n0.80.010.19</p><p>p0.90.050.05</p><p>那么P(n,v,p,n|M) &#x3D; P(n) * P(v|n) * P(p|v) * P(n|p) &#x3D; 1 * 0.8 *0.1 * 0.05 &#x3D; 0.004</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271042015.png" alt="image-20231027104218854"></p><ul><li><strong>隐马尔可夫模型HMM</strong><a name = "HMM"></a></li></ul><p>隐马尔可夫模型（Hidden Markov Model，HMM）是一种概率模型，用于解决序列预测问题</p><p>在马尔可夫模型中，每个状态代表了一个可观察到的事件。如：天气马尔可夫模型，前提是，第二天是天气是可以观察到的。如果知道某个事件的观察序列，是可以使用一个马尔可夫模型来计算；但是，有时候有些事件是不可以直接观测到的。例如：如果一个盲人，他不能通过观察天气来预测天气，他只能通过摸水藻的干湿程度来间接预测天气。这时，水藻的干湿就是可观察事件，其状态为可观察状态；而天气则是隐状态；</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271055416.png" alt="image-20231027105528232"></p><p><strong>隐含马尔可夫模型被认为是解决大多数自然语言处理问题最快速、有效的方法</strong>；</p><p>应用：语音识别、NLP中的分词、词性标注、计算机视觉中的动作识别等；成功解决了复杂的语音识别、机器翻译等问题；</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271059853.png" alt="image-20231027105902710"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271100620.png" alt="image-20231027110042426"></p><ol><li>评估问题。</li></ol><p>给定观测序列 O&#x3D;O1O2O3…Ot和模型参数λ&#x3D;(A,B,π)，怎样有效计算某一观测序列的概率，进而可对该HMM做出相关评估。例如，已有一些模型参数各异的HMM，给定观测序列O&#x3D;O1O2O3…Ot，我们想知道哪个HMM模型最可能生成该观测序列。通常我们利用forward算法分别计算每个HMM产生给定观测序列O的概率，然后从中选出最优的HMM模型。</p><p>这类评估的问题的一个经典例子是语音识别。在描述语言识别的隐马尔科夫模型中，每个单词生成一个对应的HMM，每个观测序列由一个单词的语音构成，单词的识别是通过评估进而选出最有可能产生观测序列所代表的读音的HMM而实现的。</p><p>2.解码问题</p><p>给定观测序列 O&#x3D;O1O2O3…Ot 和模型参数λ&#x3D;(A,B,π)，怎样寻找某种意义上最优的隐状态序列。在这类问题中，我们感兴趣的是马尔科夫模型中隐含状态，这些状态不能直接观测但却更具有价值，通常利用Viterbi算法来寻找。</p><p>这类问题的一个实际例子是中文分词，即把一个句子如何划分其构成才合适。例如，句子“发展中国家”是划分成“发展-中-国家”，还是“发展-中国-家”。这个问题可以用隐马尔科夫模型来解决。句子的分词方法可以看成是隐含状态，而句子则可以看成是给定的可观测状态，从而通过建HMM来寻找出最可能正确的分词方法。</p><ol start="3"><li>学习问题。</li></ol><p>即HMM的模型参数λ&#x3D;(A,B,π)未知，如何调整这些参数以使观测序列O&#x3D;O1O2O3…Ot的概率尽可能的大。通常使用Baum-Welch算法以及Reversed Viterbi算法解决。</p><p>怎样调整模型参数λ&#x3D;(A,B,π)，使观测序列 O&#x3D;O1O2O3…Ot的概率最大？</p><p>针对以下三个问题，人们提出了相应的算法</p><ol><li>评估问题： 直接计算法（概念上可行，计算上不科学）、前向算法、后向算法</li></ol><p>​当然也存在穷举搜索算法（就是列举出所有可能性，就是把所有组合路径找出来，计算每条路径的概率，当序列词数比较多的时候就会耗费很多时间，为了避免耗费过多时间就会使用前向算法）</p><ol start="2"><li>解码问题：</li></ol><p>​<a href = "#viterbi">Viterbi算法</a>：使用动态规划求解概率最大（最优）路径。</p><p>​近似算法：选择每一时刻最有可能出现的状态，从而得到一个状态序列。</p><ol start="3"><li>学习问题： Baum-Welch算法(向前向后算法)、监督学习算法</li></ol><h5 id="词性标注相关概念"><a href="#词性标注相关概念" class="headerlink" title="词性标注相关概念"></a>词性标注相关概念</h5><p><strong>词性标注的定义</strong></p><p>即判定给定句子中每个词的语法范畴，确定其词性并加以标注的过程。</p><p>如果词w存在两个或两个以上的词性，则词w具有<strong>词性标注歧义</strong>。</p><p><strong>词性标注的必要性</strong></p><p>汉语由于缺乏语法形态变化，词的应用非常灵活，词类兼类现象特别多，也特别复杂，因此需要做词性标注。</p><p>自然语言中普遍存在<strong>词类兼类</strong>现象<strong>（一个词可做多个词性的现象）</strong>，正因为存在词类兼类的问题，所以在对词切分时必然要注明词的词性，于是就出现了词性标注</p><p>例：他是总<em>编辑</em>（名词）             他正在<em>编辑</em>这本书（动词）</p><p><strong>应用</strong></p><p>词性标注是一个比较活跃的研究领域，应用广泛，如：口语识别与生成、机器翻译、信息检索和词典编撰等</p><p><strong>词性标准的研究方法</strong></p><ul><li>基于规则方法进行标注</li><li>统计方法进行标注</li><li>规则与统计方法结合进行标注</li><li>基于转换的错误驱动学习</li></ul><h5 id="基于规则的词性标注"><a href="#基于规则的词性标注" class="headerlink" title="基于规则的词性标注"></a>基于规则的词性标注</h5><p><strong>原理</strong></p><p>利用事先制定好的规则对具有多个词性的词进行消歧，最后保留一个正确的词性。</p><p><strong>步骤</strong></p><ol><li>对词性歧义建立单独的标注规则库；</li><li>标注时，查词典，如果某个词具有多个词性，则查找规则库，对具有相同模式的歧义进行排歧，否则保留。</li><li>程序和规则库是独立的两个部分。</li></ol><p><strong>举例</strong></p><p>一把青菜(量词)                                 </p><p>我把书放在冰箱上(动词)</p><p>要求：要对这两句话进行切分并标注词性。</p><p>实现步骤：</p><ol><li><p>已建词典中有：     把  v,l</p></li><li><p>已建规则库中有：</p></li></ol><p>   规则1：如果当前词的前相邻词的词性为s，则该词的词性为l ，如果当前词的前相邻词的词性为n，则该词的词性为v</p><ol start="3"><li><p>算法：             </p><p>用MM方法来切分句子，边切边标注词性。             </p><p>词性标注时，当切分到‘把’时，有两个词性，怎么办？</p><p>到规则库中去寻找相同模式的规则，如这里的规则1恰好满足，所以这里的“把”取q词性。</p></li></ol><h5 id="基于统计的词性标注"><a href="#基于统计的词性标注" class="headerlink" title="基于统计的词性标注"></a>基于统计的词性标注</h5><p><strong>基本思路</strong></p><p>初始：令W&#x3D;w1w2…wn是由n个词组成的词串，T&#x3D;t1t2…tn是词串W对应的词性标注串，其中tk是wk的词性标注；</p><p>目标：计算使得条件概率 P(T|W)值最大的词性标注序列T’</p><p>思路：</p><ul><li><p>根据贝叶斯公式：P(T|W)&#x3D; P(T) P(W|T)&#x2F; P(W)</p></li><li><p>.由于词串不变,p(W)不影响总的概率值，因此继续简化为：<strong>P(T|W)&#x3D; P(T) P(W|T)</strong></p></li><li><p>其中P(T)&#x3D; P(t1|t0) P(t2|t1,t0)… P(ti|ti-1..)</p></li><li><p>根据2元语法模型，可得：**P(T)&#x3D; P(t1|t0) P(t2|t1)… P(ti|ti-1) **</p></li></ul><p><strong>P(ti|ti-1)&#x3D;训练语料中ti出现在ti-1之后的次数 &#x2F; 训练语料中ti-1出现的总次数</strong></p><ul><li>根据乘法公式：P(W|T)&#x3D; P(w1|t1) P(w2|t2,t1)… P(wi|ti,ti-1…,t1)</li><li>上式使用1元语法模型：<strong>P(W|T)&#x3D; P(w1|t1) P(w2|t2)… P(wi|ti)</strong></li></ul><p><strong>P(wi|ti)&#x3D;训练语料中wi的词性被标记为ti的次数 &#x2F; 训练语料中ti出现的总次数</strong></p><p><strong>CLAWS算法</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310172350012.png" alt="image-20231017235037944"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310172351455.png" alt="image-20231017235100395"></p><p><strong>VOLSUNGA算法</strong></p><p>对CLAWS算法进行改进后得到</p><p>CLAWS算法中最佳路径的定义为N个可能的排列中概率乘积最大的那条路径</p><p>VOLSUNGA算法从左往右，对于当前考虑的词，只保留通往该词的每个词类的最佳路径，然后继续将这些路径与下个词的所有词类标记进行匹配，分别找出通往这个词的每个标记的最佳路径，后面的词依次重复</p><p><strong>下面是跟马尔可夫链相关的算法</strong></p><h6 id="前向算法"><a href="#前向算法" class="headerlink" title="前向算法"></a>前向算法</h6><p><strong>解决问题</strong></p><p>给定一个隐马尔科夫模型M&#x3D;(A,B)，以及一个观测序列O，计算P(O|M) (A表示转移概率，B表示发射概率)例如，给定一个天气的HMM模型，计算某个观测序列{dry,damp,soggy}的概率？即：   P(dry,damp,soggy|A,B)</p><p><strong>描述</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271211679.png" alt="image-20231027121142439"></p><p><em>个人理解：</em>前向算法是为了评估HMM模型的，返回一个概率以评估HMM模型，以找到最好的HMM模型，对于概率矩阵，第一列跟维特比算法一样，<strong>初始概率  * 发射概率</strong>，从第二列开始跟维特比算法有区别，对于每列，列中每个元素等于<strong>前一列每个元素 * 转移概率求和，然后再 * 发射概率</strong>，最后返回最后一列的所有概率的和。</p><h6 id="HMM-Viterbi"><a href="#HMM-Viterbi" class="headerlink" title="HMM+Viterbi"></a>HMM+Viterbi</h6><p><strong>维特比算法思想</strong> <a name = "viterbi"></a></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271106664.png" alt="image-20231027110654483"></p><p>这样每个节点保存的是到当前节点的局部最优概率；依据最后一个时刻中概率最高的状态，逆向找其路径中的上一个最大部分最优路径，从而找到整个最优路径。</p><p><strong>隐马尔可夫模型+维特比算法在词性标注中的应用</strong>  </p><p>（<a href = "#hmm+viterbi">代码</a>）</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271108872.png" alt="image-20231027110815670"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271113235.png" alt="image-20231027111331942"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271151495.png" alt="image-20231027115108390"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271151959.png" alt="image-20231027115120860"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271151224.png" alt="image-20231027115135080"></p><p><strong>具体示例和代码</strong><a name = "hmm+viterbi"></a></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271155989.png" alt="image-20231027115516565"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271201410.png" alt="image-20231027120114234"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271201210.png" alt="image-20231027120138032"></p><p><strong>这里为了代码书写方便，代码中处理的发射矩阵为下图，只需获取对应坐标即得到发射矩阵的值</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310271201469.png" alt="image-20231027120158294"></p><p><em>代码</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化相关</span></span><br><span class="line"><span class="comment"># 按照定义发射矩阵的行对应隐序列全部序列，列对应所有给定的可观测值，这样每一行的列全部概率想加为1</span></span><br><span class="line"><span class="comment"># 这里按照自己实际代码书写把传出的发射矩阵行坐标为对应隐序列全部序列，列为观测序列，在后续乘上观测序列的时候直接通过坐标值获取即可，也可以建立字典，某个词对应列坐标保存起来</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转置输入的发射矩阵得到行为隐序列，列为观测序列的矩阵，并进行数据平滑和归一化</span></span><br><span class="line"><span class="comment"># initObserveList为给定所有观测序列，observeList为观测序列，initMatrix为给定矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getEmissionMatrix</span>(<span class="params">initObserveList, initMatrix, observeList</span>):</span><br><span class="line">    <span class="comment"># 将字母转换成小写，方便后面对比观测序列和所有观测序列元素是否一样</span></span><br><span class="line">    lowerInitObserveList = [<span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(initObserveList))]</span><br><span class="line"></span><br><span class="line">    lowerObserveList = [<span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(observeList))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(initObserveList)):</span><br><span class="line">        lowerInitObserveList[i] = <span class="built_in">str</span>(initObserveList[i]).lower()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(observeList)):</span><br><span class="line">        lowerObserveList[i] = <span class="built_in">str</span>(observeList[i]).lower()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先创建列多少元素再创建行，转置矩阵</span></span><br><span class="line">    tempMatrix = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(initMatrix))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(initMatrix[<span class="number">0</span>]))]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转置矩阵后，进行数据平滑，然后得到定义的发射矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(initMatrix)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(initMatrix[<span class="number">0</span>])):</span><br><span class="line">            tempMatrix[j][i] = initMatrix[i][j] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tempMatrix)):</span><br><span class="line">        tempSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tempMatrix[<span class="number">0</span>])):</span><br><span class="line">            tempSum = tempSum + tempMatrix[i][j]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tempMatrix[<span class="number">0</span>])):</span><br><span class="line">            tempMatrix[i][j] = tempMatrix[i][j] / tempSum</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据观测序列创建对应的发射矩阵，就是行为隐序列，列为观测序列的矩阵，按照自己代码需求不删除重复列，但是概率计算正确了</span></span><br><span class="line">    emissionMatrix = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(observeList))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(initMatrix[<span class="number">0</span>]))]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据观测序列和初始提供的发射矩阵转置后的矩阵的列名确认所需发射矩阵</span></span><br><span class="line">    <span class="keyword">for</span> j1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lowerObserveList)):</span><br><span class="line">        <span class="keyword">for</span> j2 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lowerInitObserveList)):</span><br><span class="line">            <span class="keyword">if</span> lowerInitObserveList[j2] == lowerObserveList[j1]:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tempMatrix)):</span><br><span class="line">                    emissionMatrix[i][j1] = tempMatrix[i][j2]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emissionMatrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对转移矩阵进行数据平滑和归一化</span></span><br><span class="line"><span class="comment"># initMatrix为给定矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getTransferMatrix</span>(<span class="params">initMatrix</span>):</span><br><span class="line">    transferMatrix = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(initMatrix[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(initMatrix))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(initMatrix)):</span><br><span class="line">        tempSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(initMatrix[<span class="number">0</span>])):</span><br><span class="line">            transferMatrix[i][j] = initMatrix[i][j] + <span class="number">1</span>  <span class="comment"># 加1数据平滑</span></span><br><span class="line">            tempSum = tempSum + transferMatrix[i][j]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(transferMatrix[<span class="number">0</span>])):</span><br><span class="line">            transferMatrix[i][j] = transferMatrix[i][j] / tempSum  <span class="comment"># 每行的各概率加起来为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> transferMatrix</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传入发射矩阵和转移矩阵</span></span><br><span class="line"><span class="comment"># initChanceList为初始概率矩阵，emissionMatrix为发射矩阵，transferMatrix为转移矩阵，hideList为隐序列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hmmViterbi</span>(<span class="params">initChanceList, emissionMatrix, transferMatrix, hideList</span>):</span><br><span class="line">    <span class="comment"># 保存结果</span></span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 观测序列长度，也就是发射矩阵的列数</span></span><br><span class="line">    observeLen = <span class="built_in">len</span>(emissionMatrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 隐序列长度，也就是发射矩阵的行数</span></span><br><span class="line">    hideLen = <span class="built_in">len</span>(emissionMatrix)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># viterbi矩阵 记录当前概率最大矩阵,行数为隐序列长度，对应隐序列每个词，列数为观测序列长度，对于观测序列每个词</span></span><br><span class="line">    viterbiList = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(observeLen)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(hideLen)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># backPoint矩阵 记录得到viterbi当前最大值对应上一列的坐标（以列循环） 大小和viterbi大小一样</span></span><br><span class="line">    backPoint = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(observeLen)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(hideLen)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 核心部分</span></span><br><span class="line">    <span class="comment"># 初始viterbi矩阵和backPoint矩阵，初始第一列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hideLen):</span><br><span class="line">        viterbiList[i][<span class="number">0</span>] = initChanceList[i] * emissionMatrix[i][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从第二列开始</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, observeLen):</span><br><span class="line">        <span class="comment"># 每列的每个元素，就是第几行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hideLen):</span><br><span class="line">            <span class="comment"># 当前要填入的值为前一列转移到当前的最大概率，tempMax记录当前最大值</span></span><br><span class="line">            tempMax = -<span class="number">1</span></span><br><span class="line">            <span class="comment"># 前一列的每个值乘上当前待填入值的点的发射概率,发射矩阵对应坐标跟viterbi矩阵当前坐标一样,还要乘上转移概率，转移概率矩阵对应坐标为(k,j)</span></span><br><span class="line">            <span class="comment"># 最大值记录下来，一次遍历最大值填入，同时记录得出最大值的乘法中上列值的横坐标</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(hideLen):</span><br><span class="line">                <span class="keyword">if</span> viterbiList[k][j - <span class="number">1</span>] * emissionMatrix[i][j] * transferMatrix[k][i] &gt;= tempMax:</span><br><span class="line">                    tempMax = viterbiList[k][j - <span class="number">1</span>] * emissionMatrix[i][j] * transferMatrix[k][i]</span><br><span class="line">                    backPoint[i][j] = k</span><br><span class="line">            viterbiList[i][j] = tempMax</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tempMax保存最后一列最大值，tempMaxIndex保存最后一列最大值的横坐标，tempIndex保存下一次回溯的横坐标</span></span><br><span class="line">    tempMax = <span class="number">0</span></span><br><span class="line">    tempMaxIndex = <span class="number">0</span></span><br><span class="line">    tempIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(hideLen):</span><br><span class="line">        <span class="keyword">if</span> viterbiList[i][observeLen - <span class="number">1</span>] &gt;= tempMax:</span><br><span class="line">            tempMax = viterbiList[i][observeLen - <span class="number">1</span>]</span><br><span class="line">            tempMaxIndex = i</span><br><span class="line">            tempIndex = backPoint[i][observeLen - <span class="number">1</span>]</span><br><span class="line">    result.append(hideList[tempMaxIndex])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从倒数第二行开始回溯根据backPoint矩阵寻找结果</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(observeLen - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        result.append(hideList[tempIndex])</span><br><span class="line">        tempIndex = backPoint[tempIndex][j]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出viterbi矩阵</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;viterbi矩阵如下:&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(viterbiList)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(viterbiList[<span class="number">0</span>])):</span><br><span class="line">            <span class="built_in">print</span>(viterbiList[i][j], end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出backPoint矩阵</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;backPoint矩阵如下:&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(backPoint)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(backPoint[<span class="number">0</span>])):</span><br><span class="line">            <span class="built_in">print</span>(backPoint[i][j], end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    result.reverse()  <span class="comment"># 翻转</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> InitUtil</span><br><span class="line"><span class="keyword">import</span> HMMAndViterbi</span><br><span class="line"></span><br><span class="line"><span class="comment">#  观测序列  分词后的语句  &#123;The bear is on the move&#125;</span></span><br><span class="line">observeList = [<span class="string">&#x27;The&#x27;</span>, <span class="string">&#x27;bear&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;move&#x27;</span>]</span><br><span class="line"></span><br><span class="line">observeLen = <span class="built_in">len</span>(observeList)  <span class="comment"># 观测序列长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐序列 词性 &#123;AT BEZ IN NN VB PERIOD&#125;</span></span><br><span class="line">hideList = [<span class="string">&#x27;AT&#x27;</span>, <span class="string">&#x27;BEZ&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="string">&#x27;NN&#x27;</span>, <span class="string">&#x27;VB&#x27;</span>, <span class="string">&#x27;PERIOD&#x27;</span>]</span><br><span class="line"></span><br><span class="line">hideLen = <span class="built_in">len</span>(hideList)  <span class="comment"># 隐序列长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始概率矩阵 隐序列的每个元素的初始概率 &#123;0.2 0.1 0.1 0.2 0.3 0.1&#125;</span></span><br><span class="line">initChanceList = [<span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># viterbi矩阵 记录当前概率最大矩阵,行数为隐序列长度，对应隐序列每个词，列数为观测序列长度，对于观测序列每个词</span></span><br><span class="line">viterbiList = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(hideLen)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(observeLen)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># backPoint矩阵 记录得到viterbi当前最大值对应上一列的坐标（以列循环） 大小和viterbi大小一样</span></span><br><span class="line">backPoint = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(hideLen)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(observeLen)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转移矩阵</span></span><br><span class="line">initTranslateList = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">48636</span>, <span class="number">0</span>, <span class="number">19</span>], [<span class="number">1973</span>, <span class="number">0</span>, <span class="number">426</span>, <span class="number">187</span>, <span class="number">0</span>, <span class="number">38</span>], [<span class="number">43322</span>, <span class="number">0</span>, <span class="number">1325</span>, <span class="number">17314</span>, <span class="number">0</span>, <span class="number">185</span>],</span><br><span class="line">                     [<span class="number">1067</span>, <span class="number">3720</span>, <span class="number">42470</span>, <span class="number">11773</span>, <span class="number">614</span>, <span class="number">21392</span>], [<span class="number">6072</span>, <span class="number">42</span>, <span class="number">4758</span>, <span class="number">1476</span>, <span class="number">129</span>, <span class="number">1522</span>],</span><br><span class="line">                     [<span class="number">8016</span>, <span class="number">75</span>, <span class="number">4656</span>, <span class="number">1329</span>, <span class="number">954</span>, <span class="number">0</span>]]</span><br><span class="line">translateList = InitUtil.getTransferMatrix(initTranslateList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发射矩阵</span></span><br><span class="line">initObserveList = [<span class="string">&#x27;bear&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;move&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;president&#x27;</span>, <span class="string">&#x27;progress&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">initFireMatrix = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">43</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">10065</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">36</span>, <span class="number">133</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">5484</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">382</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">108</span>, <span class="number">4</span>, <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">69016</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">48809</span>]]</span><br><span class="line">fireList = InitUtil.getEmissionMatrix(initObserveList, initFireMatrix, observeList)</span><br><span class="line"></span><br><span class="line">result = HMMAndViterbi.hmmViterbi(initChanceList, fireList, translateList, hideList)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最大可能序列为&#x27;</span>, end=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="句法分析"><a href="#句法分析" class="headerlink" title="句法分析"></a>句法分析</h3><h4 id="相关知识-3"><a href="#相关知识-3" class="headerlink" title="相关知识"></a>相关知识</h4><p><strong>字符和字符串相关定义（一些概念与后面概念相关）</strong></p><p>假定∑是字符的有限集合，它的每一个元素称为字符。<strong>由∑中字符相连而成的有限序列称为∑上的字符串</strong>。特殊的，不包括任何字符的字符串称为<strong>空串，记作ε</strong>。<strong>包括空串在内的∑上字符串的全体记为∑</strong>*</p><p> 链接和闭包是字符串操作中的两种基本运算</p><p>假定∑是字符的有限集合，x,y是∑上的符号串，则把y的各个符号一次写在x符号串之后得到的符号串称为x与y的<strong>链接</strong>，记作xy。</p><p><em>例如</em>：<br>$$<br>∑&#x3D;{a,b,c}, x&#x3D;abc, y&#x3D;cba, 那么：xy&#x3D;abccba<br>$$</p><p>设A,B是字符表∑上符号串的集合，则A和B的<strong>乘积</strong>定义为：<br>$$<br>AB&#x3D;{xy|x∈ A, y∈ B}，其中A^0 &#x3D; {ε}。当n&gt;&#x3D;1时，A^n&#x3D;A^{n-1}A&#x3D;AA^{n-1}<br>$$</p><p>字符串V的<strong>闭包</strong>定义为：<br>$$<br>V^*&#x3D;V^0 ∪ V^1 ∪ V^2 ∪ …，<br>V^+ &#x3D; V^1 ∪ V^2 ∪ …， V^+ &#x3D; V^* - {ε}<br>$$<br>例如：<br>$$<br>如果V&#x3D;{a,b} ，则：V^*&#x3D;{ε, a, b, aa, ab, bb, ba, aaa, …}，V^+&#x3D;{a, b, aa, ab, bb, ba, aaa, …}<br>$$</p><p><strong>形式语言（形式语法和自动机）</strong></p><p>形式语言学（Formal Linguistics）（也称代数语言学），是一门研究语言的科学领域，它主要关注语言的结构、语法、语义、音系和语音等方面的形式性质。形式语言学使用数学符号和形式规则来描述和分析语言，旨在深入理解语言的本质和结构，以及解决语言相关的理论和应用问题。<strong>形式语法理论和自动机理论都属于形式语言理论的一部分。</strong>形式语言理论是自然语言描述和分析的基础（目的是试图用精确的数学模型（形式语言）来刻划自然语言），自动机理论在自然语言的词法分析、拼写检查、短语识别等很多方面都有广泛用途。</p><p><strong>描述语言的三种途径</strong></p><ul><li><p>枚举法</p><p>把语言中的句子穷尽地枚举出来，对于含无限多个句子的语言不合适</p></li><li><p>文法（语法）描述</p><p>给出生成语言中所有句子的方法（文法），而且只生成合格的句子，形式文法是一种语言的文法是一种格式，说明什么句子在该语言中是合法的，并指明把词组合成短语和子句的规则。</p></li><li><p>自动机</p><p>对输入的语符序列进行检验，区别哪些是语言中的句子，哪些不是语言中的句子</p></li></ul><p><strong>文法</strong>用来<strong>生成</strong>语言的句子，属于<a href = "#formal grammar">形式语法</a>理论；<strong>自动机</strong>用来<strong>识别</strong>语言的句子,属于自动机理论</p><p><strong>形式语法</strong><a name = "formal grammar"></a></p><ul><li><strong>形式语法特点</strong></li></ul><p>高度形式化和抽象化，是一套演绎系统。（从S出发，依靠有限数量的规则，在有限数量的词汇<br>的基础上，可以产生出无限数量的丰富多彩的句子或终端符序列。）</p><ul><li><p><strong>形式语法的类型（四种文法之间的关系是逐级包含关系，0型包含1型，1型包含2型，2型包含3型）</strong></p><ul><li><p><strong>3型文法–正则文法</strong></p><p>特点：与2型文法相比，多出的限制是规则右侧最多只能有一个非终端语符紧跟在终端语符的后面<br>$$<br>形式语法G&#x3D;&lt;V_N,V_T,P,S&gt;<br>\ S:表示起始符, S∈V_N;V_N:非终端语符集;V_T:终端语符集,;P表示重写规则集,V&#x3D;V_N∪V_T.<br>\ \ 如果文法G的规则集P中所有规则满足如下形式,则称该文法G为3型文法,形式如下：<br>\ A →Bx, 其中:A,B∈V_N;\ x ∈ V_T<br>$$</p></li></ul><p>$$<br>例子：<br>\ G2&#x3D;&lt;V_N,V_T,P,S&gt;,其中 V_N&#x3D;{S,A,B,C}, V_T&#x3D;{a,b,c}<br>\ P由下列规则组成：<br>S→ABC;\ A→aA;\ A→a;\ B→Bb;\ B→b<br>$$</p><ul><li><p><strong>2型文法–上下文无关文法</strong></p><p>特点：与1型文法相比，多出的限制是α和β必须是“空”的(因为规则的左边必须是非终结符)，即非终结语符的改写不受它出现的语境制约。<br>$$<br>形式语法G&#x3D;&lt;V_N,V_T,P,S&gt;<br>\ S:表示起始符, S∈V_N;V_N:非终端语符集;V_T:终端语符集,;P表示重写规则集,V&#x3D;V_N∪V_T. \ \<br>如果P每个产生式可以描述为A→α,其中A是非终结符，α是空或多个终结符和非终结符的序列<br>\ \ 字符串中A被改写时，不需要上下文语境，体现<br>了上下文无关的含义(物理意义的理解)<br>$$</p></li></ul><p>$$<br>例子:<br>\ G1&#x3D;&lt;V_N,V_T,P,S&gt;<br>\ 其中 V_N&#x3D;{S,A,B,C}, V_T&#x3D;{a,b,c}<br>\ P由下列规则组成：S→ABC;\ A→aA;\ A→a;\ B→Bb;\ B→b<br>$$</p><ul><li><p><strong>1型文法–上下文相关文法</strong></p><p>特点：与0型文法相比，每条规则箭头的左侧只能有一个非终端语符被改写，而且它的改写与上下文有关.<br>$$<br>形式语法G&#x3D;&lt;V_N,V_T,P,S&gt;<br>\ S:表示起始符, S∈V_N;V_N:非终端语符集;V_T:终端语符集,;P表示重写规则集,V&#x3D;V_N∪V_T. \ \<br>如果文法中的所有规则满足如下形式,则称该文法G为1型文法，形式如下： \<br>αAβ →αγβ，其中:<br>A ∈V_N;\ α,β ∈ V^*(即V中零个或多个符号序列);\ 且γ至少包含一个字符<br> \ \ 字符串中A被改写时，需要上文语境α和下文语境β，体现了上下文相关的含义(物理意义的理解)<br>$$</p></li></ul><p>$$<br>例子:<br>\ G1&#x3D;&lt;V_N,V_T,P,S&gt;<br>\ 其中 V_N&#x3D;{S,A,B,C}, V_T&#x3D;{a,b,c}<br>\ P由下列规则组成：<br>S→ABC;\ A→a A | a;\ B→b B|b;\ BC→Bcc<br>\ 该文法所识别的语言为：<br>L(G)&#x3D;{a^nb^mc^2}, n&gt;&#x3D;1, m&gt;&#x3D;1<br>$$</p><ul><li><p><strong>0型文法–无约束文法</strong></p><p>特点：规则部分不加任何限制，可以生成任意句子<br>$$<br>形式语法G&#x3D;&lt;V_N,V_T,P,S&gt; \<br>S:表示起始符, S∈V_N;V_N:非终端语符集;V_T:终端语符集,;P表示重写规则集,V&#x3D;V_N∪V_T. \ \<br>如果文法中的所有规则满足如下形式,则称该文法G为0型文法，形式如下： \<br>α → β，其中: \<br>α ∈ V^+(V的正闭包，即V中一个或多个符号序列),\β∈V^*(V的自反闭包,即V中零个或多个符号序列)<br>$$</p></li></ul></li></ul><p>$$<br>例子(该文法将产生所有非负整数)： \<br>G&#x3D;&lt;V_N,V_T,P,S&gt;，其中 V_N&#x3D;{S,D}, V_T&#x3D;{0,1,2,3,…,9} \<br>P&#x3D;{S→D|SD;\ D→0|1|2|3|4|5|6|7|8|9}<br> \ 解析：S→D; S→SD→DD; S→SD→SDD→DDD…<br>$$</p><p><strong>总结</strong><br>从描述能力上说，上下文无关语法不足以描述自然语言，自然语言中上下文相关的情况非常常见； 从计算复杂度来说，上下文无关语法的复杂度是多项式的，其复杂度可以忍受。为弥补上下文无关语法描述能力的不足，需要加上一些其他手段扩充其描述能力。<strong>（这里主要涉及2型文法）</strong>3型文法生成句子是严格顺着一个方向扩展。</p><h4 id="句法分析相关概念"><a href="#句法分析相关概念" class="headerlink" title="句法分析相关概念"></a>句法分析相关概念</h4><p>**句法分析(syntatic parsing)**：自然语言处理中的关键技术之一，其基本任务是确定句子的句法结构或句子中词汇之间的依存关系。 </p><p><strong>句法分析器（Syntactic Parser）</strong>：是自然语言处理（NLP）中的一个关键组件，用于分析文本的句法结构，即文本中单词和短语之间的语法关系。句法分析器的主要任务是确定文本中的句子是如何构建的，包括词法分析、短语结构分析和句法依存分析。</p><p><strong>句法分析分类</strong></p><ul><li><p>句法结构分析(syntatic structure parsing)</p><ul><li>成分结构分析(constituent structure parsing)</li><li>短语结构分析(phrase structure parsing)</li></ul></li><li><p>依存关系分析(dependency parsing)</p></li></ul><p><em>不同语法形式对应的句法分析不尽相同：基于短语结构语法的句法分析以及基于依存关系语法的依存句法分析</em></p><p>另一种分类</p><ul><li><p>完全句法分析 或 完全短语结构分析：</p><p>获取整个句子的句法结构</p><p>Full syntactic parsing ；Full phrase structure parsing；Full parsing</p></li><li><p>浅层句法分析 (partial parsing)</p><p>获得局部成分(如名词短语)的句法分析</p></li></ul><p><strong>依存语法</strong>：又称从属关系语法，便于计算机对自然语言进行处理</p><p>所谓依存是指词与词之间支配与被支配的关系,是一种有方向的不对等关系.处于支配地位的成分成为支配者<br>(government,head),处于被支配地位的成分成为从属者(modifier,dependency)。在依存结构图中，依存语法的支配者和从属者被描述为head和dependency，支配和被支配的关系用带有方向的边来表示。</p><p><strong>基于依存语法的依存句法分析</strong></p><p>分析图片来源：<a href="https://www.ltp-cloud.com/">语言云（语言技术平台云 LTP-Cloud）</a></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311072344927.png" alt="image-20231107230440197"></p><p><strong>基于短语结构语法的句法分析</strong></p><p>短语结构语法，如基于上下文无关语法的短语结构树句法分析。（主要涉及上下文无关语法）</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311072344072.png" alt="image-20231107230646255"></p><p><strong>基本策略</strong></p><p>一个句法分析可以表述为一个搜索过程，搜索空间是语法规则，搜索过程是检查各种语法规则所有可能的组合方式，目的是最终找到一种组合，其中的语法规则能够生成一棵用来表示句子结构的句法树。</p><p>句法分析常用策略有：</p><ul><li>自顶向下分析法（这里讲解）；</li><li>自底向上分析法；</li><li>左角分析法；</li><li>其他策略。</li></ul><p>句法分析的过程也可以理解为句法树的构造过程；所谓自顶向下分析法也就是先构造句法树的根结点，再逐步向下扩展，直到叶结点；所谓自底向上分析法也就是先构造句法树的叶结点，再逐步向上合并，直到根结点。</p><p><strong>自顶向下算法描述：</strong></p><p>1.初始当前状态为((s) 1)记为C，候选状态为空；<br>2.当算法未失败且算法未成功，则重复：<br>    (1)若C是空字符列且词位置到了句尾，则算法成功，返回。<br>    (2)若当前状态和候选状态都为空，且词未知未到句尾，则算法失败，返回。否则，产生新状态：<br>        • 若C中字符列的第一个字符是句子中下一个词的词类，则从字符列中移去第一个字符，并修改词位置，修改后的状态为当前状态，记为C，转(2)。<br>        • 若C中字符列的第一个字符是非终止符β，用语法中能重写β的每个规则产生新状态，产生的第一个状态为当<br>前状态（记为C)，产生的其它状态加入到候选状态的栈顶，转（2）.<br>        • 否则，回溯，从候选状态中取出栈顶作为当前状态。</p><p><strong>自顶向下分析算法示例：</strong></p><table><thead><tr><th>初始状态</th><th>候选状态</th><th>comment备注</th></tr></thead><tbody><tr><td>((S)1)</td><td></td><td></td></tr><tr><td>((NP VP)1)</td><td></td><td></td></tr><tr><td>((ART N VP)1)</td><td>((ART ADJ N VP)1)</td><td>匹配the，修改初始状态为下一行初始状态</td></tr><tr><td>((N VP)2)</td><td></td><td>匹配old</td></tr><tr><td>((VP)3)</td><td></td><td></td></tr><tr><td>((V)3)</td><td>((V NP)3)</td><td>匹配man</td></tr><tr><td>(()4)</td><td></td><td>为空但是未到词尾，回溯，从候选状态栈弹出一个状态</td></tr><tr><td>((V NP)3)</td><td></td><td>匹配man</td></tr><tr><td>((NP)4)</td><td></td><td>匹配失败，回溯</td></tr><tr><td>((ART ADJ N VP)1)</td><td></td><td>匹配the</td></tr><tr><td>((ADJ N VP)2)</td><td></td><td>匹配old</td></tr><tr><td>((N VP)3)</td><td></td><td>匹配man</td></tr><tr><td>((VP)4)</td><td></td><td></td></tr><tr><td>((V)4)</td><td>((V NP)4)</td><td>匹配cried</td></tr><tr><td>(()5)</td><td></td><td>成功</td></tr></tbody></table><h4 id="基于规则的句法分析"><a href="#基于规则的句法分析" class="headerlink" title="基于规则的句法分析"></a>基于规则的句法分析</h4><p>使用手工定义的语法规则和规则匹配算法来分析句子结构。这需要领域专家手动创建规则，因此适用于特定领域或语言。上面的自顶向上就是一种基于规则的句法分析。</p><p><strong>缺点：</strong></p><p>计算量大，情况复杂，一些情况下回溯可能很多，不太合理</p><p>Top-Down Parsing: 从起始符开始搜索派生空间<br>Bottom-up Parsing:从终止符开始，反向搜索派生空间<br>• 属于全搜索，时间复杂度高，不够灵活</p><h4 id="基于统计的句法分析"><a href="#基于统计的句法分析" class="headerlink" title="基于统计的句法分析"></a>基于统计的句法分析</h4><p>用统计方法和机器学习算法从大量已标注的语料库中学习语法结构。常见的方法包括基于PCFG（Probabilistic Context-Free Grammar）的方法和基于依存关系的方法。</p><p><strong>分析：</strong></p><p>自顶向下算法最坏情况下需要回溯多次，算法优化方面依然是使用基于使用动态规划思想的句法分析算法，这类算法有CKY、Earley Parser、Chart Parsers，这里主要介绍的是CKY算法。</p><ul><li><p>CKY (Cocke-Kasami-Younger) </p><p> 基于自底向上的句法分析算法CKY，该算法需要首先规范化语法。</p></li><li><p>Earley Parser</p><p>基于自顶向下的句法分析算法Earley算法，该算法部需要规范化语法。</p></li><li><p>Chart Parsers</p></li></ul><p>  线图算法，它在图表中完整保留短语，并且可以组合自顶向下和自底向上搜索策略。</p><h5 id="CKY算法"><a href="#CKY算法" class="headerlink" title="CKY算法"></a>CKY算法</h5><p><strong>相关内容：</strong></p><ul><li><p>上下文无关文法(CFG)</p></li><li><p>乔姆斯基范式(Chomsky normal form,CNF)</p><p>在该范式中，产生式只有2个非终端语符或者1个终端语符。</p></li></ul><p><strong>思想：</strong></p><p>为了方便实现自底向上的运算，CKY算法首先需要将CFG文法转换为乔布斯基范式</p><p>详细思路可以通过下面博客查看，下面记录一下老师上课讲的<strong>乔布斯基范式CNF的转换</strong></p><p><a href="https://blog.csdn.net/qq_39378221/article/details/103788893?ops_request_misc=%7B%22request_id%22:%22170058410216800226552953%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170058410216800226552953&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-103788893-null-null.142%5Ev96%5Epc_search_result_base9&utm_term=cyk&spm=1018.2226.3001.4187">句法分析——CYK分析算法_cyk算法-CSDN博客</a></p><p>$$<br>给定一个句子s &#x3D; w_1,w_2,…,w_3,和一个上下文无关文法PCFG,G&#x3D;(T,S,R,P)<br>\ 定义一个跨越单词i到j的概率最大的语法成分π:π(i,j,X)(i,j∈1…N,X∈N),<br>\ 目标是找到一个属于π[1,n,s]中所有树中概率最大的那棵。<br>\ \ CYK算法用于PCFG下的句法分析:<br>\ ·基本定义:for\ all\ i&#x3D;1,…,n,X∈N<br>\ π(i,i,X)&#x3D;q(X→w_i) (if\ X → w_i 没有出现在语法中，则定义q(X → w_i)&#x3D;0)<br>\ ·递归定义:for\ all\ i&#x3D;1,…,n, j&#x3D;(i+1),…,n, X ∈N<br>\ π(i,j,X)&#x3D;max(q(X→YZ)×π(i,k,Y)×π(k+1,j,Z)) (i≤k≤j−1)<br>$$</p><p><strong>乔布斯基范式CNF的转换：</strong></p><ol><li>递归删除空</li><li>递归删除一元</li><li>对于规则中右边有超过2个非终结符时，则引入新的非终结符来处理</li></ol><p>（注意递归的概念）</p><ol><li><p>将NP以空替换其他规则（递归删除空）</p><p>注意一次只能改写一个</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311220831046.png" alt="image-20231119164857317"></p></li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311220831095.png" alt="image-20231119164916995"></p><p>紫色部分表示用<code>NP-&gt;empty</code>将原来的<code>S-&gt;NP VP</code>替换成了<code>S-&gt;VP</code></p><ol start="2"><li><p>递归处理一元</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311220831281.png" alt="image-20231119223512972"></p><p>像这里第一个一元就是<code>S-&gt;VP</code>，第一个要处理的就是这个，可以得到右边紫色的结果，最后所有的结果如下</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311220831640.png" alt="image-20231119223717804"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311220831015.png" alt="image-20231119223737957"></p></li></ol><p>接着就是处理第二个一元<code>S-&gt;V</code>，之后同理一直处理一元</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311220832161.png" alt="image-20231119223939110"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311220832596.png" alt="image-20231119223950260"></p><p>处理完的结果如下：</p><p><img src="C:\Users\GTR\AppData\Roaming\Typora\typora-user-images\image-20231119223958338.png" alt="image-20231119223958338"></p><ol start="3"><li><p>递归处理三元及以上结果</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311220832975.png" alt="image-20231119224136022"></p></li></ol><p><strong>分析</strong><br>$$<br>时间复杂度：<br>\有 (n(n+1)&#x2F;2) &#x3D; O(n^2) 格子<br>\有 O(n) 个可能的分裂点<br>\总的时间复杂度为 O(n^3)<br>\并且可能存在多个句法树的情况，没有局部最优的概念，下面引进的概率就是解决相关问题的<br>$$</p><h5 id="概率CKY统计句法分析算法"><a href="#概率CKY统计句法分析算法" class="headerlink" title="概率CKY统计句法分析算法"></a>概率CKY统计句法分析算法</h5><p><strong>相关概念</strong></p><p>上下文无关文法CFG</p><p>概率上下文无关文法PCFG</p><p><strong>理解</strong></p><p>无概率的CFG分析符合语法的句子，答案只有两个：是或不是；基于概率上下文无关文法PCFG，则是分析符合语法的句子的可能性，即为一个概率值。</p><h5 id="扩展CKY句法分析算法"><a href="#扩展CKY句法分析算法" class="headerlink" title="扩展CKY句法分析算法"></a>扩展CKY句法分析算法</h5><p>这个其实就是上面的概率CKY统计句法分析算法在书写代码中的变种，这里主要讲这种。</p><p>在这种算法书写思路中一元可以整合进入算法，虽然使得语法有点凌乱，但是并不增加算法的复杂度，空也可以整合进入算法，和一元一样，并不增加算法的复杂度</p><p><strong>理解和分析（可以看看其中例题的分析过程）</strong></p><p>这份博客的作者应该是广外毕业的，毕竟昵称很直接</p><p><a href="https://blog.csdn.net/Chase1998/article/details/84504191?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%9F%BA%E4%BA%8Ecyk+PCFG&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-84504191.142%5Ev96%5Epc_search_result_base9&spm=1018.2226.3001.4187">基于CYK+PCFG的短语结构句法分析-CSDN博客</a></p><p><strong>个人代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核心类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCKY</span>:</span><br><span class="line">    <span class="comment"># tuple_all保存所有出现的语符序列</span></span><br><span class="line">    <span class="comment"># tuple_one保存一元，如其中一个元素为(0.1, &#x27;S&#x27;, &#x27;VP&#x27;)表示&#x27;S-&gt;VP 0.1&#x27;</span></span><br><span class="line">    <span class="comment"># tuple_two保存二元，如其中一个元素为(0.9, &#x27;S&#x27;, (&#x27;NP&#x27;, &#x27;VP&#x27;))表示&#x27;S-&gt;NP VP 0.9&#x27;</span></span><br><span class="line">    <span class="comment"># tuple_over保存终端语符号,如其中一个元素(0.5, &#x27;N&#x27;, &#x27;people&#x27;)表示&#x27;N-&gt;people 0.5&#x27;</span></span><br><span class="line">    <span class="comment"># statement为需要分析的句子</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, tuple_one, tuple_two, tuple_over, statement</span>):</span><br><span class="line">        self.tuple_one = tuple_one</span><br><span class="line">        self.tuple_two = tuple_two</span><br><span class="line">        self.tuple_over = tuple_over</span><br><span class="line">        self.statement = statement.split(<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 切分字符串得到列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理过程，主方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self</span>):</span><br><span class="line">        len_s = <span class="built_in">len</span>(self.statement)  <span class="comment"># 字符串词数</span></span><br><span class="line">        <span class="comment"># 创建记录矩阵</span></span><br><span class="line">        matrix = [[<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(len_s)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(len_s)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 叶子节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_s):</span><br><span class="line">            list_add = []  <span class="comment"># 保存添加的值</span></span><br><span class="line">            <span class="comment"># index_start保存本次开始坐标，index_end保存本次结束坐标，遍历过的下次不遍历</span></span><br><span class="line">            index_start = <span class="number">0</span></span><br><span class="line">            index_end = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 终端语符</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> self.tuple_over:</span><br><span class="line">                <span class="keyword">if</span> j[<span class="number">2</span>] == self.statement[i]:</span><br><span class="line">                    <span class="comment"># 记录以回溯,叶子节点的终端语符记录为None</span></span><br><span class="line">                    temp = <span class="built_in">list</span>(j)</span><br><span class="line">                    temp.append(<span class="literal">None</span>)</span><br><span class="line">                    list_add.append(temp)</span><br><span class="line">                    index_end += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 一元</span></span><br><span class="line">            <span class="keyword">while</span> index_start &lt; index_end:</span><br><span class="line">                last_index_end = index_end  <span class="comment"># 遍历过的下次不遍历，保存上次的结束坐标，待会赋值给开始坐标</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> self.tuple_one:</span><br><span class="line">                    <span class="comment"># 修改概率，相乘</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(index_start, index_end):</span><br><span class="line">                        <span class="keyword">if</span> j[<span class="number">2</span>] == list_add[k][<span class="number">1</span>]:</span><br><span class="line">                            temp = <span class="built_in">list</span>(j)</span><br><span class="line">                            temp[<span class="number">0</span>] *= list_add[k][<span class="number">0</span>]  <span class="comment"># 更改概率</span></span><br><span class="line">                            <span class="comment"># 记录以回溯,叶子节点的一元加入的记录为本位置[i,i]</span></span><br><span class="line">                            temp.append([i, i])</span><br><span class="line">                            index_end += <span class="number">1</span></span><br><span class="line">                            list_add.append(temp)</span><br><span class="line">                index_start = last_index_end</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 填入</span></span><br><span class="line">            matrix[i][i] = list_add</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印叶子节点处理结果</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_s):</span><br><span class="line">            <span class="built_in">print</span>(matrix[i][i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 非叶子节点</span></span><br><span class="line">        step = <span class="number">1</span></span><br><span class="line">        <span class="comment"># t控制循环次数，也就是列数-1</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(len_s - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_s - step):</span><br><span class="line">                <span class="comment"># 根据横纵坐标关系确认当前处理的点 j = i + step</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 保存添加的值</span></span><br><span class="line">                list_add = []</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 切分的下标</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, i + step):</span><br><span class="line">                    list1 = matrix[i][k]</span><br><span class="line">                    list2 = matrix[k + <span class="number">1</span>][i + step]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 从二元中看哪个能推导出来</span></span><br><span class="line">                    <span class="keyword">for</span> i1 <span class="keyword">in</span> list1:</span><br><span class="line">                        <span class="keyword">for</span> j1 <span class="keyword">in</span> list2:</span><br><span class="line">                            <span class="keyword">for</span> k1 <span class="keyword">in</span> self.tuple_two:</span><br><span class="line">                                <span class="keyword">if</span> k1[<span class="number">2</span>][<span class="number">0</span>] == i1[<span class="number">1</span>] <span class="keyword">and</span> k1[<span class="number">2</span>][<span class="number">1</span>] == j1[<span class="number">1</span>]:</span><br><span class="line">                                    temp = <span class="built_in">list</span>(k1)</span><br><span class="line">                                    temp[<span class="number">0</span>] *= (i1[<span class="number">0</span>] * j1[<span class="number">0</span>])</span><br><span class="line">                                    <span class="comment"># 记录回溯，二元保存两个分支的来源</span></span><br><span class="line">                                    temp.append([i, k])</span><br><span class="line">                                    temp.append([k + <span class="number">1</span>, i + step])</span><br><span class="line"></span><br><span class="line">                                    <span class="comment"># 下面遍历list_add以保存最大概率的决定值相同的</span></span><br><span class="line">                                    <span class="keyword">if</span> <span class="built_in">len</span>(list_add) == <span class="number">0</span>:</span><br><span class="line">                                        list_add.append(temp)</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">for</span> t1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list_add)):</span><br><span class="line">                                        <span class="comment"># 找到相同的决定项就能break了，保证唯一，走到最后就直接加进去就行</span></span><br><span class="line">                                        <span class="keyword">if</span> list_add[t1][<span class="number">1</span>] == temp[<span class="number">1</span>]:</span><br><span class="line">                                            <span class="keyword">if</span> temp[<span class="number">0</span>] &gt; list_add[t1][<span class="number">0</span>]:</span><br><span class="line">                                                <span class="comment"># 修改以回溯</span></span><br><span class="line">                                                list_add[t1] = temp</span><br><span class="line"></span><br><span class="line">                                            <span class="keyword">break</span></span><br><span class="line">                                        <span class="keyword">if</span> t1 == <span class="built_in">len</span>(list_add) - <span class="number">1</span>:</span><br><span class="line">                                            list_add.append(temp)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 从一元中再寻找是否有决定值一样的且能推导出且概率大的</span></span><br><span class="line">                <span class="keyword">for</span> i1 <span class="keyword">in</span> self.tuple_one:</span><br><span class="line">                    <span class="keyword">for</span> j1 <span class="keyword">in</span> list_add:</span><br><span class="line">                        <span class="keyword">if</span> i1[<span class="number">1</span>] == j1[<span class="number">1</span>]:</span><br><span class="line">                            <span class="comment"># 能够推导的</span></span><br><span class="line">                            <span class="keyword">for</span> k1 <span class="keyword">in</span> list_add:</span><br><span class="line">                                <span class="keyword">if</span> i1[<span class="number">2</span>] == k1[<span class="number">1</span>] <span class="keyword">and</span> i1[<span class="number">0</span>] * k1[<span class="number">0</span>] &gt; j1[<span class="number">0</span>]:</span><br><span class="line">                                    temp = <span class="built_in">list</span>(i1)</span><br><span class="line">                                    temp[<span class="number">0</span>] = i1[<span class="number">0</span>] * k1[<span class="number">0</span>]</span><br><span class="line">                                    <span class="comment"># 记录回溯，一元替换把之前的删除了并把回溯记录为当前节点</span></span><br><span class="line">                                    temp.append([i, i + step])</span><br><span class="line">                                    list_add.append(temp)</span><br><span class="line">                                    list_add.remove(j1)  <span class="comment"># 移除概率小的</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(list_add)</span><br><span class="line">                matrix[i][i + step] = list_add</span><br><span class="line"></span><br><span class="line">            step += <span class="number">1</span>  <span class="comment"># 每次循环step+1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理最后一层找到概率最大放入递归回溯</span></span><br><span class="line">        <span class="built_in">max</span> = <span class="number">0</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        list1 = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> matrix[<span class="number">0</span>][len_s - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> i[<span class="number">0</span>] &gt; <span class="built_in">max</span>:</span><br><span class="line">                <span class="built_in">max</span> = i[<span class="number">0</span>]</span><br><span class="line">                index = matrix[<span class="number">0</span>][len_s - <span class="number">1</span>].index(i)</span><br><span class="line">        list1.append(matrix[<span class="number">0</span>][len_s - <span class="number">1</span>][index])</span><br><span class="line"></span><br><span class="line">        self.backtrack(matrix, <span class="number">0</span>, list1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># list1表示本层的list，顶节点需要先找出概率最大放到list1传入</span></span><br><span class="line">    <span class="comment"># t表示树的第几层</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">self, matrix, t, list1</span>):</span><br><span class="line">        <span class="comment"># print(t)</span></span><br><span class="line">        <span class="comment"># 不是所有都为None就继续，所有为空就结束</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list1)):</span><br><span class="line">            <span class="keyword">if</span> list1[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(list1) - <span class="number">1</span> <span class="keyword">and</span> list1[i] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>()  <span class="comment"># 回车</span></span><br><span class="line">        <span class="comment"># 保存下一层</span></span><br><span class="line">        list_temp = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> ** (t + <span class="number">1</span>))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> ** t):</span><br><span class="line">            <span class="comment"># 输出并保存下一层的值</span></span><br><span class="line">            <span class="keyword">if</span> list1[i] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="literal">None</span>, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(list1[i]) == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> list1[i][<span class="number">3</span>] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="built_in">print</span>(list1[i][<span class="number">1</span>], end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;(&#x27;</span> + list1[i][<span class="number">2</span>] + <span class="string">&#x27;)&#x27;</span>, end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(list1[i][<span class="number">1</span>], end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">                    list_temp[i * <span class="number">2</span>] = self.getRightList(matrix, list1[i][<span class="number">2</span>][<span class="number">0</span>], list1[i][<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(list1[i]) == <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">print</span>(list1[i][<span class="number">1</span>], end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">                list_temp[i * <span class="number">2</span>] = self.getRightList(matrix, list1[i][<span class="number">2</span>][<span class="number">0</span>], list1[i][<span class="number">3</span>])</span><br><span class="line">                list_temp[i * <span class="number">2</span> + <span class="number">1</span>] = self.getRightList(matrix, list1[i][<span class="number">2</span>][<span class="number">1</span>], list1[i][<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">        self.backtrack(matrix, t + <span class="number">1</span>, list_temp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过坐标寻找matrix的块中正确的值</span></span><br><span class="line">    <span class="comment"># list1存储坐标</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRightList</span>(<span class="params">self, matrix, target, list1</span>):</span><br><span class="line">        list_all = matrix[list1[<span class="number">0</span>]][list1[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list_all:</span><br><span class="line">            <span class="keyword">if</span> i[<span class="number">1</span>] == target:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试用例</span></span><br><span class="line"><span class="keyword">from</span> Homewrok3.PCKY <span class="keyword">import</span> PCKY</span><br><span class="line"></span><br><span class="line">tuple_one = (</span><br><span class="line">    (<span class="number">0.1</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;VP&#x27;</span>),</span><br><span class="line">    (<span class="number">0.1</span>, <span class="string">&#x27;VP&#x27;</span>, <span class="string">&#x27;V&#x27;</span>),</span><br><span class="line">    (<span class="number">0.7</span>, <span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">tuple_two = (</span><br><span class="line">    (<span class="number">0.9</span>, <span class="string">&#x27;S&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;VP&#x27;</span>)),</span><br><span class="line">    (<span class="number">0.5</span>, <span class="string">&#x27;VP&#x27;</span>, (<span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>)),</span><br><span class="line">    (<span class="number">0.3</span>, <span class="string">&#x27;VP&#x27;</span>, (<span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;@VP_V&#x27;</span>)),</span><br><span class="line">    (<span class="number">0.1</span>, <span class="string">&#x27;VP&#x27;</span>, (<span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;PP&#x27;</span>)),</span><br><span class="line">    (<span class="number">1.0</span>, <span class="string">&#x27;@VP_V&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;PP&#x27;</span>)),</span><br><span class="line">    (<span class="number">0.1</span>, <span class="string">&#x27;NP&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>)),</span><br><span class="line">    (<span class="number">0.2</span>, <span class="string">&#x27;NP&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;PP&#x27;</span>)),</span><br><span class="line">    (<span class="number">1.0</span>, <span class="string">&#x27;PP&#x27;</span>, (<span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">tuple_over = (</span><br><span class="line">    (<span class="number">0.5</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;people&#x27;</span>),</span><br><span class="line">    (<span class="number">0.2</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>),</span><br><span class="line">    (<span class="number">0.2</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;tanks&#x27;</span>),</span><br><span class="line">    (<span class="number">0.1</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;rods&#x27;</span>),</span><br><span class="line">    (<span class="number">0.1</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;people&#x27;</span>),</span><br><span class="line">    (<span class="number">0.6</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>),</span><br><span class="line">    (<span class="number">0.3</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;tanks&#x27;</span>),</span><br><span class="line">    (<span class="number">1.0</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;with&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pcky = PCKY(tuple_one, tuple_two, tuple_over, <span class="string">&#x27;fish people fish tanks&#x27;</span>)</span><br><span class="line">pcky.solve()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许结果如图</span></span><br><span class="line">[[<span class="number">0.2</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>, <span class="literal">None</span>], [<span class="number">0.6</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>, <span class="literal">None</span>], [<span class="number">0.06</span>, <span class="string">&#x27;VP&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, [<span class="number">0</span>, <span class="number">0</span>]], [<span class="number">0.13999999999999999</span>, <span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, [<span class="number">0</span>, <span class="number">0</span>]], [<span class="number">0.006</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;VP&#x27;</span>, [<span class="number">0</span>, <span class="number">0</span>]]]</span><br><span class="line">[[<span class="number">0.5</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;people&#x27;</span>, <span class="literal">None</span>], [<span class="number">0.1</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;people&#x27;</span>, <span class="literal">None</span>], [<span class="number">0.010000000000000002</span>, <span class="string">&#x27;VP&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, [<span class="number">1</span>, <span class="number">1</span>]], [<span class="number">0.35</span>, <span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, [<span class="number">1</span>, <span class="number">1</span>]], [<span class="number">0.0010000000000000002</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;VP&#x27;</span>, [<span class="number">1</span>, <span class="number">1</span>]]]</span><br><span class="line">[[<span class="number">0.2</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>, <span class="literal">None</span>], [<span class="number">0.6</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>, <span class="literal">None</span>], [<span class="number">0.06</span>, <span class="string">&#x27;VP&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, [<span class="number">2</span>, <span class="number">2</span>]], [<span class="number">0.13999999999999999</span>, <span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, [<span class="number">2</span>, <span class="number">2</span>]], [<span class="number">0.006</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;VP&#x27;</span>, [<span class="number">2</span>, <span class="number">2</span>]]]</span><br><span class="line">[[<span class="number">0.2</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;tanks&#x27;</span>, <span class="literal">None</span>], [<span class="number">0.3</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;tanks&#x27;</span>, <span class="literal">None</span>], [<span class="number">0.03</span>, <span class="string">&#x27;VP&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, [<span class="number">3</span>, <span class="number">3</span>]], [<span class="number">0.13999999999999999</span>, <span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, [<span class="number">3</span>, <span class="number">3</span>]], [<span class="number">0.003</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;VP&#x27;</span>, [<span class="number">3</span>, <span class="number">3</span>]]]</span><br><span class="line">[[<span class="number">0.105</span>, <span class="string">&#x27;VP&#x27;</span>, (<span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>), [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]], [<span class="number">0.0049</span>, <span class="string">&#x27;NP&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>), [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]], [<span class="number">0.0105</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;VP&#x27;</span>, [<span class="number">0</span>, <span class="number">1</span>]]]</span><br><span class="line">[[<span class="number">0.006999999999999999</span>, <span class="string">&#x27;VP&#x27;</span>, (<span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>), [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]], [<span class="number">0.0189</span>, <span class="string">&#x27;S&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;VP&#x27;</span>), [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]], [<span class="number">0.0049</span>, <span class="string">&#x27;NP&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>), [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]]]</span><br><span class="line">[[<span class="number">0.041999999999999996</span>, <span class="string">&#x27;VP&#x27;</span>, (<span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>), [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]], [<span class="number">0.0019599999999999995</span>, <span class="string">&#x27;NP&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>), [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]], [<span class="number">0.0042</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;VP&#x27;</span>, [<span class="number">2</span>, <span class="number">3</span>]]]</span><br><span class="line">[[<span class="number">0.00147</span>, <span class="string">&#x27;VP&#x27;</span>, (<span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>), [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>]], [<span class="number">0.0008819999999999998</span>, <span class="string">&#x27;S&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;VP&#x27;</span>), [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>]], [<span class="number">6.859999999999999e-05</span>, <span class="string">&#x27;NP&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>), [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>]]]</span><br><span class="line">[[<span class="number">9.799999999999998e-05</span>, <span class="string">&#x27;VP&#x27;</span>, (<span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>), [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]], [<span class="number">0.013229999999999999</span>, <span class="string">&#x27;S&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;VP&#x27;</span>), [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]], [<span class="number">6.859999999999999e-05</span>, <span class="string">&#x27;NP&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>), [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]]]</span><br><span class="line">[[<span class="number">2.0579999999999996e-05</span>, <span class="string">&#x27;VP&#x27;</span>, (<span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>), [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">3</span>]], [<span class="number">0.00018521999999999996</span>, <span class="string">&#x27;S&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;VP&#x27;</span>), [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]], [<span class="number">9.603999999999997e-07</span>, <span class="string">&#x27;NP&#x27;</span>, (<span class="string">&#x27;NP&#x27;</span>, <span class="string">&#x27;NP&#x27;</span>), [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">3</span>]]]</span><br><span class="line"></span><br><span class="line">S</span><br><span class="line">NPVP</span><br><span class="line">NPNPV(fish)NP</span><br><span class="line">N(fish)<span class="literal">None</span>N(people)<span class="literal">None</span><span class="literal">None</span><span class="literal">None</span>N(tanks)<span class="literal">None</span></span><br></pre></td></tr></table></figure><p><strong>这里最终输出的句法树可能有点难理解，这里解释一下，就是层次遍历的去看，第一层节点为S，第二层为NP VP，第三层为NP NP V NP，以此类推，最中每层都跟上层形成二叉树的连接即可，None为空，也就是不存在，后面带括号的，如V(fish)表示V后直接再接一个fish即可</strong></p><p><strong>总结</strong></p><p>CKY算法在PCFG下的改进算法(PCKY)，其优点在于：</p><ul><li><p>存储局部最优语法成分；</p></li><li><p>搜索空间减少；</p></li><li><p>获得结果更为准确的句法树。</p></li></ul><p>缺点：依赖于上下文无关文法PCFG，而大规模这样的语法实际是比较难以人工标注的。</p><p><strong>最后，基于同一个语句生成的不同句法分析树哪个更符合语言需求就是后面的语义分析</strong></p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><h2 id="应用部分"><a href="#应用部分" class="headerlink" title="应用部分"></a>应用部分</h2><h3 id="2023自然语言处理大作业"><a href="#2023自然语言处理大作业" class="headerlink" title="2023自然语言处理大作业"></a>2023自然语言处理大作业</h3><h4 id="本文算法"><a href="#本文算法" class="headerlink" title="本文算法"></a>本文算法</h4><h5 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h5><p><strong>中文纠错算法</strong></p><p>本系统中使用的中文文本纠错算法会根据输入词语返回词频最高的正确词语，也就是概率最大的可经过编辑操作获取到词语。</p><p>本算法结合了编辑距离算法思想，也就是一个拼写错误的字符串可以通过插入、删除、替换、交换转换成另一个可能为拼写正确的字符串；并且定义了一个规则，两个词语的拼音完全一样则优先级最高；两个词语第一个字的拼音完全一样则优先级次之，其余则优先级最低，再根据优先级高低去寻找词典中存在且词频最高的单词返回，这个单词就是返回的拼写正确的词语。</p><p><strong>倒排索引搜索</strong></p><p>本系统使用的倒排索引搜索算法主要是构建一个按照TF-IDF进行打分的倒排索引文件，而后对于每个搜索的词语在倒排索引文件中进行搜索，找到相关内容出现的page以及按照打分进行排序。</p><p>本算法首先会在对内容进行分词后统计词频生成倒排索引文件，而后会对每个词语索引进行TF-IDF打分，生成最终倒排索引文件。</p><h4 id="算法各模块描述"><a href="#算法各模块描述" class="headerlink" title="算法各模块描述"></a>算法各模块描述</h4><h5 id="中文纠错算法"><a href="#中文纠错算法" class="headerlink" title="中文纠错算法"></a>中文纠错算法</h5><p>​中文纠错算法本质就是拼写检查，其中最重要的思想就是莱文斯坦距离，又称Levenshtein距离，是编辑距离的一种。指两个字串之间，由一个转成另一个所需的最少编辑操作次数。允许的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。莱文斯坦距离以俄国科学家Vladimir levenshtein命名，他于1965年发明了这个算法。<br>$$<br>在数学上，两个字符串a,b的莱文斯坦距离记作lev_{a,b}(|a|,|b|)<br>$$</p><p>$$<br>lev_{a,b}(i,j)&#x3D;\begin{cases}<br>    \quad \quad \quad max(i,j)\quad \quad \quad \quad \quad \quad if min(i,j)&#x3D;0,\</p><pre><code>min\begin&#123;cases&#125;lev_&#123;a,b&#125;(i-1,j)+1\\lev_&#123;a,b&#125;(i,j-1)+1\\lev_&#123;a,b&#125;(i-1,j-1)+1_&#123;(a_i≠b_j)&#125;\end&#123;cases&#125;</code></pre><p>   otherwise</p><p>  \end{cases}<br>$$</p><p>$$<br>这里，|a|和|b|分别表示字符串a和b的长度,1_{(a_i≠b_j)}是当a_i≠b_j时值为1，否则值为0的示性函数。<br>\这样,lev_{a,b}(i,j)是a的前i个字符和b的前j个字符之间的距离。<br>$$</p><p>​</p><p><strong>下面是本算法的具体流程：</strong></p><p>①第一步：</p><p>首先需要读取数据集，第一个读取的数据集是词频词典phrase_freq，该词典中包含了许多的词语以及搜索的频次；第二个读取的数据集是中文字典cn_words_dict，该字典包含所有的中文汉字。</p><p>②第二步：</p><p>对于需要纠正的单词按照下标按照下标切分成为前后两块，L和R，其实就是分治思想，根据不同长度的词语会有许多组合，保存在splits列表中；</p><p>之后遍历删除R的第一个字，也就是删除其中任意一个字的所有组合保存到deletes列表中；</p><p>之后将满足长度的R的两个字进行交换，也就是其中两个字进行交换的所有组合保存到transposes列表中；</p><p>之后从字典中取一个字替换R中第一个字，也就是取一个字和其中任意一个字进行替换的所有组合保存到replaces列表中；</p><p>之后从字典中取出一个字去插入到L和R之间，也就是往词语中插入一个字的所有组合保存到inserts列表中；</p><p>最后通过set(deletes+transposes+replaces+inserts)借助Python的特性完成去重，得到所有可能的正确组合。</p><p>③第三步：</p><p>在得到所有可能的正确组合后，遍历并通过Pinyin库取得所有可能正确组合中的组合的拼音，并按照本系统定义的规则，与拼写错误的词语的拼音进行比较，</p><p>如果两者拼音相等则把该预测组合加入到一级数组，</p><p>剩余的组合中，如果两者的第一个字的拼音相等则把该预测组合加入到二级数组，</p><p>剩余的组合则直接全部加入到三级数组中。</p><p>④第四步：</p><p>从一级数组到三级数组进行遍历，对于每级数组都从词频词典phrase_freq查找是否存在该词语，遍历完成后保存频次最大且在词频词典中存在的词，这个就是一个拼写错误的词语进行纠正后的词语。</p><p>⑤第五步：</p><p>对于一个句子输入错误进行纠错，则会使用jieba库进行中文分词，得到分词列表，如果有的分词不能直接通过词频词典phrase_freq查询得到，那么就可以认定为拼写错误，就执行第二步到第四步得到正确拼写的词语。最后没有拼写错误的词语以及纠正错误的词语进行拼接就是正确的句子。</p><h5 id="倒排索引搜索"><a href="#倒排索引搜索" class="headerlink" title="倒排索引搜索"></a>倒排索引搜索</h5><p><strong>倒排索引</strong></p><p>倒排索引(Inverted index) 倒排索引是一种将词项映射到文档的数据结构，这与传统关系型数据库的工作方式不同。可以把倒排索引当做面向词项的而不是面向文档的数据结构。（倒排索引源于实际应用中需要根据属性的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)）</p><p>倒排索引：Inverted index，指的是将文档内容中的单词作为索引，将包含该词的文档 ID 作为记录的结构。</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312181618301.png"></p><p><strong>TF-IDF</strong></p><p>TF-IDF（term frequency–inverse document frequency）是一种用于资讯检索与资讯探勘的常用加权术。TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常被搜寻引擎应用，作为文件与用户查询之间相关程度的度量或评级。TF-IDF的主要思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。TF-IDF实际上是：TF * IDF，TF词频(Term Frequency)，IDF反文档频率(Inverse Document Frequency)。TF表示词条在文档d中出现的频率。IDF的主要思想是：如果包含词条t的文档越少，也就是n越小，IDF越大，则说明词条t具有很好的类别区分能力。如果某一类文档C中包含词条t的文档数为m，而其它类包含t的文档总数为k，显然所有包含t的文档数n&#x3D;m+k，当m大的时候，n也大，按照IDF公式得到的IDF的值会小，就说明该词条t类别区分能力不强。</p><p>$$<br>词频tf_{t,d}表示词t出现在文档d中的次数,则\<br>w_{t,d}&#x3D;\begin{cases}<br>1+log_{10}tf_{t,d}\ ,\quad if\ tf_{t,d}&gt;0\<br>\quad\quad\quad 0 \ ,\quad\quad\quad otherwise<br>\end{cases}<br>$$</p><p>$$<br>文档频率df_t是指包含词t的文档的总数,\<br>逆文档频率的定义为：\<br>idf_t &#x3D; log_{10}(\frac{N}{df_t})<br>$$</p><p>$$<br>那么一个词t的tf-idf权重值为：\<br>tf-idf_{t,d}&#x3D;(1+logtf_{t,d})×log_{10}(\frac{N}{df_t})<br>$$</p><p><strong>下面是本算法的具体流程：</strong></p><p>①第一步：</p><p>首先定义一个cut_word函数，这个函数对文本做一些处理，用空格替换阿拉伯数字、以及各种符号，然后对处理后的文本调用jieba库进行分词，分词后才能进行相关的处理。</p><p>②第二步：</p><p>首先从数据库读入全部相关的文件，其中每行数据包含标题title、作者author、文章text、翻译translation，并检查翻译字段是否为空，为空则不进行分词，不为空才进行分词，并且对标题、作者和文章都进行分词处理，并用回车区分不同内容并进行拼接，之后再进行第三步生成倒排索引文件（没有进行TF-IDF打分）。</p><p>③第三步：</p><p>这一步主要就是生成倒排索引的核心步骤之一。</p><p>遍历第二步经过处理的列表，经过分词处理的文本进行切割得到所有出现的词语，借助这些词语借助Counter类统计TF词频，并保存在index字典中，如果字典中的键存在这个词语就说明统计过，则可以直接在原本的值后面拼接出现的文本page和在当前page出现的频率，没有就新加键并保存值，倒排索引生成完成，保存在index字典中。</p><p>④第四步：</p><p>这一步主要就是使用TF&#x2F;IDF打分机制进行每个词语的打分，构建最后的倒排索引。</p><p>在原本的倒排索引文件的基础上，遍历每个词语，根据键名可以拿到每个词语，而键对应的值就对应每个词语在某篇文章出现的频次tf，可以根据计算得出权重w&#x3D;1.0 + math.log(tf)，而后可以根据值这个列表的长度得到当前词语出现文章的数量df，而所有文章的数量record_count可以直接获取到，那么idf&#x3D;math.log10(record_count &#x2F; df)，计算完成后保存即可。</p><p>到这里为止，TF&#x2F;IDF进行打分的倒排索引文件就完成了，后续索引文件即可，对于每次查询可以根据倒排索引快速找到按照分值排序的所有的相关古诗内容。</p><h4 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h4><h5 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h5><p><strong>古诗内容相关数据集</strong></p><p>其中最重要的数据集就是文章内容相关的数据集了，这份数据集中包含了每首古诗的标题、作者、古诗内容、古诗翻译、作者生活朝代以及更加详细阅读跳转链接。这份数据集是队内组员书写爬虫获取到的数据，进行相关数据处理得到。</p><p>下面是存放在数据库中的数据集部分内容：</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312181618862.png" alt="微信图片_20231218114520"></p><p>这份数据集是用来构建倒排索引文件的重要数据集，对于其中的古诗标题、作者、文本和翻译我们会使用结巴中文分词库进行分词处理，而后统计所有词语的频次，并记录每个词语在不同文档出现的频次（这里的文档包括古诗标题、作者、文本和翻译）以及文档的编号，而后会借助统计信息完成TF-IDF打分，并记录打分值，完成倒排索引文件的构建。</p><p>下面就是最终生成的倒排索引文件的部分内容：</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312181618898.png" alt="微信图片_20231218114206"></p><p><strong>完成拼写检查中编辑距离处理所需数据集</strong></p><p>处理编辑距离是完成拼写检查的重要步骤之一，首先需要中文汉字字典，按照单字进行删除、转换、交换、插入操作错误字符串，得到可能正确字符串，再进行后面的比对。</p><p>下面是中文汉字字典的部分（收录了3500个中文汉字）：</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312181617709.png" alt="image-20231218115746403"></p><p>再得到可能正确字符串后就需要进行比对并且需要一个打分机制，我们的系统自定义了规则进行一个预先的排名，而后再对频次进行比较，这里就需要一个搜索词语频次的数据集，其中记录着可能搜索结果和搜索频次（其中也记录着词性，但这在本系统中并没有运用到）。</p><p>下面是词频词典的部分（其中有340000多种搜索的可能以及词频）：</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312181617310.png" alt="image-20231218120411391"></p><h5 id="中文纠错算法细节"><a href="#中文纠错算法细节" class="headerlink" title="中文纠错算法细节"></a>中文纠错算法细节</h5><p>本系统的作文纠错算法中和核心之一就是编辑距离的处理，下面是对一些重要代码的介绍，对于传入的错误拼写词语，会从中文字典中依次去除所有的字，进行删除、调换、转换、插入的操作生成所有的可能正确拼写词语，依次存放在deletes、transposes、replaces、inserts中，之后借助set的特性进行去重。</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312181617848.png" alt="image-20231218120703408"></p><p>之后便是对于不同可能正确结果的操作进行一个规则的处理，对于错误拼写词语和可能正确词语的拼音进行对比，两者拼音完全相等就存放在一级列表，只有第一个字的拼音相等就存放在二级列表，其余的存放在三级列表中。</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312181617777.png" alt="image-20231218121145419"></p><p>之后便从不同级别的列表依次去寻找，在级别高的列表中找到则返回，对于同一级别的列表就会调用下面的find_max方法进行查找，对比查找词频词典中的词语，找到词频最大的返回，就对拼写错误的词语进行了纠错。</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312181617060.png" alt="image-20231218121521306"></p><p>对于需要纠错的句子就只需要调用结巴中文分词库对其进行分词，根据每个词进行处理，若能直接在词频词典中找到则说明没有拼写错误，若查找不到则对每个词调用上面的方法进行纠错，最后局部纠错完成后将所有词语拼接成句子就是对句子的纠错了。</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312181617118.png" alt="image-20231218122158235"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2023/11/18/%E7%AE%97%E6%B3%95/"/>
      <url>/2023/11/18/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>加油！！！</p><h3 id="递归改写迭代"><a href="#递归改写迭代" class="headerlink" title="递归改写迭代"></a>递归改写迭代</h3><p>引入队列是递归改写程序常做方法，然后借助循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> check(root,root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left==<span class="literal">null</span>&amp;&amp;right==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left==<span class="literal">null</span>||right==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.val== right.val&amp;&amp;check(left.left,right.right)&amp;&amp;check(left.right,right.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面递归方法改写成迭代，借助队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> check(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode u, TreeNode v)</span> &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    q.offer(u);</span><br><span class="line">    q.offer(v);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        u = q.poll();</span><br><span class="line">        v = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="literal">null</span> &amp;&amp; v == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((u == <span class="literal">null</span> || v == <span class="literal">null</span>) || (u.val != v.val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q.offer(u.left);</span><br><span class="line">        q.offer(v.right);</span><br><span class="line"></span><br><span class="line">        q.offer(u.right);</span><br><span class="line">        q.offer(v.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分治法（递归）"><a href="#分治法（递归）" class="headerlink" title="分治法（递归）"></a>分治法（递归）</h3><p> <strong>分治法的设计思想</strong>：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p><p>  <strong>分治策略</strong>：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p><p>  如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p><p><strong>分治法适用的情况</strong></p><p>  分治法所能解决的问题一般具有以下几个特征：</p><p>  \1) 该问题的规模缩小到一定的程度就可以容易地解决</p><p>  \2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p><p>  \3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p><p>  \4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p><p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p><p>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；</p><p>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p><p>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p><p>分治法在每一层递归上都有三个步骤：</p><p>  step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p><p>  step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p><p>  step3 合并：将各个子问题的解合并为原问题的解。</p><h4 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SuanFa.DiGuiFenZhi.HanNuoTa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HanNuoTa</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        hanoi(n,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,ints);</span><br><span class="line">        System.out.format(<span class="string">&quot;移动%d个盘子总共需要移动%d次盘子&quot;</span>,n,ints[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*一个直接移动到c即可；两个就先把一个移动到b，再把最下面一个移动到c，然后把b上的移动到c即可；</span></span><br><span class="line"><span class="comment">    * 三个怎么办呢，可以想办法把最大的移动到c，再把剩下的移动到最大的上面，那怎么把最大的移动到c呢，</span></span><br><span class="line"><span class="comment">    * 要先把上面的都移动到b，怎么把上面的移动到b呢，</span></span><br><span class="line"><span class="comment">    * 这不就是只有两个的时候的情况吗，这样来看就是递归了*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//a为一开始在的柱子，b为中间柱子，c为最终放在的柱子,n为几个盘子</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> a,<span class="type">char</span> b,<span class="type">char</span> c,<span class="type">int</span>[] ints)</span>&#123;</span><br><span class="line">        <span class="comment">//只有一个就从a直接移动到c</span></span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            move(n,a,c,ints);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//大于1个就把n-1个盘子借助c从a移动到b，之后递归了</span></span><br><span class="line">        hanoi(n-<span class="number">1</span>,a,c,b,ints);</span><br><span class="line">        <span class="comment">//然后把最下面也就是第n个盘子移动到c</span></span><br><span class="line">        move(n,a,c,ints);</span><br><span class="line">        <span class="comment">//之后把b柱子上的盘子借助a柱子移动到c，也是递归</span></span><br><span class="line">        hanoi(n-<span class="number">1</span>,b,a,c,ints);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> a,<span class="type">char</span> c,<span class="type">int</span>[] ints)</span>&#123;</span><br><span class="line">        <span class="comment">//一秒移动一个盘子，要把64个盘子移动完都可以移动到宇宙毁灭了</span></span><br><span class="line"><span class="comment">//        System.out.format(&quot;编号为：%d的盘子正在从%c柱子移动到%c柱子\n&quot;,n,a,c);</span></span><br><span class="line">        ints[<span class="number">0</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h4><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：<em>F</em>(0)&#x3D;0，<em>F</em>(1)&#x3D;1, <em>F</em>(n)&#x3D;<em>F</em>(n - 1)+<em>F</em>(n - 2)（<em>n</em> ≥ 2，<em>n</em> ∈ N*）在现代物理、准晶体结构晶体结构、化学等领域，斐波那契数列都有直接的应用</p><ul><li><strong>楼梯问题</strong></li><li><strong>兔子繁殖问题（不死亡）</strong></li><li><strong>兔子繁殖问题（会死亡）</strong></li><li><strong>求解质数（基本方法有试除法和筛法，试除法除到根号n就好，规律），这里有斐波那契质数（ 若某Fibonacci数与任何比它小的Fibonacci数互质，那么它就是Fibonacci质数。可以保存到一个数组然后开始一个个推）</strong></li></ul><p><strong>1. 爬楼梯问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.爬楼梯问题（solve3）</span></span><br><span class="line"><span class="keyword">package</span> LeeCode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span></span><br><span class="line"><span class="comment">每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exercise70</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(solve1(n));</span><br><span class="line">        System.out.println(solve2(n));</span><br><span class="line">        System.out.println(solve3(n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="comment">//斐波那契问题除了爬楼梯还有兔子繁殖问题，满足f(n) = f(n-1) + f(n-2)就是</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//无脑，递归，能一次上3步同理,很耗时，超时，O(2^n),能一次上3步就是3^n</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solve1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//0台阶一步</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1台阶就只有一种情况，爬一步</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2台阶两种情况，一种每次爬1步，一种直接爬2步</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//多于2楼梯的就根据当前选择有不同情况，如爬了1级，那么剩下n-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> solve1(n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//爬了2级,剩下n-2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> solve1(n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> first + second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过分析上4次楼梯有多少情况发现有问题重叠计算了、</span></span><br><span class="line">    <span class="comment">//同斐波那契数列，可以用一个数组存结果，原理也同其实，4阶楼梯上法可以由3阶上楼梯方法推出来，3阶可以由2阶上楼梯方法推出来</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solve2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//这里由于输入的n为1的话新建的数组根本没这么大，直接ints[2]直接错，</span></span><br><span class="line">        <span class="comment">// 可以做个判断或者把数组直接new很大出来，也可以直接new n+3长度就行，让数组最短都有3个格子</span></span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">3</span>];</span><br><span class="line">        ints[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        ints[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        ints[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            ints[i] = ints[i-<span class="number">1</span>] + ints[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面还要建数组根本就不需要，就跟斐波那契一样，根本不需要去建数组，直接3个数轮换就可以求出来</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solve3</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//n3表示第三个数，第三个数是前2个数n1和n2相加，然后把下次要相加的两个数往后移动n2变为n3，n1变为n2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">1</span>, n2 = <span class="number">2</span>, n3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            n3 = n2 + n1;</span><br><span class="line">            n1 = n2;</span><br><span class="line">            n2 = n3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.兔子繁殖问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.兔子繁殖（会死亡），不死亡同前面其实</span></span><br><span class="line"><span class="keyword">package</span> SuanFa.FeiBoNaQie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*题目</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有一对兔子，从出生后，</span></span><br><span class="line"><span class="comment">第 1、2 月为 幼年期</span></span><br><span class="line"><span class="comment">第 3 月开始，进入了 成年期，每个月都生一对 兔子</span></span><br><span class="line"><span class="comment">小兔子 长到 第3月 后，每个月又生一对兔子</span></span><br><span class="line"><span class="comment">当 一对兔子 在 第5月 时，他们产完仔之后，就会死亡*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitProblemWillDie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Rabbit</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">growUp</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> month)</span>&#123;</span><br><span class="line">        <span class="comment">//用队列很容易理解且比递归快</span></span><br><span class="line">        Queue&lt;Rabbit&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">Rabbit</span>());</span><br><span class="line">        <span class="type">int</span> <span class="variable">monthNow</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (monthNow&lt;month)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span> (count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Rabbit</span> <span class="variable">rabbit</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">                <span class="keyword">switch</span> (rabbit.age)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        rabbit.growUp();</span><br><span class="line">                        queue.add(rabbit);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//一起写就可以</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        rabbit.growUp();</span><br><span class="line">                        queue.add(rabbit);</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="title class_">Rabbit</span>());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//4个月这个月变成5个月会死，并且生一只兔子</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="title class_">Rabbit</span>());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            monthNow++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">RabbitProblemWillDie</span> <span class="variable">dd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RabbitProblemWillDie</span>();</span><br><span class="line">        System.out.println(dd.count(scanner.nextInt()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.求解质数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.求解质数</span></span><br><span class="line"><span class="keyword">package</span> SuanFa.FeiBoNaQie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求解质数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(isPrime(num));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">byte</span>[] date = getAllPrime(range);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; date.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (date[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//试除法，优化除到根号n即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">0</span>||num==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i&lt;=Math.sqrt(num); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//筛法,返回一个范围内所有质数</span></span><br><span class="line">    <span class="comment">/*全称：The Sieve of Eratosthens（爱拉托逊斯筛选法），简称为筛法</span></span><br><span class="line"><span class="comment">    筛法就是把每一个质数的倍数去掉 余下的数就是质数</span></span><br><span class="line"><span class="comment">    2 是最小的质数，将 2 的所有倍数去掉，然后找 2 的下一个质数：3 ，将 3 的所有倍数去掉，寻找下一个质数：5 , 去掉 5 的所有倍数…以此类推*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getAllPrime(<span class="type">int</span> range)&#123;</span><br><span class="line">        <span class="type">byte</span>[] date = <span class="keyword">new</span> <span class="title class_">byte</span>[range+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= range ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (date[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; i*j &lt;=range ; j++) &#123;</span><br><span class="line">                    date[i*j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回值为一个byte数组</span></span><br><span class="line">        <span class="comment">//从下标为2的值开始，值为0说明该下标数是质数</span></span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><p><strong>二分搜索算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//length是数组长度（数组有序，这里是升序，降序自己给一下变化就行），target是要查找的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">BinarySearch</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> length,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (ints[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ints[mid]&gt;target)&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ints[mid]&lt;target)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p><strong>1.冒泡排序</strong></p><p><strong>数量少时选择，每轮把最大的数放在数组最后</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序 传入数组长度</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (ints.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//每次把最大的数放在最后一个</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (ints[j] &gt; ints[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                   swap(ints, j, j + <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[left];</span><br><span class="line">       ints[left] = ints[right];</span><br><span class="line">       ints[right] = temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>2.选择排序</strong></p><p>选择排序就是每轮把剩余中最小的往前面已经放好的后面放，相对冒泡就是少了频繁交换,每次大循环就交换数组里面的值一次，每次把最小的放前面，用min保存当前循环的最小数值的下标就好，每轮循环min开始置为当前循环的i值就好，因为上一轮把最小的放在这里了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[min] &gt; ints[j]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(ints, min, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[left];</span><br><span class="line">        ints[left] = ints[right];</span><br><span class="line">        ints[right] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3.归并排序(合并排序，基于二分实现)</strong></p><p><strong>数多时选择，一直递归把数据一分为二，把两半数据排好后复制到原数组，最小是只有2个数的情况，这时候就相当于有序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序（合并排序） 需要同等大小的复制控件 传入数组的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//不断划分子问题（分治思想）</span></span><br><span class="line">            MergeSort(ints, left, mid, temp);</span><br><span class="line">            MergeSort(ints, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//解决子问题并且把子问题的值从临时数组复制回原数组</span></span><br><span class="line">            Merge(ints, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里的循环条件考虑递归到最小的时候，也就是只有两个数的时候</span></span><br><span class="line">        <span class="comment">//下面是把两个有序数组进行合并</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ints[left] &lt; ints[right]) &#123;</span><br><span class="line">                temp[t++] = ints[left++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = ints[right++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= mid) &#123;</span><br><span class="line">            temp[t++] = ints[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &lt;= end) &#123;</span><br><span class="line">            temp[t++] = ints[right++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//临时数组保存的是当前这个子问题这个小段的正确顺序</span></span><br><span class="line">        <span class="comment">//下面是把临时数组中排好序的数组复制回原数组</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            ints[i] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><em>归并算法求逆序对</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//保存交换次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序借助另一个数组合并的过程,先把两个串按照顺序合并放到临时数组再放回去</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> *ints, <span class="type">int</span> *temp, <span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ints[left] &lt;= ints[right]) &#123;</span><br><span class="line">            <span class="comment">//因为是最小，等会的情况不交换</span></span><br><span class="line">            temp[t++] = ints[left++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[t++] = ints[right++];</span><br><span class="line">            sum+=(mid-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid) &#123;</span><br><span class="line">        temp[t++] = ints[left++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right &lt;= end) &#123;</span><br><span class="line">        temp[t++] = ints[right++];</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; ++i) &#123;</span><br><span class="line">        ints[i] = temp[t++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> *ints, <span class="type">int</span> *temp, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(ints, temp, left, mid);</span><br><span class="line">        mergeSort(ints, temp, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(ints, temp, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> *ints = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> *temp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; ints[i];</span><br><span class="line">    &#125;</span><br><span class="line">    mergeSort(ints, temp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.快速排序（双指针递归实现）</strong></p><p><strong>数量多时选择，一开始把基准值设为数组第一个值，每轮把基准值放在对的位置并把交换得到的值作为基准值</strong></p><p>变形问题：</p><p>设计一个平均时间为O(n)的算法，在n(1&lt;&#x3D;n&lt;&#x3D;1000)个无序的整数中找出第k小的数。（因为每轮的right值都会是放在正确位置的值，看right这个是不是对应下标，对可以直接返回了，根本不用全排序完，如果right大了递归左边的那段，小了递归右边半段，因为这时候左边的数都小于right下标的值，右边都大于right下标的值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序(递归) 传入数组的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">//一开始start&lt;end记得写</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = end, base = ints[left];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="comment">//这两个while都有等于作为判断条件</span></span><br><span class="line">                <span class="comment">//这里之所以写&lt;=base是因为在交换一次不对的数字后没有把left和right直接改变，而是在下次的while中改变</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt;= end &amp;&amp; ints[left] &lt;= base) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; start &amp;&amp; ints[right] &gt;= base) &#123;</span><br><span class="line">                    <span class="comment">//right&gt;start其实可以不用写，因为前面有基准值堵住，不会超出去</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果不是left&lt;right说明序列正确</span></span><br><span class="line">                <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                    swap(ints, left, right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里是遍历基准值后面的数结束了，这时候right在左边，left在右边或者left=right，</span></span><br><span class="line">            <span class="comment">// 这时候把基准值跟小的值交换才对，自己写个数组就明白了，小的值就是right对应的值</span></span><br><span class="line">            swap(ints, start, right);</span><br><span class="line">            <span class="comment">//然后递归已经放置正确的值的左边和右边，也就是right这个值的左边和右边，</span></span><br><span class="line">            <span class="comment">// start衡为数组界限，如果right-1小于这个值不会进行循环，不会越界，right+1同理</span></span><br><span class="line">            QuickSort(ints, start, right - <span class="number">1</span>);</span><br><span class="line">            QuickSort(ints, right + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[left];</span><br><span class="line">        ints[left] = ints[right];</span><br><span class="line">        ints[right] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>5.堆排序</strong></p><p><strong>数多时选择，每次都形成大顶堆，也就是数字最大的在父节点，每轮得到最大的放在数组最后并进行交换</strong></p><p>首先要了解一下一些关系，下标为i的节点的父节点的下标为（i-1）&#x2F;2,下标为i的节点的左孩子节点的下标为ix2+1,右孩子节点下标为ix2+2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="comment">//方法入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="comment">//建堆,一开始先把堆建好，之后递归就好</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//倒着建堆，根据规律父节点为（n-1）/2,注意这个方法传入的不是下标是长度，n要减多一个1</span></span><br><span class="line">            Heap(ints, length, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span> (i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//最后一个元素和第一个元素交换，就是把最大的数放到最后,swap方法在这个类最后面</span></span><br><span class="line">            swap(ints, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//交换完成最大元素在最后，之后从堆顶开始维护堆，这里容易错，长度改变了</span></span><br><span class="line">            Heap(ints, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> length, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//维护堆,length为数组长度,i为维护的目标节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//要把最大的那个数放在父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">//假设目前最大的是父节点，根据规律看哪个节点最大就记录它的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lson</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, rson = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (lson &lt; length &amp;&amp; ints[lson] &gt; ints[largest]) &#123;</span><br><span class="line">            largest = lson;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rson &lt; length &amp;&amp; ints[rson] &gt; ints[largest]) &#123;</span><br><span class="line">            largest = rson;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断最大节点是不是已经在父节点，不是就进行交换，并且要递归调整下面的堆</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(ints, largest, i);</span><br><span class="line">            <span class="comment">//这时候的largest记录的是被交换过来的不是最大的值的父节点的下标，容易出错</span></span><br><span class="line">            Heap(ints, length, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[left];</span><br><span class="line">        ints[left] = ints[right];</span><br><span class="line">        ints[right] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="线性时间选择算法"><a href="#线性时间选择算法" class="headerlink" title="线性时间选择算法"></a>线性时间选择算法</h4><p>如果要要在一个数组中找到最大或者最小的数是可以轻易做到O(n)时间完成的，但如果要寻找中位数或者说寻找第几大的数看起来是非常难在O(n)时间完成的，但事实上从渐近的意义上来看，它们是一样的<strong>（线性时间选择算法是在快排的基础上实现的，也叫快速选择算法）</strong></p><p>看了一下b站的视频感觉寻找第几小的数字，貌似自己的思路是正确的，但不知道是不是原版线性时间选择算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计一个平均时间为O(n)的算法，在n(1&lt;=n&lt;=1000)个无序的整数中找出第k小的数。</span></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *ints,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[left];</span><br><span class="line">    ints[left] = ints[right];</span><br><span class="line">    ints[right] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> *ints,<span class="type">int</span> target,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start,right = end,base = ints[left];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;end&amp;&amp;ints[left]&lt;=base)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right&gt;start&amp;&amp;ints[right]&gt;=base)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                swap(ints,left,right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(ints,start,right);</span><br><span class="line">        <span class="comment">//前面都是跟快排一样的，这里不同而已</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里通过下标看中间值也就是right值，right左边比right小，右边比right大，</span></span><br><span class="line">        <span class="comment">//如果要找到第几小的值在right左边就递归左边，反之递归右边</span></span><br><span class="line">        <span class="keyword">if</span>(right==target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;target)&#123;</span><br><span class="line">            solve(ints,target,right+<span class="number">1</span>,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;target)&#123;</span><br><span class="line">            solve(ints,target,start,right-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> length,target;</span><br><span class="line">    cin &gt;&gt; length &gt;&gt; target;</span><br><span class="line">    <span class="type">int</span> *ints = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        cin &gt;&gt; ints[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solve(ints,target-<span class="number">1</span>,<span class="number">0</span>,length-<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ints[target-<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//有n场比赛</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> *ints, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = end, base = ints[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= end &amp;&amp; ints[left] &lt;= base) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; start &amp;&amp; ints[right] &gt;= base) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            swap(ints[left], ints[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(ints[start], ints[right]);</span><br><span class="line">    <span class="keyword">if</span> (right == target - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ints[right];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; target - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSort(ints, start, right - <span class="number">1</span>, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSort(ints, right + <span class="number">1</span>, end, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> *ints = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; ints[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> target;<span class="comment">//目标寻找第target大的值</span></span><br><span class="line">    cin &gt;&gt; target;</span><br><span class="line">    cout &lt;&lt; quickSort(ints, <span class="number">0</span>, n - <span class="number">1</span>, target);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法（greedy algorithm [8] ，又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。</p><p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择 。</p><p>把求解的问题分成若干个子问题，对每个子问题求解，得到子问题的局部最优解，把子问题的解局部最优解合成原来解问题的一个解。（贪心算法<strong>一般用来解决求最大或最小解</strong>，贪心算法只能确定某些问题的可行性范围，不能保证最佳，因为贪心算法总是从局部出发，并没从整体考虑）</p><ul><li><p>题目：121，找零问题（注意贪心是不是有最优解）（从大的零钱开始找）</p></li><li><p>题目:删数问题（给定n位正整数a，去掉其中任意k≤n 个数字后，剩下的数字按原次序排列组成一个新的正整数。对于给定的n位正整数a和正整数 k，设计一个算法找出剩下数字组成的新数最小的删数方案。如果数字最前面有0不输出。）（从头开始，递减段的第一个数字删掉，因为这样会让后面小的数字上来顶替它）</p></li><li><p>题目：最优分解问题（设 n 是一个正整数。现在要求将 n 分解为若干个互不相同的自然数的和，且使这些自然数的乘积最大。）</p></li></ul><p>（整数的一个性质：若 a + b &#x3D;N(常数)，则| a - b |越小， a * b 越大，<em>因为要使乘积最大，所以要尽量分解为相似大小的数。    分解时，因数从2开始，每次加1，n&#x3D;n-a[i]，保证剩下的数比下一次的数大。    否则<strong>从后往前循环</strong>（从前往后会出现相同数字，拿去10来看就知道了）已经出现的数a[i]，一次加1，知道n&#x3D;0为止。     例如：        分解13        分解为 2 3 4 ，还剩下 4 ，不够继续分解的下一个数”5”，就把 4 依次分配给前面的因子，        分配顺序是 4 &#x3D;&gt; 3 &#x3D;&gt; 2 。所以最终结果为 3 4 6，这就是最大乘积的因子。        （分配顺序为从大到小，如果还剩下，就继续从大到小分配）</em>）</p><ul><li>在0-1背包的贪心算法模型中把物品质量和价格初始化为double类型最好，不然会因为int类型保存时有误差导致sort排序有时候不对</li></ul><h4 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h4><p>学校的礼堂每天都会有许多活动，有时间这些活动的计划时间会发生冲突，需要选择出一些活动进行举办。小刘的工作就是安排学校礼堂的活动，每个时间最多安排一个活动。现在小刘有一些活动计划的时间表，他想尽可能的安排更多的活动，请问他该如何安排。</p><p><strong>输入格式：</strong></p><p>第一行是一个整型数m(m&lt;100)表示共有m组测试数据。<br>每组测试数据的第一行是一个整数n(1&lt;n&lt;10000)表示该测试数据共有n个活动。<br>随后的n行，每行有两个正整数Bi,Ei(0&lt;&#x3D;Bi,Ei&lt;10000),分别表示第i个活动的起始与结束时间（Bi&lt;&#x3D;Ei)</p><p><strong>输出格式：</strong></p><p>对于每一组输入，输出最多能够安排的活动数量。<br>每组的输出占一行</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">1 10</span><br><span class="line">10 11</span><br><span class="line">3</span><br><span class="line">1 10</span><br><span class="line">9 11</span><br><span class="line">11 20</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><p>贪心选择，最早结束时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;<span class="comment">//m组测试数据</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//每组数据有n个活动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ac</span> &#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ac ac1, ac ac2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ac1.end &lt; ac2.end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> result, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        ac *p = <span class="keyword">new</span> ac[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; p[j].start &gt;&gt; p[j].end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(p, p + n, cmp);</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j].start &gt;= p[temp].end) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                temp = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            cout &lt;&lt; result;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; endl &lt;&lt; result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="活动安排进阶（需保存状态）"><a href="#活动安排进阶（需保存状态）" class="headerlink" title="活动安排进阶（需保存状态）"></a>活动安排进阶（需保存状态）</h4><ul><li><strong>保存状态的这个思想很重要，有些贪心的题目也用得上</strong></li></ul><p>假设要在足够多的会场里安排一批活动，并希望使用尽可能少的会场。设计一个有效的<br>贪心算法进行安排。（这个问题实际上是著名的图着色问题。若将每一个活动作为图的一个<br>顶点，不相容活动间用边相连。使相邻顶点着有不同颜色的最小着色数，相应于要找的最小<br>会场数。）</p><p><strong>输入格式</strong></p><p>第一行有 1 个正整数k，表示有 k个待安排的活动。<br>接下来的 k行中，每行有 2个正整数，分别表示 k个待安排的活动开始时间和结束时间。时间<br>以 0 点开始的分钟计。</p><p><strong>输出格式</strong></p><p>输出最少会场数。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 23</span><br><span class="line">12 28</span><br><span class="line">25 35</span><br><span class="line">27 80</span><br><span class="line">36 50 </span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/10/29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//代安排的活动数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ac</span> &#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ac ac1, ac ac2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ac1.start &lt; ac2.start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(ac *p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(p, p + n, cmp);</span><br><span class="line">    <span class="type">int</span> *target = <span class="keyword">new</span> <span class="type">int</span>[n]&#123;<span class="number">0</span>&#125;;<span class="comment">//保存当前会场信息</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;<span class="comment">//保存开了多少个会场</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">//j从会场0号下标开始遍历到result，如果能安排进去就结束了，如果不能就会到下标result对应会场，表示要新开会场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= result; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == result) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[i].start &gt;= target[j]) &#123;</span><br><span class="line">                target[j] = p[i].end;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ac *p = <span class="keyword">new</span> ac[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; p[i].start &gt;&gt; p[i].end;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(p) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最优合并问题（借助优先队列）"><a href="#最优合并问题（借助优先队列）" class="headerlink" title="最优合并问题（借助优先队列）"></a>最优合并问题（借助优先队列）</h4><ul><li><strong>有时候借助优先队列解决更快和方便</strong></li></ul><p>给定k 个排好序的序列, 用 2 路合并算法将这k 个序列合并成一个序列。<br>假设所采用的 2 路合并算法合并 2 个长度分别为m和n的序列需要m+n-1 次比较。试设<br>计一个算法确定合并这个序列的最优合并顺序，使所需的总比较次数最少。<br>为了进行比较，还需要确定合并这个序列的最差合并顺序，使所需的总比较次数最多。</p><p><strong>输入格式：</strong></p><p>第一行有 1 个正整数k，表示有 k个待合并序列。<br>第二行有 k个正整数，表示 k个待合并序列的长度。</p><p><strong>输出格式：</strong></p><p>输出最多比较次数和最少比较次数。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5 12 11 2 </span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">78 52</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><p>次数最少的情况就是尽量减少长的序列的比较次数(每次都让短的两个序列先比较)，而最大的情况就是尽量增加长的序列的比较次数(每次都让最长的两个序列比较)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; small, <span class="type">int</span> &amp;small_result,</span></span></span><br><span class="line"><span class="params"><span class="function">           priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; big, <span class="type">int</span> &amp;big_result)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp1, temp2;</span><br><span class="line">    <span class="keyword">while</span> (small.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        temp1 = small.<span class="built_in">top</span>();</span><br><span class="line">        small.<span class="built_in">pop</span>();</span><br><span class="line">        temp2 = small.<span class="built_in">top</span>();</span><br><span class="line">        small.<span class="built_in">pop</span>();</span><br><span class="line">        small_result += (temp1 + temp2 - <span class="number">1</span>);</span><br><span class="line">        small.<span class="built_in">push</span>(temp1 + temp2);</span><br><span class="line">        temp1 = big.<span class="built_in">top</span>();</span><br><span class="line">        big.<span class="built_in">pop</span>();</span><br><span class="line">        temp2 = big.<span class="built_in">top</span>();</span><br><span class="line">        big.<span class="built_in">pop</span>();</span><br><span class="line">        big_result += (temp1 + temp2 - <span class="number">1</span>);</span><br><span class="line">        big.<span class="built_in">push</span>(temp1 + temp2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*次数最少的情况就是尽量减少长的序列的比较次数(每次都让短的两个序列先比较),</span></span><br><span class="line"><span class="comment">    而最大的情况就是尽量增加长的序列的比较次数(每次都让最长的两个序列比较)*/</span></span><br><span class="line">    <span class="type">int</span> k, temp, small_result = <span class="number">0</span>, big_result = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; small;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; big;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        small.<span class="built_in">push</span>(temp);</span><br><span class="line">        big.<span class="built_in">push</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(small, small_result, big, big_result);</span><br><span class="line">    cout &lt;&lt; big_result &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; small_result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####图最短问题（迪杰斯特拉算法）</p><ul><li><p><strong>单源最短路径</strong></p></li><li><p><strong>迪杰斯特拉要求的图的权值要为正数</strong></p></li></ul><p><a href="https://blog.csdn.net/PRML_MAN/article/details/114477814?ops_request_misc=%7B%22request_id%22:%22166826569516782388091019%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166826569516782388091019&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114477814-null-null.142%5Ev63%5Econtrol,201%5Ev3%5Econtrol_2,213%5Ev2%5Et3_esquery_v2&utm_term=%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89&spm=1018.2226.3001.4449">(26条消息) 算法之迪杰斯特拉（dijkstra）非常详细介绍_PRML_MAN的博客-CSDN博客_迪杰斯特拉</a></p><p>城市的道路四通八达，我们经常需要查找从某地出发到其他地方的路径，当然我们希望能最快到达。现得到去每个地方需要花费的时间，现请你编写程序，计算从特定地点出发到所有城市之间的最短时间。</p><p><strong>输入格式：</strong></p><p>输入的第一行给出城市数目N (1≤N≤10)和道路数目M和1（表示有向图）或0（表示无向图）；</p><p>接下来的M行对应每个城市间来往所需时间，每行给出3个正整数，分别是两个城市的编号（从1编号到N）和来往两城市间所需时间。最后一行给出一个编号，表示从此编号地点出发。</p><p><strong>输出格式：</strong></p><p>输出从特定地点出发到达所有城市（按编号1-编号N顺序输出）的距离（用编号1-&gt;编号**: 表示 ），如果无路，请输出no path。每个城市占一行。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 4 1</span><br><span class="line">1 2 2</span><br><span class="line">1 4 8</span><br><span class="line">3 2 16</span><br><span class="line">3 4 10</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;1:0</span><br><span class="line">1-&gt;2:2</span><br><span class="line">1-&gt;3:no path</span><br><span class="line">1-&gt;4:8</span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><p>&#x2F;&#x2F;迪杰斯特拉算法,每次寻找图中到某个点最小的距离，更新和这个点相连的且没有被访问过的点，并把这个点置为已访问过，如果要知道具体路径就可以再增加一个数组保存前驱点（这个点最小值出现的时候也就是要刷新这个点的值的时候改变前驱点）,根据目的地一直往前驱找到起始点就是具体路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/9.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">//邻接矩阵两个点没有相连定义初始化的值</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//城市数目1&lt;=n&lt;=10</span></span><br><span class="line"><span class="type">int</span> m;<span class="comment">//图中路的条数</span></span><br><span class="line"><span class="type">int</span> target;<span class="comment">//一开始指定的点</span></span><br><span class="line"><span class="type">int</span> kind;<span class="comment">//表示图的种类，1表示有向图，0表示无向图，根据这个初始化邻接矩阵</span></span><br><span class="line"><span class="type">int</span> g[<span class="number">11</span>][<span class="number">11</span>];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> dist[<span class="number">11</span>];<span class="comment">//保存特殊路径长度，一开始初始化为定义的目标点到每个点的距离</span></span><br><span class="line"><span class="type">bool</span> visit[<span class="number">11</span>];<span class="comment">//是否被加进去集合遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        visit[i] = <span class="literal">false</span>;</span><br><span class="line">        dist[i] = g[target][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= n; ++t) &#123;</span><br><span class="line">        <span class="type">int</span> point = <span class="number">-1</span>, min = INF;<span class="comment">//一开始让point为-1，如果在下面的循环中point依然为-1说明dist一开始全保存为INF，就是图所有点都是不相通的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[i] &amp;&amp; dist[i] &lt; min) &#123;</span><br><span class="line">                min = dist[i];</span><br><span class="line">                point = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (point == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[point] = <span class="literal">true</span>;<span class="comment">//加进集合，visit[point]置为true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="comment">//之前遍历过的点就不用遍历了，因为已经保存了目标值到这个点的最小值了</span></span><br><span class="line">            <span class="keyword">if</span> (!visit[i] &amp;&amp; dist[point] + g[point][i] &lt; dist[i]) &#123;</span><br><span class="line">                dist[i] = dist[point] + g[point][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; kind;</span><br><span class="line">    <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; ++j) &#123;</span><br><span class="line">            g[i][j] = INF;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                g[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a][b] = c;</span><br><span class="line">        <span class="keyword">if</span> (kind == <span class="number">0</span>) &#123;</span><br><span class="line">            g[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; target;</span><br><span class="line">    <span class="built_in">Dijkstra</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i] != INF) &#123;</span><br><span class="line">            cout &lt;&lt; target &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; target &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="string">&quot;no path&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希映射"><a href="#哈希映射" class="headerlink" title="哈希映射"></a>哈希映射</h3><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希（Hash）表，函数f(key)为哈希(Hash) 函数。</p><p><strong>Example:</strong></p><p>现在给出 <strong>n</strong> 个数(a[0],a[1],…,a[n-1])，且每个数的大小都是小于等于 10的10次方 的非负数(0&lt;&#x3D;a[i]&lt;&#x3D;1010)，现需要<strong>统计每个数的出现次数</strong>，并从小到大依次输出，且 <strong>n</strong> 是小于等于 <strong>100</strong> 的正整数(0&lt;n&lt;&#x3D;100)。</p><p><strong>基础解决方法：</strong></p><p>对于这道题确实可以直接定义一个很长的数组，然后遍历输入的数，出现一次就在对应的下标的数组保存的值加1，这样子可以做到O(n)</p><p>的效率，算是优解了，但是这里的数最大为10的10次方，数组定义不了这么长</p><p><strong>解决方法（发现问题）</strong></p><p>那么就可以构造一个哈希函数通过一个映射关系压缩如此大的一个数组，因为这个数组里面很多值其实很多都是0来着，非常稀疏，例如H*(*k)&#x3D;k  mod m，取模，但是这种可能会出现碰撞冲突，如1%100&#x3D;1，但101%100&#x3D;1</p><p><strong>解决问题（解决冲突）</strong></p><p>解决碰撞冲突的思路有两个，<strong>其一</strong>是为冲突发生的情况下，设置新的规则来应对，比方说，如果出现冲突，那么就从冲突出现位置顺序往后找，直到找到一个空的位子，填上去；<strong>或者</strong>是隔几个位子跳着跳着找；<strong>又或者</strong>是在冲突出现的位置链接上一条链表，依次记录相同哈希值元素的出现次数。</p><p><strong>1. 线性探测法</strong></p><p>顾名思义，若出现冲突，则逐个往后或往前搜索，直到找到空的位子。假设现在又出现一个元素 <strong>20</strong> 经哈希函数后得到的映射结果也是位置 <strong>0</strong> ，而发现该位置已被元素 <strong>10</strong> 所占据，那么就可以线性向后查找，直到找到第一个空的位置 <strong>2</strong> ，然后放上去。(若找到了哈希表结尾，则回到开头继续向后查找，由于保证了哈希表的大小一定比元素总个数多，所以能保证每个元素都能找到自己的位置)</p><p>但这样有一个弊端就是，此时 <strong>20</strong> 占据了一个本不属于它的位置 <strong>2</strong> ，如若下次来了一个本就映射到位置 <strong>2</strong> 的元素，那么它也只好继续向后探测，换句话说，虽然你解决了一个冲突，但同时又产生了另一个产生冲突的隐患，而且甚至还有可能出现无限冲突的情况。另一方面对于要在表中删除元素的情况，处理起来也不太方便。</p><p><strong>2. 链地址法</strong></p><p>这种思想是将所有映射到位置 <strong>i</strong> 的元素构建一条链表，并将单链表的头指针存在哈希表的第 <strong>i</strong> 个单元中，这样做的好处是一方面不会出现前面方法的那种解决一个哈希冲突，又带了新冲突隐患的问题，另一方面是在元素的删除上也能很好的处理，只需删除对应节点即可。但缺点也有，就是可能会在某个位置出现一条很长很长的链，增加了时间的开销。</p><p><strong>3.再哈希法</strong></p><p>这种方式是选取多个哈希函数，若第 <strong>j</strong> 个哈希函数出现了冲突，那么选用第 <strong>j+1</strong> 个哈希函数计算，直至找到不发生冲突的哈希函数。又或者使用同一个哈希函数，以上一轮产生的哈希值作为键值进行再次映射，直至找到可用的位置。</p><p>**4. 其他结局冲突方法 **</p><p>除了以上这些方法外，还有很多类似的方法，如平方探测法等等</p><p><strong>解决问题（设计更好的哈希函数）</strong></p><p>这类处理思路都是着重于当冲突发生的时候如何处理，此外，另一种解决冲突的思想便是在冲突发生之前尽可能的减少冲突的发生概率，即设计更好的哈希函数。</p><p><strong>1. 使用更大的哈希表</strong></p><p>不难想到，一张更大的哈希表能降低冲突发生的概率，以之前的简单哈希函数为例，极端情况是如果把 <strong>m</strong> 取得很大到 <strong>1010</strong> 时，那么显然就不会发生冲突了。一般而言，在经验和习惯上，会将哈希表的大小设置在元素个数的 <strong>1~10</strong> 倍之间，以实现在较小空间冗余的代价上，减小冲突的发生，提高时间效率。</p><p><strong>2. 更好的哈希运算</strong></p><p>之前提到的最简单的哈希函数，被称为除留余数法，可以说没有对键值 <strong>k</strong> 作任何的处理，直接进行了求余数，而如果我们加上些其它的运算，便能够使得映射更加复杂，以达到更随机的映射效果。例如下面的一阶线性映射：<br>H ( k ) &#x3D; ( a × k + b )  m o d  m ( a , m ∈ Z ) H(k) &#x3D; (a×k + b)\ mod\ m (a,m \in Z)<em>H</em>(<em>k</em>)&#x3D;(<em>a</em>×<em>k</em>+<em>b</em>) <em>m<strong>o</strong>d</em> <em>m</em>(<em>a</em>,<em>m</em>∈<em>Z</em>)从理论上来说， <strong>a</strong>、<strong>b</strong>、<strong>m</strong>取不要太接近2的幂或10的幂的数会更好(同理前面简单取余的哈希函数里的 <strong>m</strong> 也一样)，冲突率更小，有兴趣的可以上网找找相关证明，这里之间简单说一下如果 <strong>m</strong> 取偶数，由于一个偶数对偶数取余结果仍然是偶数，这将导致所有的偶数元素只能映射到偶数位置，显然将会导致分布不均匀，容易出现冲突。<br>再来看看下面的乘法映射。<br>H ( k ) &#x3D; ( A ⋅ k  m o d  2 w )  r s h  ( w − r ) H(k) &#x3D; (A·k\ mod\ 2^w)\ rsh\ (w-r)<em>H</em>(<em>k</em>)&#x3D;(<em>A</em>⋅<em>k</em> <em>m<strong>o</strong>d</em> 2<em>w</em>) <em>r<strong>s</strong>h</em> (<em>w</em>−<em>r</em>)其中 <strong>m&#x3D;2r</strong> ，<strong>w</strong> 表示计算机一个字的长度的bit位数，<strong>A</strong> 为奇数，且 <strong>2(w-r) &lt; A &lt; 2w</strong>(A不能太接近2w-r和2w)， <strong>rsh</strong> 指右移运算。<br>这是一个快速的哈希算法，介于编译器对这些二进制运算的优化，有兴趣的查阅相关资料，这里不做过多说明。</p><h3 id="摩尔投票"><a href="#摩尔投票" class="headerlink" title="摩尔投票"></a>摩尔投票</h3><p>摩尔投票法：摩尔投票法的核心思想为<strong>对拼消耗</strong>。首先我们考虑最基本的摩尔投票问题，比如找出一组数字序列中出现次数大于总数一半的数字（并且假设这个数字一定存在）。我们可以直接利用反证法证明这样的数字只可能有一个。</p><p><strong>Example:</strong></p><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>当然这题也可以直接sort排序然后因为最多的数超过一半长度，所以排序后中间的数一定是最大的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">majorityElement2</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> nums[<span class="number">0</span>],count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count==<span class="number">0</span>)&#123;</span><br><span class="line">                result = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=result)&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">solve</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="literal">null</span>||length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> <span class="number">0</span>,count2 = <span class="number">0</span>,result1 = nums[<span class="number">0</span>],result2 = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="comment">//注意顺序逻辑，因为result1和result2一开始已经赋值了</span></span><br><span class="line">            <span class="keyword">if</span> (num==result1)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num==result2)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count1==<span class="number">0</span>)&#123;</span><br><span class="line">                result1=num;</span><br><span class="line">                count1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count2==<span class="number">0</span>)&#123;</span><br><span class="line">                result2 = num;</span><br><span class="line">                count2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count1--;</span><br><span class="line">            count2--;</span><br><span class="line">        &#125;</span><br><span class="line">        count1=<span class="number">0</span>;</span><br><span class="line">        count2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result1==nums[i])&#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result2==nums[i])&#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count1&gt;length/<span class="number">3</span>)&#123;</span><br><span class="line">            list.add(result1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count2&gt;length/<span class="number">3</span>)&#123;</span><br><span class="line">            list.add(result2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="双指针技巧"><a href="#双指针技巧" class="headerlink" title="双指针技巧"></a>双指针技巧</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span></span><br><span class="line"><span class="comment">请注意 ，必须在不复制数组的情况下原地对数组进行操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*1、定义两个指针i和k，初始化i = 0，k = 0。</span></span><br><span class="line"><span class="comment">    2、i指针向后移动，遍整个nums数组，如果 nums[i] != 0，也就是说遇到了非0元素，此时我们就将nums[i]元素放置到nums[k]位置</span></span><br><span class="line"><span class="comment">    ，同时k++后一位。</span></span><br><span class="line"><span class="comment">    3、最后将k位置之后的元素都赋值为0。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">moveZeroes1</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[k++]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k&lt;length)&#123;</span><br><span class="line">            nums[k++]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k </span></span><br><span class="line"><span class="comment">，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">你返回所有和为 0 且不重复的三元组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：答案中不可以包含重复的三元组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [-1,0,1,2,-1,-4]</span></span><br><span class="line"><span class="comment">输出：[[-1,-1,2],[-1,0,1]]</span></span><br><span class="line"><span class="comment">解释：</span></span><br><span class="line"><span class="comment">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span></span><br><span class="line"><span class="comment">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span></span><br><span class="line"><span class="comment">注意，输出的顺序和三元组的顺序并不重要。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//如果length不大于三不会有三元组</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组用Arrays.sort()排序，List用Collections.sort()排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">//当第一个数大于0，最后一个数为整数且是最大的，中间的数为多少三个数加起来都不会为0</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i=0时存在只有三个0的情况，这种情况满足，右边条件是去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//left为中间加数，i为左边加数，right为右边加数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (total == <span class="number">0</span>) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    list.add(nums[left]);</span><br><span class="line">                    list.add(nums[right]);</span><br><span class="line">                    result.add(list);</span><br><span class="line">                    <span class="comment">//下面两个while和left++，right--都是去重后得到正确的数</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>####Floyd判圈算法（龟兔赛跑算法）</p><ul><li><strong>可以在有限<a href="https://so.csdn.net/so/search?q=%E7%8A%B6%E6%80%81%E6%9C%BA&spm=1001.2101.3001.7020">状态机</a>、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。</strong></li></ul><ol><li>判断链表上是否存在环</li></ol><p>设两个指针<code>t</code>和<code>h</code>已不同步伐（<code>t</code>一步<code>h</code>两步）从起点出发：如果快指针到达了链表尾部，两者都没相遇，则没有环。如果两个指针相遇，则有环。（快2步相当于快的走两圈，慢的走一圈，快的走一圈没有终点就会再走一圈跟慢的相遇）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle1</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>求链表环的起点</li></ol><p>两个指针相遇，设相遇点为<code>M</code>，让<code>h</code>指针留在<code>M</code>点，<code>t</code>指针回到原点<code>head</code>，两个指针同时已每次一步的步伐前进，再次相遇时即为环的起点。</p><ol start="3"><li>链表环的长度</li></ol><p>两个指针相遇，设相遇点为<code>M</code>，让<code>h</code>指针留在<code>M</code>点，<code>t</code>指针继续前进，每次一步。再次到达<code>M</code>点时，前进的步数即为环的长度。                        </p><h4 id="双指针解决求相交链表问题"><a href="#双指针解决求相交链表问题" class="headerlink" title="双指针解决求相交链表问题"></a>双指针解决求相交链表问题</h4><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/">相交链表 - 相交链表 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回两个链表相交的节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="翻转链表（逆序输出）"><a href="#翻转链表（逆序输出）" class="headerlink" title="翻转链表（逆序输出）"></a>翻转链表（逆序输出）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无脑list倒序输出即可,借助空间了</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">result</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(result);</span><br><span class="line">            result = result.next;</span><br><span class="line">        &#125;</span><br><span class="line">        result = list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">        head = result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result.next = list.get(i);</span><br><span class="line">            result = result.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意一开始节点的next为第二个节点，倒序后原第一个节点next为null才对</span></span><br><span class="line">        result.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其实完全没必要借助list，可以用一个节点保存前一个，遍历到下一个的时候把next转为上一个（迭代）</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList1</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">now</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> now.next;</span><br><span class="line">            now.next = pre;</span><br><span class="line">            pre = now;</span><br><span class="line">            now = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="判断是否是回文链表"><a href="#判断是否是回文链表" class="headerlink" title="判断是否是回文链表"></a>判断是否是回文链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先把链表的值全部复制到list判断    </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">now</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(now.val);</span><br><span class="line">            now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Objects.equals(list.get(left), list.get(right))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>关于树的几个术语：</strong> <strong>节点</strong>，<strong>根节点</strong>，<strong>父节点</strong>，<strong>子节点</strong>，<strong>叶子节点</strong>，<strong>节点的权（节点值）</strong>，<strong>路径（从root找到该节点的路线）</strong>，<strong>层</strong>，<strong>子树</strong>，<strong>树的高度（最大层数）</strong>，<strong>森林（多棵子树构成森林）</strong></p><p><strong>二叉树：</strong> 每个节点<strong>最多</strong>只有两个子节点，分为左子节点和右子节点</p><p><strong>满二叉树：</strong> 如果一棵二叉树的叶子节点都在最后一层，且节点总数为2^n-1，n为层数</p><p><strong>完全二叉树：</strong> 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称这为完全二叉树</p><p>**二叉查找树:*<em>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</em>判断一棵二叉树是不是二叉搜索树用递归写法（遍历传参包括当前允许最小值和最大值和当前判断节点，如果不在允许范围就返回false，然后递归左右子树，遍历传参更改范围值即可，递归左子树更改最大值，递归右子树更改最小值，只能说设计很巧妙）。*</p><p><strong>关于二叉树代码（有备注）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ShuJuJieGou;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="comment">//创建二叉树</span></span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建需要的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>, <span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>, <span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置节点的关系，二叉树一般是遍历创建，这里是测试就手动创建了，主要看三中遍历</span></span><br><span class="line">        root.setLeft(node1);</span><br><span class="line">        root.setRight(node2);</span><br><span class="line">        node2.setRight(node3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);<span class="comment">//1 2 3 4</span></span><br><span class="line">        binaryTree.preOrder1();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        binaryTree.preOrder2();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历：&quot;</span>);<span class="comment">//2 1 3 4</span></span><br><span class="line">        binaryTree.midOrder1();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        binaryTree.midOrder2();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历：&quot;</span>);<span class="comment">//2 4 3 1</span></span><br><span class="line">        binaryTree.postOrder1();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        binaryTree.postOrder2();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;层次遍历：&quot;</span>);<span class="comment">//1 2 3 4</span></span><br><span class="line">        binaryTree.floorOrder();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;树的深度：&quot;</span>);</span><br><span class="line">        binaryTree.getDeep1();</span><br><span class="line">        binaryTree.getDeep2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="comment">//只要有根节点就可以进行遍历</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个数的root节点是Node类型，带有Node类型的方法，也就是说只要把root确定就可以开始遍历</span></span><br><span class="line">    <span class="comment">/*递归*/</span></span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不为空才调用方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder1();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrder1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不为空才调用方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.midOrder1();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不为空才调用方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder1();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个数的root节点是Node类型，带有Node类型的方法，也就是说只要把root确定就可以开始遍历</span></span><br><span class="line">    <span class="comment">/*递归*/</span></span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不为空才调用方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrder2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不为空才调用方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.midOrder2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不为空才调用方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*层次遍历*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floorOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.floorOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*求树的最大深度*/</span></span><br><span class="line">    <span class="comment">//层次遍历基础上演变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeep1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.root.getDeep1());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归求解子树最大深度加1就是整棵树的最大深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeep2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.root.getDeep2(<span class="built_in">this</span>.root));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//不构造left和right，让左右节点默认为空,当然也可以构建，这样子就不需要left和right的get和set方法了，都一样其实</span></span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(Node left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(Node right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> + <span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*递归写法*/</span></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//能进这个方法说明这个节点不为空</span></span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrder1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.midOrder1();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.midOrder1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.postOrder1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.postOrder1();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*迭代写法，借助栈*/</span></span><br><span class="line">    <span class="comment">//前序遍历,直接写法虽然简单，但为了统一还是用两个while这种吧，方便记忆，不过感觉都行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder2</span><span class="params">()</span> &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*        stack.push(this);</span></span><br><span class="line"><span class="comment">        while (!stack.empty())&#123;</span></span><br><span class="line"><span class="comment">            Node node = stack.pop();</span></span><br><span class="line"><span class="comment">            System.out.format(&quot;%d %s\n&quot;,node.getId(),node.getName());</span></span><br><span class="line"><span class="comment">            //栈先进后出，为了让左孩子先出来就得让左孩子后入栈</span></span><br><span class="line"><span class="comment">            if (node.right!=null)&#123;</span></span><br><span class="line"><span class="comment">                stack.push(node.right);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if (node.left!=null)&#123;</span></span><br><span class="line"><span class="comment">                stack.push(node.left);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> || !stack.empty()) &#123;</span><br><span class="line">            <span class="comment">//这里输出过的节点要保存在栈中，因为还要回溯回来得到它的右节点，可以先得到它但不输出直接通过它拿到右节点</span></span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.format(<span class="string">&quot;%d %s\n&quot;</span>, node.getId(), node.getName());</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左边输出完了要回溯右边，结束一次循环，换一棵子树</span></span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrder2</span><span class="params">()</span> &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> || !stack.empty()) &#123;</span><br><span class="line">            <span class="comment">//每次都把最左边的节点放在最后</span></span><br><span class="line">            <span class="comment">//节点不为空时，把左子树的所有结点都入栈，因为栈是后进先出的，所以最后一个入栈的一定是当前二叉树左子树的最后一个结点</span></span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            System.out.format(<span class="string">&quot;%d %s\n&quot;</span>, node.getId(), node.getName());</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder2</span><span class="params">()</span> &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//pre代表上一次已经处理完的节点</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> || !stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="literal">null</span> || node.right == pre) &#123;</span><br><span class="line">                <span class="comment">//此时右边树已经处理完，可以输出这个节点了</span></span><br><span class="line">                System.out.format(<span class="string">&quot;%d %s\n&quot;</span>, node.getId(), node.getName());</span><br><span class="line">                pre = node;<span class="comment">//node此时为处理完的节点</span></span><br><span class="line">                node = <span class="literal">null</span>;<span class="comment">//node处理完了要处理其他子树了，把node变成null，去获取栈里面上个节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明这个节点右边有树要处理，把这个节点存起来先，且这个节点没有左树了，因为一开始一路向左，</span></span><br><span class="line">               <span class="comment">//这个节点是一棵树最左边那个</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*层次遍历*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floorOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            node = queue.poll();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*求树的深度*/</span></span><br><span class="line">    <span class="comment">//在层次遍历的基础上求树的最大深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDeep1</span><span class="params">()</span> &#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//next队列是存放下一层节点的，每存一层count++最后就可以根据count的数值知道树的深度</span></span><br><span class="line">            Queue&lt;Node&gt; next = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//能进入循环说明存当前这层数据的队列不为空，层数+1</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//队列被一直抛出，长度在减少，如果用队列长度判断是否结束会出错，可以一开始作为</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    next.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    next.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                queue = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种求解深度的方法是得到最长的左右子数的深度加1即可，递归实现，深度更快</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDeep2</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//判断传入的这个节点是否为空，为空返回0，不为空继续求这个节点的子树的深度</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(getDeep2(node.left), getDeep2(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历按照层添加节点值到list</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue_now = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue_now.add(root);</span><br><span class="line">            <span class="keyword">while</span> (!queue_now.isEmpty()) &#123;</span><br><span class="line">                Queue&lt;TreeNode&gt; queue_next = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> queue_now.size();</span><br><span class="line">                <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue_now.poll();</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                        queue_next.add(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                        queue_next.add(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num--;</span><br><span class="line">                &#125;</span><br><span class="line">                queue_now = queue_next;</span><br><span class="line">                result.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h3><h4 id="首先认识备忘录方法"><a href="#首先认识备忘录方法" class="headerlink" title="首先认识备忘录方法"></a>首先认识备忘录方法</h4><h4 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以多建一个数组用来保存k的位置，也就是断开的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DP_Solve</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从1开始填</span></span><br><span class="line">    <span class="type">int</span> target[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//这里可以一开始初始斜对角为0也可以后面填充的时候再添加0</span></span><br><span class="line"><span class="comment">//    for (int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//        target[i][i]=0;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                target[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            target[i][j] = target[i][i] + target[i + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[i] * p[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                <span class="type">int</span> temp = target[i][k] + target[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j];</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; target[i][j]) &#123;</span><br><span class="line">                    target[i][j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">DP_Solve</span>(p, n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最长公共子序列，最长公共子串"><a href="#最长公共子序列，最长公共子串" class="headerlink" title="最长公共子序列，最长公共子串"></a>最长公共子序列，最长公共子串</h4><ul><li>子串是连在一起的数字，而子序列是可以断开的</li></ul><p>​<code>ababc</code>和<code>cbaab</code>最长公共子串为2，而最长子序列为3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最长子序列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LENGTH = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归公式(target[i][j]表示第一个串长度为i,第二个串长度为j时最长子序列长度),i=1,j=1开始填表</span></span><br><span class="line"><span class="comment"> * 两个串最后一个值相等就相当于看前面n-1个子串最长子串值就是数组的值加1,否则就是第一个串减1长度保存的值或者第二个串减1长度保存的值</span></span><br><span class="line"><span class="comment"> * 当i=0时整一行为0,当j=0时整一列为0,递归先添加边界值,斜边从小到大添加</span></span><br><span class="line"><span class="comment"> * 当string1[i-1]=string2[j-1]时(i和j表示长度),target[i][j]=target[i-1][j-1]+1</span></span><br><span class="line"><span class="comment"> * 否则target[i][j] = max(target[i - 1][j], target[i][j - 1])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DP_Solve</span><span class="params">(string string1, string string2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> target[LENGTH][LENGTH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= string1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= string2.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (string1[i - <span class="number">1</span>] == string2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                target[i][j] = target[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[i][j] = <span class="built_in">max</span>(target[i - <span class="number">1</span>][j], target[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[string1.<span class="built_in">size</span>()][string2.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string string1, string2;</span><br><span class="line">    cin &gt;&gt; string1 &gt;&gt; string2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">DP_Solve</span>(string1, string2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最长子串，可以用来优化前面的最长子序列，空间上更合理</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归公式(target[i][j]表示第一个串下标为i,第二个串下标为j时最长子序列长度),i=0,j=0开始填表</span></span><br><span class="line"><span class="comment"> * 两个串最后一个值相等就相当于看前面n-1个子串最长子串值就是数组的值加1,否则就是0</span></span><br><span class="line"><span class="comment"> * 一开始把整个表初始化为0</span></span><br><span class="line"><span class="comment"> * 当string1[i]=string2[j]且i！=0,j!=0时(i和j表示下标),target[i][j]=target[i-1][j-1]+1</span></span><br><span class="line"><span class="comment"> * 当string1[i]=string2[j]且i和j有0时时(i和j表示下标),target[i][j]=1</span></span><br><span class="line"><span class="comment"> * 否则target[i][j] = 0*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DP_Solve</span><span class="params">(string string1, string string2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length1 = string1.<span class="built_in">size</span>(), length2 = string2.<span class="built_in">size</span>(), max = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> **target = <span class="keyword">new</span> <span class="type">int</span> *[length1];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length1; ++i) &#123;</span><br><span class="line">        target[i] = <span class="keyword">new</span> <span class="type">int</span>[length2]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length1; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length2; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (string1[i] == string2[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) &#123;</span><br><span class="line">                    target[i][j] = target[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    target[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (target[i][j] &gt; max) &#123;</span><br><span class="line">                    max = target[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string string1, string2;</span><br><span class="line">    cin &gt;&gt; string1 &gt;&gt; string2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">DP_Solve</span>(string1, string2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h4><p>给定n(n&lt;&#x3D;100)种物品和一个背包。物品i的重量是wi，价值为vi，背包的容量为C(C&lt;&#x3D;1000)。问:应如何选择装入背包中的物品，使得装入背包中物品的总价值最大? 在选择装入背包的物品时，对每种物品i只有两个选择：装入或不装入。不能将物品i装入多次，也不能只装入部分物品i。</p><p>输入格式：</p><p>共有n+1行输入： 第一行为n值和c值，表示n件物品和背包容量c； 接下来的n行，每行有两个数据，分别表示第i(1≤i≤n)件物品的重量和价值。</p><p>输出格式：</p><p>输出装入背包中物品的最大总价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入格式</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="comment">//输出格式</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//有n种物品</span></span><br><span class="line"><span class="type">int</span> c;<span class="comment">//背包容量为n</span></span><br><span class="line"><span class="type">int</span> w[<span class="number">101</span>];<span class="comment">//物品i的重量</span></span><br><span class="line"><span class="type">int</span> v[<span class="number">101</span>];<span class="comment">//物品i的价值</span></span><br><span class="line"><span class="type">int</span> target[<span class="number">101</span>][<span class="number">1001</span>];<span class="comment">/*</span></span><br><span class="line"><span class="comment">保存当前判断到第i个物品且剩余容量为j时最优值*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*(背包能装时，不能装直接跳过)target[i][j]=max(target[i+1][j],target[i+1][j-w[i]]+v[i]);</span></span><br><span class="line"><span class="comment">当只有一个物品时</span></span><br><span class="line"><span class="comment">target[n][j]=v[n];(还能装的时候)</span></span><br><span class="line"><span class="comment">target[n][j]=0(不能装了)*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DP_Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=c;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[n]&gt;j)&#123;</span><br><span class="line">            target[n][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            target[n][j]=v[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&lt;=j)&#123;</span><br><span class="line">                target[i][j]=<span class="built_in">max</span>(target[i+<span class="number">1</span>][j],target[i+<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                target[i][j]=target[i+<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[<span class="number">1</span>][c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">DP_Solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图最短路问题（弗洛伊德算法）"><a href="#图最短路问题（弗洛伊德算法）" class="headerlink" title="图最短路问题（弗洛伊德算法）"></a>图最短路问题（弗洛伊德算法）</h4><h3 id="回溯算法Backtrack"><a href="#回溯算法Backtrack" class="headerlink" title="回溯算法Backtrack"></a>回溯算法Backtrack</h3><ul><li><p><strong>回溯算法有“通用的解题法”之称，回溯实际上是一种试探算法，这种算法跟暴力搜索最大的不同在于，在回溯算法里，是一步一步地小心翼翼地进行向前试探，会对每一步探测到的情况进行评估，如果当前的情况已经无法满足要求，那么就没有必要继续进行下去，也就是说，它可以帮助我们避免走很多的弯路。</strong></p></li><li><p><strong>回溯算法的特点在于，当出现非法的情况时，算法可以回退到之前的情景，可以是返回一步，有时候甚至可以返回多步，然后再去尝试别的路径和办法。这也就意味着，想要采用回溯算法，就必须保证，每次都有多种尝试的可能。这种以深度优先方式系统搜索问题的算法称为回溯法，适合解组合数较大的问题</strong></p></li></ul><p><strong>步骤</strong></p><ul><li><strong>定义解空间</strong></li></ul><p>​可以通过一维的向量来保存结果和要试的数</p><ul><li><strong>试解</strong></li></ul><p>​试解的这个过程最主要的是要把这些数组织起来，一般是以<strong>解空间树</strong>这种形式组织起来，对于有n个数这棵树就会有n层，每层的这个值有加进去结果集和不加进去两中情况并且是在上一层各个节点的情况下继续的，这样就形成了一棵能表示所有组合的一棵满二叉树，只要以<strong>深度优先遍历</strong>整棵树就能得到所有的组合（这个解空间树是不用以一个数据结构搭建出来的）</p><p>​而仅仅知道解空间树还没有用，还需要避免在搜索结果都过程中<strong>避免无效搜索</strong>，这个过程叫<strong>剪枝</strong>，剪枝有<strong>两种方式</strong>，一种是<strong>约束函数</strong>  （扩展节点时剪去不满足约束的子树），一种是<strong>限界函数</strong>（剪去得不到最优解的子树）</p><p>​解空间树有<strong>三种典型的解空间树</strong>（三种问题种类）</p><p>子集树就是每个物品都去看选择与否组成最优解，而排列树是看n个点按照顺序不同有多少种的排列组合</p><pre><code>    1. 子集树（0-1背包问题）    2. 排列树（旅行售货员）</code></pre><p><strong>递归回溯写法模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Backtrack</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//t表示当前为第几层(深度)</span></span><br><span class="line">    <span class="comment">//if为递归结束条件(t &gt; n即为叶子节点)</span></span><br><span class="line">    <span class="keyword">if</span>(t &gt; n)&#123;</span><br><span class="line">        <span class="built_in">Output</span>(x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//f(n, t)，g(n, t)分别表示扩展结点的子树的起始编号和终止编号，尝试这些解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">f</span>(n, t); i &lt;= <span class="built_in">g</span>(n, t); i++)&#123;</span><br><span class="line">            x[t] = <span class="built_in">h</span>(i);<span class="comment">//h(i)表示第i个可选值</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Constraint</span>(t) &amp;&amp; <span class="built_in">Bound</span>(t))&#123;</span><br><span class="line">                <span class="comment">//Constraint和Bound分别表示约束函数和限界函数</span></span><br><span class="line">                <span class="built_in">Backtrack</span>(t+<span class="number">1</span>);<span class="comment">//通过全局变量了解当前状态知道遍历到是哪个孩子节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子集树（0-1背包问题）"><a href="#子集树（0-1背包问题）" class="headerlink" title="子集树（0-1背包问题）"></a>子集树（0-1背包问题）</h4><ul><li><strong>数据量小时就可以不剪枝，但数据量大就要剪值了</strong></li></ul><p><strong>无剪枝，只有约束函数(条件)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">good</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//n件物品</span></span><br><span class="line"><span class="type">int</span> c;<span class="comment">//c为背包容量</span></span><br><span class="line"><span class="type">int</span> max_value = <span class="number">-1</span>;<span class="comment">//最大价值</span></span><br><span class="line"><span class="type">int</span> c_temp = <span class="number">0</span>, v_temp = <span class="number">0</span>;<span class="comment">//存当前装入容量和价值</span></span><br><span class="line">good *goods;<span class="comment">//存货物信息</span></span><br><span class="line"><span class="type">bool</span> *result_max;<span class="comment">//保存最优结果时这个点选不选，当到叶子节点时如果最大值被刷新就要更新这个数组</span></span><br><span class="line"><span class="type">bool</span> *visited;<span class="comment">//保存遍历过程中这个点是否选择</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回溯算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Backtrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//t&gt;n表示走到叶子节点了</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v_temp &gt; max_value) &#123;</span><br><span class="line">            max_value = v_temp;</span><br><span class="line">            <span class="comment">//当最大价值被刷新才复制选择结果到最佳选择情况数组，不然就会到叶子节点就复制了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                result_max[i] = visited[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//else这一块代码也可以用一个循环来弄，n从0到1的循环，visited[t]=0表示不放，处理，visited[t]=1表示放，处理</span></span><br><span class="line">        <span class="comment">//选这个点，判断装进去会不会超，会肯定只能不选了，约束函数(条件)</span></span><br><span class="line">        <span class="keyword">if</span> (goods[t].weight + c_temp &lt;= c) &#123;</span><br><span class="line">            c_temp += goods[t].weight;</span><br><span class="line">            v_temp += goods[t].value;</span><br><span class="line">            visited[t] = <span class="literal">true</span>;<span class="comment">//选了它</span></span><br><span class="line">            <span class="built_in">Backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//下面是递归回来，要回溯把选上的值全部不要了</span></span><br><span class="line">            c_temp -= goods[t].weight;</span><br><span class="line">            v_temp -= goods[t].value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不选这个点,那种就直接跳到下一层就可以了</span></span><br><span class="line">        visited[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">Backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    goods = <span class="keyword">new</span> good[n + <span class="number">1</span>];</span><br><span class="line">    result_max = <span class="keyword">new</span> <span class="type">bool</span>[n + <span class="number">1</span>];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">bool</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//从1号下标开始存东西</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; goods[i].weight &gt;&gt; goods[i].value;</span><br><span class="line">        result_max[i] = <span class="literal">false</span>;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; max_value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result_max[i]) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>有剪枝，约束函数(条件)加限界函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">good</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">double</span> unit_price;<span class="comment">//单位价格</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//n件物品</span></span><br><span class="line"><span class="type">int</span> c;<span class="comment">//c为背包容量</span></span><br><span class="line"><span class="type">int</span> max_value = <span class="number">-1</span>;<span class="comment">//最大价值</span></span><br><span class="line"><span class="type">int</span> c_temp = <span class="number">0</span>, v_temp = <span class="number">0</span>;<span class="comment">//存当前装入容量和价值</span></span><br><span class="line">good *goods;<span class="comment">//存货物信息</span></span><br><span class="line"><span class="type">bool</span> *result_max;<span class="comment">//保存最优结果时这个点选不选，当到叶子节点时如果最大值被刷新就要更新这个数组</span></span><br><span class="line"><span class="type">bool</span> *visited;<span class="comment">//保存遍历过程中这个点是否选择</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序规则，单位价值高的在前面</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(good good1, good good2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> good1.unit_price &gt; good2.unit_price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*限界函数，原理其实也很简单，就在一开始按照跟贪心一样的单位价格进行排序，</span></span><br><span class="line"><span class="comment">把剩下的要处理的点里面把单位价格高的物品装进去背包肯定能得到最高的价值，</span></span><br><span class="line"><span class="comment">虽然题目原本是不允许装一部分物品的，但如果最大可能性都比之前保存的最高价值小那肯定不用处理这棵子树了，处理了也是浪费时间*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Bound</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = c_temp;</span><br><span class="line">    <span class="type">double</span> value = v_temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp + goods[i].weight &lt;= c) &#123;</span><br><span class="line">            temp += goods[i].weight;</span><br><span class="line">            value += goods[i].value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value += (c - temp) * goods[i].unit_price;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; max_value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回溯算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Backtrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//t&gt;n表示走到叶子节点了</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v_temp &gt; max_value) &#123;</span><br><span class="line">            max_value = v_temp;</span><br><span class="line">            <span class="comment">//当最大价值被刷新才复制选择结果到最佳选择情况数组，不然就会到叶子节点就复制了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                result_max[i] = visited[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//else这一块代码也可以用一个循环来弄，n从0到1的循环，visited[t]=0表示不放，处理，visited[t]=1表示放，处理</span></span><br><span class="line">        <span class="comment">//选这个点，判断装进去会不会超，会肯定只能不选了，约束函数(条件)</span></span><br><span class="line">        <span class="keyword">if</span> (goods[t].weight + c_temp &lt;= c) &#123;</span><br><span class="line">            c_temp += goods[t].weight;</span><br><span class="line">            v_temp += goods[t].value;</span><br><span class="line">            visited[t] = <span class="literal">true</span>;<span class="comment">//选了它</span></span><br><span class="line">            <span class="built_in">Backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//下面是递归回来，要回溯把选上的值全部不要了</span></span><br><span class="line">            c_temp -= goods[t].weight;</span><br><span class="line">            v_temp -= goods[t].value;</span><br><span class="line">            visited[t] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不选这个点,那种就直接跳到下一层就可以了,限界函数Bound</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Bound</span>(t + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">Backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    goods = <span class="keyword">new</span> good[n + <span class="number">1</span>];</span><br><span class="line">    result_max = <span class="keyword">new</span> <span class="type">bool</span>[n + <span class="number">1</span>];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">bool</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; goods[i].weight &gt;&gt; goods[i].value;</span><br><span class="line">        goods[i].unit_price = (<span class="type">double</span>) goods[i].value / (<span class="type">double</span>) goods[i].weight;</span><br><span class="line">        result_max[i] = <span class="literal">false</span>;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(goods + <span class="number">1</span>, goods + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="built_in">Backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; max_value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result_max[i]) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>####排列树（旅行售货员）</p><p>某售货员要到若干城市去推销商品，已知各城市之间的路程(或旅费)。他要选定一条从驻地出发，经过每个城市一遍，最后回到驻地的路线，使总的路程（或总旅费）最小。</p><p><strong>输入格式:</strong></p><p>第一行为城市数n</p><p>下面n行n列给出一个完全有向图，如 i 行 j 列表示第 i 个城市到第 j 个城市的距离。</p><p><strong>输出格式:</strong></p><p>一个数字，表示最短路程长度。</p><p><strong>输入样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 2 1</span><br><span class="line">1 0 2</span><br><span class="line">2 1 0</span><br></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>理解：</strong></p><p>这道题和前面的子集树最明显的不同就是子集树主要是针对某个点的选择与不选，是一颗满二叉树，但这题就不是了，这道题要知道的是n个点的排列组合（这里假设都是从点1出发）</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//城市点的个数</span></span><br><span class="line"><span class="type">int</span> *best;<span class="comment">//记录最短路径的排列</span></span><br><span class="line"><span class="type">int</span> dis_min = <span class="number">0x3f3f3f3f</span>;<span class="comment">//记录最短路径的长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *dis;<span class="comment">//记录遍历过程中保存的节点和路径信息</span></span><br><span class="line"><span class="type">int</span> *vist;<span class="comment">//记录遍历过的信息</span></span><br><span class="line"><span class="type">int</span> dis_temp = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> **g;<span class="comment">//保存图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归到第t层</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) &#123;</span><br><span class="line">        <span class="comment">//注意这里是g[dis[t-1]][1]或者g[dis[n]][1],最后一个点，而不是直接n</span></span><br><span class="line">        <span class="keyword">if</span> (dis_temp + g[dis[t<span class="number">-1</span>]][<span class="number">1</span>] &lt; dis_min) &#123;</span><br><span class="line">            dis_min = dis_temp + g[dis[t<span class="number">-1</span>]][<span class="number">1</span>];<span class="comment">//判断条件和这一句可以写g[dis[n]][1]的，一样的，dis是保存这次遍历的路径信息的，</span></span><br><span class="line">            <span class="comment">// 可以通过dis[t]确认当前添加到点，那么dis[t-1]自然就是上次添加到点了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                best[i] = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代码初始化后都以第一个点为起始点，并把visit[1]置为1了，这个循环是按照题目来的，把每个点都当做第二个点为开始遍历点，</span></span><br><span class="line">    <span class="comment">//遍历到就把visit中对应的点置为1即可，在递归中就不会再查找找过的点，这样子就能遍历完所有的点，最后回溯即可换另一个点进行遍历了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vist[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            vist[i] = <span class="number">1</span>;</span><br><span class="line">            dis[t] = i;</span><br><span class="line">            dis_temp += g[dis[t<span class="number">-1</span>]][i];</span><br><span class="line">            <span class="comment">//约束函数</span></span><br><span class="line">            <span class="keyword">if</span> (dis_temp &lt; dis_min) &#123;</span><br><span class="line">                <span class="built_in">backTrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            vist[i] = <span class="number">0</span>;</span><br><span class="line">            dis_temp -= g[dis[t - <span class="number">1</span>]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    g = <span class="keyword">new</span> <span class="type">int</span> *[n + <span class="number">1</span>];<span class="comment">//从1开始</span></span><br><span class="line">    best = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    dis = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    vist = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        g[i] = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    best[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    vist[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//这个很容易忘记</span></span><br><span class="line">    <span class="built_in">backTrack</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//    for (int i = 1; i &lt;= n; ++i) &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; best[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    cout &lt;&lt; dis_min &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="k叉树（n后问题）"><a href="#k叉树（n后问题）" class="headerlink" title="k叉树（n后问题）"></a>k叉树（n后问题）</h4><p>在n×n格的棋盘上放置彼此不受攻击的n个皇后。按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n后问题等价于在n×n格的棋盘上放置n个皇后，任何2个皇后不放在同一行或同一列或同一斜线上</p><p><strong>输入格式:</strong></p><p>一个数字n</p><p><strong>输出格式:</strong></p><p>按照深度优先输出所有可行的解</p><p><strong>输入样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 4 1 3 </span><br><span class="line">3 1 4 2 </span><br></pre></td></tr></table></figure><p><strong>理解</strong></p><p>对于每一行都可以把棋子放在任何一个地方，这样可以构成一棵n叉树</p><p>我们从第一行开始放皇后，每一行只能放一个皇后，这样就不用考虑行会冲突了，而列就可以通过路径数组（result数组）来判断前面有没有放过这一列，斜线的话就可以根据三角形性质，当两个点的横坐标的相差（就是绝对值）和纵坐标相差相等就在一条斜线上来判断（这两个条件构成约束函数），当到达最后一行直接输出路径即可</p><p>其实也可以用求排列的思想来实现，行和列都不同，那所有点就是一个排列，最后判断是不是所有点都不在斜线上即可</p><p><strong>代码:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/30.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//有几个皇后</span></span><br><span class="line"><span class="type">int</span> *result;<span class="comment">//保存结果，下标从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断本次这一行把这个数字放进能不能成立</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; t; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((result[i] == result[t]) || (<span class="built_in">abs</span>(result[t] - result[i]) == <span class="built_in">abs</span>(t - i))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//n叉树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">//一行一行放的，一行放一个，所以不用考虑有行冲突</span></span><br><span class="line">        result[t] = i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(t)) &#123;</span><br><span class="line">            <span class="built_in">backTrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//result[i]表示第i行放在哪一列</span></span><br><span class="line">    result = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">backTrack</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维递归回溯（求解数独）"><a href="#二维递归回溯（求解数独）" class="headerlink" title="二维递归回溯（求解数独）"></a>二维递归回溯（求解数独）</h4><ul><li><strong>本身也是k叉树，但是比n后问题多一个维度，因为n后问题每次递归其实就是完成一行，递归可以看成是行遍历，而递归中填写这一行是遍历这一行中每个点，可以看成是列遍历，对于每个点就是简单的放与不放皇后（一个循环就可以解决），但数独还要看是填哪个数字</strong></li></ul><p>返回值为bool类型，因为其实只要得到一个数独的解就可以返回了</p><p>终止条件其实也在下面的处理逻辑中给包含了，只有放满才会返回true，否则就返回false，一定会有返回值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断数独填写过程中这个数字能不能填</span></span><br><span class="line"><span class="comment">//line第一行,row第几列</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isWriteAvailable</span><span class="params">(<span class="type">int</span> line, <span class="type">int</span> row, <span class="type">int</span> **target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同列不能有相同数字，i==line就是同个格子来的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW_NUM; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != line &amp;&amp; target[i][row] == target[line][row]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同行不能有相同数字，j==row就是同个格子来的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= ROW_NUM; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j != row &amp;&amp; target[line][j] == target[line][row]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//规定的九个格子里面数字各不相同,可以找到这个格子所在的块的左上角这个坐标</span></span><br><span class="line">    <span class="comment">//根据这个格子是第几行求出对于九个格子其实点的行坐标</span></span><br><span class="line">    <span class="type">int</span> temp1 = line / <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> temp2 = line % <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> start1;</span><br><span class="line">    <span class="keyword">if</span> (temp2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        start1 = temp1 * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start1 = (temp1 - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据这个格子是第几列求出对于九个格子其实点的列坐标</span></span><br><span class="line">    <span class="type">int</span> temp3 = row / <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> temp4 = row % <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> start2;</span><br><span class="line">    <span class="keyword">if</span> (temp4 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        start2 = temp3 * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start2 = (temp3 - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始判断所在块是否符合,不在目标格子并且周围的数字跟它相同就不能放进去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start1; i &lt; start1 + <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = start2; j &lt; start2 + <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != line &amp;&amp; j != row &amp;&amp; target[i][j] == target[line][row]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面条件都满足就走到这里，返回true即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求解算法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solveSudoku</span><span class="params">(<span class="type">int</span> **target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两层循环去找哪个格子未填数字就去填这个格子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW_NUM; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= ROW_NUM; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//填数字,1到9</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= ROW_NUM; ++k) &#123;</span><br><span class="line">                    target[i][j] = k;<span class="comment">//先填，填完去判断填进去成不成立，成立递归</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isWriteAvailable</span>(i, j, target)) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">solveSudoku</span>(target))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果下一层没有得到结果就要回到这里，那么就找另一个数字去填看能不能成功，如果下一层成功就直接return了，走不到这里</span></span><br><span class="line">                    target[i][j] = <span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有格子能填完直接返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="一些例题（这里是很典型能看出区别的）"><a href="#一些例题（这里是很典型能看出区别的）" class="headerlink" title="一些例题（这里是很典型能看出区别的）"></a>一些例题（这里是很典型能看出区别的）</h4><p><strong>子集合问题（子集树）</strong></p><p>设集合S&#x3D;{x1,x2,…,xn}是一个正整数集合，c是一个正整数，子集和问题判定是否存在S的一个子集S1，使S1中的元素之和为c。试设计一个解子集和问题的回溯法，并输出利用回溯法在搜索树（按输入顺序建立）中找到的第一个解。</p><p><strong>输入格式:</strong></p><p>输入数据第1行有2个正整数n和c，n表示S的大小，c是子集和的目标值。接下来的1行中，有n个正整数，表示集合S中的元素。<br>是子集和的目标值。接下来的1 行中，有n个正整数，表示集合S中的元素。</p><p><strong>输出格式:</strong></p><p>输出利用回溯法找到的第一个解，以空格分隔，最后一个输出的后面有空格。当问题无解时，输出“No Solution!”。</p><p><strong>输入样例:</strong></p><p>在这里给出一组输入。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 10</span><br><span class="line">2 2 6 5 4</span><br></pre></td></tr></table></figure><p><strong>输出样例:</strong></p><p>在这里给出相应的输出。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 2 6 </span><br></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//集合元素个数</span></span><br><span class="line"><span class="type">int</span> target;<span class="comment">//目标子集合的合</span></span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *ints;<span class="comment">//保存集合</span></span><br><span class="line"><span class="type">bool</span> *result;<span class="comment">//保存结果</span></span><br><span class="line"><span class="type">bool</span> *visited;<span class="comment">//保存递归过程中的状态</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历右子树也就是不选时如果所有值加起来都没有目标值大就没必要递归了，限界函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Bound</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt; n; ++i) &#123;</span><br><span class="line">        sum += ints[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Backtrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp == target) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            result[i] = visited[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//约束函数</span></span><br><span class="line">    <span class="keyword">if</span> (t &lt; n &amp;&amp; !flag &amp;&amp; temp &lt; target) &#123;</span><br><span class="line">        temp += ints[t];</span><br><span class="line">        visited[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">Backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        temp -= ints[t];</span><br><span class="line">        visited[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Bound</span>(t + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">Backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; target;</span><br><span class="line">    ints = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    result = <span class="keyword">new</span> <span class="type">bool</span>[n];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">bool</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; ints[i];</span><br><span class="line">        result[i] = <span class="literal">false</span>;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Backtrack</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result[i]) &#123;</span><br><span class="line">                cout &lt;&lt; ints[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No Solution!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全排列</strong></p><p>请编写程序输出前<em>n</em>个正整数的全排列（<em>n</em>&lt;10），并通过9个测试用例（即<em>n</em>从1到9）观察<em>n</em>逐步增大时程序的运行时间。</p><p><strong>输入格式:</strong></p><p>输入给出正整数<em>n</em>（&lt;10）。</p><p><strong>输出格式:</strong></p><p>输出1到<em>n</em>的全排列。每种排列占一行，数字间无空格。排列的输出顺序为字典序，即序列<em>a</em>1,<em>a</em>2,⋯,<em>a**n</em>排在序列<em>b</em>1,<em>b</em>2,⋯,<em>b**n</em>之前，如果存在<em>k</em>使得<em>a</em>1&#x3D;<em>b</em>1,⋯,<em>a**k</em>&#x3D;<em>b**k</em> 并且 <em>a**k</em>+1&lt;<em>b**k</em>+1。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">132</span><br><span class="line">213</span><br><span class="line">231</span><br><span class="line">312</span><br><span class="line">321</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//从1到n全排列</span></span><br><span class="line"><span class="type">int</span> *visited;<span class="comment">//标记是否遍历过，这题就从大到小假设一开始就进入一个点然后递归遍历其他点即可</span></span><br><span class="line"><span class="type">int</span> *temp;<span class="comment">//保存遍历过程结果</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;<span class="comment">//标记要不要输出回车的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历到最后一层，直接输出即可</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是最后一层就是遍历其他点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            temp[t] = i;</span><br><span class="line">            <span class="built_in">backTrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            visited[i] = <span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    temp = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">        temp[<span class="number">1</span>] = i;</span><br><span class="line">        <span class="built_in">backTrack</span>(<span class="number">2</span>);</span><br><span class="line">        visited[i] = <span class="number">0</span>;<span class="comment">//这轮结束把一开始的点改为未访问，下一轮换点为初始点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回溯法总结"><a href="#回溯法总结" class="headerlink" title="回溯法总结"></a>回溯法总结</h4><ul><li><p>求子集：从n个元素的集合S中找出满足某个性质的<strong>子集</strong>。<strong>（每个节点都是可选或者不选的）</strong>其搜索树称为子集树，是典型的二叉树，通常有<code>2^n</code>个叶子节点，遍历时间为O（2^n）</p></li><li><p>求排列：n个节点的<strong>排列组合</strong>。<strong>（每个节点都包括在内，顺序不同罢了）</strong>其中搜索树称为排列树，通常有<code>n!</code>个叶子节点，因此遍历排列树需要时间为O（n!），这个算法有两种书写方法，还是习惯用visit数组保存遍历过节点信息的方法，<strong>都是从第二层开始遍历</strong></p></li><li><p>求路径：只需要找到一条路径便可以得到解。设每个状态有k个后继，其搜索树为k叉树，其节点总数为<code>k^(n+1)-1</code>，遍历的时间为O（k^n）,<strong>每层都可以选n个点中的任意一个</strong>，以n后问题来看，其实也可以用求排列的思想来实现，行和列都不同，那所有点就是一个排列，最后判断是不是所有点都不在斜线上即可</p></li></ul><h3 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h3><p>相较于回溯法就是广度优先遍历</p><ul><li><p><strong>队列式分支限界法</strong></p></li><li><p><strong>优先队列式分支限界法</strong></p></li></ul><h4 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h4><p><strong>普通队列</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/12/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">good</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">double</span> average;</span><br><span class="line">&#125;;<span class="comment">//物品信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp_value;<span class="comment">//当前价值</span></span><br><span class="line">    <span class="type">int</span> remain;<span class="comment">//剩余</span></span><br><span class="line">    <span class="type">int</span> deep;<span class="comment">//层数</span></span><br><span class="line">&#125;;<span class="comment">//扩展节点</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//物品个数</span></span><br><span class="line"><span class="type">int</span> c;<span class="comment">//背包容量</span></span><br><span class="line">good *goods;<span class="comment">//保存物品信息</span></span><br><span class="line"><span class="type">int</span> max_value = <span class="number">0</span>;<span class="comment">//最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sort排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(good good1, good good2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> good1.average &gt; good2.average;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减枝，限界函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bound</span><span class="params">(node *node)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = node-&gt;temp_value;</span><br><span class="line">    <span class="type">int</span> temp = node-&gt;remain;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = node-&gt;deep + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (goods[i].weight &lt;= temp) &#123;</span><br><span class="line">            temp -= goods[i].weight;</span><br><span class="line">            sum += goods[i].value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += goods[i].average * temp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; max_value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分支限界法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(node *head)</span> </span>&#123;</span><br><span class="line">    queue&lt;node *&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node *temp = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        max_value = <span class="built_in">max</span>(max_value, temp-&gt;temp_value);</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;deep &lt; n &amp;&amp; goods[temp-&gt;deep + <span class="number">1</span>].weight &lt;= temp-&gt;remain) &#123;</span><br><span class="line">            node *left_child = <span class="keyword">new</span> node;</span><br><span class="line">            left_child-&gt;deep = temp-&gt;deep + <span class="number">1</span>;</span><br><span class="line">            left_child-&gt;remain = temp-&gt;remain - goods[left_child-&gt;deep].weight;</span><br><span class="line">            left_child-&gt;temp_value = temp-&gt;temp_value + goods[left_child-&gt;deep].value;</span><br><span class="line">            queue.<span class="built_in">push</span>(left_child);</span><br><span class="line">            max_value = <span class="built_in">max</span>(max_value, left_child-&gt;temp_value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;deep &lt; n &amp;&amp; <span class="built_in">bound</span>(temp)) &#123;</span><br><span class="line">            node *right_child = <span class="keyword">new</span> node;</span><br><span class="line">            right_child-&gt;deep = temp-&gt;deep + <span class="number">1</span>;</span><br><span class="line">            right_child-&gt;remain = temp-&gt;remain;</span><br><span class="line">            right_child-&gt;temp_value = temp-&gt;temp_value;</span><br><span class="line">            queue.<span class="built_in">push</span>(right_child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    goods = <span class="keyword">new</span> good[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; goods[i].weight &gt;&gt; goods[i].value;</span><br><span class="line">        goods[i].average = <span class="built_in">double</span>(goods[i].value) / goods[i].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(goods + <span class="number">1</span>, goods + n + <span class="number">1</span>, cmp);</span><br><span class="line">    node *head = <span class="keyword">new</span> node;</span><br><span class="line">    head-&gt;deep = <span class="number">0</span>;</span><br><span class="line">    head-&gt;temp_value = <span class="number">0</span>;</span><br><span class="line">    head-&gt;remain = c;</span><br><span class="line">    <span class="built_in">dfs</span>(head);</span><br><span class="line">    cout &lt;&lt; max_value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="八数码问题八重境界"><a href="#八数码问题八重境界" class="headerlink" title="八数码问题八重境界"></a>八数码问题八重境界</h3><p><strong>境界二（广搜+哈希（康托展开））：</strong></p><h3 id="力扣做题遇到技巧总结"><a href="#力扣做题遇到技巧总结" class="headerlink" title="力扣做题遇到技巧总结"></a>力扣做题遇到技巧总结</h3><p>借助前面的数求解当前值，时间为1</p><p>338题</p><p>如果题目叫尝试空间复杂度为1的话要记录可以借助题目给定范围之外的数字</p><p>448题</p><h4 id="备注一下"><a href="#备注一下" class="headerlink" title="备注一下"></a>备注一下</h4><p>贪心算法和动态规划有个不同的就是动态规划后面的子问题不会影响前面子问题，但贪心算法就会，比如力扣121很明显最小值会改变并且后面的结果依靠新的最小值，后面的子问题跟前面的就没关系了</p><p>11题自己想用贪心写不出来，后面回去看看</p><p>79回溯</p><p>public <a href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a> void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</p><p>src:源数组;</p><p>srcPos:源数组要复制的起始位置;</p><p>dest:目的数组;</p><p>destPos:目的数组放置的起始位置;</p><p>length:复制的长度.</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发常用 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Pages+Hexo+Git快速搭建个人博客</title>
      <link href="/2023/11/17/GitHub+Hexo+Git/"/>
      <url>/2023/11/17/GitHub+Hexo+Git/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub-Pages-Hexo-Git快速搭建个人博客"><a href="#GitHub-Pages-Hexo-Git快速搭建个人博客" class="headerlink" title="GitHub Pages+Hexo+Git快速搭建个人博客"></a>GitHub Pages+Hexo+Git快速搭建个人博客</h1><h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p><strong>简介</strong></p><p>Node.js发布于2009年5月，由Ryan Dahl开发，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I&#x2F;O模型，让JavaScript 运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。</p><p><strong>简单理解</strong></p><p> 脚本语言需要一个解析器才能运行，JavaScript是脚本语言，在不同的位置有不一样的解析器，如写入html的js语言，浏览器是它的解析器角色。而对于需要独立运行的JS，nodejs就是一个解析器。</p><p><strong>官网</strong></p><p><a href="https://nodejs.org/en">Node.js (nodejs.org)</a></p><p><strong>安装教程</strong></p><p><a href="https://blog.csdn.net/muzidigbig/article/details/80493880">NodeJS入门（一）—nodejs详细安装步骤_nodejs安装及环境配置-CSDN博客</a></p><p><strong>其他</strong></p><p>并且Node.js为大多数平台提供了官方的安装程序，可以通过Node.js的相关命令在命令行安装官方安装程序。</p><p>安装完成后可以通过<code>node -v</code>查看node.js的版本，安装Node.js后npm（Node Package Manager）会随之安装，这是因为 npm 在 Node.js 生态系统中被广泛使用，几乎所有的 Node.js 项目都依赖于 npm 来管理项目的依赖关系和构建任务，可以通过<code>npm -v</code>命令查看npm的版本。</p><hr><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p><strong>简介</strong></p><p>Git 是一个免费且开源的分布式版本控制系统，旨在处理从小型到 具有速度和效率的超大型项目。</p><p>Git 易于学习，占用空间小，性能快如闪电。 它优于 Subversion、CVS、Perforce 和 ClearCase 等 SCM 工具 具有廉价本地分支等功能， 方便的暂存区域和多个工作流程。</p><p><strong>官网</strong></p><p><a href="https://git-scm.com/">Git (git-scm.com)</a></p><p><strong>安装教程</strong></p><p><a href="https://blog.csdn.net/mukes/article/details/115693833?ops_request_misc=%7B%22request_id%22:%22170018840816800213035331%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170018840816800213035331&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115693833-null-null.142%5Ev96%5Epc_search_result_base9&utm_term=Git%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187">【精选】Git 详细安装教程（详解 Git 安装过程的每一个步骤）_git安装_mukes的博客-CSDN博客</a></p><p><strong>其他</strong></p><p>下面是Git和GitHub的一些介绍，Hexo初始化项目需要通过Git去拉取</p><p><a href="https://blog.csdn.net/jiahuan_/article/details/105933423?ops_request_misc=%7B%22request_id%22:%22170018857116800211523315%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170018857116800211523315&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105933423-null-null.142%5Ev96%5Epc_search_result_base9&utm_term=Git%E5%92%8CGithub&spm=1018.2226.3001.4187">Git和Github详细入门教程（别再跟我说你不会Git和Github)_git github-CSDN博客</a></p><p><a href="https://blog.csdn.net/a2360051431/article/details/130836633?ops_request_misc=%7B%22request_id%22:%22170018857116800211523315%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170018857116800211523315&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-130836633-null-null.142%5Ev96%5Epc_search_result_base9&utm_term=Git%E5%92%8CGithub&spm=1018.2226.3001.4187">一篇文章搞懂Git与Github_git github_一名机电研究生的博客-CSDN博客</a></p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p><strong>简介</strong></p><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p><strong>官网</strong></p><p><a href="https://hexo.io/zh-cn/">Hexo官网</a></p><p><strong>安装教程</strong></p><p><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p><p><strong>其他</strong></p><p>可以直接从官网的文档中了解Hexo的具体使用</p><p>Hexo的在GitHub的项目地址</p><p><a href="https://githubfast.com/hexojs/hexo">hexojs&#x2F;hexo：一个快速、简单和强大的博客框架，由 Node.js 提供支持。 (githubfast.com)</a></p><p><strong>常用命令</strong></p><p><code>hexo clean</code> 清除已生成文件及缓存</p><p><code>hexo generate</code> 生成静态页面，简写做 <code>hexo g</code></p><p><code>hexo deploy</code>推送到 github 库，简写做<code> hexo d</code></p><p><code>hexo server </code>启动本地 WEB 服务器，简写做 <code>hexo s</code></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li><p>安装Node.js</p></li><li><p>安装Git</p></li><li><p>安装Hexo</p></li><li><p>安装部署插件</p><p>在Hexo目录下通过Git Bash</p><p><code>npm install hexo-deployer-git --save</code></p></li><li><p>Hexo初始化项目</p><p>在你需要存放项目的路径下打开Git Bash输入<code>hexo init &lt;folder&gt;</code>，这里我输入<code>hexo init myBlog</code>就会在路径下生成<code>myBlog</code>文件夹，之后输入<code>cd &lt;folder&gt;</code>就进入生成的文件夹，这里输入<code>cd myBlog</code>，最后输入<code>npm install</code>即可</p></li><li><p>简单运行</p><p>在初始化项目路径下（如使用上面命令那么初始化项目路径就是<code>myBlog</code>）通过<code>Git Bash</code>（在文件夹下右击选择<code>Open Git Bash here</code>打开命令行窗口）使用<code>Hexo s</code>后就开启服务，可以在本地浏览器访问<code>localhost:4000</code>访问到Hexo初始化的项目构建的网站了，Hexo服务的默认端口是4000，如果端口出现了冲突可以使用<code>Hexo s -p 2000</code>命令指定端口号（这里指定端口号为2000）</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191208281.png"></p></li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191208588.png" alt="image-20231117110109912"></p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="加载主题"><a href="#加载主题" class="headerlink" title="加载主题"></a>加载主题</h3><p>可以通过官网从已有的主题中选择自己喜欢的主题以应用到网站主页，我选择的主题是Butterfly</p><p><a href="https://hexo.io/themes/">Themes | Hexo|主题官网</a></p><p><a href="https://www.butterfly1.cn/problem.html">Hexo-Butterfly主题 | 主题文档(🦋Hexo butterfly theme document) (butterfly1.cn)</a></p><ul><li><p>首先需要先下载主题，可以直接下载，如果作者有在其他地方（如GitHub）进行介绍使用Git的下载方式也可以使用，下载主题后放置到项目的<code>themes</code>目录下（自行从Hexo官网查阅项目初始化不同文件夹的作用）</p></li><li><p>修改Hexo初始项目下的<code>_config.yml</code>文件（不是下载的主题目录下的）中的<code>theme</code>属性指定主题，<strong>注意theme:后面加空格再接值</strong></p></li></ul><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191209345.png" alt="image-20231117113139545"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191209868.png" alt="image-20231119111518672"></p><ul><li>之后执行<code>hexo g</code>（清除缓存，生成新的静态文件)然后再<code>hexo s</code>运行，刷新界面即可看到变化</li></ul><h3 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h3><p>可以继续在项目的<code>_config.yml</code>文件下配置一下基本信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="comment">#标题</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">myBlog</span></span><br><span class="line"><span class="comment">#副标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">记录学习</span></span><br><span class="line"><span class="comment">#个性签名</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">加油！</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="comment">#作者</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">无泪真伤</span></span><br><span class="line"><span class="comment">#语言</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="comment">#中国的时区</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure><p>之后可以配置主题相关的了，更加详细的配置可以查阅相关主题的文档介绍，这里只进行简单介绍，<strong>修改主题可以按照官网的建议来（非常详细了）</strong>，也可以直接在下载的主题目录下的<code>_config.yml</code>文件中直接修改，可以直接使用记事本打开搜索关键词快速定位到相应配置的地方</p><p><a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">非官网介绍主题配置</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Menu 目录，显示在顶部</span></span><br><span class="line"><span class="comment"># 这里只演示了简单写法，具体参考官方文档，按需求使用</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># Code Blocks (代码相关)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="comment"># 代码主题</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">pale</span> <span class="string">night</span> <span class="comment">#  darker / pale night / light / ocean / mac / mac light / false</span></span><br><span class="line"><span class="comment"># 代码是否显示复制按钮</span></span><br><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span> <span class="comment"># copy button</span></span><br><span class="line"><span class="comment"># 显示代码使用的语言，这个是自己在markdown中标注的语言</span></span><br><span class="line"><span class="attr">highlight_lang:</span> <span class="literal">true</span> <span class="comment"># show the code language</span></span><br><span class="line"><span class="comment"># 是否自动展开</span></span><br><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">false</span> <span class="comment"># true: shrink the code blocks / false: expand the code blocks | none: expand code blocks and hide the button</span></span><br><span class="line"><span class="comment"># 代码高度限制，可展开，要限制把false替换成具体数字，单位为px</span></span><br><span class="line"><span class="attr">highlight_height_limit:</span> <span class="literal">false</span> <span class="comment"># unit: px</span></span><br><span class="line"><span class="comment"># 代码过长自动换行</span></span><br><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">true</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Favicon（网站图标）</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/img/86634.jpg</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 边栏</span></span><br><span class="line"><span class="comment"># Avatar (头像)</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="comment"># http可以直接输入图床图像进行加载，也可以使用本地img下的图像</span></span><br><span class="line">  <span class="comment"># 头像是否一直旋转</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不展示顶部图像</span></span><br><span class="line"><span class="attr">disable_top_img:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置顶部图片</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="string">https://pic.imgdb.cn/item/655825b2c458853aef027a19.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章详情页顶部图片，没有在front-matter设置top_img和cover下使用该图</span></span><br><span class="line"><span class="attr">default_top_img:</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 归档顶部图像</span></span><br><span class="line"><span class="attr">archive_img:</span> <span class="string">https://pic.imgdb.cn/item/65582792c458853aef088495.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tag界面顶部图像</span></span><br><span class="line"><span class="attr">tag_img:</span> <span class="string">https://pic.imgdb.cn/item/65582792c458853aef088495.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独设置</span></span><br><span class="line"><span class="comment"># format:</span></span><br><span class="line"><span class="comment">#  - tag name: xxxxx</span></span><br><span class="line"><span class="attr">tag_per_img:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类界面顶部图像</span></span><br><span class="line"><span class="attr">category_img:</span> <span class="string">https://pic.imgdb.cn/item/65582792c458853aef088495.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独设置</span></span><br><span class="line"><span class="comment"># format:</span></span><br><span class="line"><span class="comment">#  - category name: xxxxx</span></span><br><span class="line"><span class="attr">category_per_img:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># 是否显示文章封面</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># the position of cover in home page (封面位置)</span></span><br><span class="line">  <span class="comment"># left/right/both</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">both</span></span><br><span class="line">  <span class="comment"># When cover is not set, the default cover is displayed (没有设置cover时，默认显示)</span></span><br><span class="line">  <span class="comment"># 随机选择，前面加上-</span></span><br><span class="line">  <span class="attr">default_cover:</span></span><br><span class="line">      <span class="comment"># - https://pic.imgdb.cn/item/65586ff1c458853aef149c7e.jpg</span></span><br><span class="line">      <span class="comment"># - https://pic.imgdb.cn/item/65587027c458853aef156fb1.jpg</span></span><br><span class="line">      <span class="comment"># - https://pic.imgdb.cn/item/6558704bc458853aef160963.jpg</span></span><br><span class="line">      <span class="comment"># - https://pic.imgdb.cn/item/6558706bc458853aef16912a.jpg</span></span><br><span class="line">      <span class="comment"># - https://pic.imgdb.cn/item/65587081c458853aef16f416.jpg</span></span><br><span class="line">    <span class="comment"># - https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace Broken Images (替换无法显示的图片)</span></span><br><span class="line"><span class="attr">error_img:</span></span><br><span class="line">  <span class="attr">flink:</span> <span class="string">/img/friend_404.gif</span></span><br><span class="line">  <span class="attr">post_page:</span> <span class="string">/img/404.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A simple 404 page（404图片）</span></span><br><span class="line"><span class="attr">error_404:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&#x27;Page Not Found&#x27;</span></span><br><span class="line">  <span class="attr">background:</span> <span class="string">https://i.loli.net/2020/05/19/aKOcLiyPl2JQdFD.png</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># the subtitle on homepage (主页subtitle)</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Customize typed.js (配置typed.js)</span></span><br><span class="line">  <span class="comment"># https://github.com/mattboldt/typed.js/#customization</span></span><br><span class="line">  <span class="attr">typed_option:</span></span><br><span class="line">  <span class="comment"># source 调用第三方服务</span></span><br><span class="line">  <span class="comment"># source: false 开关</span></span><br><span class="line">  <span class="comment"># source: 1  調用一言網的一句話（簡體） https://hitokoto.cn/</span></span><br><span class="line">  <span class="comment"># source: 2  調用一句網（簡體） https://yijuzhan.com/</span></span><br><span class="line">  <span class="comment"># source: 3  調用今日詩詞（簡體） https://www.jinrishici.com/</span></span><br><span class="line">  <span class="comment"># subtitle 會先顯示 source , 再顯示 sub 的內容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果打开打字效果，subtitle 只会显示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">如果你很迷茫的话就去读书，健身，这是唯一你付出就会有回报的东西</span>  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="attr">theme_color:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># main: &quot;#2D4554&quot; # 主要的颜色，底部，选中，按钮等</span></span><br><span class="line">  <span class="attr">main:</span> <span class="string">&quot;#15405D&quot;</span></span><br><span class="line">  <span class="comment"># paginator: &quot;#00c4b6&quot;  # 页码选中颜色</span></span><br><span class="line">  <span class="attr">paginator:</span> <span class="string">&quot;#30867F&quot;</span></span><br><span class="line">  <span class="comment"># button_hover: &quot;#FF7242&quot; # 按钮选中按钮</span></span><br><span class="line">  <span class="attr">button_hover:</span> <span class="string">&quot;#00c4b6&quot;</span></span><br><span class="line">  <span class="comment"># text_selection: &quot;#00c4b6&quot; # 复制等鼠标滑动选择一段字时的颜色</span></span><br><span class="line">  <span class="attr">text_selection:</span> <span class="string">&quot;#509892&quot;</span></span><br><span class="line">  <span class="comment"># meta_color: &quot;#858585&quot; # 显示发布时间等的字体颜色</span></span><br><span class="line">  <span class="attr">meta_color:</span> <span class="string">&quot;#858585&quot;</span></span><br><span class="line">  <span class="comment"># hr_color: &quot;#A4D8FA&quot; #暂时不知道</span></span><br><span class="line">  <span class="comment"># hr_color: &quot;#F70456&quot;</span></span><br><span class="line">  <span class="attr">code_foreground:</span> <span class="string">&quot;#F47466&quot;</span></span><br><span class="line">  <span class="attr">code_background:</span> <span class="string">&quot;rgba(27, 31, 35, .05)&quot;</span></span><br><span class="line">  <span class="comment"># toc_color: &quot;#00c4b6&quot; # 目录显示toc，就是阅读界面选中颜色</span></span><br><span class="line">  <span class="attr">toc_color:</span> <span class="string">&quot;#30867F&quot;</span></span><br><span class="line">  <span class="comment"># blockquote_padding_color: &quot;#49b1f5&quot;</span></span><br><span class="line">  <span class="comment"># blockquote_background_color: &quot;#49b1f5&quot; # 暂时这个和上面的不知道</span></span><br><span class="line">  <span class="comment"># blockquote_background_color: &quot;#01101B&quot;</span></span><br><span class="line">  <span class="comment"># scrollbar_color: &quot;#49b1f5&quot; # 滑动条颜色</span></span><br><span class="line">  <span class="attr">scrollbar_color:</span> <span class="string">&quot;#2A536D&quot;</span></span><br><span class="line">  <span class="comment"># meta_theme_color_light: &quot;ffffff&quot;</span></span><br><span class="line">  <span class="comment"># meta页面是显示文章相关信息的</span></span><br><span class="line">  <span class="comment"># meta_theme_color_light: &quot;#BDBBBB&quot;</span></span><br><span class="line">  <span class="comment"># meta_theme_color_light: &quot;#0d0d0d&quot;</span></span><br><span class="line">  <span class="comment"># meta_theme_color_dark: &quot;#0d0d0d&quot;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Website Background (设置网站背景)</span></span><br><span class="line"><span class="comment"># can set it to color or image (可设置图片或者颜色)</span></span><br><span class="line"><span class="comment"># The formal of image: url(http://xxxxxx.com/xxx.jpg)</span></span><br><span class="line"><span class="attr">background:</span> <span class="string">url(https://pic.imgdb.cn/item/6558cafec458853aef90363f.jpg)</span></span><br></pre></td></tr></table></figure><h3 id="博客书写规则"><a href="#博客书写规则" class="headerlink" title="博客书写规则"></a>博客书写规则</h3><p>这里直接看网站文档介绍，讲的很清楚了</p><p><a href="https://butterfly.js.org/posts/dc584b87/#Post-Front-matter">Butterfly 安裝文檔(二) 主題頁面 | Butterfly</a></p><h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3><ul><li><p>这里需要先在Git中配置SSH，（GitHub推荐使用方式）可以在博客发布的Git相关文章中查阅到，不懂的可以先看Git的文章</p></li><li><p>新建GitHub仓库，我的仓库名<code>为wuleizhenshang.github.io</code>用来存放博客，并在<code>_config.yml</code>中进行配置</p><p> <img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191209638.png" alt="image-20231117222658079"></p></li><li><p>之后在Git Bash中输入<code>hexo g</code>等待生成完成后输入<code>hexo d</code>上传到配置文件设置的GitHub的仓库上，可以手动把md文件放到<code>source/_posts</code>下</p></li><li><p>之后就可以通过指定的网址进行访问，这里我的仓库名为<code>wuleizhenshang.github.io</code>，之后在浏览器输入仓库名作为网址就可以访问</p></li></ul><h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><p><strong>如果使用图床写博客的话需要在Hexo中做一些更改</strong></p><p>http请求体的header中有一个referrer字段，用来表示发起http请求的源地址信息，这个referrer信息是可以省略但是不可修改的，就是说你只能设置是否带上这个referrer信息，不能定制referrer里面的值。服务器端在拿到这个referrer值后就可以进行相关的处理，比如图片资源，可以通过referrer值判断请求是否来自本站，若不是则返回403或者重定向返回其他信息，从而实现图片的防盗链。上面出现403就是因为，请求的是别人服务器上的资源，但把自己的referrer信息带过去了，被对方服务器拦截返回了403。这样加载不到图床的图像。</p><p><strong>解决</strong></p><p>在下载的主题目录下的<code>layout/includes</code>目录下有一个<code>head.pug</code>文件，修改该文件的meta信息，会使生成的所有页面都带有该head。在head.pug文件中添加如下内容，结果参见图片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">meta</span>(name=<span class="string">&quot;referrer&quot;</span> content=<span class="string">&quot;no-referrer&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191209470.png" alt="image-20231119120805384"></p><h3 id="可能遇到问题"><a href="#可能遇到问题" class="headerlink" title="可能遇到问题"></a>可能遇到问题</h3><p>   <strong>仓库公开才允许访问</strong></p><p>   GitHub官网有说明，公开的仓库或者升级仓库才能使用GitHub Pages功能，升级需要付费，这里把仓库设置为公开仓库就好</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191209967.png" alt="image-20231117212215793"></p><p>​修改仓库是否为公开在仓库的设置的基础设置的最下面可以进行修改</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191209049.png" alt="image-20231117212448073"></p><p><strong>仓库为公开但输入网址为404</strong></p><p>可能访问网址发现打不开可能需要等待一下，过段时间才能部署好，还有就是可能需要在GitHub Pages中设置一下解析的分支</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191209624.png" alt="image-20231117212606182"></p><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><p>首先需要了解GitHub Pages是什么，可以通过下面的链接查看具体的介绍</p><p><a href="https://zhuanlan.zhihu.com/p/647963756">GitHub Pages 是什么？ - 知乎 (zhihu.com)</a></p><p>通过Hexo快速生成静态网页后通过Git上传到GitHub的仓库上，在仓库设置中设置GitHub Pages访问的网页为生成的静态网页就实现了具体的功能，而Node.js就是运行Hexo的必要环境。</p><h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h2><p>绑定个人域名后可以输入个人域名跳转到GitHub Pages页面</p><ol><li><p>首先需要拥有一个个人域名，自行购买</p></li><li><p>添加CNAME文件，共有三种方式进行创建</p><ul><li><p>直接在Hexo初始化的项目下的<code>source</code>文件夹在新建<code>CNAME</code>文件（这个文件没有后缀名，可以先创建为txt文件，修改完后删除后缀），里面输入自己的域名即可</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191209005.png" alt="image-20231117215745546"></p></li></ul><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191209131.png" alt="image-20231117215818235"></p><ul><li><p>直接在GitHub项目主页里面的<code>Create new file</code>按钮进行创建，因为在本地创建完上传项目到GitHub也会一起上传这个文件</p></li><li><p>在GitHub项目中的Setting标签下的Custom domain中直接填入域名，然后点击Save保存即可</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191210369.png" alt="image-20231117215351427"></p></li></ul></li><li><p>配置域名解析，我这里是腾讯云购买的域名</p><p>配置<code>CNAME</code>记录类型，主机记录可以写为<code>www</code>，记录值可以写为你的域名，这样可以通过www+你的域名访问到GitHub Pages，路线类型选默认类型就行</p></li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191210221.png" alt="image-20231117232828687"></p><ol start="4"><li><p>设置为Https安全访问</p><p>在域名解析完成后可Enforce HTTPS就可以勾选了，勾选后就可以进行Https安全访问</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202311191210013.png" alt="image-20231117231934712"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非关系型数据库（选修课）</title>
      <link href="/2023/10/11/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E9%80%89%E4%BF%AE%E8%AF%BE%EF%BC%89/"/>
      <url>/2023/10/11/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E9%80%89%E4%BF%AE%E8%AF%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="非关系型数据库（选修课）"><a href="#非关系型数据库（选修课）" class="headerlink" title="非关系型数据库（选修课）"></a>非关系型数据库（选修课）</h1><p>上课老师发的课件合计，下载地址如下</p><p><a href="https://wwcz.lanzout.com/b04kt28wb">https://wwcz.lanzout.com/b04kt28wb</a></p><p>密码:4a0t</p><hr><h2 id="Redis基础内容"><a href="#Redis基础内容" class="headerlink" title="Redis基础内容"></a>Redis基础内容</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>简介</strong></p><p>Remote Dictionary Server，简称Redis，即远程字典服务器，它是一个开源的、高性能的、基于键值对的缓存与存储数据库，并且通过提供多种键值数据结构来适应不同场景下的缓存与存储需求。Redis数据库是基于ANSI C语言编写开发的，并且提供了多种语言API，例如Java、C&#x2F;C++、C#、PHP、JavaScript、Perl、Python及Ruby等语言。</p><p><strong>特点</strong></p><ul><li>支持多种数据结构</li><li>功能丰富</li><li>应用广泛</li><li>读写速度快</li></ul><p><strong>应用场景</strong></p><ul><li>构建队列系统</li><li>排行榜</li><li>实时的垃圾系统</li><li>数据自动过期处理</li><li>计数器应用</li><li>缓存</li></ul><p><strong>支持的数据结构</strong></p><ul><li>String（字符串）</li><li>List（列表）</li><li>Set（集合）</li><li>Hash（散列）</li><li>Sorted Sets（有序集合）</li></ul><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>启动 redis-cli 客户端工具，可以做如下处理：</p><p>修改 cmd 控制台的编码格式为 UTF-8：</p><p>命令：chcp 65001</p><p>然后再输入：</p><p>命令：redis-cli –raw</p><p>再查询时，就能得到想要的中文数据了。</p><h4 id="Key（键）"><a href="#Key（键）" class="headerlink" title="Key（键）"></a>Key（键）</h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SET</td><td>为指定键设置值</td></tr><tr><td>MSET</td><td>为多个键设置值</td></tr><tr><td>GET</td><td>获取指定键等值</td></tr><tr><td>MGET</td><td>获取多个键对应的值</td></tr><tr><td>EXISTS</td><td>判断指定键是否存在</td></tr><tr><td>KEYS</td><td>查找所有符合给定pattern（正则表达式）的键</td></tr><tr><td>DUMP</td><td>序列化置顶的键，并返回被序列化的值</td></tr><tr><td>TYPE</td><td>查看指定键的类型</td></tr><tr><td>RENAME</td><td>重命名指定键的键名</td></tr><tr><td>EXPIRE</td><td>设置指定键的生存时间，以秒为单位</td></tr><tr><td>TTL</td><td>查看指定键的剩余生存时间</td></tr><tr><td>PERSIST</td><td>移除键的生存时间</td></tr><tr><td>DEL</td><td>在键存在时，删除键</td></tr></tbody></table><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310091411821.jpg" alt="img"></p><h4 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h4><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/ed51cb6e01193b494c5b3b953d72fdeceb4ff3b7/img/202309132144659.png"></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SET</td><td>为指定键设置值</td></tr><tr><td>MSET</td><td>为多个键设置值</td></tr><tr><td>GET</td><td>获取指定字符串key中的值</td></tr><tr><td>MGET</td><td>获取多个字符串key中的值</td></tr><tr><td>GETSET</td><td>获取指定字符串的旧值并设置新值</td></tr><tr><td>STRLEN</td><td>获取字符串的字节长度</td></tr><tr><td>GETRANGE</td><td>获取字符串键指定索引范围的值的内容</td></tr><tr><td>SETRANGE</td><td>为字符串的指定索引位置设置值</td></tr><tr><td>APPEND</td><td>追加新内容到值的末尾</td></tr></tbody></table><p><strong>注：setrange是指定一个字符串的开始替换位置，然后从这个位置开始把要设置的值替换进去，相当于从指定位置开始把原始值和指定值做覆盖，指定值覆盖在原始值上面</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310091345977.png" alt="image-20231009134539937"></p><h4 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h4><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/107996c962e2d2e88caa0d8a9506a941405f1e0d/img/202309132144835.png"></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>LPUSH</td><td>将一个或多个元素推入到列表的左端</td></tr><tr><td>RPUSH</td><td>将一个或多个元素推入到列表的右端</td></tr><tr><td>LRANGE</td><td>获取列表指定索引范围内的元素</td></tr><tr><td>LINDEX</td><td>获取列表指定索引位置上的元素</td></tr><tr><td>LPOP</td><td>弹出列表最左端的元素</td></tr><tr><td>RPOP</td><td>弹出列表最右端的元素</td></tr><tr><td>LLEN</td><td>获取指定列表的长度</td></tr><tr><td>LREM</td><td>移除列表中的指定元素</td></tr></tbody></table><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310091411257.png" alt="image-20231009141108214"></p><h4 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h4><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/8f1a08fedf7717ad349f3243bde26cda07f83766/img/202309142231846.png"></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>SADD</td><td>将一个或多个元素添加到集</td></tr><tr><td>SCARD</td><td>获取集合中元素数量</td></tr><tr><td>SMEMBERS</td><td>获取集合中所有存在元素</td></tr><tr><td>SISMEMBER</td><td>检查指定元素是否存在在集合中</td></tr><tr><td>SREM</td><td>移除集合中的一个或多个已存在的元素</td></tr><tr><td>SMOVE</td><td>将元素从一个集合移到另一个集合中</td></tr></tbody></table><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310091318434.png" alt="image-20231009131701212"></p><h4 id="Hash（散列）"><a href="#Hash（散列）" class="headerlink" title="Hash（散列）"></a>Hash（散列）</h4><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/576cd8aee0db0bbd776d88cef4871917b7b1bcc3/img/202309142239035.png"></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>HSET</td><td>为散列中指定键设置值</td></tr><tr><td>HMSET</td><td>为散列中多个键设置值</td></tr><tr><td>HGET</td><td>获取散列中的指定键的值</td></tr><tr><td>MMGET</td><td>获取散列中多个键的值</td></tr><tr><td>HGETALL</td><td>获取散列中的所有键值对</td></tr><tr><td>HKEYS</td><td>获取散列中所有键</td></tr><tr><td>HVALS</td><td>获取散列中所有键的值</td></tr><tr><td>HDEL</td><td>删除散列中指定键及其对应的值</td></tr></tbody></table><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310091328205.png" alt="image-20231009132839165"></p><h4 id="Sorted-Sets（有序集合）"><a href="#Sorted-Sets（有序集合）" class="headerlink" title="Sorted Sets（有序集合）"></a>Sorted Sets（有序集合）</h4><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/a4bf7bf0ae370177764f8b3e27ddcedbe8890830/img/202309142301526.png"></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>ZADD</td><td>为有序集合添加一个或多个键值对（先写值后写键）</td></tr><tr><td>ZCARD</td><td>获取有序集合中元素个数</td></tr><tr><td>ZCOUNT</td><td>统计有序集合中指定分值范围内的元素个数</td></tr><tr><td>ZRANGE</td><td>获取有序集合中指定索引范围内的元素</td></tr><tr><td>ZSCORE</td><td>获取有序集合中指定元素的分值</td></tr><tr><td>ZREM</td><td>移除有序集合中的指定元素</td></tr></tbody></table><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310091338917.png" alt="image-20231009133819875"></p><hr><h2 id="Docker基础内容"><a href="#Docker基础内容" class="headerlink" title="Docker基础内容"></a>Docker基础内容</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><strong>概念</strong></p><p>Docker 是一个开源的应用容器引擎，诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品（后改名为Docker Inc） Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux 机器上。容器是完全使用沙箱机制，相互隔离容器性能开销极低。Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）</p><p><strong>架构</strong></p><ul><li><p>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</p></li><li><p>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p></li><li><p>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。</p></li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><p><strong>Window端通过安装docker软件，通过软件启动、停住重启docker服务</strong></p><h4 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h4><ul><li><p>查看镜像</p><p><code>docker images</code></p><p><code>docker images –q </code>   查看所用镜像的id</p></li><li><p>搜索镜像</p><p><code>docker search 镜像名称</code></p></li><li><p>拉取镜像</p><p><code>docker pull 镜像名称</code></p></li><li><p>删除镜像</p><p><code>docker rmi 镜像id</code>   删除指定本地镜像</p><p><code>docker rmi docker images -q</code>    删除所有本地镜像</p></li></ul><h4 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h4><ul><li><p>查看容器</p><p><code>docker ps</code>  查看正在运行的容器</p><p><code>docker ps –a </code>  查看所有容器</p></li><li><p>创建容器</p><p><code>docker run 参数</code></p><p><strong>参数如下</strong></p><p>-i：保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。</p><p>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。</p><p>-d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。</p><p>-it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器</p><p>–name：为创建的容器命名。</p><p>-p: 把写在前面的本地tcp端口映射到写在后面的容器内部端口号，如<code>-p 8000:8080</code>表示将容器内的8080端口映射到主机的8000端口。</p></li><li><p>进入容器</p><p><code>docker exec 参数</code>   退出容器，容器不会关闭</p></li><li><p>启动容器</p><p><code>docker start 容器名称</code></p><p><strong>进入容器、启动容器、停止容器可以通过docker软件以可视化的方式完成</strong></p></li><li><p>停止容器</p></li></ul><p>  <code>docker stop 容器名称</code></p><ul><li>删除容器</li></ul><p>  <code>docker rm 容器名称</code>  删除已经停止的容器，运行状态的容器会删除失败</p><ul><li>查看容器信息</li></ul><p>  <code>docker inspect 容器名称</code></p><h4 id="数据卷配置"><a href="#数据卷配置" class="headerlink" title="数据卷配置"></a>数据卷配置</h4><p><strong>概念</strong></p><ul><li><p>数据卷是宿主机中的一个目录或文件</p></li><li><p>当容器目录和数据卷目录绑定后，对方的修改会立即同步</p></li><li><p>一个数据卷可以被多个容器同时挂载</p></li><li><p>一个容器也可以被挂载多个数据卷</p></li></ul><p><strong>作用</strong></p><ul><li><p>容器数据持久化</p></li><li><p>外部机器和容器间接通信</p></li><li><p>容器之间数据交换</p></li></ul><p><strong>配置数据卷</strong></p><p><strong>创建启动容器时，使用-v参数设置数据卷</strong>、</p><p><code>docker run ... –v 宿主机目录(文件):容器内目录(文件) ...</code> </p><p><strong>注意：目录必须是绝对路径，如果目录不存在会自动创建，可以挂载多个数据卷</strong></p><h3 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h3><h4 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h4><p>使用 Docker 时，宿主机和容器内系统、容器和容器之间都需要进行网络连接，因此要考虑容器和宿主机、容器和容器之间的网络连接方式，了解 Docker 的网络模式对正确使用 Docker 是非常重要的。<br>Docker 启动后，它默认会创建三个网络，使用 <code>docker network ls</code> 命令可以查看这些网络。</p><p>docker 自动创建了 bridge、host 和 none 3 种网络模式，默认情况下，使用的是 <strong>bridge</strong> 模式。</p><p>另外，用户还可以创建 Container 网络模式和自定义网络模式。在实际应用中，通过这 5 种网络模式就可以实现：</p><ul><li><p>容器间的互联和通信</p></li><li><p>容器和宿主机的通信以及端口映射</p></li><li><p>容器 IP 变动时，可以通过服务名直接进行网络通信，不需要重新配置</p></li></ul><p>Docker 中的网络接口默认都是<strong>虚拟</strong>的接口。对于本地系统和容器内系统来说，虚拟接口跟一个正常的以太网卡相比，是一样的。</p><h5 id="Bridge（桥接模式）"><a href="#Bridge（桥接模式）" class="headerlink" title="Bridge（桥接模式）"></a>Bridge（桥接模式）</h5><p>Bridge 模式是 docker 默认的，也是最常使用的网络模式。</p><p>当 Docker 服务启动时：会在宿主机上创建一个名为 docker0 的虚拟网桥，并选择一个和宿主机不同的IP 地址(172.12.0.1)和子网(172.12.0.0&#x2F;16)分配给 docker0 网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上；</p><p> 创建一个容器时，docker 也会为该容器创建独立的网络环境，保证容器内的进程使用独立的网络环境，同时还会将容器连接到 docker0 虚拟网桥；</p><p> 通过宿主机上的 docker0 网桥，就实现了容器之间、容器与宿主机之间乃至外界进行网络通信。</p><p><code>docker network inspect bridge</code>  查看docker0的相关信息</p><p>创建容器时，使用<code>--network=bridge</code>,参数表示使用 bridge 网络模式，该参数可以不写，默认情况下就是使用 bridge。命令：<code>docker run --network=bridge</code></p><p><code>docker inspect r1</code> 查看一个容器的网络信息</p><p>如果宿主机外的机器想访问容器，只能先访问宿主机，再使用端口映射来访问，即将容器的端口与宿主机的端口进行映射，供外面的机器访问</p><h5 id="Host（主机模式）"><a href="#Host（主机模式）" class="headerlink" title="Host（主机模式）"></a>Host（主机模式）</h5><p>如果启动容器的时候使用 Host 模式，那么这个容器将不会获得独立的网络命名空间，而是和宿主机共用一个 Network Namespace；容器也不会模拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。但是，容器的其他方面，如文件系统，进程列表等还是和宿主机隔离的。</p><p>Host模式下虽然容器和宿主机的IP一样，但是<strong>端口号不同</strong>。</p><p>创建容器时，使用<code>--network=host</code>参数表示使用 host 网络模式<strong>。</strong>命令：<code>docker run --network=host</code></p><h5 id="none（无网络模式）"><a href="#none（无网络模式）" class="headerlink" title="none（无网络模式）"></a>none（无网络模式）</h5><p>none 无网络模式下，容器有独立的 network namespace,但不对其进行任何网络设置。该模式实际上是关闭了容器的网络功能，容器不能联网。</p><h2 id="Docker下使用Redis"><a href="#Docker下使用Redis" class="headerlink" title="Docker下使用Redis"></a>Docker下使用Redis</h2><ol><li><p>搜索redis镜像</p><p><code>docker search redis</code></p></li><li><p>下载redis镜像</p><p><code>docker pull redis</code></p><p>不添加下载参数就是默认下载最新版本，默认补全为该命令<code>docker pull redis:latest</code></p></li><li><p>新建redis容器</p><p><code>docker run -id --name redis_test -p 6379:6379 redis</code></p></li></ol><h2 id="Docker下使用MySql"><a href="#Docker下使用MySql" class="headerlink" title="Docker下使用MySql"></a>Docker下使用MySql</h2><p><code>docker run -d --name mysql_test_6367 -e MYSQL_ROOT_PASSWORD=wang10086 -p 6367:3306 mysql</code></p><p><a href="https://blog.csdn.net/qq_42847719/article/details/128097426">MySQL安装_mysql :: download mysql installer (archived versio-CSDN博客</a></p><h2 id="Docker下使用MongoDB"><a href="#Docker下使用MongoDB" class="headerlink" title="Docker下使用MongoDB"></a>Docker下使用MongoDB</h2><p><code>docker pull mongo</code>拉取镜像</p><p><code>docker run -d --name mongodb -p 27017:27017 --privileged=true -v /d/mongodb/data:/data/db mongo</code></p><hr><h2 id="Redis数据持久化"><a href="#Redis数据持久化" class="headerlink" title="Redis数据持久化"></a>Redis数据持久化</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>简介</strong></p><p>持久化可以理解为数据的永久存储，就是将数据存储到一个不会丢失的地方。如果把数据放在内存中，电脑关闭或重启数据就会丢失，所以放在内存中的数据不是持久化的，而放在磁盘上就是一种持久化。Redis 的数据存储在内存中，内存是瞬时的，如果系统宕机或重启，又或者 Redis崩溃或重启，所有内存数据都会丢失，尤其是在 Redis 作为缓存使用时，数据丢失影响非常大。为解决这个问题，Redis 提供两种机制对数据进行持久化存储，以便发生故障后能迅速恢复数据。</p><p><strong>Redis两种持久化方式</strong></p><ul><li>RDB 默认的持久化方式，备份数据</li><li>AOF 备份读写操作</li></ul><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>Redis Database（RDB），就是在指定的时间间隔内将内存中的数据集快照写入磁盘。每次进行数据写入时，为了不影响 Redis 服务的正常使用，都会通过 fork 方式创建一个新的写入子进程，将当前的数据以二进制的形式写入到 dump.rdb 文件中。当Redis 实例故障重启后，会自动从磁盘读取快照文件，恢复数据。快照文件称为 RDB 文件，保存了在某个时间点的全部数据，默认是保存在当前运行目录，默认文件名是 <strong>dump.rdb</strong>，该文件会自动创建。RDB 技术可能会造成主进程和子进程之间数据不同步，产生部分数据丢失现象，比较适合定期对数据做完整备份。</p><h5 id="手动方式"><a href="#手动方式" class="headerlink" title="手动方式"></a>手动方式</h5><ul><li><p>执行 save 命令</p><p>执行save命令会使用主进程来执行RDB，这个进程中其他所有命令都会被阻塞，即redis无法对外提供服务，因此一般关闭redis之前或在数据迁移时可能会用到该命令。</p></li><li><p>执行 bgsave 命令</p><p>bgsave命令是异步执行RDB，执行后会开启子线程来完成EDB，主线程可以继续处理用户请求，不受影响。</p></li><li><p>执行 shutdown 命令时，Redis 自动执行 save 命令</p></li></ul><p>  执行该命令后会redis会自动执行save命令然后关闭服务器</p><h5 id="自动方式"><a href="#自动方式" class="headerlink" title="自动方式"></a>自动方式</h5><ul><li>触发RDB方式（修改配置文件）</li></ul><p>Redis的配置文件redis.conf中设置了出发RDB的机制，启动redis时可以指定绑定conf配置文件，其中的save参数下面有几个属性设置了执行RDB生成快照文件的时间策略。</p><p><strong>配置格式：</strong>save <seconds> <changes> <seconds> <changes>..</p><p>作用：在N秒内数据集至少有M个key改动，这一条件被满足时自动保存一次数据集，如“save 900 1”就是900秒内如果至少有1个key被修改，则执行bgsave命令。</p><p><strong>注：可以根据系统需要，加入自己的触发机制，save “”表示禁用RDB</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202309292202354.png"></p><p><strong>其他配置</strong></p><ul><li><p>dbfilename:设置 RDB 文件的名称</p></li><li><p>dir：指定 RDB 文件的存储位置</p></li><li><p>Rebcompression：是否压缩 RDB 文件</p></li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>为解决 RDB 方式丢失数据的问题，从 1.1 版本开始，redis 增加了一种更加可靠的方式：AOF 持久化方式。Append-only File（AOF），Redis 每次接收到一条<strong>更新数据</strong>的命令时，它将把该命令写到一个 AOF 文件中（只登记写操作，读操作不登记）。当 Redis 重启时，它通过重新执行 AOF 文件中所有的命令来恢复数据。</p><p><strong>配置（也是修改conf配置文件实现）</strong></p><ul><li>Appendonly：开启 aof 功能</li></ul><p>  默认是no，给成yes是开启aof持久化</p><ul><li><p>appendfilename：指定 AOF 文件名</p><p>默认文件名为 appendonly.aof ，可以修改。</p></li><li><p>dir:指定 RDB 和 AOF 文件存放的目录，默认是.&#x2F;</p></li><li><p>appendfsync：配置向 aof 文件写命令数据时的策略</p><p>有以下三种策略（对比在下面表格）：</p><ul><li><p>no：写命令执行完先放入 AOF 缓冲区，由操作系统决定何时将缓冲区内容写回磁盘；</p></li><li><p>always：表示每执行一次写命令，立即记录到 AOF 文件；</p></li><li><p>everysec：写命令执行完先放入 AOF 缓冲区，然后表示每隔 1 秒将缓冲区数据写到 AOF 文件，是默认方案。</p></li></ul></li></ul><table><thead><tr><th>配置项</th><th>刷盘时机</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Always</td><td>同步刷盘</td><td>可靠性高，几乎不丢数据</td><td>性能影响大</td></tr><tr><td>everysec</td><td>每秒刷盘</td><td>性能适中</td><td>最多丢死1秒数据</td></tr><tr><td>no</td><td>操作系统控制</td><td>性能最好</td><td>可靠性较差，可能丢失大量数据</td></tr></tbody></table><h3 id="Docker下的Redis实现数据持久化"><a href="#Docker下的Redis实现数据持久化" class="headerlink" title="Docker下的Redis实现数据持久化"></a>Docker下的Redis实现数据持久化</h3><h4 id="RDB-1"><a href="#RDB-1" class="headerlink" title="RDB"></a>RDB</h4><ol><li>将本地修改好的conf配置文件<strong>（记得把这个挂载的配置文件的save等允许持久化挂载打开并且有需要修改的修改）</strong>挂载数据卷到redis容器</li></ol><p><strong>现在的redis初始配置文件默认开启RDB了，会自动备份到data目录（容器运行目录）下，不做任何修改可以不挂载配置文件，直接执行下一步操作即可</strong></p><p><code>docker run -p 6379:6379 --name redis -v /home/docker/redis/conf:/etc/redis/redis.conf -v /home/docker/redis/data:/data redis</code></p><p>这条命令就是把容器中<code>/etc/redis/redis.conf</code>映射到本地，本地<code>/home/docker/redis/conf</code>配置文件会挂载在容器的配置文件，修改会同步生效</p><p><code>docker run -p 6379:6379 --name redis -v /home/docker/redis/conf:/etc/redis/redis.conf -v /home/docker/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes</code></p><ol start="2"><li>将容器data目录映射到本地（挂载data目录）</li></ol><p><code>docker run -d --name redis1 -p 6379:6379 -v /d/redis/data:/data redis </code></p><p>这条命令主要就是<code>-v</code>部分去挂载数据卷，这里表示把本地<code>D:\redis\data</code><strong>（如果路径不存在，Docker会自动创建）</strong>映射到容器内的路径（容器的data路径是容器内自动创建的目录）</p><p><strong>示例命令（包括挂载conf和data）</strong></p><p><code>docker run -id -p 6380:6379 --name redis2 -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/conf:/etc/redis/redis.conf -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/data:/data redis</code></p><h4 id="AOF-1"><a href="#AOF-1" class="headerlink" title="AOF"></a>AOF</h4><p>修改配置文件并在挂载data后命令加上<code>--appendonly yes</code>表示开启aof数据持久化</p><p>运行起来后会发现在挂载的data目录下会出现appendolydir文件夹，该文件夹下自动生成了多个备份文件，这是因为在 redis7.x 以后，采取了 AOF 多文件存储技术。</p><p><strong>示例命令</strong></p><p><code>docker run -id -p 6380:6379 --name redis2 -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/conf:/etc/redis/redis.conf -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/data:/data redis --appendonly yes  </code></p><hr><h2 id="Redis主从复制（适合中小型系统）"><a href="#Redis主从复制（适合中小型系统）" class="headerlink" title="Redis主从复制（适合中小型系统）"></a>Redis主从复制（适合中小型系统）</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><strong>简介</strong></p><p>主从复制，是将多台数据库服务器分为主节点（master）和从节点（slaver），主节点数据更新后会根据配置和策略，自动同步到从节点上，从而保证主从节点中存有相同的数据。主从复制常见结构如下。</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202309271033679.png"></p><p><strong>当有许多从节点时，可以采用主-从-从的链式结构，以减少主节点的压力</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031241996.png"></p><p><strong>好处</strong></p><ul><li>默认实现读写分离机制，Master 以写为主，Slave 以读为主，提升系统的缓存读写性能；</li></ul><p>容灾快速恢复，提升整个系统的可用性。因为从节点中有主节点数据的副本，当主节点宕机后，可以立刻提升其中一个从节点为主节点，继续提供服务；</p><ul><li><p>数据备份，主从节点上都有数据，且都可以进行数据持久化处理；</p></li><li><p>支持高并发，提升数据库系统的请求处理能力。单个节点能够支撑的读流量有限。部署多个节点，并构成主从关系，主从节点一起提供服务。</p></li></ul><h3 id="简单实现数据同步"><a href="#简单实现数据同步" class="headerlink" title="简单实现数据同步"></a>简单实现数据同步</h3><p><strong>一开始6379为主节点，6380、6381为从节点，名称就是对应端口号</strong></p><ol><li><p>修改配置文件</p><p>修改其中的slaveof参数，这个参数指定成为哪一个master的从节点</p></li><li><p>启动主从服务器（一台主服务器，两台从服务器）</p></li></ol><p><strong>通过redis-server redis_6379.confredis-server redis_6380.confredis-server redis_6381.conf指定以哪个配置文件启动服务</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031207098.png"></p><p><strong>6379主节点信息</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031209856.png"></p><p><strong>6380从节点信息</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031210035.png"></p><p><strong>6381从节点信息</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031211196.png"></p><ol start="3"><li>测试数据同步</li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031213070.png"></p><h3 id="主从复制的容灾处理（手动）"><a href="#主从复制的容灾处理（手动）" class="headerlink" title="主从复制的容灾处理（手动）"></a>主从复制的容灾处理（手动）</h3><ol><li><p>手动关闭主节点（模拟主节点宕机）</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031218817.png"></p></li><li><p>将一个从节点提升为主节点，原先从节点挂载到新主节点上</p><p><code>slaveof no one</code>  : 将一台 slave 服务器提升为 Master</p><p><code>slaveof 主节点的 ip + 端口号</code>  : 将 slave 挂至新的 master 上</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031222911.png"></p></li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031223645.png"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031239001.png"></p><ol start="3"><li>重启原先主节点，修改原先主节点为新主节点的从节点</li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031239456.png"></p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p><strong>简介</strong></p><p>哨兵（Sentinel）是 Redis 官方提供的一种高可用方案，它可以监控多个 Redis 服务实例的运行情况，监控主节点是否出现故障。如果出现故障，它会根据投票数自动将某一个从节点提升为主节点，以继续对外提供服务。<br>本质上，Sentinel 也是一个运行在特殊模式下的 Redis 服务器。主从复制模式下，一般会配置多个 Sentinel 节点，通过互相协作来实现系统的高可用，如下图所示。</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031251312.png"></p><p><strong>作用</strong></p><ul><li><p>主从监控：Sentinel 不断的检查主节点和从节点是否按照预期正常工作；</p></li><li><p>消息通知： Sentinel 会将故障和故障转移的结果通知客户端或其他应用程序；</p></li><li><p>自动故障转移：如果主节点异常，Sentinel 会自动进行故障迁移操作。即将一个从节点升级新的主节点，并让其他从服务器挂到新的主服务器，同时向客户端提供新的主服务器地址；</p></li><li><p>配置中心：客户端通过连接哨兵来获得当前 redis 服务的主节点地址。</p></li></ul><p><strong>原理</strong></p><p>Sentinel 基于心跳机制监测服务状态，每隔 1 秒向集群的每个实例发送 ping 命令：</p><ul><li>主观下线：如果某个 Sentinel 发现某个 redis 服务未在规定时间内（默认 30秒）响应，则认为该实例主观下线；</li><li>客观下线：若超过指定数（投票数）的 Sentinel 认为该 redis 服务主观下线，则该实例为客观下线，即哨兵模式确认该 redis 服务下线了。投票数的值最好超过 Sentinel 实例数量的一半。</li></ul><h4 id="具体样例搭建"><a href="#具体样例搭建" class="headerlink" title="具体样例搭建"></a>具体样例搭建</h4><p><strong>一开始6379为主节点，6380、6381为从节点，26379、26380、26381分别为6379、6380、6381哨兵</strong></p><ol><li><p>修改配置文件</p><p>以哨兵1（监听6379服务器）的配置文件为例，修改端口号为26379（自己设定），修改sentinel monitor参数</p><p><code>Sentinel monitor &lt;master-name&gt; &lt;masterIP&gt; &lt;masterPort&gt;&lt;Quorum 投票数&gt;</code></p><p><strong>参数说明</strong></p><ul><li>Master-name：主节点的名字</li><li>masterIP：主节点的 IP</li><li>masterPort：主节点的端口号</li><li>Quorum：判断主节点失效时，需要的哨兵节点的投票数</li></ul><p><strong>哨兵1样例</strong></p><p><code>sentinel monitor mymaster 127.0.0.1 6379 2</code></p></li><li><p>启动主从服务的三个Redis服务</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310092023593.jpg" alt="img"></p></li><li><p>启动三个哨兵服务</p><p><strong>通过 redis-server sentinel_26379.conf –sentinel  redis-server sentinel_26380.conf  –sentinel  redis-server sentinel_26381.conf  –sentinel命令启动哨兵</strong></p><p>可以通过<code>info sentinel</code>命令查看哨兵运行情况</p></li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031339981.png"></p><ol start="4"><li>模拟主机宕机</li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031350890.png"></p><p>主机宕机前后哨兵变化，可以看到主节点自动迁移到从节点了，从节点提升为主节点</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031352158.png"></p><p>6380变成了主节点</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031352298.png"></p><p>6379重启变成了从节点</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031352298.png"></p><p>6379重启后的主从结构</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310031354263.png"></p><h3 id="Docker下Redis实现哨兵模式"><a href="#Docker下Redis实现哨兵模式" class="headerlink" title="Docker下Redis实现哨兵模式"></a>Docker下Redis实现哨兵模式</h3><ol><li>修改redis服务的配置文件</li></ol><p>​需要注意的是默认情况下新建一个redis主节点，其ip为172.17.0.2，端口号为6379，然后需要跟正常配置主从模式一样，要在配置文件中把6380和6381设置为是6379的从节点，这就需要知道主节点的ip以及端口号，但是如果存在建立过的docker容器可能主节点ip不同，所以可以先启动主节点，通过<code>docker inspect 主节点容器名称 </code>查看其ip再修改从节点配置文件以及启动从节点。</p><p><strong>下面是各节点配置文件</strong></p><p><em>主节点</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">#protected-mode no</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line">#开启分片集群</span><br><span class="line">cluster-enabled no</span><br><span class="line"></span><br><span class="line">#指定分片集群需要使用的节点配置文件名</span><br><span class="line">appendonly yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"></span><br><span class="line">cluster-announce-ip 192.168.101.26</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br></pre></td></tr></table></figure><p><em>从节点1</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">port 6380</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">#protected-mode no</span><br><span class="line">slaveof 172.17.0.2 6379</span><br><span class="line"></span><br><span class="line">cluster-enabled no</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"></span><br><span class="line">cluster-announce-ip 192.168.101.26</span><br><span class="line">cluster-announce-port 6380</span><br><span class="line">cluster-announce-bus-port 16380</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p><em>从节点2</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">port 6381</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">#protected-mode no</span><br><span class="line"></span><br><span class="line">slaveof 172.17.0.2 6379</span><br><span class="line">cluster-enabled no</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"></span><br><span class="line">cluster-announce-ip 192.168.101.26</span><br><span class="line">cluster-announce-port 6381</span><br><span class="line">cluster-announce-bus-port 16381</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><ol start="2"><li>搭建和运行1主2从服务</li></ol><p><strong>下面是运行例子的命令</strong></p><p><em>新建主节点容器</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis_master -p 6379:6379 --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/docker_sentinel/redis_6379.conf:/etc/redis/redis_6379.conf redis redis-server /etc/redis/redis_6379.conf</span><br></pre></td></tr></table></figure><p><em>新建从节点1容器</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis_slave1 -p 6380:6380 --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/docker_sentinel/redis_6380.conf:/etc/redis/redis_6380.conf redis redis-server /etc/redis/redis_6380.conf</span><br></pre></td></tr></table></figure><p><em>新建从节点2容器</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis_slave2 -p 6381:6381 --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/docker_sentinel/redis_6381.conf:/etc/redis/redis_6381.conf redis redis-server /etc/redis/redis_6381.conf</span><br></pre></td></tr></table></figure><p>新建容器完成后，可以进入主节点，通过<code>info replication</code>查看主从复制是否成功建立</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310092013504.png" alt="image-20231009201343377"></p><ol start="3"><li>修改哨兵的配置文件</li></ol><p>修改配置需要修改的有端口号，以及添加sentinel指令去指定监听的redis服务的ip和端口、投票数</p><p><strong>下面是各哨兵的配置</strong></p><p><em>26379哨兵监听6379</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">#protected-mode no</span><br><span class="line"></span><br><span class="line">#Sentinel去监视一个名为mymaster的主redis实例</span><br><span class="line">sentinel monitor mymaster 172.17.0.2 6379 2</span><br></pre></td></tr></table></figure><p><em>26380哨兵监听6380</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 26380</span><br><span class="line">#protected-mode no</span><br><span class="line"></span><br><span class="line">#Sentinel去监视一个名为mymaster的主redis实例</span><br><span class="line">sentinel monitor mymaster 172.17.0.2 6379 2</span><br></pre></td></tr></table></figure><p><em>26381哨兵监听6381</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 26381</span><br><span class="line">#protected-mode no</span><br><span class="line"></span><br><span class="line">#Sentinel去监视一个名为mymaster的主redis实例</span><br><span class="line">sentinel monitor mymaster 172.17.0.2 6379 2</span><br></pre></td></tr></table></figure><ol start="4"><li>创建哨兵节点</li></ol><p><strong>下面是运行例子的命令</strong></p><p><em>新建26379哨兵监听6379节点</em></p><p> docker run -d –name redis_sentinel1 -p 26379:26379 –privileged&#x3D;true -v C:&#x2F;Users&#x2F;GTR&#x2F;Desktop&#x2F;temp&#x2F;大学上课学习&#x2F;大三上&#x2F;非关系型数据库&#x2F;redis&#x2F;docker_sentinel&#x2F;redis_26379.conf:&#x2F;etc&#x2F;redis&#x2F;redis_26379.conf redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis_26379.conf –sentinel</p><p><em>新建26380哨兵监听6380节点</em></p><p> docker run -d –name redis_sentinel2 -p 26380:26380 –privileged&#x3D;true -v C:&#x2F;Users&#x2F;GTR&#x2F;Desktop&#x2F;temp&#x2F;大学上课学习&#x2F;大三上&#x2F;非关系型数据库&#x2F;redis&#x2F;docker_sentinel&#x2F;redis_26380.conf:&#x2F;etc&#x2F;redis&#x2F;redis_26380.conf redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis_26380.conf –sentinel</p><p><em>新建26381哨兵监听6381节点</em></p><p> docker run -d –name redis_sentinel3 -p 26381:26381 –privileged&#x3D;true -v C:&#x2F;Users&#x2F;GTR&#x2F;Desktop&#x2F;temp&#x2F;大学上课学习&#x2F;大三上&#x2F;非关系型数据库&#x2F;redis&#x2F;docker_sentinel&#x2F;redis_26381.conf:&#x2F;etc&#x2F;redis&#x2F;redis_26381.conf redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis_26381.conf –sentinel</p><p>可以进入哨兵1容器，通过<code>info sentinel</code>查看整个哨兵结构</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310092052516.png" alt="image-20231009205204440"></p><ol start="5"><li>主从数据同步实验</li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310092055948.png" alt="image-20231009205530879"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310092055110.png" alt="image-20231009205552051"></p><ol start="6"><li>自动处理故障</li></ol><p>​首先将master主节点停止，模拟宕机</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310092057813.png" alt="image-20231009205744720"></p><p>可以发现6381节点自动变成了主节点，并且此时6381作为主节点，6380节点为从节点依然可以满足用户请求需求</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310092059589.png" alt="image-20231009205908530"></p><p>重启6379节点，可以发现他自动变成6381的从节点了</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310092101097.png" alt="image-20231009210113033"></p><p>最后主从结构为下图</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310092102176.png" alt="image-20231009210223118"></p><hr><h2 id="Redis-Cluster-分片集群"><a href="#Redis-Cluster-分片集群" class="headerlink" title="Redis Cluster 分片集群"></a>Redis Cluster 分片集群</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>分布式数据存储</strong></p><p>分布式数据存储是一种计算机数据存储架构，它将数据存储在多台独立的数据库服务器上，以实现数据的高可靠性、可扩展性和性能。在分布式存储中，每个计算机或服务器都可以看作一个存储节点，它们通过网络连接相互通信和协作，以实现数据的分布式存储和管理，同时还采用可扩展的系统结构，不仅提高了系统的可靠性、可用性和存取效率，还易于扩展。</p><p>分布式存储通常使用<strong>数据分片</strong>和<strong>副本复制</strong>技术，以确保数据的可靠性和可用性。</p><p>为了确保数据在不同节点之间的一致性，分布式存储系统通常使用数据同步和管理机制。</p><p>在分布式存储系统中，数据可以并行地从多个节点中读取和写入，以提高读写性能和吞吐量。数据访问通常使用<strong>负载均衡机制</strong>来实现，例如，使用分布式哈希表、分布式缓存或分布式文件系统等技术来实现。（负载均衡是一种用于分布式计算和网络系统中的关键技术，旨在平衡服务器集群的负载，以确保每个服务器都能充分利用并均匀分担请求负荷。负载均衡机制有助于提高系统的可用性、性能和稳定性。）</p><p><strong>数据分片</strong></p><p>在分布式存储系统中，数据被分成多个部分，每个部分存储在不同的节点上，以实现数据的分布式存储和管理。<strong>数据分片</strong>通常使用<strong>哈希函数</strong>或<strong>一致性哈希算法</strong>等技术来实现。分布式数据存储首先要考虑的是如何将整体数据按照分片规则映射到多个存储节点上，让节点负责数据的一个子集。</p><p><strong>副本复制</strong></p><p>为了提高数据的可靠性和可用性，分布式存储系统通常使用副本复制技术。每个数据副本都存储在不同的节点上，以确保即使某些节点出现故障，仍然可以从其他节点中恢复数据。副本复制通常使用复制策略来实现，例如，简单的复制、多副本复制和跨区域复制等。</p><p><strong>哈希取余分区</strong></p><ul><li><p>公式：<code>hash(key) % n</code>（其中key可以为特定的数据，如键或用户ID；n为节点数量）</p></li><li><p>优点：简单明了，常用于可以预估数据节点，或扩容&#x2F;缩容不太频繁的应用场景，如使用 5 台服务器，就可以保证可支撑未来一段时间的数据请求处理。</p></li><li><p>缺点：当节点数量变化频繁时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移。</p></li></ul><p><strong>一致性哈希分区</strong></p><ul><li><p>一致性哈希算法：一致性哈希算法的目的是解决分布式数据变动和映射问题，在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与服务器之间的映射关系。</p></li><li><p>工作原理</p><ul><li>构建哈希环：一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环，即哈希环。整个哈希空间的取值范围为 0~2的32 次方-1，并按<strong>顺时针</strong>方向组织，最后的2的32次方和零点重合，形成哈希环；</li><li>服务器节点映射：可以选择服务器的 IP 或主机名作为 key,进行 hash 运算，将服务器也映射到了哈希环上；</li><li>数据读写映射：先根据 key 计算 hash 值，然后沿哈希环<strong>顺时针</strong>找到第一个大于等于该哈希值的服务器节点，即为该数据的服务节点。</li></ul></li><li><p>优点：当增加一台新的服务器时，受影响的数据仅仅是新添加的服务器到其环空间中的前一台服务器（也就是顺着逆时针方向遇到的第一台服务器）之间的数据，其他节点都不会受到影响。因此，一致性哈希算法对于节点的增减，只需重新定位环空间中的一小部分数据，具有较好的容错性和扩展性。</p></li><li><p>缺点：不适合作为少量数据节点的分布式存储方案。在一致性哈希算法中，数据的分布和服务器节点的位置有关，这些节点不是均匀分布在哈希环上的。因此，当使用少量节点时，节点变化可能会影响哈希环中大范围的数据映射，产生<strong>数据倾斜问题</strong>（一部分数据集中在少数的节点或分区上，而其他节点或分区相对空闲），出现数据访问<strong>负载不均衡</strong></p></li></ul><p><strong>虚拟一致性哈希分区</strong></p><p>为了解决一致性哈希分区的缺点，一些分布式系统采用<strong>虚拟槽&#x2F;虚拟节点</strong>对一致性哈希方法进行了改进，如虚拟一致性哈希分区方法。</p><p>虚拟一致性哈希分区为了让各节点能够保持动态的<strong>均衡</strong>，在每个<strong>真实节点上虚拟出若干个虚拟节点</strong>，再将这些虚拟节点随机映射到哈希环上。此时，每个真实节点就不再直接映射到环上了，它只负责管理一组环上的虚拟节点和实际存储的键值对数据。</p><p>这样，就形成了<strong>数据 - - 虚拟节点 - - 真实节点</strong>的映射关系。当对数据进行存取操作时，</p><p>首先映射到虚拟节点上，再由虚拟节点找到对应的真实节点。</p><p><strong>如</strong>，三个真实节点: Node1、Node2 和 Node3，每个真实节点再虚拟出三个虚拟节点: V1，V2，V3，一共是 9 个虚拟节点。然后，这 9 个虚拟节点再映射到哈希环上。</p><p>这样，每个真实节点所负责的 hash 空间不再是连续的一段，而是分散在环上的各处，这样就可以将局部的压力均衡到不同的节点，虚拟节点越多，分散性越好，理论上负载就越倾向均匀</p><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><strong>Cluster 分片集群架构基本结构</strong></p><p>Redis 哨兵模式虽然提供了 Redis 高可用、高并发读写的解决方案，但是在当前的一些互联网海量数据应用场景下，因为只有一组 master-slave 结构对外提供服务，数据的高并发写、数据备份和恢复都会大大降低效率,因此仍然存在海量数据存储问题、高并发和高可用等问题。</p><p>针对这些问题，Redis 推出 Cluster 分片集群架构，集群基本结构如下：</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182126654.png"></p><p>Redis分片集群实现了自动数据分片，实现了数据负载均衡，方便集群动态伸缩。（优点）</p><p><strong>Cluster 分片集群架构特点</strong></p><ul><li><p>Redis Cluster 采用的是基于 P2P 的去中心化的网络拓扑架构，没有中心节点，支持多个 master 节点，所master 节点既是数据存储节点，也是监控节点；</p></li><li><p>引入槽(slot)的概念，通过 <strong>CRC + hashslot</strong>算法支持多个主节点（分片），每个主节点分别负责存储一部分数据，集群<strong>自动维护数据 – 哈希槽 – 节点之间的对应关系</strong>，这样理论上可以支持无限主节点的水平扩容以便支持海量吞吐量；</p></li><li><p>每个 master 节点又可以配置多个 slave 节点，支持读写分离；</p></li><li><p><strong>内置类似哨兵的高可用机制</strong>，能够实现自动故障转移，保证每个 master 节点的高可用；</p></li><li><p>Master 节点之间通过 ping 监测彼此健康状态；</p></li><li><p>客户端请求可以<strong>访问集群任意节点</strong>，最终都会<strong>被转发到正确节点</strong>。</p></li></ul><p>因此，Redis Cluster 集群也叫分片集群，是一个有多个主从节点群组成的分布式服务集群。它具有复制、高可用性和分布存储的特性。该集群不需要哨兵也可以完成节点故障自动转移功能，并可实现动态扩容（官方建议不要超过 1000 个节点）。Cluster 集群的性能和高可用性均优于哨兵模式，且集群配置非常简单，更加适合应用于海量数据、高并发和高可用的场景。</p><p><strong>数据自动分片的实现</strong></p><p>Redis参考虚拟<strong>一致性哈希分区</strong>的思想，提出了<strong>虚拟槽分区方案</strong>。哈希槽(hash slot)是 Redis 实现分片集群的基础，也是集群内数据管理和迁移的基本单位。虚拟槽的取值为整数，<strong>范围为 0<del>16383（0</del>2的14次方-1），每一个整数即为一个哈希槽</strong>。</p><p><strong>具体步骤</strong></p><ul><li><p>预先设定哈希槽：共 <strong>16384</strong> 个哈希槽<strong>（默认数量）</strong>；</p></li><li><p>为每个 Redis 节点分配哈希槽位：根据节点的性能分配槽位，一般是平均分配。分配后，该节点就负责管理这些槽的读写操作；</p></li><li><p>计算要写入数据的哈希槽：当在 master 节点上写入数据时，Redis 先对每个键（key）用 <strong>CRC16 + hashslot</strong> 算法进行运算，所得数值即为槽位号；</p></li><li><p>在对应节点上写入数据：寻找该槽位号所在的 Redis 节点，并在对应编号的哈希槽中写入数据；</p></li><li><p>读取数据: 计算该数据的槽位号，寻找该槽位所在的 Redis 节点，然后读取数据。</p></li></ul><p><strong>默认情况下虚拟槽位值的计算：<code>slot = CRC16(key) mod 16383</code></strong></p><h3 id="Docker下简单实现"><a href="#Docker下简单实现" class="headerlink" title="Docker下简单实现"></a>Docker下简单实现</h3><p><strong>因为本身就是分布式实现，需要多台电脑，一台电脑多开虚拟机很卡，无法实践，这里这里借助docker简单展示使用</strong></p><ol><li><p>配置六个redis服务器，形成<strong>一主一从，一共3组</strong>的分片集群，修改所有节点的配置文件</p><p>主节点 1: IP:127.0.0.1 6379，配置文件：redis_6379.conf</p><p>主节点 2: IP:127.0.0.1 6380，配置文件：redis_6380.conf</p><p>主节点 3: IP:127.0.0.1 6381，配置文件：redis_6381.conf</p><p>从节点 4: IP:127.0.0.1 26379，配置文件：redis_26379.conf</p><p>从节点 5 :IP:127.0.0.1 26380，配置文件：redis_26380.conf</p><p>从节点 6 :IP:127.0.0.1 26381，配置文件：redis_26381.conf</p><p>主节点就以主节点1的配置文件修改为例，<strong>其他节点类似</strong>，<strong>修改端口号、打开分片集群、设置节点配置文件名</strong><code>cluster-enabled yes</code>表示开启分片集群</p><p><code>cluster-config-file 配置文件名</code>表示指定分片集群需要使用的节点配置文件名，这个指定的文件Redis自动创建，这里只需要给出配置文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6379.conf</span><br></pre></td></tr></table></figure></li><li><p>启动docker服务并创建6个Redis容器，并查看启动情况</p><p>主节点挂载data卷和redis配置卷，从节点挂载redis配置卷即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis_6379 -p 6379:6379 --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/data/6379:/data -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/docker_cluster:/etc/redis redis redis-server /etc/redis/redis_6379.conf</span><br><span class="line"></span><br><span class="line">docker run -d --name redis_6380 -p 6380:6380 --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/data/6380:/data -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/docker_cluster:/etc/redis redis redis-server /etc/redis/redis_6380.conf</span><br><span class="line"></span><br><span class="line">docker run -d --name redis_6381 -p 6381:6381 --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/data/6381:/data -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/docker_cluster:/etc/redis redis redis-server /etc/redis/redis_6381.conf</span><br><span class="line"></span><br><span class="line">docker run -d --name redis_26379 -p 26379:26379 --privileged=true  -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/docker_cluster:/etc/redis redis redis-server /etc/redis/redis_26379.conf</span><br><span class="line"></span><br><span class="line">docker run -d --name redis_26380 -p 26380:26380 --privileged=true  -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/docker_cluster:/etc/redis redis redis-server /etc/redis/redis_26380.conf</span><br><span class="line"></span><br><span class="line">docker run -d --name redis_26381 -p 26381:26381 --privileged=true  -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/docker_cluster:/etc/redis redis redis-server /etc/redis/redis_26381.conf</span><br></pre></td></tr></table></figure></li></ol><p>​</p><p>docker创建容器</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182239225.png" alt="image-20231018223901128"></p><p>查看服务器启动情况</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182240214.png" alt="image-20231018224027141"></p><ol start="3"><li><p>查询每个redis节点的容器内IP</p><p><code>docker inspect redis_6379</code></p><p>6379主节点</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182241823.png" alt="image-20231018224118722"></p></li></ol><p>​6380主节点</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182241347.png" alt="image-20231018224136241"></p><p>​6381主节点</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182241868.png" alt="image-20231018224154777"></p><p>​26379从节点</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182242899.png" alt="image-20231018224212782"></p><p>​26380从节点</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182242711.png" alt="image-20231018224229607"></p><p>​26381从节点</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182242679.png" alt="image-20231018224240573"></p><ol start="4"><li><p>创建集群：将 6 个节点创建成 3 主 3 从的分片集群<strong>（最重要的步骤）</strong>，到这里就搭建完成了，后面可以查看是否正确搭建</p><ul><li>先进入一个容器（也可以在docker可视化里面进入容器，然后执行后面的命令就行）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis_6380 /bin/bash</span><br></pre></td></tr></table></figure><ul><li>然后执行下面创建分片集群语句，然后输入yes后面出现绿色语句说明创建成功</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 172.17.0.2:6379 172.17.0.3:6380 172.17.0.4:6381 172.17.0.5:26379 172.17.0.6:26380 172.17.0.7:26381 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p><code>redis-cli --cluster help </code>查询集群创建相关参数</p></li></ol><p>​<code>redis-cli --cluster create --cluster-replicas 1 &lt;节点 1&gt;，&lt;节点 2&gt;...</code></p><p>​cluster create参数表示要创建集群；cluster-replicas 1表示1个主节点配置1个从节点</p><p>​</p><p>根据上面查询的IP地址，可以用最上面的命令创建分片集群，redis 会根据–cluster-replicas 1 参数，自动平均分配 6 个节点，前 3 个为主节点，后 3 个为从节点，这里的端口号也可以根据上面查询得到，也可以根据一开始创建容器的指令直接得到</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182229096.png" alt="image-20231018222924014"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182230309.png" alt="image-20231018223018233"></p><ol start="5"><li><p>连接任一节点，查看集群节点和集群状态信息</p><p><code>cluster nodes</code> 查看各节点信息，如主从配置信息，节点 ID 等</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182247991.png" alt="image-20231018224734914"></p></li></ol><p>​<code>cluster info</code> 显示集群的相关信息</p><p>​<img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182250493.png" alt="image-20231018225002419"></p><h3 id="搭建完成后读写操作"><a href="#搭建完成后读写操作" class="headerlink" title="搭建完成后读写操作"></a>搭建完成后读写操作</h3><ol><li><p>进入6381节点容器内并连接redis服务</p><p><code>docker exec -it redis_6381 /bin/bash</code> </p><p><code>redis-cli -c -p 6381</code> <strong>这里一定要加上<code>-c</code>表示进入集群环境</strong></p></li><li><p>写入数据</p><p>集群会计算键等slot值，并存储到相应的redis节点上</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182257427.png" alt="image-20231018225740346"></p></li><li><p>查询数据</p><p>查询数据时也会计算slot值，然后从对应节点上拉取数据</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182300444.png" alt="image-20231018230016368"></p></li><li><p>查询集群各节点的数据存储情况</p><p><code>redis-cli --cluster check 任一节点 ip:端口号</code></p></li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182302133.png" alt="image-20231018230258046"></p><h3 id="搭建完成后的故障转移"><a href="#搭建完成后的故障转移" class="headerlink" title="搭建完成后的故障转移"></a>搭建完成后的故障转移</h3><ol><li>停止6379，进入6380容器输入<code>redis-cli -p 6380 cluster nodes</code>可以看到6379的fail说明出现问题并且26380成为master了</li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182310255.png" alt="image-20231018231007176"></p><ol start="2"><li>重启6379，再次查询集群节点信息，可以发现6379变成了从节点</li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182312343.png" alt="image-20231018231206246"></p><h3 id="搭建完成后的扩容"><a href="#搭建完成后的扩容" class="headerlink" title="搭建完成后的扩容"></a>搭建完成后的扩容</h3><ol><li>新建一个6382主节点，端口号为6382，配置文件类似前面6379主节点，创建这个容器并查看IP</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis_6382 -p 6382:6382 --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/data/6382:/data -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/docker_cluster:/etc/redis redis redis-server /etc/redis/redis_6382.conf</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182322593.png" alt="image-20231018232223517"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182321409.png" alt="image-20231018232158309"></p><ol start="2"><li><p>进入任一节点，将6382节点加入到集群，默认是主节点</p><p><code>docker exec -it redis_6379 /bin/bash</code></p><p><code>redis-cli --cluster add-node 172.17.0.8:6382 172.17.0.2:6379</code></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182327427.png" alt="image-20231018232719313"></p></li></ol><p>查看集群节点信息</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310182329532.png" alt="image-20231018232900447"></p><ol start="3"><li><p>为6382节点分配4096个slot插槽（即4个主节点平均分配）</p><p>当前，6382 节点虽然已加入集群，但是没有 slot 插槽，不能使用，所以还需要为它分配插槽。</p></li></ol><p>​<code>redis-cli --culuster reshard 集群中任一节点的 IP + port</code>reshard表示在集群中重新分配slot插槽，后面接目标分配节点和端口号，这个命令中的IP和端口是集群中的任何一个可访问的节点的IP地址和端口，通常是用于执行reshard操作的源节点。这个节点将被用作数据的来源，从而将数据从一个源槽移动到目标槽。</p><p>​<code>redis-cli --cluster reshard 172.17.0.8:6382</code></p><p>​然后输入分配的槽位4096，输入all表示平均分配，系统分配方案，输入yes表示同意该方案，等待分配，分配完没有报错即为正确</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310221705967.png" alt="image-20231022170537837"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310221707212.png" alt="image-20231022170736126"></p><p><code>redis-cli --cluster check 172.17.0.3:6380</code>  查看集群各节点数据存储情况</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310222202173.png" alt="image-20231022220225083"></p><ol start="4"><li><p>为6382主节点配置从节点26382</p><ul><li>创建26382节点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis_26382 -p 26382:26382 --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/docker_cluster:/etc/redis redis redis-server /etc/redis/redis_26382.conf</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310221727472.png" alt="image-20231022172731409"></p><ul><li>为6382节点指定26382从节点，进入主节点执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 172.17.0.9:26382 172.17.0.8:6382 --cluster-slave --cluster-master-id dc3f89457c6038e72b5f70a7b44af39f9b748c58</span><br></pre></td></tr></table></figure><p><code>redis-cli --cluster add-node 新节点IP 旧节点IP --cluster-slave --cluster-master-id 指定的主节点的容器 id </code></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310222314532.png"></p></li></ol><p><strong>补充（手动迁移槽位）</strong></p><p>指定从某个节点移动多少个槽位到指定节点，这里把6382所有节点移动到6379节点</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310222221605.png"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202310222222511.png"></p><h3 id="搭建完成后的缩容"><a href="#搭建完成后的缩容" class="headerlink" title="搭建完成后的缩容"></a>搭建完成后的缩容</h3><p><strong>（在Redis Cluster中，你可以从集群中移除节点，然后再重新分配虚拟槽。这个过程不会导致数据丢失，因为Redis Cluster具有数据复制和故障转移机制，可以确保数据的可靠性。）</strong></p><p>缩容可以先备份数据，然后从集群中删除节点，之后通过上面的方法手动迁移删除的节点的槽位到其他节点（也可以直接均匀分配槽位，都是同个命令，同上面），等待槽位迁移完成后，验证集群状态。（也可以先迁移槽位再删除节点，这种方式更加安全）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster  reshard  172.17.0.3:6380  --cluster-from 2bea24374ee6403d86cd5fb2d81ff1f55640471f  --cluster-to ffa0585637379e96c91b6f6f8de7f7aa3248567f  --cluster-slots 4096</span><br></pre></td></tr></table></figure><p>这条指定可以直接把第一个容器<code>2bea24374ee6403d86cd5fb2d81ff1f55640471f</code>指定的槽位数<code>4096</code>转移到第二个容器<code>ffa0585637379e96c91b6f6f8de7f7aa3248567f</code><strong>（可以直接用这条命令，会更快一点）</strong></p><p><code>cluster slots</code>检查槽位分配情况</p><p><code>cluster nodes</code>验证集群状态</p><p><code>redis-cli --cluster del-node 172.17.0.2:6379  c6a46b48e977b86b369c6b25f8b146cdf4f94655</code>删除节点</p><hr><h2 id="Java连接数据库（MySQL和Redis）"><a href="#Java连接数据库（MySQL和Redis）" class="headerlink" title="Java连接数据库（MySQL和Redis）"></a>Java连接数据库（MySQL和Redis）</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li><p><strong>关于Maven和SpringBoot的配置和创建</strong></p><p><a href="https://blog.csdn.net/qq_42057154/article/details/106114515">【精选】IDEA配置Maven（详细版）_idea maven-CSDN博客</a></p><p><a href="http://python1234.cn/archives/python24132">idea将普通项目更改为maven项目的两种方式 - 程序员小屋（寒舍） (python1234.cn)</a></p><p><a href="https://www.php.cn/faq/542631.html">怎么使用IDEA创建SpringBoot项目-java教程-PHP中文网</a></p></li><li><p><strong>JUnit单元测试框架的基本介绍和使用</strong></p><p><a href="https://blog.csdn.net/qq_53869058/article/details/131055237">JUnit单元测试框架_junit框架-CSDN博客</a></p></li><li><p>非关系型数据库这门课程主要是介绍Redis相关的，这部分主要介绍使用关于Java访问Redis以及Redis搭配MySQL的使用，需要应用到的主要有Jedis、JDBC、SpringDataRedis、SpringBoot、MyBatis，案例可以直接通过文档最顶部的网盘链接打开</p></li></ul><h3 id="Jedis-API访问Redis"><a href="#Jedis-API访问Redis" class="headerlink" title="Jedis API访问Redis"></a>Jedis API访问Redis</h3><ol><li><p>基于Maven项目导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基本使用，使用单元测试框架进行展示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPubSub;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> JedisDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/6/21</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisDemo</span> &#123;</span><br><span class="line">    Jedis jedis;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//关闭jedis</span></span><br><span class="line">        <span class="built_in">this</span>.jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试redis是否连通</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ping</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">        System.out.println(ping);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string类型测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stringTest</span><span class="params">()</span> &#123;</span><br><span class="line">        jedis.set(<span class="string">&quot;site&quot;</span>, <span class="string">&quot;http://www.itsoku.com&quot;</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;site&quot;</span>));</span><br><span class="line">        System.out.println(jedis.ttl(<span class="string">&quot;site&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * list类型测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listTest</span><span class="params">()</span> &#123;</span><br><span class="line">        jedis.rpush(<span class="string">&quot;courses&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;spring&quot;</span>, <span class="string">&quot;springmvc&quot;</span>, <span class="string">&quot;springboot&quot;</span>);</span><br><span class="line">        List&lt;String&gt; courses = jedis.lrange(<span class="string">&quot;courses&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String course : courses) &#123;</span><br><span class="line">            System.out.println(course);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set类型测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTest</span><span class="params">()</span> &#123;</span><br><span class="line">        jedis.sadd(<span class="string">&quot;users&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;ready&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; users = jedis.smembers(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash类型测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hashTest</span><span class="params">()</span> &#123;</span><br><span class="line">        jedis.hset(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;1001&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;30&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; userMap = jedis.hgetAll(<span class="string">&quot;user:1001&quot;</span>);</span><br><span class="line">        System.out.println(userMap);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zset类型测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">zsetTest</span><span class="params">()</span> &#123;</span><br><span class="line">        jedis.zadd(<span class="string">&quot;languages&quot;</span>, <span class="number">100d</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;languages&quot;</span>, <span class="number">95d</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;languages&quot;</span>, <span class="number">70d</span>, <span class="string">&quot;php&quot;</span>);</span><br><span class="line">        List&lt;String&gt; languages = jedis.zrange(<span class="string">&quot;languages&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(languages);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribeTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// subscribe(消息监听器,频道列表)</span></span><br><span class="line">        jedis.subscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String channel, String message)</span> &#123;</span><br><span class="line">                System.out.println(channel + <span class="string">&quot;:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;sitemsg&quot;</span>);</span><br><span class="line">        TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishTest</span><span class="params">()</span> &#123;</span><br><span class="line">        jedis.publish(<span class="string">&quot;sitemsg&quot;</span>, <span class="string">&quot;hello redis&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="SpringDataRedis-API访问Redis集群"><a href="#SpringDataRedis-API访问Redis集群" class="headerlink" title="SpringDataRedis API访问Redis集群"></a>SpringDataRedis API访问Redis集群</h3><p>这里给定的是一个基于spring boot 的java web项目</p><p><a name = "SpringDataRedis的集群"></a></p><ol><li><strong>首先需要基于docker搭建redis集群环境</strong></li></ol><p>其中的<code>cluster-announce-ip</code>是用来宣告IP的，需要的是一个可访问redis的IP，不宣告则为本地IP，这里宣告为本地IP</p><p><em>6380</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">port 6380</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6380.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"></span><br><span class="line">cluster-announce-ip 192.168.3.226</span><br><span class="line">cluster-announce-port 6380</span><br><span class="line">cluster-announce-bus-port 16380</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>6381</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">port 6381</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6381.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br><span class="line">cluster-announce-ip 192.168.3.226</span><br><span class="line">cluster-announce-port 6381</span><br><span class="line">cluster-announce-bus-port 16381</span><br></pre></td></tr></table></figure><p><em>6382</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">port 6382</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6382.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br><span class="line">cluster-announce-ip 192.168.3.226</span><br><span class="line">cluster-announce-port 6382</span><br><span class="line">cluster-announce-bus-port 16382</span><br></pre></td></tr></table></figure><p><em>6383</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">port 6383</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6383.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br><span class="line">cluster-announce-ip 192.168.3.226</span><br><span class="line">cluster-announce-port 6383</span><br><span class="line">cluster-announce-bus-port 16383</span><br></pre></td></tr></table></figure><p><em>6384</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">port 6384</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6384.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br><span class="line">cluster-announce-ip 192.168.3.226</span><br><span class="line">cluster-announce-port 6384</span><br><span class="line">cluster-announce-bus-port 16384</span><br></pre></td></tr></table></figure><p><em>6385</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">port 6385</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6385.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br><span class="line">cluster-announce-ip 192.168.3.226</span><br><span class="line">cluster-announce-port 6385</span><br><span class="line">cluster-announce-bus-port 16385</span><br></pre></td></tr></table></figure><ul><li>创建容器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name redis_6380  -p 6380:6380 -p 16380:16380   --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/data/6380:/data  -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/conf_cluster:/etc/redis redis redis-server /etc/redis/redis-6380.conf </span><br><span class="line"></span><br><span class="line">docker run -id --name redis_6381  -p 6381:6381 -p 16381:16381   --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/data/6381:/data  -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/conf_cluster:/etc/redis redis redis-server /etc/redis/redis-6381.conf</span><br><span class="line"></span><br><span class="line">docker run -id --name redis_6382  -p 6382:6382 -p 16382:16382   --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/data/6382:/data  -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/conf_cluster:/etc/redis redis redis-server /etc/redis/redis-6382.conf</span><br><span class="line"></span><br><span class="line">docker run -id --name redis_6383  -p 6383:6383 -p 16383:16383   --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/data/6383:/data  -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/conf_cluster:/etc/redis redis redis-server /etc/redis/redis-6383.conf </span><br><span class="line"></span><br><span class="line">docker run -id --name redis_6384  -p 6384:6384 -p 16384:16384   --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/data/6384:/data  -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/conf_cluster:/etc/redis redis redis-server /etc/redis/redis-6384.conf </span><br><span class="line"></span><br><span class="line">docker run -id --name redis_6385  -p 6385:6385 -p 16385:16385   --privileged=true -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/data/6385:/data  -v C:/Users/GTR/Desktop/temp/大学上课学习/大三上/非关系型数据库/redis/conf_cluster:/etc/redis redis redis-server /etc/redis/redis-6385.conf </span><br></pre></td></tr></table></figure><ul><li>进入容器并创建集群</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//进入容器</span><br><span class="line">docker exec -it redis_6380 /bin/bash</span><br><span class="line"></span><br><span class="line">//创建集群</span><br><span class="line">redis-cli --cluster create 192.168.3.226:6380 192.168.3.226:6381 192.168.3.226:6382 192.168.3.226:6383 192.168.3.226:6384  192.168.3.226:6385  --cluster-replicas 1</span><br><span class="line"></span><br><span class="line">//查询集群</span><br><span class="line">redis-cli -p 6380  cluster nodes</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>案例</strong></li></ol><p><em>这个类是对redis的相关操作</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.DataType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDataRedisController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.操作 字符串 类型</span></span><br><span class="line">    <span class="comment">//访问的 URL：http://localhost:8080/testString</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testString&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//默认情况下，SpringDataRedis将存入 redis中的 key和 value</span></span><br><span class="line">        <span class="comment">// 都作为 java对象进行了序列化处理，转换为 字节 后存入redis</span></span><br><span class="line">        <span class="comment">//如：&quot;k1&quot;---&quot;\xac\xed\x00\x05t\x00\x02k1&quot;</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">// redisTemplate.expire(&quot;k1&quot;,20, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello: &quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实验1：自行设计一个对String类型操作的方法，并访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.操作 列表类型</span></span><br><span class="line"><span class="comment">//    操作list数据是redisTemplate.opsForList()方法，返回类型是ListOperations</span></span><br><span class="line"><span class="comment">//    listOperations.leftPush为存值（只存一个），listOperations.leftPushAll为存值（存多个） --lpush</span></span><br><span class="line"><span class="comment">//    listOperations.range为取值 --相当于命令行 lrange</span></span><br><span class="line"><span class="comment">//    listOperations.size为获取长度 --相当于命令行 llen</span></span><br><span class="line"><span class="comment">//    listOperations.rightPop为移除最后一个元素 --相当于命令行 rpop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问的 URL：http://localhost:8080/testList</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testList&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ListOperations</span> <span class="variable">listOperations</span> <span class="operator">=</span> redisTemplate.opsForList();</span><br><span class="line">        <span class="comment">//插入数据</span></span><br><span class="line">        listOperations.leftPush(<span class="string">&quot;list1&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        listOperations.leftPush(<span class="string">&quot;list1&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        listOperations.leftPush(<span class="string">&quot;list1&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        <span class="comment">//取出数据</span></span><br><span class="line">        List&lt;String&gt; list1 = listOperations.range(<span class="string">&quot;list1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String value : list1) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取列表的长度</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> listOperations.size(<span class="string">&quot;list1&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lSize</span> <span class="operator">=</span> ((<span class="type">int</span>) size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lSize; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> (String) listOperations.rightPop(<span class="string">&quot;list1&quot;</span>);</span><br><span class="line">            System.out.println(element);  <span class="comment">//a b c</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.操作 Set 类型</span></span><br><span class="line"><span class="comment">//   操作set类型数据是redisTemplate.opsForSet()，返回类型为 SetOperations</span></span><br><span class="line"><span class="comment">//setOperations.add 是存值，可以存一个或多个。 --对应命令行 sadd</span></span><br><span class="line"><span class="comment">//setOperations.members 是取值。 --对应命令行为 smembers</span></span><br><span class="line"><span class="comment">//setOperations.remove 是删除成员。 --对应命令行 srem</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问的 URL：http://localhost:8080/testSet</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testSet&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SetOperations</span> <span class="variable">setOperations</span> <span class="operator">=</span> redisTemplate.opsForSet();</span><br><span class="line">        <span class="comment">//插入集合数据</span></span><br><span class="line">        setOperations.add(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; myset = setOperations.members(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String o : myset) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;---删除后------&quot;</span>);</span><br><span class="line">        <span class="comment">//删除元素</span></span><br><span class="line">        setOperations.remove(<span class="string">&quot;myset&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        myset = setOperations.members(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String o : myset) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 操作 hash数据</span></span><br><span class="line">    <span class="comment">// 对应的是 redisTemplate.opsForHash()方法，返回值是 hashOperations 类型</span></span><br><span class="line">    <span class="comment">//hashOperations.put 为存值 --相当于命令行中 hset</span></span><br><span class="line">    <span class="comment">//hashOperations.get 为取值 --相当于命令行中 hget</span></span><br><span class="line">    <span class="comment">//hashOperations.keys 为获取所有字段（key值） --相当于命令行中 hkeys</span></span><br><span class="line">    <span class="comment">//hashOperations.values 为获取 hash结构的所有值（value值） --相当于命令函中的hvals</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问的 URL：http://localhost:8080/testHash</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testHash&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        HashOperations hashOperations=redisTemplate.opsForHash();</span><br><span class="line">        <span class="comment">//插入数据</span></span><br><span class="line">        hashOperations.put(<span class="string">&quot;s001&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        hashOperations.put(<span class="string">&quot;s001&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line"></span><br><span class="line">        hashOperations.put(<span class="string">&quot;s001&quot;</span>,<span class="string">&quot;phone&quot;</span>,<span class="string">&quot;13900000&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String age=(String)hashOperations.get(<span class="string">&quot;s001&quot;</span>,<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(age);</span><br><span class="line">        <span class="comment">//获取所有字段</span></span><br><span class="line">        Set keys=hashOperations.keys(<span class="string">&quot;s001&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object key:keys)&#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取所有的值</span></span><br><span class="line"></span><br><span class="line">        List values=hashOperations.values(<span class="string">&quot;s001&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object value:values)&#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在hash表中一次性插入多个元素</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;xxx@gdufs.edu.cn&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;phone&quot;</span>,<span class="string">&quot;13500000&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().putAll(<span class="string">&quot;s002&quot;</span>, map);</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().entries(<span class="string">&quot;s002&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 操作 zset 数据</span></span><br><span class="line"><span class="comment">//   操作 zset 类型的是 redisTemplate.opsForZSet()，返回类型 ZSetOperations</span></span><br><span class="line"><span class="comment">//    zSetOperations.add 存值 -- zadd</span></span><br><span class="line"><span class="comment">//    zSetOperations.range 取值 -- zrange</span></span><br><span class="line"><span class="comment">//    zSetOperations.remove 删除成员 -- zrem</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问的 URL：http://localhost:8080/testZset</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testZset&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ZSetOperations</span> <span class="variable">zSetOperations</span> <span class="operator">=</span> redisTemplate.opsForZSet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入数据</span></span><br><span class="line">        zSetOperations.add(<span class="string">&quot;myZset&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="number">10.0</span>);</span><br><span class="line">        zSetOperations.add(<span class="string">&quot;myZset&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="number">20.0</span>);</span><br><span class="line">        zSetOperations.add(<span class="string">&quot;myZset&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="number">15.0</span>);</span><br><span class="line">        zSetOperations.add(<span class="string">&quot;myZset&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="number">51.0</span>);</span><br><span class="line">        <span class="comment">//取数据</span></span><br><span class="line">        Set&lt;String&gt; myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----数据修改后-------&quot;</span>);</span><br><span class="line">        zSetOperations.incrementScore(<span class="string">&quot;myZset&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        myZset = zSetOperations.range(<span class="string">&quot;myZset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : myZset) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zSetOperations.remove(<span class="string">&quot;myZset&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    6.操作通用命令（针对不同的类型都可以操作）</span></span><br><span class="line"><span class="comment">//    redisTemplate.keys(“*”) 获取数据库所有的 key字段 --keys *</span></span><br><span class="line"><span class="comment">//    redisTemplate.hasKey判断 key值是否存在 --exists (key)</span></span><br><span class="line"><span class="comment">//    redisTemplate.delete删除 key – del (key)</span></span><br><span class="line"><span class="comment">//    redisTemplate.type获取指定 key的类型 --type(key)</span></span><br><span class="line"><span class="comment">//    这里返回的为 DataType类型，dataType.name()为其类型所对应名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问的 URL：http://localhost:8080/testCommon</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testCommon&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCommon</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        Set&lt;String&gt; keys=redisTemplate.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(redisTemplate.keys(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (String key:keys)&#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Boolean itcast=redisTemplate.hasKey(<span class="string">&quot;User：4&quot;</span>);</span><br><span class="line">        System.out.println(itcast);</span><br><span class="line">        </span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;myZset&quot;</span>);</span><br><span class="line"></span><br><span class="line">       DataType dataType= redisTemplate.type(<span class="string">&quot;myset&quot;</span>);</span><br><span class="line">       System.out.println(dataType.name());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>pom.xml文件中导入了相关的依赖</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.7</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;demo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;demo&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project <span class="keyword">for</span> Spring Boot&lt;/description&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;<span class="number">1.8</span>&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        springDataRedis--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--        redis连接池--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        web项目--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>application.yml和application.properties文件配置文件的作用一样，但是格式不一样，配置文件中配置了对redis数据库的访问信息</p><p><em>下面是application.yml的配置</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">   redis:</span><br><span class="line">     # redis分片集群配置</span><br><span class="line">     cluster:</span><br><span class="line">       nodes:</span><br><span class="line">         - <span class="number">192.168</span><span class="number">.3</span><span class="number">.226</span>:<span class="number">6380</span></span><br><span class="line">         - <span class="number">192.168</span><span class="number">.3</span><span class="number">.226</span>:<span class="number">6381</span></span><br><span class="line">         - <span class="number">192.168</span><span class="number">.3</span><span class="number">.226</span>:<span class="number">6382</span></span><br><span class="line">         - <span class="number">192.168</span><span class="number">.3</span><span class="number">.226</span>:<span class="number">6383</span></span><br><span class="line">         - <span class="number">192.168</span><span class="number">.3</span><span class="number">.226</span>:<span class="number">6384</span></span><br><span class="line">         - <span class="number">192.168</span><span class="number">.3</span><span class="number">.226</span>:<span class="number">6385</span></span><br><span class="line">         #  重定向最大次数</span><br><span class="line">       max-redirects: <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     # redis连接池配置</span><br><span class="line">     lettuce:</span><br><span class="line">       pool:</span><br><span class="line">         max-active: <span class="number">10</span></span><br><span class="line">         max-idle: <span class="number">10</span></span><br><span class="line">         min-idle: <span class="number">1</span></span><br><span class="line">         max-wait: -1ms</span><br><span class="line">       cluster:</span><br><span class="line">        # 使能集群拓扑自适应刷新，默认值：<span class="literal">false</span></span><br><span class="line">         refresh:</span><br><span class="line">           adaptive: <span class="literal">true</span></span><br><span class="line">          # 集群拓扑定时刷新周期，Unit：毫秒</span><br><span class="line">           period: <span class="number">6000</span></span><br></pre></td></tr></table></figure><h3 id="MyBatis框架"><a href="#MyBatis框架" class="headerlink" title="MyBatis框架"></a>MyBatis框架</h3><p>ORM框架连接MySQL： ORM（Object-Relational Mapping）框架是一种将对象和关系数据库进行映射的技术。MyBatis就是一种ORM框架。</p><h4 id="简单学习"><a href="#简单学习" class="headerlink" title="简单学习"></a>简单学习</h4><p><a href="https://blog.csdn.net/weixin_49211683/article/details/127975868?ops_request_misc=%7B%22request_id%22:%22169997537916800188521933%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169997537916800188521933&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-127975868-null-null.142%5Ev96%5Epc_search_result_base9&utm_term=mybatis%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B&spm=1018.2226.3001.4187">MyBatis的入门学习（增删改查）_mybatis增删改查项目demo-CSDN博客</a></p><p><a href="https://blog.csdn.net/vcj1009784814/article/details/106391982?ops_request_misc=%7B%22request_id%22:%22169997007516800188590517%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=169997007516800188590517&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106391982-null-null.142%5Ev96%5Epc_search_result_base9&utm_term=mybatis&spm=1018.2226.3001.4187">mybatis看这一篇就够了，简单全面一发入魂-CSDN博客</a></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p><a href="https://blog.csdn.net/dhptkq9465/article/details/101503739">spring boot +mybatis(通过properties配置) 集成-CSDN博客</a></p><p><strong>也可以通过<code>.yml</code>文件配置，两者作用一样就是书写方式有些区别</strong></p><p><a href="https://blog.csdn.net/qq_33164994/article/details/85042378">IntelliJ IDEA 整合 Spring Boot 2.1.1 + mybatis + mysql 8.0.13 使用application.properties配置文件 微服务框架整合-CSDN博客</a></p><p><a href="https://blog.csdn.net/fly_leopard/article/details/78498804">Spring-Boot (二) application.properties配置文件内容_springboot application.properties配置-CSDN博客</a></p><p><a href="https://blog.51cto.com/u_16175508/6658766">如何实现spring boot redis 集群 配置的具体操作步骤_mob649e81664bd9的技术博客_51CTO博客</a></p><p>集群配置中，如<code>spring.redis.cluster.nodes=redis1:6379,redis2:6379,redis3:6379</code>中<code>redis1</code>、<code>redis2</code>和<code>redis3</code>是Redis集群中的三个节点的主机名或IP地址，<code>6379</code>是这些节点上Redis服务器的端口号，也可以直接使用IP进行配置，这里是本地使用Docker创建了几个容器并且配置了集群环境</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 集群信息</span><br><span class="line"><span class="function">root@901954ace2ba:/<span class="title">data</span># <span class="title">redis</span>-<span class="title">cli</span> -<span class="title">p</span> 6380  <span class="title">cluster</span> <span class="title">nodes</span></span></span><br><span class="line"><span class="function"><span class="title">d9a4c5850392510e49da4ded6bd0b0811067e716</span> 192.168.3.226:6381@16381 <span class="title">master</span> - 0 1700135929120 2 <span class="title">connected</span> 5461-10922</span></span><br><span class="line"><span class="function">7<span class="title">a298025c3ac129278d7eabaf3fa85c70549f128</span> 192.168.3.226:6384@16384 <span class="title">slave</span> <span class="title">d9a4c5850392510e49da4ded6bd0b0811067e716</span> 0 1700135930526 2 <span class="title">connected</span></span></span><br><span class="line"><span class="function"><span class="title">de6be6bfb2abf66fdbb5d7f66d78b4993f32ad2e</span> 192.168.3.226:6383@16383 <span class="title">slave</span> 20<span class="title">edeaa91aecdfdc3ac91d1baddadd667c495fc9</span> 0 1700135930526 1 <span class="title">connected</span></span></span><br><span class="line"><span class="function"><span class="title">c2121c060fdb513c6dad9f596164ee83f5d660a0</span> 192.168.3.226:6382@16382 <span class="title">master</span> - 0 1700135929522 3 <span class="title">connected</span> 10923-16383</span></span><br><span class="line"><span class="function">20<span class="title">edeaa91aecdfdc3ac91d1baddadd667c495fc9</span> 192.168.3.226:6380@16380 <span class="title">myself</span>,<span class="title">master</span> - 0 1700135929000 1 <span class="title">connected</span> 0-5460</span></span><br><span class="line"><span class="function">6<span class="title">d73ddeadb01b2c07bf93407a402f66138df5806</span> 192.168.3.226:6385@16385 <span class="title">slave</span> <span class="title">c2121c060fdb513c6dad9f596164ee83f5d660a0</span> 0 1700135929522 3 <span class="title">connected</span></span></span><br><span class="line"><span class="function"><span class="title">root</span>@901954<span class="title">ace2ba</span>:/<span class="title">data</span>#</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis集群配置</span></span><br><span class="line"><span class="attr">spring.data.redis.cluster.nodes</span>=<span class="string">192.168.3.226:6380,192.168.3.226:6381,192.168.3.226:6382,192.168.3.226:6383,192.168.3.226:6384,192.168.3.226:6385</span></span><br></pre></td></tr></table></figure><h3 id="Redis作为MySQL缓存应用"><a href="#Redis作为MySQL缓存应用" class="headerlink" title="Redis作为MySQL缓存应用"></a>Redis作为MySQL缓存应用</h3><p><strong>一般流程如下</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241240229.png" alt="image-20231114005454893"></p><h4 id="需要解决的一些问题"><a href="#需要解决的一些问题" class="headerlink" title="需要解决的一些问题"></a>需要解决的一些问题</h4><p><a href="https://www.zhihu.com/question/582570001/answer/3045002344">(5 封私信 &#x2F; 20 条消息) Redis 缓存和 MySQL 数据保持一致性的方法有哪些？ - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/MinggeQingchun/article/details/130400887">Redis - 缓存雪崩，缓存穿透，缓存击穿_雪崩redis_MinggeQingchun的博客-CSDN博客</a></p><p>缓存雪崩是指在同一时段，Redis 中的缓存 key 大面积同时失效，或者 Redis 服务宕机，导致大量的数据请求直接面向 MySQL 数据库，给数据库造成巨大压力，可能带来灾难性的问题。</p><p><strong>解决相关问题出现的一些知识回顾</strong></p><p><a href="https://zhuanlan.zhihu.com/p/472756166">【数据库】数据库锁 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/yifeiliu338/article/details/129316099">Redis的分布式锁详解_redis分布式锁-CSDN博客</a></p><h4 id="样例实现"><a href="#样例实现" class="headerlink" title="样例实现"></a>样例实现</h4><p>下面代码为学习过程中仿照给定代码进行书写的，<strong>整个样例实现了Redis作为MySQL的缓存并且Redis开启了三主三从的集群，同时对缓存穿透、缓存雪崩、缓存击穿作出了一些简单的处理</strong></p><p><strong>整个样例下载路径</strong></p><p><a href="https://wwcz.lanzout.com/b04kt8wla">https://wwcz.lanzout.com/b04kt8wla</a><br>密码:2wdy</p><ul><li><strong>首先需要在MySQL数据库中存在一个名为week_10的数据库，并且在其中创建一张名为student的表</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table student</span><br><span class="line">(</span><br><span class="line">    id        int auto_increment</span><br><span class="line">        primary key,</span><br><span class="line">    name      varchar(50) not null,</span><br><span class="line">    studentId varchar(50) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><strong>使用Docker创建集群环境，创建方法在上面讲了，创建的集群跟上面一样</strong></li></ul><p>​<a href="#SpringDataRedis的集群">跳转查看集群创建</a></p><ul><li><p><strong>使用上面构建SpringBoot项目的方法创建项目并通过maven导入依赖</strong></p><p><a href="https://blog.csdn.net/houxian1103/article/details/128721100">工具类库 Hutool介绍与使用（请记得收藏）-CSDN博客</a></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>week10_redis_20211003238<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>week10_redis_20211003238<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>week10_redis_20211003238<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--spring-boot-starter-web: 提供了使用 Spring MVC 进行 Web 开发所需的基本依赖。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--spring-boot-starter-test: 包含了 Spring Boot 测试模块，支持单元测试、集成测试等。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--spring-boot-starter-data-redis: 集成了 Spring Data Redis，简化了在 Spring Boot 中使用 Redis 的配置和操作。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis-spring-boot-starter: 集成了 MyBatis 持久层框架，简化了 MyBatis 在 Spring Boot 中的集成。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mysql-connector-java: MySQL 数据库的 JDBC 驱动。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--lombok: 提供了简化 Java 代码的注解，如 @Data、@Getter、@Setter 等，减少了冗长的 Java 代码。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;optional&gt;true&lt;/optional&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--commons-pool2: Apache Commons 池化库，用于提供对象池的实现，通常用于数据库连接池等场景。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--hutool-all: Hutool 工具库，提供了丰富的工具方法，包括字符串处理、日期时间处理、加密解密等，简化了 Java 开发中的常见任务。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 将java目录下的xml文件打包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">builder</span>&gt;</span>paketobuildpacks/builder-jammy-base:latest<span class="tag">&lt;/<span class="name">builder</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>application.properties</code>配置文件</strong></li></ul><p><strong>该文件位于resources文件夹下</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql配置</span></span><br><span class="line"><span class="comment">#配置访问驱动</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"># spring.datasource.url指定连接数据库URL信息</span></span><br><span class="line"><span class="comment">#jdbc:mysql:///week10连接week10数据库，jdbc是Java数据库连接的标准前缀，mysql是数据库的类型，///表示使用默认的主机（通常是 localhost），week10 是数据库的名称。</span></span><br><span class="line"><span class="comment"># characterEncoding=utf8: 这是设置数据库连接的字符编码为UTF-8，确保能够正确处理包含非英文字符的数据。</span></span><br><span class="line"><span class="comment"># serverTimezone=Hongkong设置地区</span></span><br><span class="line"><span class="comment">#serverTimezone=GMT%2B8: 这是设置数据库服务器的时区为GMT+8。这对于确保应用程序和数据库之间的时间一致性非常重要，特别是在涉及到时间戳等信息时。</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql:///week10?serverTimezone=Hongkong?characterEncoding=utf8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="comment">#配置redis用户名和密码</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">wang10086</span></span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#redis</span></span><br><span class="line"><span class="comment">#配置访问redis的主机和端口号，也可以使用spring.redis.url=</span></span><br><span class="line"><span class="attr">spring.data.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">spring.data.redis.port</span>=<span class="string">16366</span></span><br><span class="line"><span class="comment"># 修改配置集群</span></span><br><span class="line"><span class="attr">spring.data.redis.cluster.nodes</span>=<span class="string">192.168.3.226:6380,192.168.3.226:6381,192.168.3.226:6382,192.168.3.226:6383,192.168.3.226:6384,192.168.3.226:6385</span></span><br><span class="line"><span class="comment"># 配置重定向最大次数</span></span><br><span class="line"><span class="comment"># 在 Redis 集群中，当执行某个命令时，如果节点发生了槽分区的迁移，客户端会被重定向到新的节点。</span></span><br><span class="line"><span class="comment">#当某个节点执行槽分区迁移时，可能会触发重定向。在一些异常情况下，可能发生多次重定向。max-redirects 的作用就是为了防止客户端无限制地进行重定向，避免陷入死循环。</span></span><br><span class="line"><span class="attr">spring.data.redis.cluster.max-redirects</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#配置连接池，lettuce连接池专门为redis使用的，pring.data.redis.lettuce.pool配置lettuce连接池,还有commnon连接池</span></span><br><span class="line"><span class="comment">#max-active:连接池中的最大活跃连接数。max-idle:连接池中的最大空闲连接数。min-idle:连接池中的最小空闲连接数。max-wait:当连接池没有可用连接时，最大等待时间。若为负数，则表示无限等待。</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.max-active</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.max-idle</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.max-wait</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment"># adaptive是否启用集群拓扑自适应刷新</span></span><br><span class="line"><span class="comment"># 集群拓扑自适应刷新点作用包括故障转移感知、节点变化感知、动态适应性</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.cluster.refresh.adaptive</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 集群拓扑定时刷新周期，单位为毫秒</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.cluster.refresh.period</span>=<span class="string">6000</span></span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#mybatis配置</span></span><br><span class="line"><span class="comment">#指定sql配置文件的位置</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:com/example/week10_redis_20211003238/mapper/*.xml</span></span><br><span class="line"><span class="comment">#指定实体类所在的包名</span></span><br><span class="line"><span class="attr">mybatis.type-aliases-package</span>=<span class="string">com.example.week10_redis_20211003238.pojo</span></span><br><span class="line"><span class="comment">#输出SQL命令</span></span><br><span class="line"><span class="attr">mybatis.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p><strong>注：也可以使用<code>.yml</code>配置文件进行配置，下面放出两者的区别的介绍博客</strong></p><p><a href="https://www.cnblogs.com/flower-dance/p/14268237.html">SpringBoot之yml与properties配置文件格式的区别 - 彼岸舞 - 博客园 (cnblogs.com)</a></p><ul><li><strong>首先需要了解这几层再进行代码书写，各层放在了项目不同文件夹下，可以看项目结构了解</strong></li></ul><p>经典的四层架构，通常在使用 Spring 框架进行开发时会采用这种结构。下面是每一层的主要职责：</p><ol><li><p><strong>Pojo层（Model层）</strong>：</p><ul><li>主要包含应用程序的领域模型，通常是实体类（Entity）或者简单的 Java Bean。</li><li>用于表示业务数据以及业务规则。</li></ul></li><li><p><strong>Mapper层（Data Access层）</strong>：</p><ul><li>负责数据的持久化，与数据库进行交互。</li><li>包含数据访问对象（DAO）或者 Repository。</li><li>可以使用 ORM 框架（如 MyBatis 或 Hibernate）简化数据库操作。</li></ul></li><li><p><strong>Service层</strong>：</p><ul><li>业务逻辑的处理中心，负责处理应用程序的业务规则。</li><li>调用 Mapper 层进行数据库操作，协调不同的业务逻辑。</li><li>提供事务管理、安全性等服务。</li></ul></li><li><p><strong>Controller层</strong>：</p><ul><li>处理用户请求，接收用户输入，调用 Service 层处理业务逻辑，最终返回结果给用户。</li><li>负责与用户界面进行交互，通常是通过 HTTP 请求和响应。</li></ul><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241241117.png" alt="image-20231116225329415"></p></li></ol><ul><li><strong>配置 Spring Boot 项目中 Redis 连接和序列化的类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.week10_redis_20211003238.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 配置 Spring Boot 项目中 Redis 连接和序列化的类</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Configuration表明是配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="comment">//Bean注解表示这是将被Spring管理的Bean对象的方法。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象，用于操作Redis数据，之后返回</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置连接工厂，指定Redis的连接方式</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">//创建JSON序列化工具，SpringDataRedis提供的一个JSON序列化工具，用于将对象序列化成JSON格式</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">//设置Key的序列化,使用了Redis的字符串序列化。</span></span><br><span class="line">        <span class="comment">//Redis中的键默认是以字符串形式存在的，但在实际应用中，你可能会使用复杂的数据结构或者自定义对象作为键。在这种情况下，你需要确定如何将这些键序列化为字符串，以便存储到 Redis 中。</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">//设置Value的序列化，使用了JSON的序列化</span></span><br><span class="line">        <span class="comment">//当你存储自定义对象或复杂数据结构时，你需要确定如何将这些值序列化为字符串，以便存储到 Redis 中</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RedisConnectionFactory</code> 是 Spring Data Redis 中的一个关键接口，它定义了用于创建 <code>RedisConnection</code> 对象的工厂方法。<code>RedisConnection</code> 表示与 Redis 数据库的连接，可以用于执行各种 Redis 操作，例如读写数据、执行事务、发布和订阅消息等。</p><p><code>RedisConnectionFactory</code> 的主要作用是抽象出连接 Redis 所需的细节，包括连接池配置、连接超时、主从配置等。通过实现这个接口，可以灵活地配置和管理与 Redis 的连接。</p><p>在 Spring 中，<code>RedisConnectionFactory</code> 的实现通常使用第三方的 Redis 客户端库，比如 Jedis 或 Lettuce。这些实现隐藏了底层连接细节，同时提供了一些配置选项，以满足不同应用场景的需求。</p><p>以下是 <code>RedisConnectionFactory</code> 的一些常见实现：</p><ol><li><p><strong>JedisConnectionFactory</strong>: 使用 Jedis 作为底层连接库，适用于传统的阻塞式 I&#x2F;O 模型。</p></li><li><p><strong>LettuceConnectionFactory</strong>: 使用 Lettuce 作为底层连接库，适用于基于 Netty 的非阻塞式 I&#x2F;O 模型，支持更多高级特性，例如异步操作和响应式编程。</p></li></ol><p>通过配置 <code>RedisConnectionFactory</code>，你可以轻松地切换底层连接库，同时可以设置连接池、超时时间、主从配置等参数，以满足具体应用的性能和可用性要求。</p><ul><li><strong>pojo层</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.week10_redis_20211003238.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Data是Lombok提供的一个组合注解，自动生成 Getter、Setter、toString、hashCode 和 equals 方法。它可以减少大量重复性的代码。</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">//自动生成无参构造函数</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动生成全参构造函数</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String studentId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>mapper层</strong></li></ul><p>StudentMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.week10_redis_20211003238.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.week10_redis_20211003238.pojo.Student;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询所有数据</span></span><br><span class="line">    <span class="comment">/*也可以在xml中</span></span><br><span class="line"><span class="comment">    *     &lt;select id=&quot;getAllStudents&quot; resultType=&quot;Student&quot;&gt;</span></span><br><span class="line"><span class="comment">        SELECT *</span></span><br><span class="line"><span class="comment">        FROM student</span></span><br><span class="line"><span class="comment">    &lt;/select&gt;</span></span><br><span class="line"><span class="comment">    * 然后在这个接口中public List&lt;Student&gt; getAllStudents();</span></span><br><span class="line"><span class="comment">    * xml中的返回类型指定为返回类型即可，不用管是不是List*/</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM student&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getAllStudents</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteStudentById</span><span class="params">(String studentId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询数据</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">findStudentById</span><span class="params">(String studentId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStudentNameById</span><span class="params">(Student student)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StudentMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.week10_redis_20211003238.mapper.StudentMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--namespace属性的值就是对应的Mapper接口的全限定名。通过这个命名空间，MyBatis就知道了要将这个XML文件中的SQL映射到哪个Java接口上。--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--SQL语句带一个参数</span></span><br><span class="line"><span class="comment">    parameterType：指定接收参数类型，返回一条记录，用下标取参数</span></span><br><span class="line"><span class="comment">    parameterType：参数类型--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--插入学生数据--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt;:这是一个用于获取数据库生成主键的配置。它的作用是在插入后执行一条额外的查询语句，从数据库中获取生成的主键值。具体解释如下：</span></span><br><span class="line"><span class="comment">    keyProperty=&quot;id&quot;: 表示将获取到的主键值设置到 User 对象的 id 属性中。</span></span><br><span class="line"><span class="comment">    order=&quot;AFTER&quot;: 表示在插入语句执行之后执行这条额外的查询语句。</span></span><br><span class="line"><span class="comment">    resultType=&quot;int&quot;: 表示查询结果的类型是整数型。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--LAST_INSERT_ID() 是 MySQL 数据库的函数，用于获取最后插入的自增主键值。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--INSERT INTO users SET name=#&#123;name&#125;,studentId=#&#123;studentId&#125;: 这是实际的插入语句，其中 #&#123;name&#125; 和 #&#123;studentId&#125; 是参数占位符，会被传入的 Student 对象的属性值替代。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addStudent&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO student SET name=#&#123;name&#125;,studentId=#&#123;studentId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;insert id=&quot;addStudent&quot; parameterType=&quot;Student&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt;</span></span><br><span class="line"><span class="comment">            select LAST_INSERT_ID()</span></span><br><span class="line"><span class="comment">        &lt;/selectKey&gt;</span></span><br><span class="line"><span class="comment">        INSERT INTO student SET name=#&#123;name&#125;,studentId=#&#123;studentId&#125;</span></span><br><span class="line"><span class="comment">    &lt;/insert&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据学号删除学生数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteStudentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span>&gt;</span></span><br><span class="line">        DELETE</span><br><span class="line">        FROM student</span><br><span class="line">        WHERE studentId = #&#123;0&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据学号查找学生--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在 MyBatis 中，#&#123;0&#125; 表示SQL语句中的第一个参数。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findStudentById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span>&gt;</span></span><br><span class="line">        SELECT *</span><br><span class="line">        FROM student</span><br><span class="line">        WHERE studentId = #&#123;0&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据学号修改学生数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStudentNameById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        UPDATE student</span><br><span class="line">        SET name=#&#123;name&#125;</span><br><span class="line">        WHERE studentId = #&#123;studentId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;select id=&quot;getAllStudents&quot; resultType=&quot;Student&quot;&gt;</span></span><br><span class="line"><span class="comment">        SELECT *</span></span><br><span class="line"><span class="comment">        FROM student</span></span><br><span class="line"><span class="comment">    &lt;/select&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>service层</strong></li></ul><p>StudentService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.week10_redis_20211003238.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.week10_redis_20211003238.pojo.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getAllStudents</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteStudentById</span><span class="params">(String studentId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">findStudentById</span><span class="params">(String studentId)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">updateStudentNameById</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储Student对象到Redis中</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveToRedis</span><span class="params">(Student student)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>StudentServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.week10_redis_20211003238.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.week10_redis_20211003238.mapper.StudentMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.week10_redis_20211003238.pojo.Student;</span><br><span class="line"><span class="keyword">import</span> com.example.week10_redis_20211003238.service.StudentService;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.BooleanUtil;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * description:数据一致性处理：需修改</span></span><br><span class="line"><span class="comment">     * 1.数据写入redis时，设置 key的超时时间，</span></span><br><span class="line"><span class="comment">     * 2.修改用户数据时，先修改 mysql，再删除 redis缓存</span></span><br><span class="line"><span class="comment">     * 3.开启事务：保证正确事务的提交</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">/*@Resource 注解是 JavaEE 的规范，而 @Autowired 是 Spring 框架特有的注解。@Resource 比 @Autowired 更通用，</span></span><br><span class="line"><span class="comment">    因为它不仅可以用于注入 Spring bean，还可以用于注入其他 JavaEE 组件。*/</span></span><br><span class="line">    <span class="keyword">private</span> StudentMapper studentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentServiceImpl</span><span class="params">(RedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询单个Student再从缓存中查询，没有再从MySQL中查询再保存到Redis</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getAllStudents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> studentMapper.getAllStudents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加Student信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> studentMapper.addStudent(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据、更新数据需要开启事物进行一致性处理，这里的方案是先更新数据库数据再删除缓存</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteStudentById</span><span class="params">(String studentId)</span> &#123;</span><br><span class="line">        <span class="comment">//删除数据库数据</span></span><br><span class="line">        studentMapper.deleteStudentById(studentId);</span><br><span class="line">        <span class="comment">//删除缓存数据</span></span><br><span class="line">        <span class="keyword">if</span> (studentId != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;student:&quot;</span> + studentId;</span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;删除成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询单个Student</span></span><br><span class="line">    <span class="comment">//这里进行了防止缓存穿透的修改，这里只是把空值也加入到缓存之中而已</span></span><br><span class="line">    <span class="comment">//下面注释的代码是没有进行缓存击穿处理的代码，只进行了简单缓存穿透处理</span></span><br><span class="line"><span class="comment">/*    @Override</span></span><br><span class="line"><span class="comment">    public Student findStudentById(String studentId) throws IOException &#123;</span></span><br><span class="line"><span class="comment">        //1.从Redis缓存中查询数据</span></span><br><span class="line"><span class="comment">        Student student = getStudentByRedis(studentId);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //2.Redis中有该用户就返回</span></span><br><span class="line"><span class="comment">        if (student != null) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;Redis缓存中查询到该用户&quot;);</span></span><br><span class="line"><span class="comment">            return student;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //3.Redis中没有找到，到MySQL中查询后加redis</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Redis缓存中没有此用户&quot;);</span></span><br><span class="line"><span class="comment">        student = studentMapper.findStudentById(studentId);</span></span><br><span class="line"><span class="comment">        if (student == null) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;Mysql中也没有此用户&quot;);</span></span><br><span class="line"><span class="comment">            //缓存穿透修改，把空对象写入redis，保存查询的studentId为查询使用的</span></span><br><span class="line"><span class="comment">            Student s = new Student();</span></span><br><span class="line"><span class="comment">            s.setStudentId(studentId);</span></span><br><span class="line"><span class="comment">            saveToRedis(s);</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;Mysql中查询到此用户&quot;);</span></span><br><span class="line"><span class="comment">            saveToRedis(student);//保存到Redis</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return student;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">findStudentById</span><span class="params">(String studentId)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.从Redis缓存中查询数据</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> getStudentByRedis(studentId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.Redis中有该用户就返回</span></span><br><span class="line">        <span class="keyword">if</span> (student != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Redis缓存中查询到该用户&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.Redis中没有找到，到MySQL中查询后加redis</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Redis缓存中没有此用户&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//①准备互斥锁的key</span></span><br><span class="line">        <span class="comment">//这里就单机测试没有并发，不会出现lock:student:的这种key，需要高并发情况下同时执行这段代码才会出现</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:student:&quot;</span> + studentId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//②调用addLock获取锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> addLock(lockKey);</span><br><span class="line">            <span class="comment">//判断锁是否获取成功，这里判断加锁失败则休眠，然后再次执行该方法</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="comment">//③休眠50毫秒后递归调用该方法，重新查询redis</span></span><br><span class="line">                <span class="keyword">return</span> findStudentById(studentId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Redis申请锁成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//④如果成功加上了锁，就要查询redis缓存中是否有该数据，因为可能有其他应用已经重建了该数据的缓存</span></span><br><span class="line">            <span class="keyword">if</span> (getStudentByRedis(studentId) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;再次查询时，Redis缓存中查询到了此用户&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> getStudentByRedis(studentId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//⑤这里表示两次查询Redis都没有查询到数据就要到MySQL中查询，重建缓存，如果MySQL中也没有就写入空对象</span></span><br><span class="line">            <span class="comment">//写入空对象是防止缓存穿透</span></span><br><span class="line">            student = studentMapper.findStudentById(studentId);</span><br><span class="line">            <span class="keyword">if</span> (student == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Mysql中也没有此用户&quot;</span>);</span><br><span class="line">                <span class="comment">//缓存穿透修改，把空对象写入redis，保存查询的studentId为查询使用的</span></span><br><span class="line">                <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">                s.setStudentId(studentId);</span><br><span class="line">                saveToRedis(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Mysql中查询到此用户&quot;</span>);</span><br><span class="line">                saveToRedis(student);<span class="comment">//保存到Redis</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//⑥删除锁</span></span><br><span class="line">            unLock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里演示通过加互斥锁的方式处理缓存击穿问题</span></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">//将存在的键的值设置为1，不存在就设置过期时间为10s</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">        <span class="comment">/*BooleanUtil 是 Hutool 工具库（HuTool）提供的一个工具类，用于处理布尔值。</span></span><br><span class="line"><span class="comment">          在Java 中，Boolean 类型是一个对象，可以为 null。而 boolean 基本类型则不能为 null。</span></span><br><span class="line"><span class="comment">          使用 BooleanUtil.isTrue(flag) 可以确保在处理 Boolean 对象时不会因为 null 而产生空指针异常。*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁，删除key就是释放锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据、更新数据需要开启事物进行一致性处理，这里的方案是先更新数据库数据再删除缓存</span></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">//开启事务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">updateStudentNameById</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">studentId</span> <span class="operator">=</span> student.getStudentId();</span><br><span class="line">        <span class="keyword">if</span> (studentId != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先更新数据库数据</span></span><br><span class="line">            studentMapper.updateStudentNameById(student);</span><br><span class="line">            <span class="comment">//删除缓存</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;student:&quot;</span> + studentId;</span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;修改成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从Redis中查询</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStudentByRedis</span><span class="params">(String studentId)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;student:&quot;</span> + studentId;</span><br><span class="line">        <span class="keyword">if</span> (redisTemplate.hasKey(key)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> (Integer) redisTemplate.opsForHash().get(key, <span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) redisTemplate.opsForHash().get(key, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">            student = <span class="keyword">new</span> <span class="title class_">Student</span>(id, name, studentId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里进行了防止缓存雪崩的简单修改，这里使用随机数设置一个随机的key的有效期</span></span><br><span class="line">    <span class="comment">//将查询到的数据加入到Redis</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveToRedis</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="comment">//设置key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;student:&quot;</span> + student.getStudentId();</span><br><span class="line">        <span class="comment">//设置值</span></span><br><span class="line">        redisTemplate.opsForHash().put(key, <span class="string">&quot;id&quot;</span>, student.getId());</span><br><span class="line">        redisTemplate.opsForHash().put(key, <span class="string">&quot;name&quot;</span>, student.getName());</span><br><span class="line">        redisTemplate.opsForHash().put(key, <span class="string">&quot;studentId&quot;</span>, student.getStudentId());</span><br><span class="line">        <span class="comment">//设置键的过期时间</span></span><br><span class="line">        <span class="comment">//redisTemplate.expire(key, 360, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="comment">//设置随机的key有效期，上面一行是没有设置随机</span></span><br><span class="line">        redisTemplate.expire(key, <span class="number">360</span> + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>), TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 缓存穿透是指在使用Redis作为缓存应用时,客户端请求的数据在Redis缓存中和Mysql数据库中都不存在,缓存不生效。</span></span><br><span class="line"><span class="comment">但是针对该数据的请求还是源源不断的过来,导致每次请求都会到数据库，从而压垮数据库。</span></span><br><span class="line"><span class="comment">2. 缓存雪崩是指在同一时段，Redis中的缓存 key 大面积同时失效，或者Redis服务宕机,导致大量的数据请求直接面向 MySQL 数据库，</span></span><br><span class="line"><span class="comment">给数据库造成巨大压力，可能带来灾难性的问题。</span></span><br><span class="line"><span class="comment">3. 缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li><strong>controller层</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.week10_redis_20211003238.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.week10_redis_20211003238.pojo.Student;</span><br><span class="line"><span class="keyword">import</span> com.example.week10_redis_20211003238.service.StudentService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentController</span><span class="params">(StudentService studentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.studentService = studentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*增加信息*/</span></span><br><span class="line">    <span class="comment">//URL:http://localhost:8080/addStudent</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;addStudent&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setName(<span class="string">&quot;王骏飚&quot;</span>);</span><br><span class="line">        student.setStudentId(<span class="string">&quot;20211003238&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> studentService.addStudent(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除信息*/</span></span><br><span class="line">    <span class="comment">//URL:http://localhost:8080/deleteStudentById</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;deleteStudentById&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteStudentById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">studentId</span> <span class="operator">=</span> <span class="string">&quot;20211003238&quot;</span>;</span><br><span class="line">        System.out.println(studentService.deleteStudentById(studentId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*查找信息*/</span></span><br><span class="line">    <span class="comment">//URL:http://localhost:8080/findStudentById</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findStudentById&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">findStudentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">studentId</span> <span class="operator">=</span> <span class="string">&quot;20211003238&quot;</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentService.findStudentById(studentId);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*修改信息*/</span></span><br><span class="line">    <span class="comment">//URL:http://localhost:8080/updateStudentNameById</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;updateStudentNameById&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStudentNameById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setName(<span class="string">&quot;王骏飚1&quot;</span>);</span><br><span class="line">        student.setStudentId(<span class="string">&quot;20211003238&quot;</span>);</span><br><span class="line">        System.out.println(studentService.updateStudentNameById(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取所有用户*/</span></span><br><span class="line">    <span class="comment">//URL:http://localhost:8080/getAllStudents</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;getAllStudents&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAllStudents</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Student&gt; list = studentService.getAllStudents();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*测试集群，运行后从cmd查看有没有对应的key*/</span></span><br><span class="line">    <span class="comment">//URL:http://localhost:8080/findStudentTestCluster</span></span><br><span class="line">    <span class="comment">//数据库中已经存在小明，小红，小王数据了，这里查找加到缓存中来测试集群是否生效</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;findStudentTestCluster&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findStudentTestCluster</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">//小明 111；小红 222；小王333</span></span><br><span class="line">        studentService.findStudentById(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        studentService.findStudentById(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        studentService.findStudentById(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>这里解决缓存雪崩介绍了缓存预热怎么做，具体做法没有实现，就是把框架搭出来，需要怎么预热自己再写，写在了cache下的RedisWarmUp类中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.week10_redis_20211003238.cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis缓存预热：实现ApplicationRunner接口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//@Component是一个通用性注解，用于表示一个类是Spring容器中的一个组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisWarmUp</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;缓存数据开始预热....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//之后可以使用RedisTemplate将一些数据先加入到缓存之中，再结束预热</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>修改Application入口代码，加上注解即可</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.example.week10_redis_20211003238;</span><br><span class="line"></span><br><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(basePackages = &quot;com.example.week10_redis_20211003238.mapper&quot;)</span><br><span class="line">public class Week10Redis20211003238Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Week10Redis20211003238Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之后可以运行起来，再浏览器测试controller中的代码</li></ul><h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><p><a href="https://blog.csdn.net/wstever/article/details/128469318">【好物推荐】性能测试之压力测试，如何使用Jmeter来压测接口？_jmeter接口压测_本本本添哥的博客-CSDN博客</a></p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><strong>社区版本安装</strong></li></ul><ol><li>下载安装包并进行安装</li></ol><p><a href="https://www.mongodb.com/try/download/community">MongoDB社区版下载地址</a></p><p>安装过程可以选择data和log的存放路径，安装程序还是会安装到默认路径，所以安装时还是直接用默认路径吧，bin目录在<code>C:\Program Files\MongoDB\Server\7.0\bin</code>，并且为了方便，安装时直接选择<code>Complete</code>选项安装所有组件吧。</p><ul><li>mongod.exe：启动数据库服务器实例进程的可执行文件，是整个 MongoDB中最核心的内容，可进行复制数据库的创建、删除等管理工作，运行在服务器端为客户端提供监听；</li><li>mongos.exe：分片集群的控制器和查询路由器；</li><li>mongod.conf：系统配置文件。</li></ul><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241241528.png" alt="image-20231122111630916"></p><ol start="2"><li>配置环境变量</li></ol><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241241708.png" alt="image-20231128203035119"></p><p>配置好环境后可以输入<code>mongod --version</code>就可以查看到MongoDB的版本</p><ol start="3"><li>之后启动服务就好，MongoDB默认端口为27017，可以在浏览器输入<code>http://localhost:27017/</code>,有响应就说明服务已启动，也可以在系统服务界面找到服务。</li></ol><ul><li><strong>进行一些配置</strong></li></ul><p>在默认情况下，MongoDB中创建的数据库文件会存储在<code>C:\Program Files\MongoDB\Server\7.0\data</code>路径下，实际开发中需要我们指定存放的路径，下面给出具体的配置方式。</p><ol><li><p>创建存放数据库文件和日志文件的文件夹，一个文件夹为data，一个文件夹为log，具体创建在哪里视自己情况来定吗，路径不能带中文</p></li><li><p>修改配置文件，7.0版本配置文件在bin目录下，名为<code>mongod.cfg</code>，<strong>注意这里log的写法，这里我的log文件在mongodb路径下，后面加上<code>\mongod.log</code></strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241241541.png" alt="image-20231128212905044"></p></li><li><p>重启服务器生效</p></li></ol><p>无法启动检查路径是否为英文，还是不行可以以管理员打开cmd或者powershell窗口下输入<code>sc delete MongoDB</code>删除原有服务，之后输入<code> mongod --install -f &quot;C:\Program Files\MongoDB\Server\7.0\bin\mongod.cfg&quot;</code>重新安装配置文件，之后点击启动即可</p><ul><li><strong>安装MongoDB Shell工具</strong></li></ul><p>早期的MongoDB版本中自带这个工具，在当前7.0版本中不包含该工具，需要另外下载，MongoDB Shell工具是MongoDB服务器常用客户端访问工具</p><ol><li>下载MongoDB Shell工具</li></ol><p><a href="https://www.mongodb.com/try/download/compass">MongoDB Shell下载地址</a></p><p>下载压缩文件即可，安装程序也是安装到跟Mongo服务器的默认路径一样，将压缩文件放到跟Mongo服务器的默认路径下，这样好找，路径为<code>C:\Program Files\MongoDB\Server\7.0\bin</code>，之后解压</p><ol start="2"><li>配置环境</li></ol><p>将解压后的文件中的bin目录也加入到环境变量中，相关路径在上面服务器的环境变量配置中框起来的下一条就是了，这里不另外截图了。配置环境后在命令行输入<code>mongosh</code>可以连接到服务器</p><ul><li><strong>安装MongoDB Compass</strong></li></ul><p>MongoDB Compass是官方提供的图形界面，在安装server时可以直接选择安装，也可以单独安装</p><ul><li><strong>Docker中安装MongoDB</strong></li></ul><ol><li>拉取MongoDB的镜像</li></ol><p><code>docker pull mongo</code> <strong>记得先开启Docker</strong></p><ol start="2"><li>查看下载的镜像</li></ol><p><code>docker images</code></p><ol start="3"><li>启动一个MongoDB服务器容器</li></ol><p><code>docker run -d --name mongodb -p 27017:27017 --privileged=true -v /d/mongodb/data:/data/db mongo</code> <strong>这里将数据卷挂载在本地的<code>D:/mongodb/data</code></strong></p><ol start="4"><li>之后可以通过shell工具连接服务器容器</li></ol><h3 id="MongoDB简单操作"><a href="#MongoDB简单操作" class="headerlink" title="MongoDB简单操作"></a>MongoDB简单操作</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><h4 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h4><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h3 id="MongoDB备份和恢复"><a href="#MongoDB备份和恢复" class="headerlink" title="MongoDB备份和恢复"></a>MongoDB备份和恢复</h3><h3 id="MongoDB复制集"><a href="#MongoDB复制集" class="headerlink" title="MongoDB复制集"></a>MongoDB复制集</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p><strong>相关概念</strong></p><p>为了提高系统的高可用，MongoDB 提供了数据复制功能。MongoDB 支持两种数据复制功能：传统的主从复制和副本集&#x2F;复制集。<strong>副本集在传统主从复制的基础上，支持故障自动恢复功能，提供了更好的可用性，也是 MongoDB 官方推荐的集群部署方式。</strong></p><p>副本集（Replica Set）是一组 MongoDB 实例保持其相同数据集的集群，即由一个主（Primary）服务器和多个副本（Secondary）服务器构成。通过复制（Replication）将数据的更新由主服务器推送到其它副本服务器上，实现每个 MongoDB 实例维护相同的数据集副本。</p><p><strong>功能</strong></p><ul><li>数据备份</li><li>读写分离</li><li>自动故障转移</li></ul><p><strong>构成</strong></p><ul><li><p>主节点(Primary)</p><p><strong>主节点</strong>是副本集中负责处理客户端请求和读写数据主要成员。主节点通过 <strong>oplog</strong>（操作日志）记录所有操作。副本集中有且只有一个主节点，如果当前主节点不可用，则会从副本节点中选举出新的主节点。</p></li><li><p>副本节点(Secondary)</p><p><strong>副本节点</strong>定期轮询主节点获取 <strong>oplog</strong> 记录的操作内容，然后对自己的数据副本执行这些操作，从而保证副本节点的数据副本与主节点保持一致。副本集中可以有一个或多个副本节点。当主节点宕机时，副本集会根据优先级等参数选举出新的主节点。</p></li><li><p>仲裁节点(Arbiter)</p><p><strong>仲裁节点</strong>不存储数据，只是负责通过心跳包来确认集群中节点的数量，并在主服务器选举的时候作为仲裁决定结果。仲裁节点需要的资源很小。<strong>当副本集中节点个数为偶数时，建议添加一个仲裁节点，防止选举新的主节点过程中出现票数一致，导致无法选举出新的主节点。</strong></p></li></ul><p><strong>默认配置</strong></p><p>主节点负责处理所有的写入请求；主节点（默认）和副节点都可以处理读取请求；副节点从主节点（或符合条件的副节点）处复制数据；</p><p>每个节点都会向其它节点发送心跳请求；每隔 2 秒发送一次，超过 10 秒则请求超时（默认）；副本集中最多可以有 50 个节点。</p><p><strong>选举</strong></p><p>主节点与副节点之间的心跳请求超时、复制集初始化、新节点加入复制集会触发选举事件。</p><p>副本集通过 <strong>replSetInitiate</strong> 命令（或 mongo shell 的 **rs.initiate()**）进行初始化。初始化后，各个成员之间开始发送心跳消息，并发起 Priamry 节点的选举操作。获得大多数成员投票支持的节点，会成为 Primary 节点，其余节点成为Secondary 节点。假设复制集内投票成员数量为 N，则大多数为 N&#x2F;2 + 1，当复制集内存活成员数量不足大多数时，整个复制集将无法选举出 Primary，复制集将无法提供写服务，处于只读状态。</p><p>被选举为主节点的节点必须能够与多数节点建立连接、具有较新的 oplog、具有较高的优先级（如果有配置）</p><h4 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h4><ol><li><p>创建三个容器</p><p>下面可以将数据卷更改成为自己需要保存的位置，其中<code>--replSet &quot;rs0&quot;</code>指定副本集的名称为<code>rs0</code>，<code>--bind_ip_all</code>表示允许所有IP连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run  -d --name mongo_1 -p 27018:27017 --privileged=true -v /d/mongodb/replicaSet/mongo_1:/data/db mongo --replSet &quot;rs0&quot; --bind_ip_all</span><br><span class="line"></span><br><span class="line">docker run  -d --name mongo_2 -p 27019:27017 --privileged=true -v /d/mongodb/replicaSet/mongo_2:/data/db mongo --replSet &quot;rs0&quot; --bind_ip_all</span><br><span class="line"></span><br><span class="line">docker run  -d --name mongo_3 -p 27020:27017 --privileged=true -v /d/mongodb/replicaSet/mongo_3:/data/db mongo --replSet &quot;rs0&quot; --bind_ip_all</span><br></pre></td></tr></table></figure><p><code>docker ps</code>查看存在容器</p></li><li><p>初始化副本集</p><p>初始化副本集，通过<code>rs.initiate()</code>选举出主节点，首先需要知道自己本机的IP地址，然后将下面的的IP地址更改成为本机的IP地址即可在cmd窗口连接，或者在docker可视化软件进行操作，这里我的IP是<code>192.168.3.226</code></p><p>通过<code>mongosh 192.168.3.226:27018</code>连接其中任何一个mongo服务器即可，然后执行下面命令初始化主节点（注意IP），返回<code>&#123;ok:1&#125;</code>表示创建成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate( &#123;</span><br><span class="line">_id : &quot;rs0&quot;,</span><br><span class="line">members: [</span><br><span class="line">&#123; _id: 0, host: &quot;192.168.3.226:27018&quot; &#125;,</span><br><span class="line">&#123; _id: 1, host: &quot;192.168.3.226:27019&quot; &#125;,</span><br><span class="line">&#123; _id: 2, host: &quot;192.168.3.226:27020&quot; &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>​<code>rs.conf()</code> 查看副本集配置信息</p><p>​<code>rs.status()</code> 查看副本集状态，可以看到哪个节点是主节点</p><ol start="3"><li><p>这里副本集就搭建完成了，可以进行数据同步验证</p><ul><li><p>首先在主节点插入数据<code>db.user.insert(&#123;&quot;id&quot;:1001,&quot;name&quot;:&quot;zhangsan&quot;&#125;)</code></p></li><li><p>然后可以在主节点查询数据（新开一个cmd窗口连接到另外一个从节点服务器执行下面查询）<code>db.user.find()</code>，这时会发现默认情况下从节点不允许读写操作，需要在连接的<strong>从节点</strong>执行<code>db.getMongo().setReadPref(&quot;secondary&quot;)</code>命令，这是再查询就可以查询到数据了</p></li></ul></li><li><p>下面也可以进行读写分离实验，这个比较简单，在从节点执行写操作会发现不允许进行，只允许在主节点进行写操作</p></li><li><p>故障自动转移实验：</p><p>首先在docker可视化界面中手动暂停主节点服务器，然后在从节点通过<code>rs.status()</code>可以发现集群选举出了新的主节点，进行了故障转移。重新启动旧的主节点会自动变成从节点。</p></li></ol><h4 id="加入仲裁节点"><a href="#加入仲裁节点" class="headerlink" title="加入仲裁节点"></a>加入仲裁节点</h4><ol><li>新建一个节点容器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create --name mongo04 -p 27021:27017 -v mongo-data-04:/data/db mongo:4 --replSet &quot;rs0&quot; --bind_ip_all</span><br></pre></td></tr></table></figure><ol start="2"><li>重新配置副本集的写关注</li></ol><p>在副本集中，WriteConcern（写关注）配置是决定一个写操作落到多少个节点上才算是成功的参数。WriterConcern 的取值包括：</p><ul><li>0：发起写操作，不关心是否成功</li><li>1：默认值，primary 节点完成写操作, 就可以返回确认写成功的消息</li><li>n：表示写操作需要被复制到指定节点数才算成功</li><li>majority：写操作需要被复制到大多数节点上才算成功</li></ul><p>由于在副本集中，添加了仲裁节点，可能会导致默认 WriterConcern 发生改变，所以需要再配置一下 setDefaultRWConcern 的内容。</p><p>在复制集中的一个节点输入下面命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.adminCommand(&#123;</span><br><span class="line"> &quot;setDefaultRWConcern&quot; : 1,</span><br><span class="line"> &quot;defaultWriteConcern&quot; : &#123;</span><br><span class="line"> &quot;w&quot; : &quot;majority&quot;</span><br><span class="line"> &#125;&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>将仲裁节点接入复集<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.addArb(&quot;192.168.3.226:27021&quot;)</span><br></pre></td></tr></table></figure></li></ol><p>之后可以通过<code>rs.status()</code>查询复制集信息</p><h3 id="MongoDB分片集群"><a href="#MongoDB分片集群" class="headerlink" title="MongoDB分片集群"></a>MongoDB分片集群</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><p><strong>相关概念</strong></p><p>MongoDB 分片是 MongoDB 支持的另一种集群形式，它可以满足 MongoDB 数据量呈爆发式增长的需求。当 MongoDB 存储海量的数据时，一台服务器可能无法满足数据存储的需求，就可以通过在多台机器上对海量数据进行划分（即分片），使得 MongoDB 数据库系统能够存储和处理更多的数据。</p><p>MongoDB 数据库提供了数据自动分片功能，它内置了多种分片逻辑，使得 MongoDB可以自动处理分片数据，也可以很容易的管理分片集群。</p><p><strong>构成</strong></p><ul><li>分片服务器（Mongod&#x2F;Shard）</li></ul><p>即 MongoDB 实例（<strong>mongod</strong>，用 <strong>Shard</strong> 表示）。分片服务器是<strong>实际存储数据</strong>的组件，持有完整数据集中的一部分。每个分片服务器都可以是一个 MongoDB 实例，也可是一组MongoDB 实例组成的集群（副本集）。从 MongoDB 3.6 开始，必须将<strong>分片部署为副本集</strong>，这样具有更好的容错性。</p><ul><li>路由服务器（Mongos）</li></ul><p>即 <strong>Mongos</strong>。路由服务器主要提供<strong>客户端应用程序</strong>与<strong>分片集群</strong>交互的接口，所有请求都需要通过路由服务器进行协调工作。<strong>Mongos 实际上就是一个消息分发请求中心</strong>，它负责把客户端应用程序对应的数据请求转发到对应的分片服务器上。应用程序将查询、存储、更新等请求原封不动地发送给 <strong>Mongos</strong>, <strong>Mongos</strong> 询问配置服务器操作分片服务器需要获取哪些元数据，然后连接相应的分片服务器进行相关操作，最后将各个分片服务器的响应进行合并，返回给客户端应用程序。生产环境中，一个分片集群通常会有<strong>多个</strong>路由服务器，一方面可以解决多个客户端同时请求，从而达到负载均衡的效果；另一方面可以解决当路由服务器宕机时导致整个分片集群无法使用的问题。</p><ul><li>配置服务器（Config Server）</li></ul><p>即 <strong>Config Server</strong>。它存储了分片集群的<strong>元数据</strong>（如，每个集群上有多少分片，数据存储范围等信息），存储了集群的认证和授权配置，这些数据是不允许丢失的。因此，在生产环境中，通常需要配置多个配置服务器以防止数据丢失。从 MongoDB 3.4 版本开始，配置服务器必须部署副本集，因此一般需要配置<strong>三个配置服务器</strong>组成的副本集。配置服务器存储着分片集群的<strong>持久化元数据</strong>，而路由服务器存储着分片集群的<strong>非持久化元数据</strong>，这些数据均为内存缓存的数据。当路由服务器初次启动或关闭重启时，就会从配置服务器中加载分片集群的元数据。若是配置服务器的信息发生变化，则会通知所有路由服务器更新自己的状态，这样路由服务器就能继续准确的协调客户端与分片集群的交互工作。</p><p><img src="https://img-blog.csdnimg.cn/61111f5f17fe40a6ab627711d5f5ad20.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bm_5rW3X-Wwj-eWr-eWr-S4tg==,size_18,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>从上图可以看出，</strong>每个分片存储一部分数据，需要部署为复制集；mongos 路由可以将客户请求发送至相关的分片，同时与配置服务器通信，一般部署多台；配置服务器保存集群配置和元数据，需要部署为复制集。</p><p><strong>分片优点</strong></p><ul><li>对集群进行抽象，让集群“不可见”</li></ul><p>Mongos 就是掌握统一路口的路由器，其会将客户端发来的请求准确无误的路由到集群中的一个或者一组服务器上，同时会把接收到的响应拼装起来发回到客户端。</p><ul><li>保证集群总是可读写</li></ul><p>MongoDB 通过多种方法来确保集群的可用性和可靠性。如，将 MongoDB 的分片和副本集功能结合使用，在确保数据分片到多台服务器的同时，也确保了每分数据都有相应的备份，这样就可以确保有服务器宕机时，其他的从节点可以立即接替工作。</p><ul><li>使集群易于扩展</li></ul><p>当系统需要更多的空间和资源的时候，可以按需方便的扩充系统容量。</p><p><strong>一般分片步骤</strong></p><ul><li>分析数据库中的哪些集合的数据，需要进行分片存储；</li><li>指定每个集合的<strong>分片键（Shard Key），</strong>分片键可以是集合文档中的一个或多个字段；</li><li>制定分片策略，如是范围分片还是哈希分片；</li><li><strong>分片键</strong>会将集合数据划分为多个<strong>块</strong>（<strong>Chunk</strong>）（默认大小为 <strong>64MB</strong>，每个块均表示集合中数据的一部分）；</li><li>MongoDB 根据分片策略和分片键，将划分的<strong>块</strong>分发到分片集群中。</li></ul><p><strong>内置分片策略</strong></p><ul><li>范围分片</li></ul><p><img src="https://img-blog.csdnimg.cn/a008e55d39694e3ab2fb84202fe42988.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bm_5rW3X-Wwj-eWr-eWr-S4tg==,size_19,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/ef3de502c08341c1b0bfd032fcbe2184.png"></p><ul><li>哈希分片</li></ul><p><img src="https://img-blog.csdnimg.cn/5c5c0d4001f2470db58eecf975630e96.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bm_5rW3X-Wwj-eWr-eWr-S4tg==,size_17,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/28240878f44240d0b46fafba84fdf043.png"></p><p><strong>分片键的选择</strong></p><p>MongoDB 分片集群中，分片键的选择很重要。分片键的选择标准包括：</p><ul><li>分片键值的取值范围大，或称基数大（如使用布尔值做片键就不合适）；</li><li>分片键值的取值分布较均衡，取值不要集中在某一个范围内；</li><li>分片键值不要单向增大或减小，以防产生数据不均衡；</li><li>分片键值要方便查询；</li></ul><p>在实际选择分片键时，可以使用 hash 运算，增加分片键值的随机性；可以使用复合片键，扩大键值的取值基数。</p><p><strong>分片集群数据库的分裂</strong></p><p>数据块 <strong>chunk</strong></p><p>在一个分片节点中，MongoDB 会根据<strong>分片键</strong>，将集合数据划分为多个<strong>块</strong>（<strong>Chunk</strong>）。系统初始时产生 1 个 chunk，每个 chunk 默认大小为 <strong>64MB</strong>，存储了集合中一部分数据。chunk 的产生，有以下两个用途：</p><ul><li><p><strong>分裂 Splitting</strong>：当一个 chunk 的大小超过配置中的 chunk size 时，MongoDB 的后台进程会自动把这个 chunk 切分成更小的 chunk，从而避免chunk 过大；</p></li><li><p><strong>均衡 Balancing：</strong>在 MongoDB 中，balancer 是一个后台进程，会负责监视和调整集群的平衡，负责 chunk 的迁移，从而均衡各个分片节点的负载。</p></li></ul><h4 id="搭建-1"><a href="#搭建-1" class="headerlink" title="搭建"></a>搭建</h4><h5 id="1-首先需要了解结构"><a href="#1-首先需要了解结构" class="headerlink" title="1. 首先需要了解结构"></a>1. 首先需要了解结构</h5><p>这里共需要11个节点，3 个 Config Server 节点构成的副本集，2 个 shard 集群。每个集群又是一个副本集，包括 1 主 1 从和 1 个仲裁节点，2 个 mongos 节点，具体的配置文件可以下载实验材料找到具体内容找到</p><h5 id="2-搭建3个Config节点构成的副本集"><a href="#2-搭建3个Config节点构成的副本集" class="headerlink" title="2. 搭建3个Config节点构成的副本集"></a>2. 搭建3个Config节点构成的副本集</h5><p>这里有3个节点，分别为conf_1、conf_2、conf_3，IP都为本机回环地址127.0.0.1，端口号分别为17000、17001、17002，副本集名称为rs_conf，配置文件为mongo.cfg</p><p>配置文件主要参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 日志文件</span><br><span class="line">storage:</span><br><span class="line">  # mongod 进程存储数据目录，此配置仅对 mongod 进程有效</span><br><span class="line">  dbPath: /data/db</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /data/logs/mongo.log</span><br><span class="line"></span><br><span class="line">#  网络设置</span><br><span class="line">net:</span><br><span class="line">  port: 27017  #端口号</span><br><span class="line">  bindIp: 0.0.0.0    #绑定ip</span><br><span class="line">replication:</span><br><span class="line">  replSetName: rs_conf  #副本集名称</span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: configsvr # 集群角色，这里配置的角色是配置节点</span><br></pre></td></tr></table></figure><p><strong>执行命令创建3个config节点容器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name conf_01 -p 17000:27017 --privileged=true -v C:/mongodb/docker/mongodb/cluster/conf/confServ:/data/configdb -v C:/mongodb/docker/mongodb/cluster/data/conf_01:/data/db -v C:/mongodb/docker/mongodb/cluster/logs/conf_01:/data/logs mongo --config /data/configdb/mongo.cfg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -d --name conf_02 -p 17001:27017 --privileged=true -v C:/mongodb/docker/mongodb/cluster/conf/confServ:/data/configdb -v C:/mongodb/docker/mongodb/cluster/data/conf_02:/data/db -v C:/mongodb/docker/mongodb/cluster/logs/conf_02:/data/logs mongo --config /data/configdb/mongo.cfg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -d --name conf_03 -p 17002:27017 --privileged=true -v C:/mongodb/docker/mongodb/cluster/conf/confServ:/data/configdb -v C:/mongodb/docker/mongodb/cluster/data/conf_03:/data/db -v C:/mongodb/docker/mongodb/cluster/logs/conf_03:/data/logs mongo --config /data/configdb/mongo.cfg</span><br></pre></td></tr></table></figure><p><strong>副本集初始化</strong></p><p>连接170000节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongosh 127.0.0.1:17000</span><br></pre></td></tr></table></figure><p>输入命令初始化，注意IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate(</span><br><span class="line">&#123;</span><br><span class="line">_id: &quot;rs_conf&quot;,</span><br><span class="line">configsvr: true,</span><br><span class="line">members: [</span><br><span class="line">&#123; _id : 0, host : &quot;192.168.3.226:17000&quot; &#125;,</span><br><span class="line">&#123; _id : 1, host : &quot;192.168.3.226:17001&quot; &#125;,</span><br><span class="line">&#123; _id : 2, host : &quot;192.168.3.226:17002&quot; &#125;</span><br><span class="line">]&#125;)</span><br></pre></td></tr></table></figure><p>输入<code>rs.status()</code>查看Config server 集群信息</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161831512.png" alt="image-20231216162616759"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161831534.png" alt="image-20231216163416070"></p><h5 id="3-创建2个shard集群"><a href="#3-创建2个shard集群" class="headerlink" title="3. 创建2个shard集群"></a>3. 创建2个shard集群</h5><p>集群1</p><p>集群1有3个节点，分别为shardsvr_01、shardsvr_02 、shardsvr_03（仲裁节点），IP都为本机回环IP，端口号分别为27018、27019、27020，副本集的名称为rs_shard01 、配置文件为mongo_1.cfg，配置文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 日志文件</span><br><span class="line">storage:</span><br><span class="line">  # mongod 进程存储数据目录，此配置仅对 mongod 进程有效</span><br><span class="line">  dbPath: /data/db</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /data/logs/mongo.log</span><br><span class="line"></span><br><span class="line">#  网络设置</span><br><span class="line">net:</span><br><span class="line">  port: 27017  #端口号</span><br><span class="line">  bindIp: 0.0.0.0    #绑定ip</span><br><span class="line">replication:</span><br><span class="line">  replSetName: rs_shard01  #副本集名称</span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: shardsvr # 集群角色，这里配置的角色是shard节点</span><br></pre></td></tr></table></figure><p>集群2</p><p>集群1有3个节点，分别为shardsvr_04、shardsvr_05 、shardsvr_06（仲裁节点），IP都为本机回环IP，端口号分别为27021、27022、27023，副本集的名称为rs_shard02 、配置文件为mongo_2.cfg，配置文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 日志文件</span><br><span class="line">storage:</span><br><span class="line">  # mongod 进程存储数据目录，此配置仅对 mongod 进程有效</span><br><span class="line">  dbPath: /data/db</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /data/logs/mongo.log</span><br><span class="line"></span><br><span class="line">#  网络设置</span><br><span class="line">net:</span><br><span class="line">  port: 27017  #端口号</span><br><span class="line">  bindIp: 0.0.0.0    #绑定ip</span><br><span class="line">replication:</span><br><span class="line">  replSetName: rs_shard02  #副本集名称</span><br><span class="line">sharding:</span><br><span class="line">  clusterRole: shardsvr # 集群角色，这里配置的角色是shard节点</span><br></pre></td></tr></table></figure><p><strong>创建rs_shard01 集群</strong></p><p>创建容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name shardsvr_01 -p 27018:27017 --privileged=true -v C:/mongodb/docker/mongodb/cluster/conf/shardServ:/data/configdb -v C:/mongodb/docker/mongodb/cluster/data/shardsvr_01:/data/db -v C:/mongodb/docker/mongodb/cluster/logs/shardsvr_01:/data/logs mongo --config /data/configdb/mongo_1.cfg</span><br><span class="line"></span><br><span class="line">docker run -d --name shardsvr_02 -p 27019:27017 --privileged=true -v C:/mongodb/docker/mongodb/cluster/conf/shardServ:/data/configdb -v C:/mongodb/docker/mongodb/cluster/data/shardsvr_02:/data/db -v C:/mongodb/docker/mongodb/cluster/logs/shardsvr_02:/data/logs mongo --config /data/configdb/mongo_1.cfg</span><br><span class="line"></span><br><span class="line">docker run -d --name shardsvr_03 -p 27020:27017 --privileged=true -v C:/mongodb/docker/mongodb/cluster/conf/shardServ:/data/configdb -v C:/mongodb/docker/mongodb/cluster/data/shardsvr_03:/data/db -v C:/mongodb/docker/mongodb/cluster/logs/shardsvr_03:/data/logs mongo --config /data/configdb/mongo_1.cfg</span><br></pre></td></tr></table></figure><p><code>mongosh 127.0.0.1:27018</code>进入服务器，然后输入下面命令初始化集群</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate( &#123;</span><br><span class="line">_id : &quot;rs_shard01&quot;,</span><br><span class="line">members: [</span><br><span class="line">&#123; _id: 0, host: &quot;192.168.3.226:27018&quot; &#125;,</span><br><span class="line">&#123; _id: 1, host: &quot;192.168.3.226:27019&quot; &#125;,</span><br><span class="line">&#123; _id: 2, host: &quot;192.168.3.226:27020&quot;,arbiterOnly:true  &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161831987.png" alt="image-20231216165017619"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161831283.png" alt="image-20231216165527784"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161831809.png" alt="image-20231216165620013"></p><p><strong>创建rs_shard02 集群</strong></p><p>创建容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name shardsvr_04 -p 27021:27017 --privileged=true -v C:/mongodb/docker/mongodb/cluster/conf/shardServ:/data/configdb -v C:/mongodb/docker/mongodb/cluster/data/shardsvr_04:/data/db -v C:/mongodb/docker/mongodb/cluster/logs/shardsvr_04:/data/logs mongo --config /data/configdb/mongo_2.cfg</span><br><span class="line"></span><br><span class="line">docker run -d --name shardsvr_05 -p 27022:27017 --privileged=true -v C:/mongodb/docker/mongodb/cluster/conf/shardServ:/data/configdb -v C:/mongodb/docker/mongodb/cluster/data/shardsvr_05:/data/db -v C:/mongodb/docker/mongodb/cluster/logs/shardsvr_05:/data/logs mongo --config /data/configdb/mongo_2.cfg</span><br><span class="line"></span><br><span class="line">docker run -d --name shardsvr_06 -p 27023:27017 --privileged=true -v C:/mongodb/docker/mongodb/cluster/conf/shardServ:/data/configdb -v C:/mongodb/docker/mongodb/cluster/data/shardsvr_06:/data/db -v C:/mongodb/docker/mongodb/cluster/logs/shardsvr_06:/data/logs mongo --config /data/configdb/mongo_2.cfg</span><br></pre></td></tr></table></figure><p><code>mongosh 127.0.0.1:27021</code>进入服务器，然后输入下面命令初始化集群</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate( &#123;</span><br><span class="line">_id : &quot;rs_shard02&quot;,</span><br><span class="line">members: [</span><br><span class="line">&#123; _id: 0, host: &quot;192.168.3.226:27021&quot; &#125;,</span><br><span class="line">&#123; _id: 1, host: &quot;192.168.3.226:27022&quot; &#125;,</span><br><span class="line">&#123; _id: 2, host: &quot;192.168.3.226:27023&quot;,arbiterOnly:true &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161831605.png" alt="image-20231216171848824"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161831262.png" alt="image-20231216171957847"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161831985.png" alt="image-20231216172149987"></p><h5 id="4-创建2个Mongos节点"><a href="#4-创建2个Mongos节点" class="headerlink" title="4. 创建2个Mongos节点"></a>4. 创建2个Mongos节点</h5><p>两个节点分别为mongos_01和mongos_02，IP都为本机回环地址，端口号分别为30001和30002，配置文件为mongo.cfg，配置文件内容如下<strong>（自己搭建的时候记得把配置文件的IP修改成自己的本机现在的实际IP）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 日志文件</span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: true</span><br><span class="line">  path: /data/logs/mongo.log</span><br><span class="line"></span><br><span class="line">#  网络设置</span><br><span class="line">net:</span><br><span class="line">  port: 27017  #端口号</span><br><span class="line">  bindIp: 0.0.0.0    #绑定ip</span><br><span class="line"></span><br><span class="line"># 配置分片，这里面配置的是需要读取的配置节点的信息</span><br><span class="line">sharding:</span><br><span class="line">  configDB: rs_conf/192.168.3.226:17000,192.168.3.226:17001,192.168.3.226:17002</span><br></pre></td></tr></table></figure><p><strong>创建2个容器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mongos_01 -p 30001:27017 --privileged=true  --entrypoint &quot;mongos&quot; -v C:/mongodb/docker/mongodb/cluster/conf/mongos:/data/configdb -v C:/mongodb/docker/mongodb/cluster/logs/mongos_01:/data/logs mongo --config /data/configdb/mongo.cfg</span><br><span class="line"></span><br><span class="line">docker run -d --name mongos_02 -p 30002:27017 --privileged=true  --entrypoint &quot;mongos&quot; -v C:/mongodb/docker/mongodb/cluster/conf/mongos:/data/configdb -v C:/mongodb/docker/mongodb/cluster/logs/mongos_02:/data/logs mongo --config /data/configdb/mongo.cfg</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161831014.png" alt="image-20231216173616436"></p><p><strong>在mongos_01节点添加2个shard 集群</strong></p><p><code>mongosh 127.0.0.1:30001</code>连接30001节点</p><p>然后输入下面命令配置WriteConcern 参数（如果需要）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.adminCommand(&#123;</span><br><span class="line"> &quot;setDefaultRWConcern&quot; : 1,</span><br><span class="line"> &quot;defaultWriteConcern&quot; : &#123;</span><br><span class="line"> &quot;w&quot; : &quot;majority&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161830067.png" alt="image-20231216174343377"></p><p><strong>在mongos_01中添加第一个shard 集群的节点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.addShard(&quot;rs_shard01/192.168.3.226:27018,192.168.3.226:27019,192.168.3.226:27020&quot;)</span><br></pre></td></tr></table></figure><p><strong>在mongos_01添加第二个shard 集群的节点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.addShard(&quot;rs_shard02/192.168.3.226:27021,192.168.3.226:27022,192.168.3.226:27023&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161830125.png" alt="image-20231216174731478"></p><p><strong>在mongos_02节点添加2个shard 集群</strong></p><p><code>mongosh 127.0.0.1:30002</code>连接30002节点</p><p><strong>在mongos_02中添加第一个shard 集群的节点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.addShard(&quot;rs_shard01/192.168.3.226:27018,192.168.3.226:27019,192.168.3.226:27020&quot;)</span><br></pre></td></tr></table></figure><p><strong>在mongos_02中添加第二个shard 集群的节点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.addShard(&quot;rs_shard02/192.168.3.226:27021,192.168.3.226:27022,192.168.3.226:27023&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161830816.png" alt="image-20231216175150714"></p><p><strong>查看分片集群状态</strong></p><p><code>sh.status()</code></p><p>也可以使用以下命令，查看特定分片的详细信息：<code>sh.status(shard 集群名字) </code>如：<code>sh.status(&#39;rs_shard01&#39;)</code></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="1-启用分片集群"><a href="#1-启用分片集群" class="headerlink" title="1. 启用分片集群"></a>1. 启用分片集群</h5><p><strong>连接到任意一个mongos节点</strong></p><p><code>mongosh 127.0.0.1:30002</code></p><p><strong>开启数据库的分片功能</strong></p><p>这里如要开启数据库study的分片功能</p><p><code>use study</code></p><p><code>sh.enableSharding(&quot;study&quot;)</code></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161830355.png" alt="image-20231216180133922"></p><h5 id="2-指定分片键和分片策略"><a href="#2-指定分片键和分片策略" class="headerlink" title="2. 指定分片键和分片策略"></a>2. 指定分片键和分片策略</h5><p>如下面的命令就是代表students集合按照_id的hash值进行分片，进行hash分片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.shardCollection(&quot;study.students&quot;, &#123;&quot;_id&quot;: &quot;hashed&quot; &#125;)</span><br></pre></td></tr></table></figure><p>如果需要使用其他键作为分片键，需要为它创建索引</p><ul><li><p><code>db.order.createIndex(&#123;&quot;id&quot;:1&#125;)</code> 用于范围分片策略</p></li><li><p><code>db.user.createIndex(&#123;id: &quot;hashed&quot;&#125;) </code>创建一个哈希索引，用于哈希分片策略</p></li></ul><h5 id="3-插入多条信息并进行查看"><a href="#3-插入多条信息并进行查看" class="headerlink" title="3. 插入多条信息并进行查看"></a>3. 插入多条信息并进行查看</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i = 1; i &lt;= 1000; i=i+1)&#123;</span><br><span class="line">db.students.insertOne(&#123;&#x27;id&#x27;:i , &#x27;ranking&#x27;: 100+i&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>db.stats()</code>查看数据库的基本信息</p><p><code>db.students.getShardDistribution()</code>查看分片集合中数据分布情况</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312161829629.jpg" alt="img"></p><h2 id="期末大作业（主题一）"><a href="#期末大作业（主题一）" class="headerlink" title="期末大作业（主题一）"></a>期末大作业（主题一）</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>首先需要先了解我的文件路径是如何的，我在<code>C</code>盘根目录创建了一个<code>examTest</code>文件夹，并在其中创建了<code>MySQL</code>和<code>Redis</code>两个文件夹，再<code>MySQL</code>文件夹下创建了<code>data</code>、<code>log</code>、<code>conf</code>文件夹，在<code>Redis</code>文件夹下创建了<code>data</code>、<code>conf</code>文件夹</p><p>出现docker端口没有权限等问题，可以先以管理员身份运行命令行窗口，然后输入<code>net stop winnat</code>停止服务，然后再输入<code>net start winnat</code>重启服务即可</p><h3 id="MySQL相关"><a href="#MySQL相关" class="headerlink" title="MySQL相关"></a>MySQL相关</h3><h4 id="1-创建MySQL容器"><a href="#1-创建MySQL容器" class="headerlink" title="1. 创建MySQL容器"></a>1. 创建MySQL容器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mysql_3307_exam -v C:/examTest/MySQL/log:/var/log/mysql -v C:/examTest/MySQL/data:/var/lib/mysql -v C:/examTest/MySQL/conf:/etc/mysql/conf.d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=wang10086 -d mysql --init-connect=&quot;SET collation_connection=utf8mb4_0900_ai_ci&quot; --init-connect=&quot;SET NAMES utf8mb4&quot; --skip-character-set-client-handshake</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241223326.png" alt="image-20231216215859408"></p><p><code>mysql -h 127.0.0.1 -P 3307 -u root -p</code>输入密码就可以进行连接</p><h4 id="2-创建数据库"><a href="#2-创建数据库" class="headerlink" title="2. 创建数据库"></a>2. 创建数据库</h4><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241223804.png" alt="image-20231216223118130"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -id --name mysql_3307_exam -p 3307:3306 mysql</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Redis创建集群"><a href="#Redis创建集群" class="headerlink" title="Redis创建集群"></a>Redis创建集群</h3><h4 id="1-创建容器"><a href="#1-创建容器" class="headerlink" title="1. 创建容器"></a>1. 创建容器</h4><p><strong>配置文件内容如下（IP修改为自己的本机IP）：</strong></p><p><strong>redis_exam_6380.conf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">port 6380</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6380.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"></span><br><span class="line">cluster-announce-ip 192.168.3.226</span><br><span class="line">cluster-announce-port 6380</span><br><span class="line">cluster-announce-bus-port 16380</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p><strong>redis_exam_6381.conf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">port 6381</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6381.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br><span class="line">cluster-announce-ip 192.168.3.226</span><br><span class="line">cluster-announce-port 6381</span><br><span class="line">cluster-announce-bus-port 16381</span><br></pre></td></tr></table></figure><p><strong>redis_exam_6382.conf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">port 6382</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6382.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br><span class="line">cluster-announce-ip 192.168.3.226</span><br><span class="line">cluster-announce-port 6382</span><br><span class="line">cluster-announce-bus-port 16382</span><br></pre></td></tr></table></figure><p><strong>redis_exam_26380.conf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">port 26380</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-26380.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br><span class="line">cluster-announce-ip 192.168.3.226</span><br><span class="line">cluster-announce-port 26380</span><br><span class="line">cluster-announce-bus-port 16383</span><br></pre></td></tr></table></figure><p><strong>redis_exam_26381.conf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">port 26381</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-26381.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br><span class="line">cluster-announce-ip 192.168.3.226</span><br><span class="line">cluster-announce-port 26381</span><br><span class="line">cluster-announce-bus-port 16384</span><br></pre></td></tr></table></figure><p><strong>redis_exam_26382.conf</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">port 26382</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-26382.conf</span><br><span class="line"></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br><span class="line">cluster-announce-ip 192.168.3.226</span><br><span class="line">cluster-announce-port 26382</span><br><span class="line">cluster-announce-bus-port 16385</span><br></pre></td></tr></table></figure><p><strong>命令行输入下面命令创建容器，并配置数据卷的位置和配置文件的位置，上面已经给出了每个配置文件的名字和内容，把配置文件放到自己的目录下后按照实际情况修改下面的路径</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis_exam_6380 -p 6380:6380 -p 16380:16380 --privileged=true -v C:/examTest/Redis/data/6380:/data -v C:/examTest/Redis/conf:/etc/redis redis redis-server /etc/redis/redis_exam_6380.conf</span><br><span class="line"></span><br><span class="line">docker run -d --name redis_exam_6381 -p 6381:6381 -p 16381:16381 --privileged=true -v C:/examTest/Redis/data/6381:/data -v C:/examTest/Redis/conf:/etc/redis redis redis-server /etc/redis/redis_exam_6381.conf</span><br><span class="line"></span><br><span class="line">docker run -d --name redis_exam_6382 -p 6382:6382 -p 16382:16382 --privileged=true -v C:/examTest/Redis/data/6382:/data -v C:/examTest/Redis/conf:/etc/redis redis redis-server /etc/redis/redis_exam_6382.conf</span><br><span class="line"></span><br><span class="line">docker run -d --name redis_exam_26380 -p 26380:26380 -p 16383:16383 --privileged=true -v C:/examTest/Redis/data/26380:/data -v C:/examTest/Redis/conf:/etc/redis redis redis-server /etc/redis/redis_exam_26380.conf</span><br><span class="line"></span><br><span class="line">docker run -d --name redis_exam_26381 -p 26381:26381 -p 16384:16384 --privileged=true -v C:/examTest/Redis/data/26381:/data -v C:/examTest/Redis/conf:/etc/redis redis redis-server /etc/redis/redis_exam_26381.conf</span><br><span class="line"></span><br><span class="line">docker run -d --name redis_exam_26382 -p 26382:26382 -p 16385:16385 --privileged=true -v C:/examTest/Redis/data/26382:/data -v C:/examTest/Redis/conf:/etc/redis redis redis-server /etc/redis/redis_exam_26382.conf</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312171145496.png" alt="image-20231217112809620"></p><h4 id="2-创建分片集群"><a href="#2-创建分片集群" class="headerlink" title="2. 创建分片集群"></a>2. 创建分片集群</h4><p>根据自己的IP进行修改，这里指定每个主节点的副本数量为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1. 进入一个容器,也可以在docker可视化界面进行操作</span><br><span class="line">docker exec -it redis_exam_6380 /bin/bash</span><br><span class="line"></span><br><span class="line">//2. 输入下面命令创建集群，记得修改IP为自己的IP</span><br><span class="line">redis-cli --cluster create 192.168.3.226:6380 192.168.3.226:6381 192.168.3.226:6382 192.168.3.226:26380 192.168.3.226:26381  192.168.3.226:26382  --cluster-replicas 1</span><br><span class="line"></span><br><span class="line">//3. 按照提示输入yes后等待即可</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312171145170.png" alt="image-20231217112852799"></p><p><code>cluster nodes</code>查看节点信息</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312171145082.png" alt="image-20231217113748109"></p><p><code>cluster info</code>查看集群信息</p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312171145144.png" alt="image-20231217113652619"></p><h4 id="3-分片集群测试"><a href="#3-分片集群测试" class="headerlink" title="3. 分片集群测试"></a>3. 分片集群测试</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis_exam_6380 /bin/bash</span><br><span class="line"></span><br><span class="line">redis-cli -c -p 6380</span><br><span class="line"></span><br><span class="line">docker exec -it redis_exam_26381 /bin/bash</span><br><span class="line"></span><br><span class="line">redis-cli -c -p 26381</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312171145186.png" alt="image-20231217114356281"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312171145493.png" alt="image-20231217114405610"></p><h3 id="系统功能模块的实现"><a href="#系统功能模块的实现" class="headerlink" title="系统功能模块的实现"></a>系统功能模块的实现</h3><h4 id="登录注册"><a href="#登录注册" class="headerlink" title="登录注册"></a>登录注册</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p><strong>Mapper</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241222554.png" alt="image-20231221232624286"></p><p><strong>Service</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241222927.png" alt="image-20231222182751185"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241222215.png" alt="image-20231221232744909"></p><p><strong>Controller</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241222808.png" alt="image-20231221232906012"></p><p><strong>Token</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241222679.png" alt="image-20231221232815864"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241222294.png" alt="image-20231221232826109"></p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p><strong>注册</strong></p><p><strong>注册成功</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241222546.png" alt="image-20231221232141276"></p><p><strong>数据库中</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241221865.png" alt="image-20231221232218134"></p><p><strong>不允许相同账号</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241221829.png" alt="image-20231221232055354"></p><p><strong>登录</strong></p><p><strong>登录成功返回token</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241221463.png" alt="image-20231221231923828"></p><p><strong>再一次登录删除旧token</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241221742.png" alt="image-20231221232015195"></p><p><strong>账号或密码错误，登录失败返回空</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241221744.png" alt="image-20231221232337228"></p><h4 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h4><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><p><strong>Mapper</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241221123.png" alt="image-20231222173729728"></p><p><strong>Service</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241221349.png" alt="image-20231222182632311"></p><p><strong>Controller</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241221543.png" alt="image-20231222173844493"></p><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><p><strong>token错误</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241221433.png" alt="image-20231222171523273"></p><p><strong>token过期</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241220628.png" alt="image-20231222171608200"></p><p><strong>更新成功</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241220154.png" alt="image-20231222173617250"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241220598.png" alt="image-20231222173629486"></p><h4 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h4><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><p><strong>Mapper</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241220946.png" alt="image-20231222111933524"></p><p><strong>Service</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241220603.png" alt="image-20231222112025074"></p><p><strong>Controller</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241220359.png" alt="image-20231222112324470"></p><h5 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h5><p><strong>反馈成功</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241220437.png" alt="image-20231222001031333"></p><p><strong>token过期</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241220501.png" alt="image-20231222111717267"></p><p><strong>token错误</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241220526.png" alt="image-20231222110112931"></p><p><strong>获取所有书本信息</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241219166.png" alt="image-20231222190118729"></p><p><strong>获取一本书</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241219785.png" alt="image-20231222190819895"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241219986.png" alt="image-20231222190804776"></p><h4 id="书籍信息"><a href="#书籍信息" class="headerlink" title="书籍信息"></a>书籍信息</h4><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><p><strong>Mapper</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241219233.png" alt="image-20231222190848610"></p><p><strong>Service</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241219645.png" alt="image-20231222191900463"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241219211.png" alt="image-20231222234345129"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241219817.png" alt="image-20231222191927165"></p><p><strong>Controller</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241219909.png" alt="image-20231222191940230"></p><h5 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h5><p><strong>不存在的</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241219769.png" alt="image-20231222183804597"></p><p><strong>Redis保存空白值</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241224507.png" alt="image-20231222183911718"></p><p><strong>查询到</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241218617.png" alt="image-20231222184404865"></p><h4 id="阅读信息"><a href="#阅读信息" class="headerlink" title="阅读信息"></a>阅读信息</h4><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><p><strong>Mapper</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241218417.png" alt="image-20231223172636078"></p><p><strong>Service</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241218219.png" alt="image-20231223172659640"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/image-20231223172726973.png" alt="image-20231223172726973"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241218066.png" alt="image-20231223172753182"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241218451.png" alt="image-20231223172826645"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241218669.png" alt="image-20231223172843143"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241218793.png" alt="image-20231223172855942"></p><p><strong>Controller</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241218709.png" alt="image-20231223222929566"></p><h5 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h5><p><strong>阅读人数</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241218480.png" alt="image-20231223160859728"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241217010.png" alt="image-20231223160918912"></p><p><strong>下载人数</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241217511.png" alt="image-20231223160946012"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241217690.png" alt="image-20231223161038043"></p><p><strong>点赞人数</strong></p><p><strong>身份过期</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241217447.png" alt="image-20231223161608218"></p><p><strong>收藏成功</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241217894.png" alt="image-20231223161950842"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241217987.png" alt="image-20231223165313274"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241217547.png" alt="image-20231223165413234"></p><p><strong>再次请求就是解除收藏</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241217951.png" alt="image-20231223164159348"></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241217190.png" alt="image-20231223165245891"></p><p><strong>token错误</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241216504.png" alt="image-20231223163636716"></p><p><strong>定时更新浏览数据到数据库</strong></p><p><img src="https://gitee.com/wuleizhenshang/person-typora-programming-pic/raw/master/img/202312241216272.png" alt="image-20231223172506002"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android学习笔记</title>
      <link href="/2022/02/24/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/24/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="安卓开发笔记"><a href="#安卓开发笔记" class="headerlink" title="安卓开发笔记"></a>安卓开发笔记</h1><h2 id="开发必做"><a href="#开发必做" class="headerlink" title="开发必做"></a>开发必做</h2><p><code>distributionUrl=https\://mirrors.cloud.tencent.com/gradle/gradle-7.3.3-bin.zip</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line"> </span><br><span class="line">    repositories &#123;</span><br><span class="line"> </span><br><span class="line">        maven &#123;</span><br><span class="line">            url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27;</span><br><span class="line">            allowInsecureProtocol = true</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &#x27;http://maven.aliyun.com/nexus/content/repositories/jcenter&#x27;</span><br><span class="line">            allowInsecureProtocol = true</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &#x27;http://maven.aliyun.com/nexus/content/repositories/google&#x27;</span><br><span class="line">            allowInsecureProtocol = true</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &#x27;http://maven.aliyun.com/nexus/content/repositories/gradle-plugin&#x27;</span><br><span class="line">            allowInsecureProtocol = true</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27;</span><br><span class="line">            allowInsecureProtocol = true</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &#x27;http://maven.aliyun.com/nexus/content/repositories/google&#x27;</span><br><span class="line">            allowInsecureProtocol = true</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &#x27;http://maven.aliyun.com/nexus/content/repositories/gradle-plugin&#x27;</span><br><span class="line">            allowInsecureProtocol = true</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        google()</span><br><span class="line">        jcenter() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin为</p><p><code>maven&#123; setUrl(&quot;http://maven.aliyun.com/nexus/content/groups/public/&quot;)&#125;</code></p><p>crtl + p 提示</p><p>ctrl +win+alt+L格式化整理代码</p><p>测试安装不了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.injected.testOnly=false</span><br></pre></td></tr></table></figure><p><img src="C:\Users\GTR\Desktop\43ee001766f0eb2d7ce42f7d72bd5a49.png"></p><p><strong>连接手机</strong></p><p>先在电脑<code>cmd</code>窗口<code>adb tcpip 5555</code>，再把手机置静态IP连接热点，之后<code>adb connect 192.168.137.66:5555</code></p><p>1、先确认Android设备开启开发者模式，并且开启USB调试；</p><p>2、确认Android设备和电脑处于同一局域网；</p><p>如果上述都确认还是出现 “由于目标计算机积极拒绝，无法连接。 (10061)” 这个问题，那就极有可能是端口被占用了：</p><p>（1）使用如下adb命令可以查看端口使用情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr 5037</span><br></pre></td></tr></table></figure><p> 如果出现以下情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TCP    127.0.0.1:5037         0.0.0.0:0              LISTENING       5596</span><br><span class="line">TCP    127.0.0.1:5037         127.0.0.1:49508        ESTABLISHED     5596</span><br><span class="line">TCP    127.0.0.1:5037         127.0.0.1:50671        TIME_WAIT       0</span><br><span class="line">TCP    127.0.0.1:5037         127.0.0.1:50672        TIME_WAIT       0</span><br><span class="line">TCP    127.0.0.1:5037         127.0.0.1:50673        TIME_WAIT       0</span><br></pre></td></tr></table></figure><p>从上面的 “TCP 127.0.0.1:5037 127.0.0.1:49508 ESTABLISHED 5596” 可以看出进程5596占用了端口，这时找到5596，并关掉它就可以了。关掉之前可以先看看是什么进程，查看进程的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist |findstr 5596</span><br></pre></td></tr></table></figure><p>关掉进程的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /pid 5596 /f</span><br></pre></td></tr></table></figure><p>此时再次尝试adb连接Android设备，如果还不行，则使用下面的最后一种方法；</p><p>（2）使用USB连接电脑，然后执行以下命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb tcpip 5555</span><br></pre></td></tr></table></figure><p>在没有报错的前提下，断开USB，再使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect IP地址:5555</span><br></pre></td></tr></table></figure><p>此时就能连接Android设备了，如果还不行，对不起，我也没办法了！</p><h5 id="themes设置相关"><a href="#themes设置相关" class="headerlink" title="themes设置相关"></a>themes设置相关</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">colorPrimary : 顧名思義，就是主要的顏色，這個通常指得是 App 本身產品的代表色，通常也是品牌的主要視覺色</span><br><span class="line">colorPrimaryVariant：主要顏色的變體，通常會從 colorPrimary 往較淡或較濃的色澤</span><br><span class="line">colorOnPrimary：字面意思就是主要顏色上頭的顏色，這個顏色通常使用在背景色是主要顏色的元件上頭(例如字樣 Label 、icon 等)</span><br><span class="line">colorSecondary：app 次要的品牌顏色，這些用於裝飾某些特定需要的 widget</span><br><span class="line">colorSecondaryVariant：次要顏色的變體，也就是次要顏色偏暗或偏亮的樣式</span><br><span class="line">colorOnSecondary：用於顯示於次要顏色上元件的顏色</span><br><span class="line">colorError：顯示錯誤的顏色 (最常見的就是紅色)</span><br><span class="line">colorOnError：在錯誤顏色上頭元件的顏色</span><br><span class="line">colorSurface：表層顏色(就是 Sheet 的顏色)</span><br><span class="line">colorOnSurface：在表層顏色上的的元件顏色</span><br><span class="line">android:colorBackground：最底的背景色</span><br><span class="line">colorOnBackground：用於對底背景色上頭的元件用的顏色</span><br><span class="line">利用这些属性，搭配上面的那些技巧，可以組合出很棒的效果。</span><br></pre></td></tr></table></figure><p><strong><code>.bridge</code>是让按钮等不默认使用主题色，<code>.NoActionBar</code>是不显示顶部导航条,现在用<code>Toolbar</code>替代<code>ActionBar</code>了,要用自带标题栏就用<code>Toolbar</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--安卓默认生成--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.MyApplication&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Primary brand color. --&gt;</span></span></span><br><span class="line"><span class="language-xml">        </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimary&quot;</span>&gt;</span>@color/purple_500<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimaryVariant&quot;</span>&gt;</span>@color/purple_700<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorOnPrimary&quot;</span>&gt;</span>@color/white<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Secondary brand color. --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorSecondary&quot;</span>&gt;</span>@color/teal_200<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorSecondaryVariant&quot;</span>&gt;</span>@color/teal_700<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorOnSecondary&quot;</span>&gt;</span>@color/black<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Status bar color. --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:statusBarColor&quot;</span>&gt;</span>?attr/colorPrimaryVariant<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="沉侵式体验"><a href="#沉侵式体验" class="headerlink" title="沉侵式体验"></a>沉侵式体验</h5><p>沉浸式状态栏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        <span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> getWindow();</span><br><span class="line">        window.getDecorView().setSystemUiVisibility(</span><br><span class="line">                View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);</span><br><span class="line">        window.setStatusBarColor(Color.TRANSPARENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setContentView(R.layout.activity_main); <span class="comment">// 设置你的布局文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>沉浸式导航栏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    <span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> getWindow();</span><br><span class="line">    window.getDecorView().setSystemUiVisibility(</span><br><span class="line">            View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN |</span><br><span class="line">            View.SYSTEM_UI_FLAG_LAYOUT_STABLE |</span><br><span class="line">            View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);</span><br><span class="line">    window.setStatusBarColor(Color.TRANSPARENT);</span><br><span class="line">    window.setNavigationBarColor(Color.TRANSPARENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用沉浸式布局</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Your content here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这将会让布局内容在状态栏和导航栏区域留出空间。</p><h5 id="透明状态栏"><a href="#透明状态栏" class="headerlink" title="透明状态栏"></a>透明状态栏</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//沉浸式状态栏，显示上面图标但状态栏透明，下面2行代码连用，如果整个界面是白色图标会消失</span></span><br><span class="line"><span class="comment">//下面这样代码一定要这么写,1024和256，单用1024就可以了其实</span></span><br><span class="line">getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_VISIBLE</span><br><span class="line">                                                 | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);</span><br><span class="line"><span class="comment">//下面这句是设置背景色的，下面这个是设置为透明，自己按需求改，只用这条属性不做设置上面各种小图标也会消失，透明了，最新方法</span></span><br><span class="line">getWindow().setStatusBarColor(Color.TRANSPARENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐藏状态栏并且会自动消失，与其他一起使用无效</span></span><br><span class="line">getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);</span><br><span class="line"><span class="comment">//显示状态栏，</span></span><br><span class="line">getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>View.SYSTEM_UI_FLAG_VISIBLE</code></td><td align="center">状态栏和Activity共存，Activity不全屏显示。也就是应用平常的显示画面</td></tr><tr><td align="center"><code>View.SYSTEM_UI_FLAG_FULLSCREEN</code></td><td align="center">Activity全屏显示，且状态栏被覆盖掉，但下拉会出现并且不能再隐藏</td></tr><tr><td align="center"><code>View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN </code></td><td align="center">Activity全屏显示，但是状态栏不会被覆盖掉，而是正常显示，只是Activity顶端布  局会被覆盖住</td></tr><tr><td align="center"><code>View.INVISIBLE </code></td><td align="center">Activity全屏显示，隐藏状态栏</td></tr></tbody></table><h5 id="隐藏ActionBar"><a href="#隐藏ActionBar" class="headerlink" title="隐藏ActionBar"></a>隐藏ActionBar</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getSupportActionBar().hide();</span><br></pre></td></tr></table></figure><h4 id="隐藏导航栏"><a href="#隐藏导航栏" class="headerlink" title="隐藏导航栏"></a>隐藏导航栏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);</span><br></pre></td></tr></table></figure><h4 id="依赖设置"><a href="#依赖设置" class="headerlink" title="依赖设置"></a>依赖设置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jcenter()</span><br><span class="line">maven &#123; url <span class="string">&#x27;https://www.jitpack.io&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.google.android.material:material:1.1.0&#x27;</span><span class="comment">//降为这个版本，不然预览视图有bug</span></span><br></pre></td></tr></table></figure><h4 id="全屏手势"><a href="#全屏手势" class="headerlink" title="全屏手势"></a>全屏手势</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getDecorView().setSystemUiVisibility(</span><br><span class="line">                View.SYSTEM_UI_FLAG_LAYOUT_STABLE</span><br><span class="line">                        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</span><br><span class="line">                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</span><br><span class="line">                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</span><br><span class="line">                        | View.SYSTEM_UI_FLAG_FULLSCREEN</span><br><span class="line">                        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>View.SYSTEM_UI_FLAG_VISIBLE</code></td><td align="center">状态栏和Activity共存，Activity不全屏显示。也就是应用平常的显示画面</td></tr><tr><td align="center"><code>View.SYSTEM_UI_FLAG_FULLSCREEN</code></td><td align="center">Activity全屏显示，且状态栏被覆盖掉</td></tr><tr><td align="center"><code>View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN </code></td><td align="center">Activity全屏显示，但是状态栏不会被覆盖掉，而是正常显示，只是Activity顶端布  局会被覆盖住</td></tr><tr><td align="center"><code>View.INVISIBLE </code></td><td align="center">Activity全屏显示，隐藏状态栏</td></tr></tbody></table><h5 id="设置图标"><a href="#设置图标" class="headerlink" title="设置图标"></a>设置图标</h5><p>第一种：(最简单的方法)</p><p>将你准备好的 图标放入res目录下的drawable，在AndroidManifest.<a href="https://so.csdn.net/so/search?q=xml&spm=1001.2101.3001.7020">xml</a>文件中，找到android:icon以及android:roundIcon这两个属性,设置为你放入的图标文件。</p><p>在这里，这两个属性都能对图标进行设置，在设置时只使用一个也可以达到效果，但如果两个同时使用的话，属性指定的对象需要设置一致。若不一致，我测试结果是显示的roundIcon指定的对象，找到android:roundIcon 属性的解释：</p><p>android:roundIcon 属性指定一个图标，但只有你需要给应用设置一个特别的圆形图标时才要用到这个属性。</p><p>第二种：(稍微复杂)</p><p>更详细的解释可以看这两篇文章</p><p><a href="https://www.jb51.net/article/188580.htm">https://www.jb51.net/article/188580.htm</a></p><p>[Android神兵利器之Image Asset Studio]</p><p><a href="https://www.jb51.net/article/138346.htm">https://www.jb51.net/article/138346.htm</a></p><p>[application中 android:icon 和 android:roundIcon 的区别]</p><h5 id="使用外部字体"><a href="#使用外部字体" class="headerlink" title="使用外部字体"></a>使用外部字体</h5><p>在<code>src/main</code>中创建了一个文件夹<code>assets</code>文件夹，在<code>assets</code>文件夹中创建<code>fonts</code>文件夹，把字体文件放到<code>fonts</code>目录下</p><p>此外，在具有以下内容的同一文件夹内创建一个名为fonts.xml的文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;font-family xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">      &lt;font</span><br><span class="line">              app:fontStyle=<span class="string">&quot;normal&quot;</span></span><br><span class="line">              app:fontWeight=<span class="string">&quot;700&quot;</span></span><br><span class="line">              app:font=<span class="string">&quot;@font/customfont&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">      &lt;font</span><br><span class="line">              app:fontStyle=<span class="string">&quot;normal&quot;</span></span><br><span class="line">              app:fontWeight=<span class="string">&quot;700&quot;</span></span><br><span class="line">              app:font=<span class="string">&quot;@font/customfont_bold&quot;</span>/&gt;</span><br><span class="line">&lt;/font-family&gt;</span><br></pre></td></tr></table></figure><p>然后，编辑文件app&gt; src&gt; res&gt; values&gt; styles.xml，为整个应用程序应用默认字体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Base application theme. --&gt;</span><br><span class="line">&lt;style name=<span class="string">&quot;AppTheme&quot;</span> parent=<span class="string">&quot;Theme.AppCompat.Light.NoActionBar&quot;</span>&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;colorPrimary&quot;</span>&gt;<span class="meta">@color</span>/colorPrimary&lt;/item&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;colorPrimaryDark&quot;</span>&gt;<span class="meta">@color</span>/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;colorAccent&quot;</span>&gt;<span class="meta">@color</span>/colorAccent&lt;/item&gt;</span><br><span class="line">    &lt;item name=<span class="string">&quot;android:fontFamily&quot;</span>&gt;<span class="meta">@font</span>/customfont&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>如果要更改单个UI元素的字体，请执行以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:fontFamily=<span class="string">&quot;@font/customfont&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android:textColor=<span class="string">&quot;@color/black&quot;</span></span><br><span class="line">    android:textSize=<span class="string">&quot;18sp&quot;</span></span><br><span class="line">    android:text=<span class="string">&quot;Some text&quot;</span></span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><p>java中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextView tv=(TextView)findViewById(R.id.custom);</span><br><span class="line">Typeface face=Typeface.createFromAsset(getAssets(),<span class="string">&quot;fonts/Verdana.ttf&quot;</span>);<span class="comment">//记得加fonts文件名</span></span><br><span class="line">tv.setTypeface(face);</span><br></pre></td></tr></table></figure><h5 id="使用内置绘制矢量图"><a href="#使用内置绘制矢量图" class="headerlink" title="使用内置绘制矢量图"></a>使用内置绘制矢量图</h5><p>在<code>Project</code>模式下<strong>右击</strong>选择<code>src</code>,然后选择<code>New/Vector Asset</code></p><h5 id="双击退出"><a href="#双击退出" class="headerlink" title="双击退出"></a>双击退出</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双击返回</span></span><br><span class="line"><span class="meta">@SuppressLint(&quot;WrongConstant&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onKeyUp</span><span class="params">(<span class="type">int</span> keyCode, KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">tempTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_BACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempTime - startTime &gt;= <span class="number">2000</span>) &#123;</span><br><span class="line">            startTime = tempTime;</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;再点击一次退出应用&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.onKeyUp(keyCode, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><ul><li><strong>OKHttp</strong></li><li><strong>Retrofit（对OKHttp的封装，下面的Retrofit2的库包含了OKHttp）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//retrofit2和retrofit转换器</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;</span></span><br><span class="line">implementation <span class="string">&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;</span></span><br></pre></td></tr></table></figure><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>布局代码过长时可以把一部分代码放带到另一个xml文件中，然后在要引用的地方<code>&lt;includelayout=&quot;@layout/tab1&quot;/&gt;</code></p><ul><li><strong>线性布局</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*android:layout_gravity=&quot;center_horizontal&quot;在线性布局中没有作用是因为</span></span><br><span class="line"><span class="comment">没有设置布局属性android:orientation=&quot;vertical&quot;*/</span></span><br></pre></td></tr></table></figure><p>一些技巧，把一个控件放在底部时，要让上面的整个界面布满可以用<code>android:layout_weight=&quot;1&quot;</code>属性，如在fragment和viewpager</p><p>使用时</p><h3 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h3><h4 id="设置控件可见与不可见"><a href="#设置控件可见与不可见" class="headerlink" title="设置控件可见与不可见"></a>设置控件可见与不可见</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xml </span></span><br><span class="line">android:visibility=<span class="string">&quot;visible&quot;</span>;</span><br><span class="line"><span class="comment">//（可见）</span></span><br><span class="line"> android:visibility=<span class="string">&quot;invisible&quot;</span>;</span><br><span class="line"><span class="comment">//（不可见，保留布局位置）</span></span><br><span class="line"> android:visibility=<span class="string">&quot;gone&quot;</span>;</span><br><span class="line"><span class="comment">//（隐藏不保留布局位置）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line">view.setVisibility(View.VISIBLE);</span><br><span class="line"><span class="comment">//（可见）</span></span><br><span class="line">view.setVisibility(View.INVISIBLE);</span><br><span class="line"><span class="comment">//（不可见，保留布局位置）</span></span><br><span class="line">view.setVisibility(View.GONE);</span><br><span class="line"><span class="comment">//（隐藏不保留布局位置）</span></span><br></pre></td></tr></table></figure><p><strong>View的一些公共属性</strong></p><p><code>android:id=&quot;@+id/tv_hello&quot;</code>注<code>dp</code>是与设备无关的属性，<code>px</code>像素就不一样了，<code>sp</code>是给字体用的</p><p><code>android:layout_width=&quot;match_parent&quot;</code></p><p><code>android:layout_height=&quot;match_parent&quot;</code></p><p><code>android:gravity=&quot;right|center_vertical&quot;</code> &#x2F;&#x2F;gravity属性字面意思重力的意思，控制view里面的内容的，多个属性用竖线分隔</p><p><code>android:layout_gravity=&quot;center_vertical&quot;</code> &#x2F;&#x2F;这个是来控制这个控件在父布局中的位置的，也会由父布局的特性影响到</p><p><code>android:background=&quot;@color/teal_200&quot;</code></p><p>padding和margin</p><h4 id="自定义背景"><a href="#自定义背景" class="headerlink" title="自定义背景"></a>自定义背景</h4><ul><li>新建Drawable Resource File文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;shape xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:shape=<span class="string">&quot;rectangle&quot;</span>&gt;</span><br><span class="line">    <span class="comment">//android:shape属性设置形状</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个属性设置圆角弧度</span></span><br><span class="line">    &lt;corners</span><br><span class="line">        android:radius=<span class="string">&quot;20dp&quot;</span>/&gt;</span><br><span class="line">            </span><br><span class="line"><span class="comment">//这个属性设置描边</span></span><br><span class="line">    &lt;stroke</span><br><span class="line">        android:color=<span class="string">&quot;@color/teal_200&quot;</span></span><br><span class="line">        android:width=<span class="string">&quot;2dp&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个属性设置描边内部的填充色        </span></span><br><span class="line">    &lt;solid</span><br><span class="line">        android:color=<span class="string">&quot;@color/teal_200&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/shape&gt;</span><br></pre></td></tr></table></figure><h4 id="Dialog（对话框）"><a href="#Dialog（对话框）" class="headerlink" title="Dialog（对话框）"></a>Dialog（对话框）</h4><p><em>1. 最简单的提示对话框</em></p><p>（1）创建<code>AlertDialog.Builder</code>实例对象。</p><p>（2）通过<code>Builder</code>对象设置对话框的属性。</p><ul><li><code>setTitle()</code>设置标题</li><li><code>setIcon ()</code>设置图标</li><li><code>setMessage ()</code>设置要显示的内容</li><li><code>setItems()</code>设置在对话框中显示的项目列表</li><li><code>setView()</code>设置自定义的对话框样式</li><li><code>setPositiveButton ()</code>设置确定按钮</li><li><code>setNegativeButton ()</code>设置取消按钮</li><li><code>setNeutralButton ()</code>设置中立按钮</li><li><code>setSingleChoiceItems</code>单选框</li><li><code>setMultiChoiceItems</code>复选框</li></ul><p>（3）调用<code>Builder</code>对象的<code>create()</code>方法创建<code>AlertDialog</code>对话框</p><p>（4）调用<code>AlertDialog</code>的<code>show()</code>方法来显示对话框</p><p>（5）调用<code>AlertDialog</code>的<code>dimiss()</code>方法销毁对话框。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog.Builder builder= <span class="keyword">new</span> <span class="title class_">AlertDialog</span>.Builder(<span class="built_in">this</span>).setMessage(<span class="string">&quot;是否要修改个人信息&quot;</span>)</span><br><span class="line">                .setPositiveButton(<span class="string">&quot;确定&quot;</span>, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialogInterface, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">                        isConfirm = <span class="number">1</span>;</span><br><span class="line">                        dialogInterface.dismiss();</span><br><span class="line">                        Toast.makeText(ChangeMessageActivity.<span class="built_in">this</span>, <span class="string">&quot;个人信息保存成功！&quot;</span>,</span><br><span class="line">                                Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .setNegativeButton(<span class="string">&quot;取消&quot;</span>, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialogInterface, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">                        dialogInterface.dismiss();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="type">AlertDialog</span> <span class="variable">alertDialog</span> <span class="operator">=</span> builder.create();</span><br><span class="line">        alertDialog.show();</span><br></pre></td></tr></table></figure><p><img src="/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/1.png"></p><p><em>2. 列表对话框（供选择）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setItems形成列表，第一个参数传列表条目的数组进去，第二个参数是监听，监听的第二个参数为选择了第几个条目，点击条目后会自动关闭</span></span><br><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;第一条&quot;</span>,<span class="string">&quot;第二条&quot;</span>,<span class="string">&quot;第三条&quot;</span>&#125;;</span><br><span class="line">        AlertDialog.Builder builder= <span class="keyword">new</span> <span class="title class_">AlertDialog</span>.Builder(<span class="built_in">this</span>)</span><br><span class="line">                .setItems(s, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialogInterface, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">                        Toast.makeText(ChangeMessageActivity.<span class="built_in">this</span>, <span class="string">&quot;选择了第&quot;</span>+i+<span class="number">1</span>+<span class="string">&quot;条消息&quot;</span>,</span><br><span class="line">                                Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="type">AlertDialog</span> <span class="variable">alertDialog</span> <span class="operator">=</span> builder.create();</span><br><span class="line">        alertDialog.show();</span><br></pre></td></tr></table></figure><p><img src="/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/2.png"></p><p><em>3. 单选列表对话框</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setSingleChoiceItems第一个参数传列表条目数组，第二个参数为默认选择值，第三个为监听</span></span><br><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;第一条&quot;</span>,<span class="string">&quot;第二条&quot;</span>,<span class="string">&quot;第三条&quot;</span>&#125;;</span><br><span class="line">        AlertDialog.Builder builder= <span class="keyword">new</span> <span class="title class_">AlertDialog</span>.Builder(<span class="built_in">this</span>)</span><br><span class="line">                .setSingleChoiceItems(s, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialogInterface, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">                        isConfirm = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .setPositiveButton(<span class="string">&quot;确定&quot;</span>, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialogInterface, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">                        Toast.makeText(ChangeMessageActivity.<span class="built_in">this</span>, <span class="string">&quot;选择了第&quot;</span>+i+<span class="number">1</span>+<span class="string">&quot;条条目&quot;</span></span><br><span class="line">                                       , Toast.LENGTH_SHORT).show();</span><br><span class="line">                        dialogInterface.dismiss();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .setNegativeButton(<span class="string">&quot;取消&quot;</span>, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialogInterface, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">                        dialogInterface.dismiss();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="type">AlertDialog</span> <span class="variable">alertDialog</span> <span class="operator">=</span> builder.create();</span><br><span class="line">        alertDialog.show();</span><br></pre></td></tr></table></figure><p><em>4. 多选列表对话框</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setMultiChoiceItems第一个参数传条目数组，第二个传一个boolean类型数组后续保存是否被选中</span></span><br><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;第一条&quot;</span>,<span class="string">&quot;第二条&quot;</span>,<span class="string">&quot;第三条&quot;</span>&#125;;</span><br><span class="line">        <span class="type">boolean</span>[] isCheck = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">3</span>];</span><br><span class="line">        AlertDialog.Builder builder= <span class="keyword">new</span> <span class="title class_">AlertDialog</span>.Builder(<span class="built_in">this</span>)</span><br><span class="line">                .setMultiChoiceItems(s, isCheck, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnMultiChoiceClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialogInterface, <span class="type">int</span> i, <span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">                        isCheck[i] = b;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .setPositiveButton(<span class="string">&quot;确定&quot;</span>, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialogInterface, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; isCheck.length; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (isCheck[j])&#123;</span><br><span class="line">                                back+=j+<span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Toast.makeText(ChangeMessageActivity.<span class="built_in">this</span>, <span class="string">&quot;选择了&quot;</span>+back, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .setNegativeButton(<span class="string">&quot;取消&quot;</span>, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialogInterface, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">                        dialogInterface.dismiss();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="type">AlertDialog</span> <span class="variable">alertDialog</span> <span class="operator">=</span> builder.create();</span><br><span class="line">        alertDialog.show();</span><br></pre></td></tr></table></figure><p><em>5. 半自定义消息框</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setView()设置自定义类型</span></span><br><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> getLayoutInflater().inflate(R.layout.half_dialog_view, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">EditText</span> <span class="variable">editText</span> <span class="operator">=</span> (EditText) view.findViewById(R.id.dialog_edit);</span><br><span class="line">        <span class="type">AlertDialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlertDialog</span>.Builder(<span class="built_in">this</span>)</span><br><span class="line">                .setIcon(R.mipmap.icon)<span class="comment">//设置标题的图片</span></span><br><span class="line">                .setTitle(<span class="string">&quot;半自定义对话框&quot;</span>)<span class="comment">//设置对话框的标题</span></span><br><span class="line">                .setView(view)</span><br><span class="line">                .setNegativeButton(<span class="string">&quot;取消&quot;</span>, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialog, <span class="type">int</span> which)</span> &#123;</span><br><span class="line">                        dialog.dismiss();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .setPositiveButton(<span class="string">&quot;确定&quot;</span>, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialog, <span class="type">int</span> which)</span> &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> editText.getText().toString();</span><br><span class="line">                        Toast.makeText(MainActivity.<span class="built_in">this</span>, content, Toast.LENGTH_SHORT).show();</span><br><span class="line">                        dialog.dismiss();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).create();</span><br><span class="line">        dialog.show();</span><br></pre></td></tr></table></figure><p><em>6. 全自定义消息框</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--对话框的样式--&gt;</span><br><span class="line">  &lt;style name=<span class="string">&quot;NormalDialogStyle&quot;</span>&gt;</span><br><span class="line">   &lt;!--对话框背景 --&gt;</span><br><span class="line">      &lt;item name=<span class="string">&quot;android:windowBackground&quot;</span>&gt;<span class="meta">@android</span>:color/transparent&lt;/item&gt;</span><br><span class="line">      &lt;!--边框 --&gt;</span><br><span class="line">      &lt;item name=<span class="string">&quot;android:windowFrame&quot;</span>&gt;<span class="meta">@null</span>&lt;/item&gt;</span><br><span class="line">      &lt;!--没有标题 --&gt;</span><br><span class="line">      &lt;item name=<span class="string">&quot;android:windowNoTitle&quot;</span>&gt;<span class="literal">true</span>&lt;/item&gt;</span><br><span class="line">      &lt;!-- 是否浮现在Activity之上 --&gt;</span><br><span class="line">      &lt;item name=<span class="string">&quot;android:windowIsFloating&quot;</span>&gt;<span class="literal">true</span>&lt;/item&gt;</span><br><span class="line">      &lt;!--背景透明 --&gt;</span><br><span class="line">      &lt;item name=<span class="string">&quot;android:windowIsTranslucent&quot;</span>&gt;<span class="literal">false</span>&lt;/item&gt;</span><br><span class="line">      &lt;!-- 是否有覆盖 --&gt;</span><br><span class="line">      &lt;item name=<span class="string">&quot;android:windowContentOverlay&quot;</span>&gt;<span class="meta">@null</span>&lt;/item&gt;</span><br><span class="line">      &lt;!--进出的显示动画 --&gt;</span><br><span class="line">      &lt;item name=<span class="string">&quot;android:windowAnimationStyle&quot;</span>&gt;<span class="meta">@style</span>/normalDialogAnim&lt;/item&gt;</span><br><span class="line">      &lt;!--背景变暗--&gt;</span><br><span class="line">      &lt;item name=<span class="string">&quot;android:backgroundDimEnabled&quot;</span>&gt;<span class="literal">true</span>&lt;/item&gt;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;!--对话框动画--&gt;</span><br><span class="line">  &lt;style name=<span class="string">&quot;normalDialogAnim&quot;</span> parent=<span class="string">&quot;android:Animation&quot;</span>&gt;</span><br><span class="line">      &lt;item name=<span class="string">&quot;@android:windowEnterAnimation&quot;</span>&gt;<span class="meta">@anim</span>/normal_dialog_enter&lt;/item&gt;</span><br><span class="line">      &lt;item name=<span class="string">&quot;@android:windowExitAnimation&quot;</span>&gt;<span class="meta">@anim</span>/normal_dialog_exit&lt;/item&gt;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自定义对话框</span></span><br><span class="line"><span class="comment">    * dialog.setContentView(view);就可以设置我们自己的布局了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">customDialog</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">Dialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dialog</span>(<span class="built_in">this</span>, R.style.NormalDialogStyle);</span><br><span class="line">       <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> View.inflate(<span class="built_in">this</span>, R.layout.dialog_normal, <span class="literal">null</span>);</span><br><span class="line">       <span class="type">TextView</span> <span class="variable">cancel</span> <span class="operator">=</span> (TextView) view.findViewById(R.id.cancel);</span><br><span class="line">       <span class="type">TextView</span> <span class="variable">confirm</span> <span class="operator">=</span> (TextView) view.findViewById(R.id.confirm);</span><br><span class="line">       dialog.setContentView(view);</span><br><span class="line">       <span class="comment">//使得点击对话框外部不消失对话框</span></span><br><span class="line">       dialog.setCanceledOnTouchOutside(<span class="literal">true</span>);</span><br><span class="line">       <span class="comment">//设置对话框的大小</span></span><br><span class="line">       view.setMinimumHeight((<span class="type">int</span>) (ScreenSizeUtils.getInstance(<span class="built_in">this</span>).getScreenHeight() * <span class="number">0.23f</span>));</span><br><span class="line">       <span class="type">Window</span> <span class="variable">dialogWindow</span> <span class="operator">=</span> dialog.getWindow();</span><br><span class="line">       WindowManager.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> dialogWindow.getAttributes();</span><br><span class="line">       lp.width = (<span class="type">int</span>) (ScreenSizeUtils.getInstance(<span class="built_in">this</span>).getScreenWidth() * <span class="number">0.75f</span>);</span><br><span class="line">       lp.height = WindowManager.LayoutParams.WRAP_CONTENT;</span><br><span class="line">       lp.gravity = Gravity.CENTER;</span><br><span class="line">       dialogWindow.setAttributes(lp);</span><br><span class="line">       cancel.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">               dialog.dismiss();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       confirm.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">               dialog.dismiss();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       dialog.show();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/3.png"></p><p><em>一个常用设计</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:background=<span class="string">&quot;@android:color/transparent&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:background=<span class="string">&quot;@drawable/round_corner&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;拍照&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;1dp&quot;</span></span><br><span class="line">        android:layout_marginLeft=<span class="string">&quot;10dp&quot;</span></span><br><span class="line">        android:layout_marginRight=<span class="string">&quot;10dp&quot;</span></span><br><span class="line">        android:background=<span class="string">&quot;#ddd&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:background=<span class="string">&quot;@drawable/round_corner&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;相册&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_marginTop=<span class="string">&quot;10dp&quot;</span></span><br><span class="line">        android:background=<span class="string">&quot;@drawable/round_corner&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;取消&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;View</span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;15dp&quot;</span> /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dialog</span>(<span class="built_in">this</span>, R.style.NormalDialogStyle);</span><br><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> View.inflate(<span class="built_in">this</span>, R.layout.dialog_bottom, <span class="literal">null</span>);</span><br><span class="line">dialog.setContentView(view);</span><br><span class="line">dialog.setCanceledOnTouchOutside(<span class="literal">true</span>);</span><br><span class="line">view.setMinimumHeight((<span class="type">int</span>) (ScreenSizeUtils.getInstance(<span class="built_in">this</span>).getScreenHeight() * <span class="number">0.23f</span>));</span><br><span class="line"><span class="type">Window</span> <span class="variable">dialogWindow</span> <span class="operator">=</span> dialog.getWindow();</span><br><span class="line">WindowManager.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> dialogWindow.getAttributes();</span><br><span class="line">lp.width = (<span class="type">int</span>) (ScreenSizeUtils.getInstance(<span class="built_in">this</span>).getScreenWidth() * <span class="number">0.9f</span>);</span><br><span class="line">lp.height = WindowManager.LayoutParams.WRAP_CONTENT;</span><br><span class="line">lp.gravity = Gravity.BOTTOM;</span><br><span class="line">dialogWindow.setAttributes(lp);</span><br><span class="line">dialog.show();</span><br></pre></td></tr></table></figure><p><img src="/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/4.png"></p><p><em>7. 进度条对话框</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//圆形</span></span><br><span class="line"><span class="type">ProgressDialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProgressDialog</span>(<span class="built_in">this</span>);</span><br><span class="line"> dialog.setMessage(<span class="string">&quot;正在加载中&quot;</span>);</span><br><span class="line"> dialog.show();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线性进度条，dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL)设置即可</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ProgressDialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProgressDialog</span>(<span class="built_in">this</span>);</span><br><span class="line">        dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span><br><span class="line">        dialog.setMessage(<span class="string">&quot;正在加载中&quot;</span>);</span><br><span class="line">        dialog.setMax(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">progress</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                dialog.setProgress(progress += <span class="number">5</span>);</span><br><span class="line">                <span class="keyword">if</span> (progress == <span class="number">100</span>) &#123;</span><br><span class="line">                    timer.cancel();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">        dialog.show();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>8. 日期和时间选择消息框</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">DatePickerDialog</span>(<span class="built_in">this</span></span><br><span class="line">        , <span class="keyword">new</span> <span class="title class_">DatePickerDialog</span>.OnDateSetListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDateSet</span><span class="params">(DatePicker view, <span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> dayOfMonth)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH))</span><br><span class="line">        .show(); </span><br></pre></td></tr></table></figure><h4 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h4><p><em><strong>空格及其他占位符</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```&amp;#160;``` == &amp;nbsp; == &amp;#xA0; == no-break space （普通的英文半角空格但不换行）</span><br><span class="line"></span><br><span class="line">```&amp;#12288; ```== 中文全角空格 （一个中文宽度）</span><br><span class="line"></span><br><span class="line">```&amp;#8194;``` == &amp;ensp; == en空格 （半个中文宽度）</span><br><span class="line"></span><br><span class="line">```&amp;#8195; ```== &amp;emsp; == em空格 （一个中文宽度）</span><br><span class="line"></span><br><span class="line">```&amp;#8197;``` == 四分之一em空格 （四分之一中文宽度）</span><br><span class="line"></span><br><span class="line">相比平时的空格（&amp;#32;），nbsp拥有不间断（non-breaking）特性。即连续的nbsp会在同一行内显示。即使有100个连续的nbsp，浏览器也不会把它们拆成两行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//设置颜色</span><br><span class="line">mTextView2.setTextColor(getResources().getColor(R.color.black));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串拼接，比直接+号进行拼接效率更高，高很多</span></span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            stringBuffer.append(year);</span><br><span class="line">            stringBuffer.append(<span class="string">&quot;111&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tv = (TextView) findViewById(R.id. text_view ); </span><br><span class="line"><span class="comment">// 中间加横线 ， 添加Paint.ANTI_ALIAS_FLAG是线会变得清晰去掉锯齿</span></span><br><span class="line">tv.getPaint().setFlags(Paint.STRIKE_THRU_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG ); </span><br><span class="line"><span class="comment">// 底部加横线 ， 添加Paint.ANTI_ALIAS_FLAG是线会变得清晰去掉锯齿</span></span><br><span class="line">tv .getPaint().setFlags(Paint. UNDERLINE_TEXT_FLAG | Paint.ANTI_ALIAS_FLAG );</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:maxLines=&quot;2&quot;</span><br><span class="line">android:ellipsize=&quot;end&quot;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*点击×的监听*/</span></span><br><span class="line">    edtTitle.setOnTouchListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnTouchListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouch</span><span class="params">(View view, MotionEvent motionEvent)</span> &#123;</span><br><span class="line">            <span class="comment">// 如果点击的是清除图标区域</span></span><br><span class="line">            <span class="keyword">if</span> (motionEvent.getX() &gt;= (view.getWidth() - view.getPaddingEnd() - edtTitle.getCompoundDrawables()[<span class="number">2</span>].getBounds().width())) &#123;</span><br><span class="line">                <span class="comment">// 处理清除图标的点击事件</span></span><br><span class="line">                edtTitle.setText(<span class="string">&quot;&quot;</span>);  <span class="comment">// 清空文本</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 消耗触摸事件，不传递给下层的触摸监听器</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 其他情况交给下层的触摸监听器处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="Edittext"><a href="#Edittext" class="headerlink" title="Edittext"></a>Edittext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文本类型，多为大写、小写和数字符号。  </span></span><br><span class="line">android:inputType=<span class="string">&quot;none&quot;</span><span class="comment">//输入普通字符 </span></span><br><span class="line">android:inputType=<span class="string">&quot;text&quot;</span><span class="comment">//输入普通字符 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textCapCharacters&quot;</span><span class="comment">//输入普通字符 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textCapWords&quot;</span><span class="comment">//单词首字母大小 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textCapSentences&quot;</span><span class="comment">//仅第一个字母大小 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textAutoCorrect&quot;</span><span class="comment">//前两个自动完成 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textAutoComplete&quot;</span><span class="comment">//前两个自动完成 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textMultiLine&quot;</span><span class="comment">//多行输入 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textImeMultiLine&quot;</span><span class="comment">//输入法多行（不一定支持） </span></span><br><span class="line">android:inputType=<span class="string">&quot;textNoSuggestions&quot;</span><span class="comment">//不提示 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textUri&quot;</span><span class="comment">//URI格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textEmailAddress&quot;</span><span class="comment">//电子邮件地址格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textEmailSubject&quot;</span><span class="comment">//邮件主题格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textShortMessage&quot;</span><span class="comment">//短消息格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textLongMessage&quot;</span><span class="comment">//长消息格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textPersonName&quot;</span><span class="comment">//人名格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textPostalAddress&quot;</span><span class="comment">//邮政格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textPassword&quot;</span><span class="comment">//密码格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textVisiblePassword&quot;</span><span class="comment">//密码可见格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textWebEditText&quot;</span><span class="comment">//作为网页表单的文本格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textFilter&quot;</span><span class="comment">//文本筛选格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;textPhonetic&quot;</span><span class="comment">//拼音输入格式 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数值类型 </span></span><br><span class="line">android:inputType=<span class="string">&quot;number&quot;</span><span class="comment">//数字格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;numberSigned&quot;</span><span class="comment">//有符号数字格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;numberDecimal&quot;</span><span class="comment">//可以带小数点的浮点格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;phone&quot;</span><span class="comment">//拨号键盘 </span></span><br><span class="line">android:inputType=<span class="string">&quot;datetime&quot;</span><span class="comment">//日期+时间格式 </span></span><br><span class="line">android:inputType=<span class="string">&quot;date&quot;</span><span class="comment">//日期键盘 </span></span><br><span class="line">android:inputType=<span class="string">&quot;time&quot;</span><span class="comment">//时间键盘</span></span><br></pre></td></tr></table></figure><p><code>maxlength</code>控制读入最大长度 </p><p><code>maxline</code>控制显示最大行数</p><p>去掉下滑线<code>background=&quot;@null&quot;</code></p><p><code>textAlignment</code>设置输入居中</p><p>EditText触点问题</p><p>setFocusable这个是用键盘是否能获得焦点<br>setFocusableInTouchMode这个是触摸是否能获得焦点</p><p><strong>记事本类似实例，大范围点击即可获取某个输入框的焦点输入，并在键盘收起后失去焦点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先导库</span></span><br><span class="line">implementation <span class="string">&#x27;net.yslibrary.keyboardvisibilityevent:keyboardvisibilityevent:3.0.0-RC3&#x27;</span></span><br><span class="line"><span class="comment">//代码        </span></span><br><span class="line">        <span class="type">RelativeLayout</span> <span class="variable">relativeLayout</span> <span class="operator">=</span> findViewById(R.id.relativelayout);</span><br><span class="line">        mEditText = findViewById(R.id.edittext_message);</span><br><span class="line">        relativeLayout.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@SuppressLint(&quot;NewApi&quot;)</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                <span class="comment">//这三行代码是展开键盘的</span></span><br><span class="line">                mEditText.requestFocus();           </span><br><span class="line">                <span class="type">InputMethodManager</span> <span class="variable">inputMethodManager</span> <span class="operator">=</span> (InputMethodManager) mEditText.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);</span><br><span class="line">                inputMethodManager.showSoftInput(mEditText,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        KeyboardVisibilityEvent.setEventListener(GetActivity.<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">KeyboardVisibilityEventListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVisibilityChanged</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!b)&#123;</span><br><span class="line">                    mEditText.clearFocus();</span><br><span class="line">                    <span class="comment">//清除焦点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); </span><br><span class="line"><span class="comment">//Edittext触点问题，现在不在xml和Java文件设置下面两个属性在进入界面时输入框也不会获取焦点，貌似默认都为true</span></span><br><span class="line">setFocusable()这个是用键盘是否能获得焦点</span><br><span class="line">setFocusableInTouchMode()这个是触摸是否能获得焦点</span><br></pre></td></tr></table></figure><p><strong>Edittext监听</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">editText.addTextChangedListener(<span class="keyword">new</span> <span class="title class_">TextWatcher</span>() &#123;  </span><br><span class="line">         </span><br><span class="line">       <span class="meta">@Override</span>  </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTextChanged</span><span class="params">(CharSequence text, <span class="type">int</span> start, <span class="type">int</span> before, <span class="type">int</span> count)</span> &#123;  </span><br><span class="line">       <span class="comment">//text  输入框中改变后的字符串信息  </span></span><br><span class="line">       <span class="comment">//start 输入框中改变后的字符串的起始位置  </span></span><br><span class="line">       <span class="comment">//before 输入框中改变前的字符串的位置 默认为0  </span></span><br><span class="line">       <span class="comment">//count 输入框中改变后的一共输入字符串的数量  </span></span><br><span class="line">         </span><br><span class="line">       &#125;  </span><br><span class="line">    <span class="comment">//在这里可以设置一点击就让提示隐藏什么的，有时候是用一个大文本框居中提示就可以在</span></span><br><span class="line">         </span><br><span class="line">       <span class="meta">@Override</span>  </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeTextChanged</span><span class="params">(CharSequence text, <span class="type">int</span> start, <span class="type">int</span> count,<span class="type">int</span> after)</span> &#123;  </span><br><span class="line">       <span class="comment">//text  输入框中改变前的字符串信息  </span></span><br><span class="line">       <span class="comment">//start 输入框中改变前的字符串的起始位置  </span></span><br><span class="line">       <span class="comment">//count 输入框中改变前后的字符串改变数量一般为0  </span></span><br><span class="line">       <span class="comment">//after 输入框中改变后的字符串与起始位置的偏移量  </span></span><br><span class="line">       </span><br><span class="line">       &#125;  </span><br><span class="line">         </span><br><span class="line">       <span class="meta">@Override</span>  </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterTextChanged</span><span class="params">(Editable edit)</span> &#123;  </span><br><span class="line">       <span class="comment">//edit  输入结束呈现在输入框中的信息  </span></span><br><span class="line">      </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h4 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h4><p>android:scaleType&#x3D;“center”<br>(1)当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按照图片的原大小居中显示，不缩放，用ImageView的大小截取图片的居中部分。</p><p>(2)当图片小于ImageView的宽高：直接居中显示该图片。</p><p>2 android:scaleType&#x3D;“centerCrop”</p><p>(1)当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按比例缩小图片，直到图片的宽高有一边等于ImageView的宽高，则对于另一边，图片的长度大于或等于ImageView的长度，最后用ImageView的大小居中截取该图片。</p><p>(2)当图片小于ImageView的宽高：以图片的中心店和ImageView的中心点为基准，按比例扩大图片，直到图片的宽高大于或等于ImageView的宽高，并按ImageView的大小居中截取该图片。</p><p>3 android:scaleType&#x3D;“centerInside”</p><p>(1)当图片大于ImageView的宽高：以图片的中心和ImageView的中心点为基准，按比例缩小图片，使图片宽高等于或者小于ImagevView的宽高，直到将图片的内容完整居中显示。<br>(2)当图片小于ImageView的宽高：直接居中显示该图片。</p><p>4 android:scaleType&#x3D;“fitCenter”</p><p>表示把图片按比例扩大（缩小）到ImageView的宽度，居中显示。<br>5 android:scaleType&#x3D;“fitStart”</p><p>表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的上方显示。</p><p>6 android:scaleType&#x3D;“fitEnd”</p><p>表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的下方显示。</p><p>7 android:scaleType&#x3D;“fitXY”</p><p>表示把图片按指定的大小在ImageView中显示，拉伸或收缩图片，不保持原比例，填满ImageView。<br>8 android:scaleType&#x3D;“matrix”<br>表示不改变原图的大小，从ImageView的左上角开始绘制原图，原图超过ImageView的部分作裁剪处理。 用矩阵来绘制，动态缩小放大图片来显示。</p><h4 id="几种Button"><a href="#几种Button" class="headerlink" title="几种Button"></a>几种Button</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让Button中书写的英文不全为大写</span></span><br><span class="line">android:textAllCaps=<span class="string">&quot;false</span></span><br><span class="line"><span class="string">//取消Button边框</span></span><br><span class="line"><span class="string">style=&quot;</span>?android:attr/borderlessButtonStyle<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p><strong>RadioButton和RadioGroup(本质是线性布局)</strong></p><p>单选选择框，搭配<strong>RadioGroup</strong>使用，RadioButton通过<code>android:checked</code>属性判断是否选中，一开始都为不选中状态，一旦选中将无法取消，只能选择其他的，<strong>但个人感觉可以一开始设计选择第一个，如果用户不选择则默认选择第一个，这样子还可以避免判断是否选择的情况，但不知道交互上哪个更好</strong></p><p><strong>RadioGroup中一个按钮被选中后checked属性将为true，其他的button属性为false，<code>android:button = &quot;&quot;</code>属性设为@null则没有圆点了</strong></p><p><strong>要根据是否选中改变RadioButton的drawableTop的图片可以新建一个drawable文件设置给这个属性，如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;selector xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=<span class="string">&quot;@drawable/home_icon_normal&quot;</span> android:state_checked=<span class="string">&quot;false&quot;</span>/&gt;</span><br><span class="line">    &lt;item android:drawable=<span class="string">&quot;@drawable/home_icon_checked&quot;</span> android:state_checked=<span class="string">&quot;true&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/selector&gt;</span><br><span class="line"><span class="comment">//然后</span></span><br><span class="line">android:drawableTop=<span class="string">&quot;@drawable/btn1_background&quot;</span></span><br><span class="line"><span class="comment">//字体同样，运用即可</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;selector xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:color=<span class="string">&quot;@color/black&quot;</span> android:state_checked=<span class="string">&quot;false&quot;</span>/&gt;</span><br><span class="line">    &lt;item android:color=<span class="string">&quot;@color/blue_02C4FF&quot;</span> android:state_checked=<span class="string">&quot;true&quot;</span>/&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/selector&gt;    </span><br></pre></td></tr></table></figure><p>使用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布局   </span></span><br><span class="line"> &lt;RadioGroup</span><br><span class="line">        android:id=<span class="string">&quot;@+id/radio_group_gender&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:orientation=<span class="string">&quot;horizontal&quot;</span></span><br><span class="line">        android:layout_alignStart=<span class="string">&quot;@id/edittext_id&quot;</span></span><br><span class="line">        android:layout_below=<span class="string">&quot;@id/textview_gander&quot;</span>&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;RadioButton</span><br><span class="line">            android:id=<span class="string">&quot;@+id/radiobutton_gender_man&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;男&quot;</span></span><br><span class="line">            android:textSize=<span class="string">&quot;20sp&quot;</span>/&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;RadioButton</span><br><span class="line">            android:id=<span class="string">&quot;@+id/radiobutton_gender_woman&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;女&quot;</span></span><br><span class="line">            android:textSize=<span class="string">&quot;20sp&quot;</span></span><br><span class="line">            android:layout_marginStart=<span class="string">&quot;25dp&quot;</span>/&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/RadioGroup&gt;</span><br><span class="line">                </span><br><span class="line"><span class="comment">//Activity中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> gender;</span><br><span class="line">        <span class="type">RadioGroup</span> <span class="variable">radioGroup_gander</span> <span class="operator">=</span> findViewById(R.id.radio_group_gender);</span><br><span class="line">        radioGroup_gender.setOnCheckedChangeListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;NonConstantResourceId&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCheckedChanged</span><span class="params">(RadioGroup radioGroup, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.radiobutton_gender_man:</span><br><span class="line">                gender = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.radiobutton_gender_woman:</span><br><span class="line">                gender = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">                gender = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//当然也可以不监听，因为监听是为了做更复杂的操作而去建议监听的，借助它只能2选1的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> gender;</span><br><span class="line">        <span class="type">RadioButton</span> <span class="variable">radioButton_gender_man</span> <span class="operator">=</span> findViewById(R.id.radiobutton_gender_man);</span><br><span class="line">        <span class="type">RadioButton</span> <span class="variable">radioButton_gender_woman</span> <span class="operator">=</span> findViewById(R.id.radiobutton_gender_woman);</span><br><span class="line">        <span class="keyword">if</span> (radioButton_gender_man.isChecked())&#123;</span><br><span class="line">            gender = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (radioButton_gender_woman.isChecked())&#123;</span><br><span class="line">            gender = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> gender = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>自定义</p><p>一个为灰色边框内部为白色，点击为蓝色打勾</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_checked</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/bg_rbtn_activate_membership_selected&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_enabled</span>=<span class="string">&quot;false&quot;</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/bg_rbtn_activate_membership_normal&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/bg_rbtn_activate_membership_normal_bottom&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span> <span class="attr">android:shape</span>=<span class="string">&quot;oval&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">stroke</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:color</span>=<span class="string">&quot;@color/gray_979797&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:width</span>=<span class="string">&quot;1dp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">android:height</span>=<span class="string">&quot;24dp&quot;</span> <span class="attr">android:tint</span>=<span class="string">&quot;#FFFFFF&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:viewportHeight</span>=<span class="string">&quot;24&quot;</span> <span class="attr">android:viewportWidth</span>=<span class="string">&quot;24&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:width</span>=<span class="string">&quot;24dp&quot;</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">android:fillColor</span>=<span class="string">&quot;@android:color/white&quot;</span> <span class="attr">android:pathData</span>=<span class="string">&quot;M12,2C6.47,2 2,6.47 2,12s4.47,10 10,10 10,-4.47 10,-10S17.53,2 12,2z&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">android:height</span>=<span class="string">&quot;24dp&quot;</span> <span class="attr">android:tint</span>=<span class="string">&quot;#3C85FF&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:viewportHeight</span>=<span class="string">&quot;24&quot;</span> <span class="attr">android:viewportWidth</span>=<span class="string">&quot;24&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:width</span>=<span class="string">&quot;24dp&quot;</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">android:fillColor</span>=<span class="string">&quot;@android:color/white&quot;</span> <span class="attr">android:pathData</span>=<span class="string">&quot;M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM10,17l-5,-5 1.41,-1.41L10,14.17l7.59,-7.59L19,8l-9,9z&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em><strong>Checkbox</strong></em></p><p>支持多选的选择框</p><h4 id="万能RecyclerView"><a href="#万能RecyclerView" class="headerlink" title="万能RecyclerView"></a>万能RecyclerView</h4><p>GitHub</p><p><code>https://github.com/youlookwhat/ByRecyclerView/wiki</code></p><ul><li><p><strong><code>ListView</code> 和 <code>GridView</code> 的加强版</strong></p></li><li><p><strong>显示大量数据，减少内存占用量</strong></p></li></ul><p><strong>类ListVeiw功能</strong></p><ol><li>先在布局文件添加<code>RecyclerView</code>控件，然后在Activity中拿到控件</li><li>然后准备数据，可以通过活动传给Adapter，也可以直接在Adapter里面直接准备，一般以第一种方式实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先要知道准备的是什么类型的数据，创建Bean类和List</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> image;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getImage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setImage</span><span class="params">(<span class="type">int</span> image)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.image = image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity中准备数据</span></span><br><span class="line">        List&lt;Item&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Item</span>();</span><br><span class="line">            item.setImage(R.mipmap.student);</span><br><span class="line">            item.setMessage(<span class="string">&quot;这是第&quot;</span>+i+<span class="string">&quot;个条目&quot;</span>);</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//调用自己写好的Adapter里面的方法</span></span><br><span class="line">mAdapter.getData(list);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//然后要把每个条目的视图创建出来，就是一个layout布局文件</span></span><br><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;ImageView</span><br><span class="line">            android:id=<span class="string">&quot;@+id/imageview_item&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;100dp&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;100dp&quot;</span></span><br><span class="line">            android:scaleType=<span class="string">&quot;fitXY&quot;</span></span><br><span class="line">            android:padding=<span class="string">&quot;10dp&quot;</span></span><br><span class="line">            android:src=<span class="string">&quot;@mipmap/student&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=<span class="string">&quot;@+id/textview_item&quot;</span></span><br><span class="line">            android:layout_marginStart=<span class="string">&quot;20dp&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;250dp&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;100dp&quot;</span></span><br><span class="line">            android:textSize=<span class="string">&quot;20sp&quot;</span></span><br><span class="line">            android:textStyle=<span class="string">&quot;bold&quot;</span></span><br><span class="line">            android:gravity=<span class="string">&quot;center&quot;</span></span><br><span class="line">            android:padding=<span class="string">&quot;10dp&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;条目&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">                </span><br><span class="line"><span class="comment">//接下来创建适配器</span></span><br><span class="line"><span class="comment">/*ecyclerView.Adapter要求有ViewHolder，这里一般用内部类RecyclerViewAdapter.ViewHolder</span></span><br><span class="line"><span class="comment">就是创建适配器名.ViewHolder的内部类，这里先一键创建ViewHolder再构造Adapter，然后都是一键自动构造就行*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecyclerViewAdapter</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Item&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 从外部得到数据</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(List&lt;Item&gt; list)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这个方法是用来创建内部的Holder的，就是每个条目的View，每个条目长什么样</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup parent, <span class="type">int</span> viewType)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewHolder</span>(View.inflate(parent.getContext(), R.layout.item, <span class="literal">null</span>));</span><br><span class="line">        <span class="keyword">return</span> viewHolder;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 这个方法是绑定内部Holder的，一般用来设置数据</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        holder.mImageView.setImageResource(list.get(position).getImage());</span><br><span class="line">        holder.mTextView.setText(list.get(position).getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 这个方法是用类设置数据数量的</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ViewHolder &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ImageView mImageView;</span><br><span class="line">        <span class="keyword">private</span> TextView mTextView;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ViewHolder</span><span class="params">(<span class="meta">@NonNull</span> View itemView)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(itemView);</span><br><span class="line"></span><br><span class="line">            mImageView = itemView.findViewById(R.id.imageview_item);</span><br><span class="line">            mTextView = itemView.findViewById(R.id.textview_item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//之后要创建LayoutManager，Adapter并把数据关联起来</span></span><br><span class="line">        <span class="type">RecyclerView</span> <span class="variable">recyclerView</span> <span class="operator">=</span> findViewById(R.id.recyclerview);</span><br><span class="line">        <span class="type">LinearLayoutManager</span> <span class="variable">layoutManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinearLayoutManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        recyclerView.setLayoutManager(layoutManager);</span><br><span class="line">        mAdapter = <span class="keyword">new</span> <span class="title class_">RecyclerViewAdapter</span>();</span><br><span class="line">        intiData();<span class="comment">//自己封装的准备和设置数据的方法</span></span><br><span class="line">        recyclerView.setAdapter(mAdapter);</span><br></pre></td></tr></table></figure><h4 id="DatePicker-时间选择器"><a href="#DatePicker-时间选择器" class="headerlink" title="DatePicker(时间选择器)"></a>DatePicker(时间选择器)</h4><table><thead><tr><th align="center">属性</th><th align="center">描述和使用</th></tr></thead><tbody><tr><td align="center"><code>android:datePickerMode=&quot;&quot;</code></td><td align="center">时间选择器有<code>spinner</code>和<code>calendar</code>两种模式，这个属性是用来设置模式的，<code>spinner</code>是直接选择日期，没有日历，<code>calendar</code>是带日历模式</td></tr><tr><td align="center"><code>android:calendarViewShown=&quot;&quot;</code></td><td align="center">这个属性是设置日历是否可见的，有<code>true</code>和<code>false</code>可选，和模式一起设置成自己想要的，貌似有冲突</td></tr><tr><td align="center"><code>android:spinnersShown=&quot;&quot;</code></td><td align="center">这个属性是设置直接选择的框是否可见，有<code>true</code>和<code>false</code>可选，和模式一起设置成自己想要的，貌似有冲突</td></tr><tr><td align="center"><code>android:calendarTextColor=&quot;&quot;</code></td><td align="center">设置日历列表文字的颜色</td></tr><tr><td align="center"><code>android:dayOfWeekTextAppearance</code></td><td align="center">顶部星期几的文字颜色</td></tr><tr><td align="center"><code>android:endYear</code></td><td align="center">去年(内容)</td></tr><tr><td align="center"><code>android:firstDayOfWeek</code></td><td align="center">设置日历列表以星期几开头</td></tr><tr><td align="center"><code>android:headerBackground</code></td><td align="center">整个头部的背景颜色</td></tr><tr><td align="center"><code>android:headerDayOfMonthTextAppearance</code></td><td align="center">头部日期字体的颜色</td></tr><tr><td align="center"><code>android:headerMonthTextAppearance</code></td><td align="center">头部月份的字体颜色</td></tr><tr><td align="center"><code>android:headerYearTextAppearance</code></td><td align="center">头部年的字体颜色</td></tr><tr><td align="center"><code>android:maxDate</code></td><td align="center">最大日期显示在这个日历视图mm &#x2F; dd &#x2F; yyyy格式</td></tr><tr><td align="center"><code>android:minDate</code></td><td align="center">最小日期显示在这个日历视图mm &#x2F; dd &#x2F; yyyy格式</td></tr><tr><td align="center"><code>android:yearListItemTextAppearance</code></td><td align="center">列表的文本出现在列表中。</td></tr><tr><td align="center"><code>android:yearListSelectorColor</code></td><td align="center">年列表选择的颜色</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;DatePicker</span><br><span class="line">        android:id=<span class="string">&quot;@+id/datePickerView&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:calendarViewShown=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:datePickerMode=<span class="string">&quot;calendar&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;center_horizontal&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.user.datapicker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.widget.DatePicker;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    DatePicker datePicker;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> year,mouth,day,hour,min;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        datePicker = (DatePicker)findViewById(R.id.datePickerView);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get time,可以在oncreate方法中初始化完成成为全局变量再在监听方法里面使用，这个是Calender模式下使用方法</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        year = cal.get(Calendar.YEAR);</span><br><span class="line">        mouth =  cal.get(Calendar.MONTH);</span><br><span class="line">        day = cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        hour = cal.get(Calendar.HOUR);</span><br><span class="line">        min = cal.get(Calendar.MINUTE);</span><br><span class="line"></span><br><span class="line">        datePicker.init(year, mouth, day, <span class="keyword">new</span> <span class="title class_">DatePicker</span>.OnDateChangedListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDateChanged</span><span class="params">(DatePicker view, <span class="type">int</span> year, <span class="type">int</span> monthOfYear, <span class="type">int</span> dayOfMonth)</span> &#123;</span><br><span class="line">                MainActivity.<span class="built_in">this</span>.year = year;</span><br><span class="line">                MainActivity.<span class="built_in">this</span>.mouth = monthOfYear;</span><br><span class="line">                MainActivity.<span class="built_in">this</span>.day = dayOfMonth;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//显示用户选择的日期</span></span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>,year + <span class="string">&quot;年&quot;</span> + monthOfYear + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Spnner模式，用这个啊，监听蛇皮</span></span><br><span class="line">        <span class="type">DatePicker</span> <span class="variable">datePicker</span> <span class="operator">=</span> findViewById(R.id.date_picker);</span><br><span class="line">        year = datePicker.getYear();</span><br><span class="line">        month = datePicker.getMonth();</span><br><span class="line">        day = datePicker.getDayOfMonth();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            date.append(year);</span><br><span class="line">            date.append(<span class="string">&quot;年&quot;</span>);</span><br><span class="line">            date.append(month + <span class="number">1</span>);<span class="comment">//月份一开始从0开始，要加1</span></span><br><span class="line">            date.append(<span class="string">&quot;月&quot;</span>);</span><br><span class="line">            date.append(day);</span><br><span class="line">            date.append(<span class="string">&quot;日&quot;</span>);</span><br></pre></td></tr></table></figure><p>####ViewPager2(轮播图)</p><p>GitHub</p><p><code>https://github.com/zhpanvip/BannerViewPager/wiki/06.快速开始</code>&#x2F;&#x2F;轮播图</p><p><code>implementation &#39;com.github.zhpanvip:bannerviewpager:3.5.11</code>&#x2F;&#x2F;依赖不能按照作者那里写latestVersion，Item的布局必须是”match_parent，嵌套在ScrollView里面会变形</p><p><code>https://github.com/zhpanvip/viewpagerindicator</code>&#x2F;&#x2F;轮播图指示器</p><ul><li><strong>滑动视图或者滑动Fragment</strong></li><li><strong>放Fragment继承<code>FragmentStateAdapter</code>，放图片继承<code>RecyclerView.Adapter&lt;ViewHolder&gt;</code>，监听方法<code>registerOnPageChangeCallback</code></strong></li></ul><p><a href="https://blog.csdn.net/m0_61544080/article/details/120642180">(26条消息) 学不动也要学！ ViewPager2新特性_程序员巴士的博客-CSDN博客_viewpager2滑动监听</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去掉边缘阴影，上下暂时没找到去掉的方法，可以把theme里面颜色换掉</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先先导入ViewPager2的库</span></span><br><span class="line">implementation <span class="string">&quot;androidx.viewpager2:viewpager2:1.0.0&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*ViewPager2只相当于一个容器，可以放View也可以放Fragment,要放置什么数据需要我们去设置，</span></span><br><span class="line"><span class="comment">这时候就需要我们去写一个Adapter适配器去设置要显示的内容*/</span></span><br><span class="line"><span class="comment">/*ViewPager2是根据RecyclerView改变过来的，这里继承的方法也跟RecyclerView的适配器创建方法类似，</span></span><br><span class="line"><span class="comment">* 这里需要传入一个&lt;&gt;范型，这里设置内部类去构建就可以，构建方法就是最后那个方法*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewPagerAdapter</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.Adapter&lt;ViewPagerAdapter.ViewHolder&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在内部设置一个方法用来从Activity获取数据给Adapter，当然也可以直接在Adapter里面设置数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">(List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是用来获取一个View的，新建一个xml文件获取过来，这样子在下面的内部类ViewHolder就可以获取到View里面的控件</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup parent, <span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">        <span class="type">ViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewHolder</span>(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_viewpager,parent,<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">return</span> viewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是根据position设置view的，这里用position%list。size()实现循环</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        holder.mImageView.setImageResource(list.get(position%list.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ViewHolder &#123;</span><br><span class="line"></span><br><span class="line">        ImageView mImageView;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ViewHolder</span><span class="params">(<span class="meta">@NonNull</span> View itemView)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(itemView);</span><br><span class="line">            mImageView = itemView.findViewById(R.id.imageview);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                 </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布局，其中的LinearLayout放置点的</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;.SecondActivity&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;androidx.viewpager2.widget.ViewPager2</span><br><span class="line">        android:id=<span class="string">&quot;@+id/viewpager2&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;300dp&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;200dp&quot;</span></span><br><span class="line">        android:layout_centerInParent=<span class="string">&quot;true&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/linear&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;40dp&quot;</span></span><br><span class="line">        android:layout_below=<span class="string">&quot;@id/viewpager2&quot;</span></span><br><span class="line">        android:layout_centerHorizontal=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:orientation=<span class="string">&quot;horizontal&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler handler;</span><br><span class="line">    <span class="keyword">private</span> ViewPager2 mViewPager2;</span><br><span class="line">    <span class="keyword">private</span> Runnable mRunnable;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_second);</span><br><span class="line"></span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;UseCompatLoadingForDrawables&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initView</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">LinearLayout</span> <span class="variable">linear</span> <span class="operator">=</span> findViewById(R.id.linear);</span><br><span class="line">        mViewPager2 = findViewById(R.id.viewpager2);</span><br><span class="line">        <span class="type">ViewPagerAdapter</span> <span class="variable">viewPagerAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewPagerAdapter</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置数据</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(R.mipmap.pic1);</span><br><span class="line">        list.add(R.mipmap.pic2);</span><br><span class="line">        list.add(R.mipmap.pic3);</span><br><span class="line">        list.add(R.mipmap.pic4);</span><br><span class="line">        list.add(R.mipmap.pic5);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据图片个数设置点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            LinearLayout.<span class="type">LayoutParams</span> <span class="variable">layoutParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinearLayout</span>.LayoutParams(<span class="number">40</span>,<span class="number">40</span>);</span><br><span class="line">            <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">View</span>(<span class="built_in">this</span>);</span><br><span class="line">            view.setBackground(getDrawable(R.drawable.point_viewpager_normal));</span><br><span class="line">            view.setLayoutParams(layoutParams);</span><br><span class="line">            layoutParams.setMarginStart(<span class="number">20</span>);</span><br><span class="line">            linear.addView(view);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//给ViewPager2设置监听，可优化，自己优化吧</span></span><br><span class="line">        mViewPager2.registerOnPageChangeCallback(<span class="keyword">new</span> <span class="title class_">ViewPager2</span>.OnPageChangeCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageScrolled</span><span class="params">(<span class="type">int</span> position, <span class="type">float</span> positionOffset, <span class="type">int</span> positionOffsetPixels)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.onPageScrolled(position, positionOffset, positionOffsetPixels);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==position%list.size())&#123;</span><br><span class="line">                        linear.getChildAt(i).setBackground(getDrawable(R.drawable.point_viewpager_checked));</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        linear.getChildAt(i).setBackground(getDrawable(R.drawable.point_viewpager_normal));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//给适配器传数据</span></span><br><span class="line">        viewPagerAdapter.getData(list);</span><br><span class="line">        mViewPager2.setAdapter(viewPagerAdapter);</span><br><span class="line">        mViewPager2.setCurrentItem(<span class="number">200</span>,<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置不可人为滑动，这样子不用再去写人为滑动时停止轮播了</span></span><br><span class="line">        mViewPager2.setUserInputEnabled(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//handler里面的Runable再执行一次Handler实现循环</span></span><br><span class="line">        handler = <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line">        mRunnable = ()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> mViewPager2.getCurrentItem();</span><br><span class="line">            mViewPager2.setCurrentItem(++current);</span><br><span class="line"></span><br><span class="line">            handler.postDelayed(mRunnable,<span class="number">2000</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//界面显示开始轮播</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAttachedToWindow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onAttachedToWindow();</span><br><span class="line">        handler.postDelayed(mRunnable,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//界面进入后台停止轮播</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDetachedFromWindow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDetachedFromWindow();</span><br><span class="line">        handler.removeCallbacks(mRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h4 id="TabLayout"><a href="#TabLayout" class="headerlink" title="TabLayout"></a>TabLayout</h4><table><thead><tr><th align="center">属性</th><th align="center">用法</th></tr></thead><tbody><tr><td align="center"><code>app:tabMode=&quot;scrollable&quot;</code></td><td align="center">**<code>fixed</code><strong>固定的，也就是标题不可滑动，无论放了多少个都平分界面长度,</strong><code> scrollable</code><strong>可滑动的，小于等于5个默认靠左固定，大于5个就可以滑动了，</strong><code>auto</code>**自动选择是否可以滑动，小于等于5个默认居中，大于5个自动滑动</td></tr><tr><td align="center"><code>app:tabGravity</code></td><td align="center">**<code>start</code><strong>居左，</strong><code>fill</code><strong>平均分配，铺满屏幕宽度</strong><code>center</code>**居中，默认fill，tab填满TabLayout,但<code>tabMode=“fixed”</code>才生效</td></tr><tr><td align="center"><code>&lt;attr name=&quot;tabTextColor&quot; format=&quot;color&quot;/&gt;</code></td><td align="center">Tab未选中字体颜色</td></tr><tr><td align="center"><code>&lt;attr name=&quot;tabSelectedTextColor&quot; format=&quot;color&quot;/&gt;</code></td><td align="center">Tab选中字体颜色</td></tr><tr><td align="center"><code>&lt;attr name=&quot;tabMinWidth&quot; format=&quot;dimension&quot;/&gt;</code></td><td align="center">Tab最小宽度</td></tr><tr><td align="center"><code>attr name=&quot;tabIndicatorColor&quot; format=&quot;color&quot;</code></td><td align="center">指示器颜色</td></tr><tr><td align="center"><code>attr name=&quot;tabIndicatorHeight&quot; format=&quot;dimension&quot;</code></td><td align="center">指示器高度</td></tr><tr><td align="center"><code>attr name=&quot;tabIndicatorFullWidth&quot; format=&quot;boolean&quot;</code></td><td align="center">指示器宽度 true:和tab同宽  false：和tab中的字同宽</td></tr><tr><td align="center"><code>attr name=&quot;tabBackground&quot; format=&quot;reference&quot;</code></td><td align="center">仅是Tab背景，设置TabLayout背景用<code>android:background</code></td></tr><tr><td align="center"><code>attr name=&quot;tabContentStart&quot; format=&quot;dimension&quot;</code></td><td align="center">tabs距TabLayout开始位置的偏移量，但<code>app:tabMode=&quot;scrollable&quot;</code>才生效</td></tr></tbody></table><p>Java中添加Tab  <code>TabLayout.addTab(TabLayout.newTab().setText(&quot;222&quot;));</code>，注意<code>addTab</code>里面传的参数是<code>控件名.newTab()</code></p><p>Java中设置某个被选中，其他会自动不被选中，代码为<code>TabLayout.getTabAt(1).select();</code></p><h4 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h4><p>进度条</p><h4 id="Spinner（下拉选择框，Android微调器）"><a href="#Spinner（下拉选择框，Android微调器）" class="headerlink" title="Spinner（下拉选择框，Android微调器）"></a>Spinner（下拉选择框，Android微调器）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标签</span></span><br><span class="line">&lt;Spinner</span><br><span class="line"><span class="comment">//下面这个androidx兼容</span></span><br><span class="line">&lt;androidx.appcompat.widget.AppCompatSpinner</span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用开源库实现更多功能</span></span><br><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">        maven &#123; url <span class="string">&quot;https://jitpack.io&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//在gradle设置中下面那部分去加，不行把mavenCentral()这个删掉然后同步完再加回来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*arrowTint设置下拉箭头上的颜色</span></span><br><span class="line"><span class="comment">hideArrow设置是显示还是隐藏下拉箭头</span></span><br><span class="line"><span class="comment">arrowDrawable设置下拉箭头的可绘制对象</span></span><br><span class="line"><span class="comment">textTint设置文本颜色</span></span><br><span class="line"><span class="comment">dropDownListPaddingBottom设置下拉列表的底部填充</span></span><br><span class="line"><span class="comment">backgroundSelector设置下拉列表行的背景选择器</span></span><br><span class="line"><span class="comment">popupTextAlignment设置默认弹出文本的水平对齐方式</span></span><br><span class="line"><span class="comment">entries从字符串数组设置数据源*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定数据方法</span></span><br><span class="line"><span class="type">NiceSpinner</span> <span class="variable">niceSpinner</span> <span class="operator">=</span> (NiceSpinner) findViewById(R.id.nice_spinner);</span><br><span class="line"> List&lt;String&gt; dataset = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>));</span><br><span class="line"> niceSpinner.attachDataSource(dataset);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">spinner.setOnSpinnerItemSelectedListener(<span class="keyword">new</span> <span class="title class_">OnSpinnerItemSelectedListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onItemSelected</span><span class="params">(NiceSpinner parent, View view, <span class="type">int</span> position, <span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// This example uses String, but your type can be any</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> parent.getItemAtPosition(position);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>三种使用方式</strong></p><p><em>第一种：</em></p><p>数据固定的，通过 <code>android:entries</code> 属性引数组来进行填充，在 <code>values</code> 下建一个 <code>arrays.xml</code> ,在这里面填充，或者直接在values包下<code>strings.xml</code>的resources标签下添加,实例在下面代码框</p><p><code>android:spinnerMode=”dialog”</code>表示<code>Spinner</code>的样式是<code>dialog</code>，<code>android:prompt</code>可以设置dialog的标题(注意必须在string资源下引用，不然程序会崩掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;string-array name=<span class="string">&quot;city_name&quot;</span>&gt;</span><br><span class="line">        &lt;item&gt;湛江&lt;/item&gt;</span><br><span class="line">        &lt;item&gt;北京&lt;/item&gt;</span><br><span class="line">&lt;/string-array&gt;</span><br></pre></td></tr></table></figure><p><em>第二种：</em></p><p>通过适配器来填充参数，继承<code>BaseAdapter</code></p><p><a href="https://www.jb51.net/article/219855.htm">Android之Spinner用法详解_Android_脚本之家 (jb51.net)</a></p><p><em>第三种：</em></p><p>实现<code>SpinnerAdaper</code>接口，其实跟继承<code>BaseAdapter</code>差不多</p><p><strong>设置样式</strong></p><p>在<code>values</code>包下新建<code>style.xml</code>用来专门保存样式，按钮什么的样式也可以集中放到这里来</p><p>不知道什么原因，自带spinner生效不了，nice—spinner可以生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    &lt;style name=<span class="string">&quot;CitySpinnerStyle&quot;</span>&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;android:divider&quot;</span>&gt;#A9A9A9&lt;/item&gt;<span class="comment">//下划线</span></span><br><span class="line">        &lt;item name=<span class="string">&quot;android:dividerHeight&quot;</span>&gt;2dp&lt;/item&gt;<span class="comment">//下划线宽度</span></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//android:theme=&quot;@style/CitySpinnerStyle&quot;在xml进行设置</span></span><br></pre></td></tr></table></figure><h4 id="NestedScrollView和ScrollView"><a href="#NestedScrollView和ScrollView" class="headerlink" title="NestedScrollView和ScrollView"></a>NestedScrollView和ScrollView</h4><p>NestedScrollView能够判断滚动视图完成哪个，滑动顺畅，使用这个即可</p><h3 id="Activity相关"><a href="#Activity相关" class="headerlink" title="Activity相关"></a>Activity相关</h3><p><strong><code>android:exported = true</code></strong>  </p><p>true表示可以被其他Activity启动</p><h4 id="生命周期相关"><a href="#生命周期相关" class="headerlink" title="生命周期相关"></a>生命周期相关</h4><p><img src="https://img-blog.csdnimg.cn/20190519191255469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70"></p><p>1）横竖屏切换对Activiy生命周期影响<br>横竖屏切换涉及到的是Activity的android:configChanges属性：<br>android:configChanges可以设置的属性值有：<br>orientation：消除横竖屏的影响<br>keyboardHidden：消除键盘的影响<br>screenSize：消除屏幕大小的影响<br>【情况1】<br>1、android:configChanges&#x3D;orientation<br>2、android:configChanges&#x3D;orientation|keyboardHidden<br>3、不设置android:configChanges<br>横竖屏切换Activity生命周期变化：<br>onPause–&gt;onSaveInstanceState–&gt;onStop–&gt;onDestroy–&gt;onCreate–&gt;onStart–&gt;onRestoreInstanceState–&gt;onResume<br>在进行横竖屏切换的时候在调用onStop之前会调用onSaveInstanceState来进行Activity的状态保存，随后在重新显示该Activity的onResume方法之前会调用onRestoreInstanceState来恢复之前由onSaveInstanceState保存的Activity信息<br>【情况2】<br>1、android:configChanges&#x3D;orientation|screenSize<br>2、android:configChanges&#x3D;orientation|screenSize|keyboardHidden<br>横竖屏切换不会重新加载Activity的各个生命周期，<strong>一定要同时出现orientation和screenSize</strong><br>【情况3】<br>屏蔽横竖屏切换操作，不会出现切换的过程中Activity生命周期重新加载的情况<br>方法1：清单文件<br>android:screenOrientation&#x3D;“portrait” 始终以竖屏显示<br>android:screenOrientation&#x3D;“landscape” 始终以横屏显示<br>方法2：动态Activity<br>Activity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);以竖屏显示<br>Activity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);以横屏显示</p><h4 id="跳转传值"><a href="#跳转传值" class="headerlink" title="跳转传值"></a>跳转传值</h4><ol><li>普通跳转和跳转网页</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在内部方法中才需要Activity.this,不然.this就好</span></span><br><span class="line"><span class="comment">//直接在onCreate方法中写</span></span><br><span class="line"><span class="comment">//显性跳转自己这个App界面</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>,MainActivity2.class);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//跳转网页或者其他APP界面（隐式跳转）</span></span><br><span class="line"><span class="comment">//再Manifest文件中设置</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction();<span class="comment">//隐性跳转必须有这个</span></span><br><span class="line">intent.addCategory();<span class="comment">/*隐性跳转可以不设置这个，系统会使用默认值，所以要使匹配一样就必须在Manifest文件中设置这个属性为默认或者你想要的值*/</span></span><br><span class="line">intent.setData();<span class="comment">/*跳转网页用这个，并设置setAction为Intent.ACTION_VIEW，intent.setData(Uri.parse(&quot;https://www.baidu.com&quot;));*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Manifest设置属性，下面这个复制在哪个Activity，哪个就作为先启动的，属性也在这个属性里面设置</span></span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;category android:name=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>带值传递不需要处理返回值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传值</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>,MainActivity2.class);</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putInt(<span class="string">&quot;result&quot;</span>,<span class="number">1</span>);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收值</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> intent.getExtras();</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> bundle.getInt(<span class="string">&quot;result&quot;</span>);</span><br></pre></td></tr></table></figure><p><em><strong>Bundle相关</strong></em></p><p>Bundle在Android开发中非常常见，它的作用主要时用于传递数据。Bundle传递的数据包括：string、int、boolean、byte、float、long、double等基本类型或它们对应的数组，也可以是对象或对象数组。当Bundle传递的是对象或对象数组时，必须实现Serialiable或Parcelable接口。<br>Bundle所保存的数据是以key-value(键值对)的形式保存在ArrayMap中，处理少量简单数据比hashmap快，处理大量数据用hashmap</p><p>Bundle使用场景<br>Activity之onSaveInstanceState<br>Activity状态数据的保存与恢复，涉及到两个回调：<br>①void onSaveInstanceState(Bundle outState)；② void onCreate(Bundle savedInstanceState)；<br>参考：Android系统之onSaveInstanceState用法及源码分析</p><p>Fragment之setArguments<br>Fragment的setArguments方法：void setArgument(Bundle args)；<br>参考：Android系统之Fragment用法</p><p>Handle之setData<br>消息机制中的Message的setData方法：void setData(Bundle data)。<br>参考：Android系统线程间通信方式之Handler机制</p><ol start="3"><li>带值传递且需要处理返回值（登陆界面跳转注册界面注册成功带账号密码返回登陆界面）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*startActivityForResult方法弃用了，用registerForActivityResult方法，这个方法只能在oncreate方法中先构造，不能在onstart方法后再构造，也不能在注册监听事件的onclick方法中构造*/</span></span><br><span class="line"><span class="keyword">private</span> ActivityResultLauncher&lt;Intent&gt; intentActivityResultLauncher;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下可以写在一个内部方法中，然后在oncreate方法中调用内部方法,如果跳转活动有传值，那么在返回这个活动时会调用</span></span><br><span class="line">        intentActivityResultLauncher = registerForActivityResult(<span class="keyword">new</span> <span class="title class_">ActivityResultContracts</span>.StartActivityForResult(), result1 -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> result1.getResultCode();</span><br><span class="line">            <span class="type">Intent</span> <span class="variable">data</span> <span class="operator">=</span> result1.getData();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后在监听事件中调用全局变量跳转。launch方法</span></span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putInt(<span class="string">&quot;result&quot;</span>, result);</span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(LoginActivity.<span class="built_in">this</span>, RegisterActivity.class);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">intentActivityResultLauncher.launch(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在跳转的活动中，用setResult方法回传数据和结果码</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putString(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">bundle.putString(<span class="string">&quot;password&quot;</span>,password);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">setResult(<span class="number">88</span>,intent);</span><br><span class="line">finish();<span class="comment">//最后完成所有操作关闭这个界面（如网络请求登陆成功后）</span></span><br></pre></td></tr></table></figure><p><strong>传递对象</strong></p><p><strong>Serializable进行对象序列化，这种序列化是通过反射机制从而削弱了性能，这种机制创建了大量的临时对象从而会引起GC频繁回收调用资源</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">                person.setName(<span class="string">&quot;chenjy&quot;</span>);</span><br><span class="line">                person.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">                bundle.putSerializable(<span class="string">&quot;person&quot;</span>,person);</span><br><span class="line"></span><br><span class="line">                <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, SecondActivity.class);</span><br><span class="line">                intent.putExtras(bundle);</span><br><span class="line">                startActivity(intent);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数据</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)getIntent().getSerializableExtra(<span class="string">&quot;person&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Parcelable是由Android提供的序列化接口,google做了大量的优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Person</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> <span class="title class_">Creator</span>&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Person <span class="title function_">createFromParcel</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">            person.name = in.readString();</span><br><span class="line">            person.age = in.readInt();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Person[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">describeContents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">     dest.writeString(name);</span><br><span class="line">     dest.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>传输数据量较大的时候Parcelable会出现异常TransactionTooLargeException。只时候就需要用到插件EventBus。</strong></p><p>EventBus 使用的是发布 订阅者模型,发布者通过EventBus发布事件，订阅者通过EventBus订阅事件。当发布者发布事件时，订阅该事件的订阅者的事件处理方法将被调用。（后续使用到再看）</p><h3 id="Fragment相关"><a href="#Fragment相关" class="headerlink" title="Fragment相关"></a>Fragment相关</h3><p>view.findViewById()</p><p>####Fragment和其他控件一起使用实现滑动点击切换</p><p><strong>构造Fragment实例</strong></p><p>构造Fragment实例的时候可以直接new出来，也可以用生成Fragment自带的<code>newInstance()</code>方法，这个方法还可以传值，传的值可以直接在Fragment操作</p><p><strong>FragmentContainerView控件绑定Fragment和普通按钮布局实现点击切换</strong></p><p>点击改变颜色和放置不同图片什么都没什么，主要是怎么切换fragment，切换fragment就只要在点击按钮时改变传入的Fragment实例化对象即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取FragmentManager</span></span><br><span class="line"><span class="type">FragmentManager</span> <span class="variable">fragmentManager</span> <span class="operator">=</span> getSupportFragmentManager();</span><br><span class="line"><span class="comment">//这个方法构造Fragment可以传值</span></span><br><span class="line"><span class="type">FirstFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> FirstFragment.newInstance(<span class="string">&quot;这是首页&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//添加Fragment到FragmentManager</span></span><br><span class="line"><span class="type">FragmentTransaction</span> <span class="variable">fragmentTransaction</span> <span class="operator">=</span> fragmentManager.beginTransaction();</span><br><span class="line">fragmentTransaction.replace(R.id.fragment_container,fragment).commit();</span><br><span class="line"><span class="comment">//第一个参数传要绑定到这个Activity界面的FragmentContainerView控件的id，第二个参数传Fragment实例</span></span><br></pre></td></tr></table></figure><p><strong>Fragment和ViewPager2实现滑动切换效果，把Fragment换为颜色去掉底部按键就是滑动</strong></p><p><strong>设置可滑动就是微信那种，不可滑动就是QQ那种，注意手势冲突</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThirdActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">RadioGroup</span>.OnCheckedChangeListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ViewPager2 mViewPager2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_third);</span><br><span class="line"></span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initView</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RadioButton</span> <span class="variable">btn1</span> <span class="operator">=</span> findViewById(R.id.btn1);</span><br><span class="line">        <span class="type">RadioButton</span> <span class="variable">btn2</span> <span class="operator">=</span> findViewById(R.id.btn2);</span><br><span class="line">        <span class="type">RadioButton</span> <span class="variable">btn3</span> <span class="operator">=</span> findViewById(R.id.btn3);</span><br><span class="line">        <span class="type">RadioGroup</span> <span class="variable">radioGroup</span> <span class="operator">=</span> findViewById(R.id.radio_group);</span><br><span class="line">        radioGroup.setOnCheckedChangeListener(<span class="built_in">this</span>);</span><br><span class="line">        mViewPager2 = findViewById(R.id.viewpager2);</span><br><span class="line">        <span class="type">ViewPagerTopAdapter</span> <span class="variable">viewPagerTopAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewPagerTopAdapter</span>(<span class="built_in">this</span>);</span><br><span class="line">        viewPagerTopAdapter.getFragment(<span class="keyword">new</span> <span class="title class_">FirstFragment</span>());</span><br><span class="line">        viewPagerTopAdapter.getFragment(<span class="keyword">new</span> <span class="title class_">SecondFragment</span>());</span><br><span class="line">        viewPagerTopAdapter.getFragment(<span class="keyword">new</span> <span class="title class_">ThirdFragment</span>());</span><br><span class="line">        mViewPager2.setAdapter(viewPagerTopAdapter);</span><br><span class="line">        mViewPager2.setCurrentItem(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*如果设置不可滑动就不需要监听ViewPager2了</span></span><br><span class="line"><span class="comment">                mViewPager2.setUserInputEnabled(false);*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//监听滑动为第几项设置哪个按钮被选中</span></span><br><span class="line">        mViewPager2.registerOnPageChangeCallback(<span class="keyword">new</span> <span class="title class_">ViewPager2</span>.OnPageChangeCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageSelected</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.onPageSelected(position);</span><br><span class="line">                <span class="keyword">switch</span> (position)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        btn1.setChecked(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        btn2.setChecked(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        btn3.setChecked(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听按钮选择而设置Fragment</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCheckedChanged</span><span class="params">(RadioGroup radioGroup, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.btn1:</span><br><span class="line">               mViewPager2.setCurrentItem(<span class="number">0</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.btn2:</span><br><span class="line">                mViewPager2.setCurrentItem(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.btn3:</span><br><span class="line">                mViewPager2.setCurrentItem(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xml布局</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;.ThirdActivity&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;androidx.viewpager2.widget.ViewPager2</span><br><span class="line">        android:id=<span class="string">&quot;@+id/viewpager2&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;0dp&quot;</span></span><br><span class="line">        android:layout_weight=<span class="string">&quot;1&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;View</span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;2dp&quot;</span></span><br><span class="line">        android:background=<span class="string">&quot;@color/gray_dark&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;RadioGroup</span><br><span class="line">        android:id=<span class="string">&quot;@+id/radio_group&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;80dp&quot;</span></span><br><span class="line">        android:layout_alignParentBottom=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:orientation=<span class="string">&quot;horizontal&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;RadioButton</span><br><span class="line">            android:id=<span class="string">&quot;@+id/btn1&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;0dp&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_weight=<span class="string">&quot;1&quot;</span></span><br><span class="line">            android:button=<span class="string">&quot;@null&quot;</span></span><br><span class="line">            android:checked=<span class="string">&quot;true&quot;</span></span><br><span class="line">            android:drawableTop=<span class="string">&quot;@drawable/btn1_background&quot;</span></span><br><span class="line">            android:gravity=<span class="string">&quot;center&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;首页&quot;</span></span><br><span class="line">            android:textColor=<span class="string">&quot;@drawable/change_radio_button&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;RadioButton</span><br><span class="line">            android:id=<span class="string">&quot;@+id/btn2&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;0dp&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_weight=<span class="string">&quot;1&quot;</span></span><br><span class="line">            android:button=<span class="string">&quot;@null&quot;</span></span><br><span class="line">            android:drawableTop=<span class="string">&quot;@drawable/btn2_background&quot;</span></span><br><span class="line">            android:gravity=<span class="string">&quot;center&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;联系人&quot;</span></span><br><span class="line">            android:textColor=<span class="string">&quot;@drawable/change_radio_button&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;RadioButton</span><br><span class="line">            android:id=<span class="string">&quot;@+id/btn3&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;0dp&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_weight=<span class="string">&quot;1&quot;</span></span><br><span class="line">            android:button=<span class="string">&quot;@null&quot;</span></span><br><span class="line">            android:drawableTop=<span class="string">&quot;@drawable/btn3_background&quot;</span></span><br><span class="line">            android:gravity=<span class="string">&quot;center&quot;</span></span><br><span class="line">            android:text=<span class="string">&quot;设置&quot;</span></span><br><span class="line">            android:textColor=<span class="string">&quot;@drawable/change_radio_button&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/RadioGroup&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Adapter适配器</span></span><br><span class="line"><span class="comment">//放Fragment继承FragmentStateAdapter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewPagerTopAdapter</span> <span class="keyword">extends</span> <span class="title class_">FragmentStateAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先记住这种用法吧,先把Fragmen的类获取过来，后面直接newInstance返回出去</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Class&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFragment</span><span class="params">(Fragment fragment)</span>&#123;</span><br><span class="line">            list.add(fragment.getClass());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewPagerTopAdapter</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity fragmentActivity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fragmentActivity);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Fragment <span class="title function_">createFragment</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Fragment) list.get(position).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TabLayout+ViewPager2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">package</span> com.example.fragmentstudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment;</span><br><span class="line"><span class="keyword">import</span> androidx.viewpager2.widget.ViewPager2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.text.style.AlignmentSpan;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.fragmentstudy.Adapter.ViewPagerTopAdapter;</span><br><span class="line"><span class="keyword">import</span> com.example.fragmentstudy.Fragment.BlankFragment1;</span><br><span class="line"><span class="keyword">import</span> com.example.fragmentstudy.Fragment.BlankFragment2;</span><br><span class="line"><span class="keyword">import</span> com.example.fragmentstudy.Fragment.BlankFragment3;</span><br><span class="line"><span class="keyword">import</span> com.google.android.material.tabs.TabLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ViewPager2 mViewPager2;</span><br><span class="line">    <span class="keyword">private</span> TabLayout mTabLayout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HomeFragment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Required empty public constructor</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HomeFragment <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HomeFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HomeFragment</span>();</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">args</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        fragment.setArguments(args);</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span><br><span class="line"><span class="params">                             Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.fragment_home, container, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        mViewPager2 = view.findViewById(R.id.viewpager2);</span><br><span class="line">        mTabLayout = view.findViewById(R.id.tab_layout);</span><br><span class="line">        initTab();</span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//传参在Activity直接this，在Fragment中this.requireActivity()</span></span><br><span class="line">        <span class="type">ViewPagerTopAdapter</span> <span class="variable">viewPagerTopAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewPagerTopAdapter</span>(<span class="built_in">this</span>.requireActivity());</span><br><span class="line">        viewPagerTopAdapter.getFragment(<span class="keyword">new</span> <span class="title class_">BlankFragment1</span>());</span><br><span class="line">        viewPagerTopAdapter.getFragment(<span class="keyword">new</span> <span class="title class_">BlankFragment2</span>());</span><br><span class="line">        viewPagerTopAdapter.getFragment(<span class="keyword">new</span> <span class="title class_">BlankFragment3</span>());</span><br><span class="line">        mViewPager2.setAdapter(viewPagerTopAdapter);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//监听ViewPager2，设置Tab选中</span></span><br><span class="line">        mViewPager2.registerOnPageChangeCallback(<span class="keyword">new</span> <span class="title class_">ViewPager2</span>.OnPageChangeCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageSelected</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.onPageSelected(position);</span><br><span class="line">                mTabLayout.getTabAt(position).select();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置TabLayout的Tab</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initTab</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] name = &#123;<span class="string">&quot;汽车&quot;</span>, <span class="string">&quot;美食&quot;</span>, <span class="string">&quot;趣闻&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            mTabLayout.addTab(mTabLayout.newTab().setText(name[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//监听TabLayout，第一个方法有用而已</span></span><br><span class="line">        mTabLayout.addOnTabSelectedListener(<span class="keyword">new</span> <span class="title class_">TabLayout</span>.OnTabSelectedListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTabSelected</span><span class="params">(TabLayout.Tab tab)</span> &#123;</span><br><span class="line">                mViewPager2.setCurrentItem(tab.getPosition());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTabUnselected</span><span class="params">(TabLayout.Tab tab)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTabReselected</span><span class="params">(TabLayout.Tab tab)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xml布局</span></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;.HomeFragment&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.google.android.material.tabs.TabLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/tab_layout&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;50dp&quot;</span></span><br><span class="line">        app:tabMode=<span class="string">&quot;auto&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;androidx.viewpager2.widget.ViewPager2</span><br><span class="line">        android:id=<span class="string">&quot;@+id/viewpager2&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;0dp&quot;</span></span><br><span class="line">        android:layout_weight=<span class="string">&quot;1&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Adapter适配器</span></span><br><span class="line"><span class="comment">//放Fragment继承FragmentStateAdapter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewPagerTopAdapter</span> <span class="keyword">extends</span> <span class="title class_">FragmentStateAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先记住这种用法吧,先把Fragmen的类获取过来，后面直接newInstance返回出去</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Class&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFragment</span><span class="params">(Fragment fragment)</span>&#123;</span><br><span class="line">            list.add(fragment.getClass());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewPagerTopAdapter</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity fragmentActivity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fragmentActivity);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Fragment <span class="title function_">createFragment</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Fragment) list.get(position).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记得return null;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_33235287/article/details/104341114?ops_request_misc=&request_id=&biz_id=102&utm_term=ViewPager2+TabLayout&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-104341114.142%5Ev99%5Epc_search_result_base9&spm=1018.2226.3001.4187">玩Android项目开发7—–项目页面（使用ViewPager 2 + TabLayout实现项目页面）_tablayout.mode_auto-CSDN博客</a></p><h3 id="Service服务"><a href="#Service服务" class="headerlink" title="Service服务"></a>Service服务</h3><p>这里以一个简单的音乐播放器引入</p><p><strong>activity_main.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/btn_play_or_stop&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerVertical</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;播放/暂停&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">SeekBar</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/skb_play&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingStart</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingEnd</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">&quot;@id/btn_play_or_stop&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerHorizontal</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在assests资源文件夹下放一首mp3音乐，命名为test_music.mp3</p><p><strong>MyTestMusicService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTestMusicService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MediaPlayer mMediaPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTestMusicService</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">//当执行完了onCreate后，就会执行onBind把操作歌曲的方法返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBinder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        <span class="comment">//这里只执行一次，用于准备播放器</span></span><br><span class="line">        mMediaPlayer = <span class="keyword">new</span> <span class="title class_">MediaPlayer</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">AssetManager</span> <span class="variable">assetManager</span> <span class="operator">=</span> getAssets();</span><br><span class="line">            <span class="type">AssetFileDescriptor</span> <span class="variable">assetFileDescriptor</span> <span class="operator">=</span> assetManager.openFd(<span class="string">&quot;test_music.mp3&quot;</span>);</span><br><span class="line">            mMediaPlayer.setDataSource(assetFileDescriptor.getFileDescriptor(), assetFileDescriptor.getStartOffset(), assetFileDescriptor.getLength());</span><br><span class="line">            <span class="comment">//准备资源</span></span><br><span class="line">            mMediaPlayer.prepare();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(<span class="string">&quot;TAGG&quot;</span>, <span class="string">&quot;准备播放音乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法包含关于歌曲的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBinder</span> <span class="keyword">extends</span> <span class="title class_">Binder</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否属于播放状态</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPlaying</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mMediaPlayer.isPlaying();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//播放或暂停歌曲</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPlaying()) &#123;</span><br><span class="line">                mMediaPlayer.pause();<span class="comment">//暂停</span></span><br><span class="line">                Log.i(<span class="string">&quot;TAGG&quot;</span>, <span class="string">&quot;音乐暂停播放&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMediaPlayer.start();<span class="comment">//播放</span></span><br><span class="line">                Log.i(<span class="string">&quot;TAGG&quot;</span>, <span class="string">&quot;音乐继续播放&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回歌曲的长度，单位为毫秒</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDuration</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mMediaPlayer.getDuration();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回歌曲目前的进度，单位为毫秒</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCurrentPosition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mMediaPlayer.getCurrentPosition();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置歌曲播放的进度，单位为毫秒</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seekTo</span><span class="params">(<span class="type">int</span> mesc)</span> &#123;</span><br><span class="line">            mMediaPlayer.seekTo(mesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MainActivity</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button btnPlayOrStop;</span><br><span class="line">    <span class="keyword">private</span> SeekBar skb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mServiceConnection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyTestMusicService.MyBinder musicController;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;<span class="comment">//定时更新播放进度</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        initView();</span><br><span class="line">        initEvent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initView</span><span class="params">()</span> &#123;</span><br><span class="line">        btnPlayOrStop = findViewById(R.id.btn_play_or_stop);</span><br><span class="line">        btnPlayOrStop.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                play();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        skb = findViewById(R.id.skb_play);</span><br><span class="line">        skb.setOnSeekBarChangeListener(<span class="keyword">new</span> <span class="title class_">SeekBar</span>.OnSeekBarChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProgressChanged</span><span class="params">(SeekBar seekBar, <span class="type">int</span> i, <span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (b)&#123;</span><br><span class="line">                    musicController.seekTo(i);<span class="comment">//进度条改变</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartTrackingTouch</span><span class="params">(SeekBar seekBar)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStopTrackingTouch</span><span class="params">(SeekBar seekBar)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(getMainLooper(), <span class="keyword">new</span> <span class="title class_">Handler</span>.Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message message)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (message.what == <span class="number">0</span>) &#123;</span><br><span class="line">                    updatePlayPosition();<span class="comment">//更新播放进度</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        startMusicService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startMusicService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyTestMusicService.class);</span><br><span class="line">        startService(intent);</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;启动服务&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        bindMusicService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stopMusicService</span><span class="params">()</span> &#123;</span><br><span class="line">        unBindMusicService();</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyTestMusicService.class);</span><br><span class="line">        stopService(intent);</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;停止服务&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindMusicService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyTestMusicService.class);</span><br><span class="line">        <span class="comment">//创建连接对象</span></span><br><span class="line">        <span class="keyword">if</span> (mServiceConnection == <span class="literal">null</span>) &#123;</span><br><span class="line">            mServiceConnection = <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">                <span class="comment">//与服务连接上回调</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> &#123;</span><br><span class="line">                    Log.i(<span class="string">&quot;TAGG&quot;</span>, <span class="string">&quot;绑定服务&quot;</span>);</span><br><span class="line">                    musicController = (MyTestMusicService.MyBinder) iBinder;<span class="comment">//绑定服务后获取Binder</span></span><br><span class="line">                    <span class="comment">//更新按钮的文字</span></span><br><span class="line">                    btnPlayOrStop.setText(<span class="string">&quot;播放&quot;</span>);</span><br><span class="line">                    <span class="comment">//设置进度条最大值</span></span><br><span class="line">                    skb.setMax(musicController.getDuration());</span><br><span class="line">                    <span class="comment">//设置进度条的进度</span></span><br><span class="line">                    skb.setProgress(musicController.getCurrentPosition());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//不会执行，不需理会</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//绑定服务</span></span><br><span class="line">            <span class="comment">//BIND_AUTO_CREATE创建后自动绑定</span></span><br><span class="line">            bindService(intent, mServiceConnection, BIND_AUTO_CREATE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;已经绑定服务&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解绑服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unBindMusicService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mServiceConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">            unbindService(mServiceConnection);</span><br><span class="line">            mServiceConnection = <span class="literal">null</span>;</span><br><span class="line">            Log.i(<span class="string">&quot;TAGG&quot;</span>, <span class="string">&quot;接绑服务&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;还未绑定服务&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新按钮的文字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updatePlayTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (musicController.isPlaying()) &#123;</span><br><span class="line">            btnPlayOrStop.setText(<span class="string">&quot;播放&quot;</span>);</span><br><span class="line">            mHandler.sendEmptyMessageDelayed(<span class="number">0</span>, <span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            btnPlayOrStop.setText(<span class="string">&quot;暂停&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 播放或暂停</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        updatePlayTest();</span><br><span class="line">        musicController.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新进度条</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updatePlayPosition</span><span class="params">()</span> &#123;</span><br><span class="line">        skb.setProgress(musicController.getCurrentPosition());</span><br><span class="line">        mHandler.sendEmptyMessageDelayed(<span class="number">0</span>, <span class="number">500</span>);<span class="comment">//500ms更新一次进度条</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进入界面后重新更新进度条</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        <span class="keyword">if</span> (musicController!=<span class="literal">null</span>)&#123;</span><br><span class="line">            mHandler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止更新进度条</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStop();</span><br><span class="line">        mHandler.removeCallbacksAndMessages(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当绑定服务后，不解绑服务直接退出，会有错误抛出，所以需要在当前Activity页面销毁的时候，执行解绑服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="keyword">if</span> (mServiceConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">            stopMusicService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存数据</span></span><br><span class="line">SharedPreferences.Editor qq_xml=getSharedPreferences(<span class="string">&quot;qq_xml&quot;</span>,MODE_PRIVATE).edit();</span><br><span class="line">qq_xml.putString(<span class="string">&quot;number&quot;</span>,number_qq);</span><br><span class="line">qq_xml.putString(<span class="string">&quot;password&quot;</span>,pass1_qq);</span><br><span class="line">qq_xml.apply();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line">SharedPreferences nw_qq=getSharedPreferences(<span class="string">&quot;qq_xml&quot;</span>,MODE_PRIVATE);</span><br><span class="line">String number=nw_qq.getString(<span class="string">&quot;number&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">String pasword=nw_qq.getString(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记住密码</span></span><br><span class="line"><span class="keyword">package</span> com.example.databasestudy.Class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.SharedPreferences;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SP</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SharedPreferences.Editor edit;</span><br><span class="line">    <span class="keyword">private</span> SharedPreferences mSharedPreferences;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要获取某个界面的sp，传入上下文</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSP</span><span class="params">(Context context)</span>&#123;</span><br><span class="line">        <span class="comment">//getSharedPreferences存在就读取，不存在创建，后面传名字和打开方式</span></span><br><span class="line">        mSharedPreferences = context.getSharedPreferences(<span class="string">&quot;data_1&quot;</span>, Context.MODE_PRIVATE);</span><br><span class="line">        <span class="comment">//需要构造editor，用edit方法构造</span></span><br><span class="line">        edit = mSharedPreferences.edit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String username,String password,String isRememberPassword)</span>&#123;</span><br><span class="line">        edit.putString(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">        edit.putString(<span class="string">&quot;password&quot;</span>,password);</span><br><span class="line">        edit.putString(<span class="string">&quot;isRememberPassword&quot;</span>,isRememberPassword);</span><br><span class="line">        <span class="comment">//apply方法是在何时时候放入数据库，速度快，还有edit.commit();，在当时就存储进去</span></span><br><span class="line">        edit.apply();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">(String isRememberPassword)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isRememberPassword.equals(<span class="string">&quot;NO&quot;</span>))&#123;</span><br><span class="line">            edit.clear();</span><br><span class="line">            edit.putString(<span class="string">&quot;isRememberPassword&quot;</span>, <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            edit.apply();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,String&gt; <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//读取不需要editor实例</span></span><br><span class="line">        data.put(<span class="string">&quot;username&quot;</span>,mSharedPreferences.getString(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">        data.put(<span class="string">&quot;password&quot;</span>,mSharedPreferences.getString(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">        data.put(<span class="string">&quot;isRememberPassword&quot;</span>,mSharedPreferences.getString(<span class="string">&quot;isRememberPassword&quot;</span>,<span class="string">&quot;NO&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><table><thead><tr><th align="left">存储类</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">NULL</td><td align="left">值是一个 NULL 值。</td></tr><tr><td align="left">INTEGER</td><td align="left">值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。</td></tr><tr><td align="left">REAL</td><td align="left">值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。</td></tr><tr><td align="left">TEXT</td><td align="left">值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储。</td></tr><tr><td align="left">BLOB</td><td align="left">值是一个 blob 数据，完全根据它的输入存储。</td></tr></tbody></table><p>数据库事务：</p><p>安全性、高效性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事物的安全性</span></span><br><span class="line"><span class="comment">//beginTransaction();//开启事务，如果事务没有成功，数据库不会改变</span></span><br><span class="line"><span class="comment">//setTransactionSuccessful();//数据库事务成功</span></span><br><span class="line"><span class="comment">//endTransaction();//关闭事物</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">insert</span><span class="params">(String number, String name, String grade, String gender)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> getWritableDatabase();</span><br><span class="line">        db.beginTransaction();<span class="comment">//开启事务，如果事务没有成功，数据库不会改变</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();<span class="comment">//其实也是键值对</span></span><br><span class="line">            values.put(<span class="string">&quot;number&quot;</span>,number);</span><br><span class="line">            values.put(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">            values.put(<span class="string">&quot;grade&quot;</span>,grade);</span><br><span class="line">            values.put(<span class="string">&quot;gender&quot;</span>,gender);</span><br><span class="line">            <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> db.insert(WE,<span class="literal">null</span>,values);<span class="comment">//第二个参数表示为空时链接到哪，不知道就先写空</span></span><br><span class="line">            db.setTransactionSuccessful();<span class="comment">//数据库事务成功</span></span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;中途出错！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            db.endTransaction();</span><br><span class="line">            db.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//事物的安全性</span></span><br><span class="line"><span class="comment">//使用普通方法添加大量数据和使用事务来添加大量的事物来对比时间，以此来看选择谁,</span></span><br><span class="line"><span class="comment">//由于开启事物是把要存储的内容先存储到内存，然后一次性写入，如果是普通方法就是打开数据库，存数据，关闭数据库这样一个操作，非常耗时间</span></span><br><span class="line"><span class="comment">//然后创建数据库时除了本身的文件还额外创建了一个文件，这个文件就是当空间不够或者说文件太大时就会存到这个wenji</span></span><br></pre></td></tr></table></figure><p><strong>构建传参时可以定死名字工厂和版本，就传界面进行构建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">DB_NAME</span> <span class="operator">=</span> <span class="string">&quot;MySQLite.db&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SQLite</span><span class="params">(Context context)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(context,DB_NAME,<span class="literal">null</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完整的构造方法，有许多种</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SQLite</span><span class="params">(<span class="meta">@Nullable</span> Context context, <span class="meta">@Nullable</span> String name, <span class="meta">@Nullable</span> SQLiteDatabase.CursorFactory factory, <span class="type">int</span> version)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, name, factory, version);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>建表语句，一个数据库可以有很多个表,下面还有更新方法，没学</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//onCreate在数据库创建时调用，只调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(SQLiteDatabase sqLiteDatabase)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">create</span> <span class="operator">=</span> <span class="string">&quot;create table &quot;</span> + WE</span><br><span class="line">                    +<span class="string">&quot; (&quot;</span> + <span class="string">&quot;id integer primary key autoincrement,&quot;</span></span><br><span class="line">                    +<span class="string">&quot;number text,&quot;</span></span><br><span class="line">                    +<span class="string">&quot;name text,&quot;</span></span><br><span class="line">                    +<span class="string">&quot;grade ,&quot;</span></span><br><span class="line">                    +<span class="string">&quot;gender text&quot;</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            sqLiteDatabase.execSQL(create);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//注意是sqLiteDatabase执行建表语句，而不是getWritableDatabase()对象执行，表名一定不能重复，重复调用语句注意传参</span></span><br><span class="line"><span class="comment">//也就是先写出数据库专门的建表语句，然后执行as自带的数据库建表方法</span></span><br><span class="line"><span class="comment">//数据库专门建表语句：  create table 表名 (id integer primary key autoincrement,number text,... )</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUpgrade</span><span class="params">(SQLiteDatabase sqLiteDatabase, <span class="type">int</span> i, <span class="type">int</span> i1)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>各种操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* insert()增加数据</span></span><br><span class="line"><span class="comment">* delete()删除数据</span></span><br><span class="line"><span class="comment">* update()修改数据</span></span><br><span class="line"><span class="comment">* query()查找数据*/</span></span><br></pre></td></tr></table></figure><p><em><strong>增加数据</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以加个Bean类，里面放各种数据，操作和代码都更简单</span></span><br><span class="line"><span class="comment">//insert方法返回值为long类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">insert</span><span class="params">(String number, String name, String grade, String gender)</span>&#123;</span><br><span class="line">    <span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> getWritableDatabase();</span><br><span class="line"></span><br><span class="line">    <span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();<span class="comment">//其实也是键值对</span></span><br><span class="line">    values.put(<span class="string">&quot;number&quot;</span>,number);</span><br><span class="line">    values.put(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">    values.put(<span class="string">&quot;grade&quot;</span>,grade);</span><br><span class="line">    values.put(<span class="string">&quot;gender&quot;</span>,gender);</span><br><span class="line">    <span class="keyword">return</span> db.insert(WE,<span class="literal">null</span>,values);<span class="comment">//第二个参数表示为空时链接到哪，不知道就先写空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>删除数据</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//delete方法返回值为int类型，删除了多少个就返回多少</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(String number)</span>&#123;</span><br><span class="line">        <span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> getWritableDatabase();</span><br><span class="line">        <span class="comment">/*第一个参数为表的名字，第二个参数为判断语句，写条件的，第三个为值,要new一个String数组</span></span><br><span class="line"><span class="comment">    ，里面填充要传的所有值，问号代表将后面的值依次填充进去问号*/</span></span><br><span class="line">        <span class="keyword">return</span> db.delete(WE,<span class="string">&quot;number like ?&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;number&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>修改数据</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//change方法返回值为int类型，更改了多少个数据就返回多少</span><br><span class="line">public int change(String number, String name, String grade, String gender)&#123;</span><br><span class="line">        SQLiteDatabase db = getWritableDatabase();</span><br><span class="line">        ContentValues values = new ContentValues();//其实也是键值对</span><br><span class="line">        values.put(&quot;number&quot;,number);</span><br><span class="line">        values.put(&quot;name&quot;,name);</span><br><span class="line">        values.put(&quot;grade&quot;,grade);</span><br><span class="line">        values.put(&quot;gender&quot;,gender);</span><br><span class="line">        /*</span><br><span class="line">        * 传入4个参数，第一个为表名，第二个为修改的完整数据，第三个为判断语句，根据什么来查找修改的</span><br><span class="line">        * 第四个为要往判断语句里面填充的值，要为String类型的数组*/</span><br><span class="line">        return db.update(WE,values,&quot;number like ?&quot;,new String[]&#123;number&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>查找数据</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//query方法传回的是指针cursor</span></span><br><span class="line"> <span class="meta">@SuppressLint(&quot;Range&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> List&lt;data&gt; <span class="title function_">check</span><span class="params">(String number)</span>&#123;</span><br><span class="line">     <span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> getWritableDatabase();</span><br><span class="line">     List&lt;data&gt;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 传入4个参数，第一个参数为表名，第二个参数为数据库语句中的要查询哪些数据，其实也就是条件语句，写要得到哪些列，</span></span><br><span class="line"><span class="comment">     * 传入null则代表哪一列都要，或者传入一个String数组，里面写着你要查询的列,</span></span><br><span class="line"><span class="comment">     * 第三个和第四个参数合起来为判断语句，根据什么来查找，第三个写判断语句，第四个写传入的参</span></span><br><span class="line"><span class="comment">     * 后面几个参数都是数据库中复杂的了*/</span></span><br><span class="line">     <span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> db.query(WE, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;number,name,grade&quot;</span>&#125;, <span class="string">&quot;number like ?&quot;</span></span><br><span class="line">                              , <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;number&#125;, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">     <span class="keyword">if</span> (cursor!=<span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="comment">//如果能移动到下一个就继续,循环不断得到的数据我们要保存到一个list中，最后返回list即可</span></span><br><span class="line">         <span class="keyword">while</span> (cursor.moveToNext())&#123;</span><br><span class="line">             <span class="comment">//getString表示得到当前指针的第几列的值，整型，这个值的类型要我们自己知道再去调用不同的get方法</span></span><br><span class="line">             <span class="comment">//getColumnIndex表示通过列名返回此列是第几列</span></span><br><span class="line">             <span class="type">String</span> <span class="variable">number_back</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;number&quot;</span>));</span><br><span class="line">             <span class="type">String</span> <span class="variable">name_back</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">             <span class="type">String</span> <span class="variable">grade_back</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;grade&quot;</span>));</span><br><span class="line"></span><br><span class="line">             <span class="type">data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">data</span>();</span><br><span class="line">             data.setNumber(number_back);</span><br><span class="line">             data.setName(name_back);</span><br><span class="line">             data.setGrade(grade_back);</span><br><span class="line"></span><br><span class="line">             list.add(data);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//最后要关闭</span></span><br><span class="line">         cursor.close();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="LitePal开源库"><a href="#LitePal开源库" class="headerlink" title="LitePal开源库"></a>LitePal开源库</h3><p>这里只展示简单用法，要了解更多用法可以去看作者博客，中午网址那里就是哦，中文网址也有相关博客教学</p><p>GitHub上LitePal开源库介绍网站：<a href="https://github.com/guolindev/LitePal">https://github.com/guolindev/LitePal</a></p><p>中文网址：<a href="https://blog.csdn.net/guolin_blog/category_9262963.html">https://blog.csdn.net/guolin_blog/category_9262963.html</a></p><p><strong>配置LitePal</strong></p><p><strong>导入jar包，添加依赖</strong></p><p><strong>原本是可以直接添加依赖的，但不知道为什么我的项目添加不成功，后面知道了，<code>jcenter</code>停用了但LitePal是在<code>jcenter</code>上的导致下载失败，还是直接导入jar包了，添加依赖的操作可以跳过，直接看下面怎么导入jar包的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在settings.gradle中找到这个代码块加入jcenter()和下面那句代码</span></span><br><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">        <span class="comment">//加入下面两句代码</span></span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">&#x27;https://jitpack.io&#x27;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//然后再正常导入依赖</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.litepal.guolindev:core:3.2.3&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>首先去<a href="https://github.com/guolindev/LitePal/blob/master/downloads/litepal-2.0.0.jar%E4%B8%8B%E8%BD%BDlitepal%E7%9A%84jar%E5%8C%85%EF%BC%8C%E4%B9%8B%E5%90%8E%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5%EF%BC%8C%E6%B2%A1%E6%9C%89%E6%89%BE%E5%88%B0lib%E7%9B%AE%E5%BD%95%E7%9A%84%E6%8C%89%E7%85%A7%E5%9B%BE%E7%89%87%E7%9A%84%E8%B7%AF%E5%BE%84%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA">https://github.com/guolindev/LitePal/blob/master/downloads/litepal-2.0.0.jar下载litepal的jar包，之后在项目导入，没有找到lib目录的按照图片的路径新建一个</a></strong></p></li><li><p><strong>将下载好的文件复制到这个目录下，这个文件我已经放在压缩包里面了哦，右击复制进来的jar包，点击<code>Add As Library</code></strong></p></li></ul><p><strong>配置<code>litepal.xml</code></strong></p><ul><li><strong>首先新建<code>assets</code>资源目录,有的就不用新建了</strong></li></ul><p>​<strong>右击<code>app</code>-&gt;<code>New </code>-&gt;<code>Folder</code>-&gt;点击<code>Assets Folder</code>-&gt;<code>Finish</code></strong></p><ul><li><strong>然后再在<code>assets</code>目录下<code>new File</code>一个litepal.xml文件，接着编辑里面的内容：</strong></li></ul><p>配置文件相当简单，<code>&lt;dbname&gt;</code>用于设定数据库的名字，<code>&lt;version&gt;</code>用于设定数据库的版本号，<code>&lt;list&gt;</code>用于设定所有的映射模型，我们稍后就会用到,复制下面的代码到新建的xml文件里面即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;litepal&gt;</span><br><span class="line">    &lt;dbname value=&quot;NewsDemo&quot; /&gt;</span><br><span class="line">    &lt;version value=&quot;1&quot; /&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line"></span><br><span class="line">&lt;/litepal&gt;</span><br></pre></td></tr></table></figure><p><strong>配置LitePalApplication(下面方式选择一种即可)</strong></p><ul><li>方式一</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest&gt;</span><br><span class="line">    &lt;application android:name=&quot;org.litepal.LitePalApplication&quot;//添加此句代码</span><br><span class="line">        ...</span><br><span class="line">        &gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><p>或者：</p><ul><li>方式二</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest&gt;</span><br><span class="line">    &lt;application android:name=&quot;org.litepal.MyOwnApplication&quot;</span><br><span class="line">        ...</span><br><span class="line">        &gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><p>这种方式需要继承 <strong>LitePalApplication</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class MyOwnApplication extends LitePalApplication &#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：</p><ul><li>方式三</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyOwnApplication extends AnotherApplication &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        LitePal.initialize(this);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用方法</strong></p><ul><li><p><strong>创建和升级数据库</strong></p></li><li><p><strong>跟前面使用SQLite数据库一样，我们以一个Student类进行讲解，新建一个Student类，并让这个类继承<code> LitePalSupport</code></strong></p></li></ul><p><strong>注：这个类是一个典型的Java Bean类，在这个Student类中我们定义了number、name、gender、grade这些字段，并且生成了getter方法（获取值）和setter方法（赋值），这个类就可以用来建表了，每个字段就是表的一列，这就是对象关系映射最直观的体验</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">LitePalSupport</span> &#123;</span><br><span class="line"><span class="comment">//跟之前不同，这里要继承LitePalSupport</span></span><br><span class="line">    String number;</span><br><span class="line">    String name;</span><br><span class="line">    String gender;</span><br><span class="line">    String grade;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(String number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGrade</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGrade</span><span class="params">(String grade)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>之后我们把Student类添加到映射模型列表当中，修改<code>litepal.xml</code>中的代码</strong></li></ul><p><strong><code>&lt;mapping class = &quot;类&quot;/&gt;</code>,双引号之间的类换成上面讲的包名.类名，如图，这里的<code>&lt;mapping&gt;</code>标签来声明要配置的映射模型类，注意一定要使用完整的类名，不管有多少模型类需要映射，都用同样的方法配置在<code>&lt;list&gt;</code>标签下</strong></p><p><img src="/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.assets/Snipaste_2022-11-11_13-21-08.png"></p><ul><li><strong>创建数据库和访问数据库的方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LitePal.getDatabase();<span class="comment">//LitePal创建数据库方法</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>而要升级数据库如增加列只需要在映射的类那里新加一个数据域即可，如果要加多一张表就只需要新建一个类似的Student类按照同样的方法写即可</strong></p></li><li><p><strong>增加数据</strong></p></li></ul><p><strong>注意：无论是要对数据进行怎么样的操作都应该要创建数据库，创建好了就是打开数据库，要先调用<code>LitePal.getDatabase();</code>这个方法才能操作数据库，万万记得</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//litepal插入数据</span></span><br><span class="line"> <span class="type">Student</span>  <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.setNumber(number);</span><br><span class="line">student.setName(name);</span><br><span class="line">student.setGrade(grade);</span><br><span class="line">student.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line"></span><br><span class="line">student.save();</span><br><span class="line"><span class="comment">//save是保存数据的方法</span></span><br><span class="line"><span class="comment">//新建映射的类的对象，并且修改完成这个对象后，直接调用save()方法即可保存，用起来很简单</span></span><br></pre></td></tr></table></figure><ul><li><strong>删除数据</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LitePal.deleteAll(Student.class,<span class="string">&quot;number like ?&quot;</span>,mEditText_number.getText().toString().trim());</span><br><span class="line"><span class="comment">//deleteAll就是删除数据的方法</span></span><br><span class="line"><span class="comment">//deleteAll第一个参数是表的名字，是之前映射类名.class；第二个参数是传一条判断根据什么删除的语句，</span></span><br><span class="line"><span class="comment">//如这里就是名字是?的，而?是什么是跟在后面传的参数</span></span><br></pre></td></tr></table></figure><p><strong>修改数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.setName(name);</span><br><span class="line">student.setGrade(grade);</span><br><span class="line">student.setGrade(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">student.updateAll(<span class="string">&quot;number like ?&quot;</span>,number);</span><br><span class="line"><span class="comment">//updateAll就是修改数据的方法</span></span><br><span class="line"><span class="comment">//updateAll第一个参数传入一个限制语句，不传就是修改全部的</span></span><br></pre></td></tr></table></figure><p><strong>查询数据</strong></p><ul><li><strong>简单查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find方法按照id查找，第一个参数为表名，第二个为第几条数据</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> LitePal.find(Student.class,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//findFirst方法传入表名即可，返回第一条数据对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> LitePal.findFirst(Student.class);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//findLast方法传入表名即可，放回最后一条数据对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> LitePal.findLast(Student.class);</span><br></pre></td></tr></table></figure><ul><li><strong>连缀查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//where方法传入一个限制语句，这里表示number为多少，后面跟要查询的数，find方法传入要在哪个表找</span></span><br><span class="line">List&lt;Student&gt;list = LitePal.where(<span class="string">&quot;number like ?&quot;</span>,mEditText_number.getText().toString().trim())</span><br><span class="line">                            .find(Student.class);</span><br></pre></td></tr></table></figure><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><h4 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h4><ul><li><strong>在Android中，帧动画的本质是把一组预先准备好的图片循环切换播放，造成一种动画效果，幻灯片快速播放形成电影。</strong></li></ul><p><em><strong>通过xml方式实现</strong></em></p><ol><li>第一步：先把要系列播放的图片导入到项目中</li><li>第二步：在<code>drawable</code>目录下创建<code>animation_flower.xml</code>文件(文件名随意)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;animation-list xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:oneshot=<span class="string">&quot;false&quot;</span>&gt;<span class="comment">// 是否只播放一次 false 循环播放</span></span><br><span class="line"></span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=<span class="string">&quot;@drawable/img01&quot;</span></span><br><span class="line">        android:duration=<span class="string">&quot;200&quot;</span> /&gt;<span class="comment">//动画持续时间</span></span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=<span class="string">&quot;@drawable/img02&quot;</span></span><br><span class="line">        android:duration=<span class="string">&quot;200&quot;</span> /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=<span class="string">&quot;@drawable/img03&quot;</span></span><br><span class="line">        android:duration=<span class="string">&quot;200&quot;</span> /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=<span class="string">&quot;@drawable/img04&quot;</span></span><br><span class="line">        android:duration=<span class="string">&quot;200&quot;</span> /&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:drawable=<span class="string">&quot;@drawable/img05&quot;</span></span><br><span class="line">        android:duration=<span class="string">&quot;200&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/animation-list&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>第三步：布局和Activity</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先在布局中的Image控件把background属性设置为drawable中刚才的drawable文件</span></span><br><span class="line"><span class="comment">//然后在Activity中引用即可</span></span><br><span class="line"><span class="type">AnimationDrawable</span> <span class="variable">animationDrawable</span> <span class="operator">=</span> (AnimationDrawable) mImageView.getBackground();<span class="comment">//获取动画对象</span></span><br><span class="line">mAnimationDrawable.start();<span class="comment">//播放动画</span></span><br><span class="line">mAnimationDrawable.stop();<span class="comment">//结束动画</span></span><br></pre></td></tr></table></figure><p><em><strong>通过Java方法形式实现</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跟xml实现方式很像        </span></span><br><span class="line"><span class="comment">// 获取动画对象</span></span><br><span class="line">mAnimationDrawable =<span class="keyword">new</span> <span class="title class_">AnimationDrawable</span>();        </span><br><span class="line">mAnimationDrawable.addFrame(getResources().getDrawable(R.drawable.img01),<span class="number">200</span>);</span><br><span class="line">mAnimationDrawable.addFrame(getResources().getDrawable(R.drawable.img02),<span class="number">200</span>);</span><br><span class="line">mAnimationDrawable.addFrame(getResources().getDrawable(R.drawable.img03),<span class="number">200</span>);</span><br><span class="line">mAnimationDrawable.addFrame(getResources().getDrawable(R.drawable.img04),<span class="number">200</span>);</span><br><span class="line">mAnimationDrawable.addFrame(getResources().getDrawable(R.drawable.img05),<span class="number">200</span>);</span><br><span class="line">mAnimationDrawable.addFrame(getResources().getDrawable(R.drawable.img06),<span class="number">200</span>);</span><br><span class="line">mAnimationDrawable.setOneShot(<span class="literal">false</span>);<span class="comment">//设置循环播放</span></span><br><span class="line">mImageViewShow.setBackground(mAnimationDrawable);</span><br><span class="line">mAnimationDrawable.start();<span class="comment">//播放动画</span></span><br><span class="line">mAnimationDrawable.stop();<span class="comment">//结束动画</span></span><br></pre></td></tr></table></figure><h4 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h4><ul><li><strong>在Android动画中，补间动画一共可以分成四类即透明度动画、缩放动画、旋转动画、位移动画。</strong></li><li><strong>其实现方法可以通过xml来配置，也可以通过代码来实现。</strong></li><li><strong>透明度动画-AlphaAnimation，缩放动画-ScaleAnimation，位移动画-TranslateAnimation，旋转动画-RotateAnimation</strong></li></ul><p><em><strong>通过xml方式实现</strong></em></p><p>用<code>xml</code>实现补间动画，需要将<code>xml</code>放到res下的<code>anim</code>目录，Android工程默认是没有<code>anim</code>文件夹的在读文件前我们先把<code>anim</code> 文件夹以及文件建好</p><p>点中工程的<code>res</code>目录 右键<code>New</code> -&gt;<code>Directory</code>-&gt; 弹窗中输入<code>anim</code><br>点中刚刚新建的<code>anim</code>目录 右键<code>New</code> -&gt; <code>Animation Resource File</code><br>创建好了以后输入如下的布局文件代码</p><ol><li><strong>透明度</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;alpha xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:interpolator=<span class="string">&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span></span><br><span class="line">    android:fromAlpha=<span class="string">&quot;1.0&quot;</span></span><br><span class="line">    android:toAlpha=<span class="string">&quot;0.1&quot;</span></span><br><span class="line">    android:duration=<span class="string">&quot;2000&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p><strong>注：<code>android:interpolator=&quot;&quot;</code></strong></p><p><code>Interpolator</code>分类如下：</p><ul><li><code>AccelerateDecelerateInterpolator</code>，效果是开始和结束的速率比较慢，中间加速；</li><li><code>AccelerateInterpolator</code>,效果是开始速率比较慢，后面加速；</li><li><code>DecelerateInterpolator</code>,效果是开始速率比较快，后面减速；</li><li><code>LinearInterpolator</code>,效果是速率是恒定的；</li><li><code>AnticipateInterpolator</code>,效果是开始向后甩，然后向前；</li><li><code>AnticipateOvershootInterpolator</code>,效果是开始向后甩，冲到目标值，最后又回到最终值；</li><li><code>OvershootInterpolator</code>,效果开始向前甩，冲到目标值，最后又回到了最终值；</li><li><code>BounceInterpolator</code>,效果是在结束时反弹；</li><li><code>CycleInterpolator</code>,效果是循环播放，速率是正弦曲线；</li><li><code>TimeInterpolator</code>,一个接口，可以自定义插值器。</li></ul><p>插值器们对应的资源ID:</p><ul><li><code>AccelerateDecelerateInterpolator</code>，对应的是<code>@android:anim/accelerate_decelerate_interpolator</code>；</li><li><code>AccelerateInterpolator</code>,对应的是<code>@android:anim/accelerate_interpolator</code>；</li><li><code>DecelerateInterpolator</code>,对应的是<code>@android:anim/decelerate_interpolator</code>；</li><li><code>LinearInterpolator</code>,对应的是<code>@android:anim/linear_interpolator</code>；</li><li><code>AnticipateInterpolator</code>,对应是<code>@android:anim/anticipate_interpolator</code>；</li><li><code>AnticipateOvershootInterpolator</code>,对应的是<code>@android:anim/anticipate_overshoot_interpolator</code>；</li><li><code>OvershootInterpolator</code>,对应的是<code>@android:anim/overshoot_interpolator</code>；</li><li><code>BounceInterpolator</code>,对应是<code>@android:anim/bounce_interpolator</code>；</li><li><code>CycleInterpolator</code>,对应是<code>@android:anim/cycle_interpolator</code>。</li></ul><table><thead><tr><th>属性值</th><th align="center">含义</th></tr></thead><tbody><tr><td>fromAlpha</td><td align="center">起始透明度（透明度的范围为：0-1，完全透明-完全不透明）</td></tr><tr><td>toAlpha</td><td align="center">结束透明度</td></tr><tr><td>duration</td><td align="center">持续时间（毫秒）</td></tr></tbody></table><ol start="2"><li><strong>缩放</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;scale xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:interpolator=<span class="string">&quot;@android:anim/accelerate_interpolator&quot;</span></span><br><span class="line">    android:fromXScale=<span class="string">&quot;0.2&quot;</span></span><br><span class="line">    android:toXScale=<span class="string">&quot;1.5&quot;</span></span><br><span class="line">    android:fromYScale=<span class="string">&quot;0.2&quot;</span></span><br><span class="line">    android:toYScale=<span class="string">&quot;1.5&quot;</span></span><br><span class="line">    android:pivotX=<span class="string">&quot;50%&quot;</span></span><br><span class="line">    android:pivotY=<span class="string">&quot;50%&quot;</span></span><br><span class="line">    android:duration=<span class="string">&quot;2000&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">fromXScale</td><td align="center">沿着X轴缩放的起始比例</td></tr><tr><td align="center">fromYScale</td><td align="center">沿着Y轴缩放的起始比例</td></tr><tr><td align="center">toXScale</td><td align="center">沿着X轴缩放的结束比例</td></tr><tr><td align="center">toYScale</td><td align="center">沿着Y轴缩放的结束比例</td></tr><tr><td align="center">pivotX</td><td align="center">缩放的中轴点X坐标，即距离自身左边缘的位置，比如50%就是以图像的 中心为中轴点</td></tr><tr><td align="center">pivotY</td><td align="center">缩放的中轴点Y坐标</td></tr><tr><td align="center">duration</td><td align="center">持续时间</td></tr></tbody></table><p>​</p><p>​</p><ol start="3"><li><strong>位移</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;translate xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:interpolator=<span class="string">&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span></span><br><span class="line">    android:fromXDelta=<span class="string">&quot;0&quot;</span></span><br><span class="line">    android:toXDelta=<span class="string">&quot;320&quot;</span></span><br><span class="line">    android:fromYDelta=<span class="string">&quot;0&quot;</span></span><br><span class="line">    android:toYDelta=<span class="string">&quot;0&quot;</span></span><br><span class="line">    android:duration=<span class="string">&quot;2000&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td>fromXDelta</td><td>动画起始位置的X坐标</td></tr><tr><td>fromYDelta</td><td>动画起始位置的Y坐标</td></tr><tr><td>toXDelta</td><td>动画结束位置的X坐标</td></tr><tr><td>toYDelta</td><td>动画结束位置的Y坐标</td></tr><tr><td>duration</td><td>持续时间</td></tr></tbody></table><ol start="4"><li><strong>旋转</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;rotate xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:interpolator=<span class="string">&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span></span><br><span class="line">    android:fromDegrees=<span class="string">&quot;0&quot;</span></span><br><span class="line">    android:toDegrees=<span class="string">&quot;360&quot;</span></span><br><span class="line">    android:duration=<span class="string">&quot;1000&quot;</span></span><br><span class="line">    android:repeatCount=<span class="string">&quot;1&quot;</span></span><br><span class="line">    android:repeatMode=<span class="string">&quot;reverse&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">fromDegrees&#x2F;toDegrees</td><td align="center">旋转的起始&#x2F;结束角度</td></tr><tr><td align="center">repeatCount</td><td align="center">旋转的次数，默认值为0，代表一次，假如是其他值，比如3，则旋转4次 另外，值为-1或者infinite时，表示动画永不停止</td></tr><tr><td align="center">repeatMode</td><td align="center">设置重复模式，默认restart，但只有当repeatCount大于0或者infinite或-1时 才有效。还可以设置成reverse，表示偶数次显示动画时会做方向相反的运动</td></tr><tr><td align="center">duration</td><td align="center">持续时间</td></tr></tbody></table><p>​<br>​</p><ol start="5"><li><strong>组合</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;set xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:interpolator=<span class="string">&quot;@android:anim/decelerate_interpolator&quot;</span></span><br><span class="line">    android:shareInterpolator=<span class="string">&quot;true&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line">    &lt;scale</span><br><span class="line">        android:duration=<span class="string">&quot;2000&quot;</span></span><br><span class="line">        android:fromXScale=<span class="string">&quot;0.2&quot;</span></span><br><span class="line">        android:fromYScale=<span class="string">&quot;0.2&quot;</span></span><br><span class="line">        android:pivotX=<span class="string">&quot;50%&quot;</span></span><br><span class="line">        android:pivotY=<span class="string">&quot;50%&quot;</span></span><br><span class="line">        android:toXScale=<span class="string">&quot;1.5&quot;</span></span><br><span class="line">        android:toYScale=<span class="string">&quot;1.5&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;rotate</span><br><span class="line">        android:duration=<span class="string">&quot;1000&quot;</span></span><br><span class="line">        android:fromDegrees=<span class="string">&quot;0&quot;</span></span><br><span class="line">        android:repeatCount=<span class="string">&quot;1&quot;</span></span><br><span class="line">        android:repeatMode=<span class="string">&quot;reverse&quot;</span></span><br><span class="line">        android:toDegrees=<span class="string">&quot;360&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=<span class="string">&quot;2000&quot;</span></span><br><span class="line">        android:fromXDelta=<span class="string">&quot;0&quot;</span></span><br><span class="line">        android:fromYDelta=<span class="string">&quot;0&quot;</span></span><br><span class="line">        android:toXDelta=<span class="string">&quot;320&quot;</span></span><br><span class="line">        android:toYDelta=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;alpha</span><br><span class="line">        android:duration=<span class="string">&quot;2000&quot;</span></span><br><span class="line">        android:fromAlpha=<span class="string">&quot;1.0&quot;</span></span><br><span class="line">        android:toAlpha=<span class="string">&quot;0.1&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure><p><em><strong>通过Java代码实现</strong></em></p><ol><li><strong>透明度</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//fromAlpha   动画开始的透明度，从0.0 --1.0 ，0.0表示全透明，1.0表示完全不透明</span></span><br><span class="line"><span class="comment">//toAlpha       动画结束时的透明度，也是从0.0 --1.0 ，0.0表示全透明，1.0表示完全不透明</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">AlphaAnimation</span><span class="params">(<span class="type">float</span> fromAlpha, <span class="type">float</span> toAlpha)</span> &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animation=  <span class="keyword">new</span> <span class="title class_">AlphaAnimation</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">animation.setDuration(<span class="number">2000</span>);</span><br><span class="line">mImageView.startAnimation(animation);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>缩放</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScaleAnimation</span><span class="params">(<span class="type">float</span> fromX, <span class="type">float</span> toX, <span class="type">float</span> fromY, <span class="type">float</span> toY,</span></span><br><span class="line"><span class="params"><span class="type">int</span> pivotXType, <span class="type">float</span> pivotXValue, <span class="type">int</span> pivotYType, <span class="type">float</span> pivotYValue)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> animation = <span class="keyword">new</span> <span class="title class_">ScaleAnimation</span>(<span class="number">0</span>, <span class="number">1.4f</span>, <span class="number">0</span>, <span class="number">1.4f</span>,</span><br><span class="line">                   ScaleAnimation.RELATIVE_TO_SELF,<span class="number">0.5f</span>,ScaleAnimation.RELATIVE_TO_SELF,<span class="number">0.5f</span>);</span><br><span class="line">animation.setDuration(<span class="number">2000</span>);</span><br><span class="line"> mImageView.startAnimation(animation);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>重要：</strong></p><table><thead><tr><th align="center"><strong>属性值</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">pivotXType</td><td align="center">有2种模式，RELATIVE_TO_SELF（相对于自身）和RELATIVE_TO_PARENT（相对于父布局）pivotx,pivotY的值就应该是0-1的浮点数，分别对应xml中的%（自身）和%p（父布局）</td></tr><tr><td align="center">pivotYType</td><td align="center">同pivotXType</td></tr></tbody></table><p><code>mRotateAnimation.setFillAfter(true);//旋转完后停止</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.requestLayout();//重新计算布局高度，布局修改时diao</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>位移</strong></li></ol><p>x正向右（小变化到大），y正向下（小变化到大）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//fromXDelta     起始点X轴坐标，可以是数值、百分数、百分数p 三种样式，同scale</span></span><br><span class="line"> <span class="comment">//fromYDelta    起始点Y轴从标，可以是数值、百分数、百分数p 三种样式</span></span><br><span class="line"><span class="comment">//toXDelta         结束点X轴坐标</span></span><br><span class="line">  <span class="comment">//toYDelta        结束点Y轴坐标 </span></span><br><span class="line"> <span class="comment">// fromYType、toYType同ScaleAnimation，</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">TranslateAnimation</span><span class="params">(<span class="type">int</span> fromXType, <span class="type">float</span> fromXValue, <span class="type">int</span> toXType,</span></span><br><span class="line"><span class="params">  <span class="type">float</span> toXValue,<span class="type">int</span> fromYType, <span class="type">float</span> fromYValue, <span class="type">int</span> toYType, <span class="type">float</span> toYValue)</span> &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animation= <span class="keyword">new</span> <span class="title class_">TranslateAnimation</span>(TranslateAnimation.RELATIVE_TO_SELF, <span class="number">0</span>, TranslateAnimation.RELATIVE_TO_SELF, <span class="number">0.5f</span>,</span><br><span class="line">        TranslateAnimation.RELATIVE_TO_SELF, <span class="number">0</span>, TranslateAnimation.RELATIVE_TO_SELF, <span class="number">0.5f</span>);</span><br><span class="line">animation.setDuration(<span class="number">2000</span>);</span><br><span class="line">mImageView.startAnimation(animation);</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>旋转</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RotateAnimation</span><span class="params">(<span class="type">float</span> fromDegrees, <span class="type">float</span> toDegrees, <span class="type">int</span> pivotXType,</span></span><br><span class="line"><span class="params"> <span class="type">float</span> pivotXValue, <span class="type">int</span> pivotYType, <span class="type">float</span> pivotYValue)</span> &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animation= <span class="keyword">new</span> <span class="title class_">RotateAnimation</span>(<span class="number">0</span>, -<span class="number">720</span>, RotateAnimation.RELATIVE_TO_SELF, <span class="number">0.5f</span>,</span><br><span class="line">                       RotateAnimation.RELATIVE_TO_SELF, <span class="number">0.5f</span>);</span><br><span class="line">animation.setDuration(<span class="number">2000</span>);</span><br><span class="line">mImageView.startAnimation(animation);</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>组合</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animation</span> <span class="variable">rotateAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RotateAnimation</span>(<span class="number">0</span>, -<span class="number">720</span>, RotateAnimation.RELATIVE_TO_SELF, <span class="number">0.5f</span>,</span><br><span class="line">        RotateAnimation.RELATIVE_TO_SELF, <span class="number">0.5f</span>);</span><br><span class="line">rotateAnimation.setDuration(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Animation</span> <span class="variable">translateAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TranslateAnimation</span>(TranslateAnimation.RELATIVE_TO_PARENT, <span class="number">0</span></span><br><span class="line">                                                      , TranslateAnimation.RELATIVE_TO_PARENT, <span class="number">0.5f</span>,</span><br><span class="line">        TranslateAnimation.RELATIVE_TO_PARENT, <span class="number">0</span>, TranslateAnimation.RELATIVE_TO_PARENT, <span class="number">0.5f</span>);</span><br><span class="line">translateAnimation.setDuration(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Animation</span> <span class="variable">scaleAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScaleAnimation</span>(<span class="number">0</span>, <span class="number">1.4f</span>, <span class="number">0</span>, <span class="number">1.4f</span>, ScaleAnimation.RELATIVE_TO_SELF,</span><br><span class="line">        <span class="number">0.5f</span>, ScaleAnimation.RELATIVE_TO_SELF, <span class="number">0.5f</span>);</span><br><span class="line">scaleAnimation.setDuration(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Animation</span> <span class="variable">alphaAnimation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlphaAnimation</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">alphaAnimation.setDuration(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">AnimationSet</span> <span class="variable">animationSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimationSet</span>(<span class="literal">true</span>);</span><br><span class="line">animationSet.addAnimation(rotateAnimation);</span><br><span class="line">animationSet.addAnimation(translateAnimation);</span><br><span class="line">animationSet.addAnimation(scaleAnimation);</span><br><span class="line">animationSet.addAnimation(alphaAnimation);</span><br><span class="line">animationSet.setDuration(<span class="number">4000</span>);</span><br><span class="line">animationSet.setFillAfter(<span class="literal">true</span>);</span><br><span class="line">mImageView.startAnimation(animationSet);</span><br></pre></td></tr></table></figure><h4 id="属性动画（补间动画优化版）"><a href="#属性动画（补间动画优化版）" class="headerlink" title="属性动画（补间动画优化版）"></a>属性动画（补间动画优化版）</h4><ul><li><p>补间动画作用的对象是View,也就是作用的对象是Android中的控件，如ImageView、Button、TextView等，也可以作用在布局上如LinearLayout、ConstraintLayout、RelativeLayout等，但是对于一些不是View的对象，无法对这些对象进行动画操作。比如我们要对某个控件的某个属性做进行动画操作，如其颜色，这个颜色也可以看成一个对象，但其并不是View对象，补间动画就无法实现，属性动画可以对这个颜色值做动画， 能实现一些更加复杂的动画效果。</p></li><li><p>补间动画只是改变了<code>View</code>的视觉效果，而不会真正去改变View的属性</p></li><li><p>ObjectAnimator 对象动画   ValueAnimator的子类，允许对指定对象的属性执行动画。</p></li><li><p>ValueAnimator 值动画   计算初始值和结束值的过渡动画。</p></li><li><p>PropertyValueHolder 用于同时执行多个动画</p></li><li><p>TypeEvaluator 估值器</p></li><li><p>AnimatorSet 动画集合   Animator的子类，用于组合多个Animator，制定多个动画的播放次序。</p></li><li><p>Interpolator 差值器</p></li></ul><p>1、属性动画都是通过ValueAnimator 类和ObjectAnimator 类来完成，其中ObjectAnimator类是对对象做动画，ValueAnimator 类是对值做动画。<br>2、PropertyValueHolder类可以同时执行多个动画，AnimatorSetl类可以将多个动画按一定的秩序先后执行。<br>3、TypeEvaluator估值器和Interpolator 差值器</p><ol><li><strong>对象动画（ObjectAnimator）</strong></li></ol><ul><li><code>ObjectAnimator</code>类是属性动画中非常重要的一个类，可以通过该类对<code>View</code>不仅可以实现一些基本的移、旋转、缩放和透明度四种基本变换动画，还能实现一些其他属性值的变换动画。</li></ul><p><em><strong>Java方法实现</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ObjectAnimator <span class="title function_">ofFloat</span><span class="params">(Object target, String propertyName, <span class="type">float</span>... values)</span> &#123;</span><br><span class="line">        <span class="type">ObjectAnimator</span> <span class="variable">anim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectAnimator</span>(target, propertyName);</span><br><span class="line">        anim.setFloatValues(values);</span><br><span class="line">        <span class="keyword">return</span> anim;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*方法中第一个参数Object target 的作用对象通常是View,也就是Android中的控件或布局。</span></span><br><span class="line"><span class="comment">方法中第二个参数String propertyName 通常是需要执行动画的属性，具体值如下表所示</span></span><br><span class="line"><span class="comment">方法中第三个参数float... values 表示属性的变换范围，该参数可以传多个值。*/</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>值的用法</th></tr></thead><tbody><tr><td>rotation</td><td>以屏幕方向为轴的旋转度数</td></tr><tr><td>alpha</td><td>透明度</td></tr><tr><td>translationX &#x2F; translationY</td><td>X&#x2F;Y方向的位移</td></tr><tr><td>scaleX &#x2F;scaleY</td><td>X&#x2F;Y方向的缩放倍数</td></tr><tr><td>rotationX &#x2F; rotationY</td><td>以X&#x2F;Y轴为轴的旋转度数</td></tr></tbody></table><p>具体使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> findViewById(R.id.imageView);</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">animator</span> <span class="operator">=</span> ObjectAnimator.ofFloat(imageView, <span class="string">&quot;alpha&quot;</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">animator.setDuration(<span class="number">5000</span>);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> findViewById(R.id.imageView);</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">animator</span> <span class="operator">=</span> ObjectAnimator.ofFloat(imageView, <span class="string">&quot;alpha&quot;</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">animator.setDuration(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//动画延迟500ms执行</span></span><br><span class="line">animator.setStartDelay(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行重复次数 +1</span></span><br><span class="line">animator.setRepeatCount(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置动画重复播放模式 RESTART -执行完一遍后重新执行</span></span><br><span class="line"><span class="comment">// REVERSE -执行完一遍后 从末位置往前执行</span></span><br><span class="line">animator.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听值变换</span></span><br><span class="line">animator.addUpdateListener(<span class="keyword">new</span> <span class="title class_">ValueAnimator</span>.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;value：&quot;</span> +animation.getAnimatedValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure><p><em><strong>xml方式实现</strong></em></p><p>在<code>res</code>目录下新建<code>animator</code>文件夹<br><code>animator</code>文件夹下创建动画XML文件，如<code>animator_alpha.xml</code><br>往该xml文件中输入如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;objectAnimator xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:propertyName=<span class="string">&quot;alpha&quot;</span></span><br><span class="line">    android:valueFrom=<span class="string">&quot;1&quot;</span></span><br><span class="line">    android:valueTo=<span class="string">&quot;0&quot;</span></span><br><span class="line">    android:valueType=<span class="string">&quot;floatType&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> findViewById(R.id.imageView);</span><br><span class="line"><span class="type">Animator</span> <span class="variable">animator</span> <span class="operator">=</span> AnimatorInflater.loadAnimator(Main2Activity.<span class="built_in">this</span>, R.animator.animator_alpha);</span><br><span class="line">animator.setTarget(imageView);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>值动画（ValueAnimator）</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator <span class="title function_">ofFloat</span><span class="params">(<span class="type">float</span>... values)</span> -- 浮点型数值</span><br><span class="line">ValueAnimator  <span class="title function_">ofInt</span><span class="params">(<span class="type">int</span>... values)</span> -- 整型数值</span><br><span class="line">ValueAnimator  <span class="title function_">ofObject</span><span class="params">(TypeEvaluator evaluator, Object... values)</span> -- 自定义对象类型</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> findViewById(R.id.imageView);</span><br><span class="line"><span class="type">ValueAnimator</span> <span class="variable">anim</span> <span class="operator">=</span> ValueAnimator.ofFloat(<span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.addUpdateListener(<span class="keyword">new</span> <span class="title class_">ValueAnimator</span>.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">currentValue</span> <span class="operator">=</span> (<span class="type">float</span>) animation.getAnimatedValue();</span><br><span class="line">        Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;cuurent value is &quot;</span> + currentValue);</span><br><span class="line">        imageView.setAlpha(currentValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>PropertyValueHolder</strong></li></ol><p><code>PropertyValueHolder</code>可以让前面的一些动画同时执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> findViewById(R.id.imageView);</span><br><span class="line"><span class="type">PropertyValuesHolder</span> <span class="variable">alphaProper</span> <span class="operator">=</span> PropertyValuesHolder.ofFloat(<span class="string">&quot;alpha&quot;</span>, <span class="number">0.5f</span>, <span class="number">1f</span>);</span><br><span class="line"><span class="type">PropertyValuesHolder</span> <span class="variable">scaleXProper</span> <span class="operator">=</span> PropertyValuesHolder.ofFloat(<span class="string">&quot;scaleX&quot;</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line"><span class="type">PropertyValuesHolder</span> <span class="variable">scaleYProper</span> <span class="operator">=</span> PropertyValuesHolder.ofFloat(<span class="string">&quot;scaleY&quot;</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line"><span class="type">PropertyValuesHolder</span> <span class="variable">translationXProper</span> <span class="operator">=</span> PropertyValuesHolder.ofFloat(<span class="string">&quot;translationX&quot;</span>, -<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">PropertyValuesHolder</span> <span class="variable">translationYProper</span> <span class="operator">=</span> PropertyValuesHolder.ofFloat(<span class="string">&quot;translationY&quot;</span>, -<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">PropertyValuesHolder</span> <span class="variable">rotationProper</span> <span class="operator">=</span> PropertyValuesHolder.ofFloat(<span class="string">&quot;rotation&quot;</span>, <span class="number">0</span>, <span class="number">360</span>);</span><br><span class="line"><span class="type">ValueAnimator</span> <span class="variable">animator</span> <span class="operator">=</span> ObjectAnimator.ofPropertyValuesHolder(imageView, alphaProper,</span><br><span class="line">        scaleXProper, scaleYProper,translationXProper,translationYProper,rotationProper);</span><br><span class="line">animator.setDuration(<span class="number">5000</span>);</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>动画组合（AnimatorSet）</strong></li></ol><p>前面的PropertyValueHolder类能实现将多个动画同时执行，AnimatorSet类不仅能让多个动画同时执行，还能让多个动画按一定的顺序执行，同时也能穿插多个动画同时执行。<br>主要的方法如下：</p><p>after(Animator anim)将现有动画插入到传入的动画之后执行<br>after(long delay) 将现有动画延迟指定毫秒后执行<br>before(Animator anim) 将现有动画插入到传入的动画之前执行<br>with(Animator anim) 将现有动画和传入的动画同时执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> findViewById(R.id.imageView);</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">rotate</span> <span class="operator">=</span> ObjectAnimator.ofFloat(imageView, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>);</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">translationX</span> <span class="operator">=</span> ObjectAnimator.ofFloat(imageView, <span class="string">&quot;translationX&quot;</span>, -<span class="number">100</span>, <span class="number">100f</span>);</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">translationY</span> <span class="operator">=</span> ObjectAnimator.ofFloat(imageView, <span class="string">&quot;translationY&quot;</span>, -<span class="number">100</span>, <span class="number">100f</span>);</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">scaleX</span> <span class="operator">=</span> ObjectAnimator.ofFloat(imageView, <span class="string">&quot;scaleX&quot;</span>, <span class="number">0</span>, <span class="number">1f</span>);</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">scaleY</span> <span class="operator">=</span> ObjectAnimator.ofFloat(imageView, <span class="string">&quot;scaleY&quot;</span>, <span class="number">0</span>, <span class="number">1f</span>);</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">alpha</span> <span class="operator">=</span> ObjectAnimator.ofFloat(imageView, <span class="string">&quot;alpha&quot;</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line"><span class="type">AnimatorSet</span> <span class="variable">animSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimatorSet</span>();</span><br><span class="line">animSet.play(rotate)</span><br><span class="line">        .with(alpha)</span><br><span class="line">        .after(scaleX)</span><br><span class="line">        .before(translationX)</span><br><span class="line">        .after(<span class="number">1000</span>)</span><br><span class="line">        .before(translationY)</span><br><span class="line">        .with(scaleY);</span><br><span class="line">animSet.setDuration(<span class="number">5000</span>);</span><br><span class="line">animSet.start();</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>差值器（Interpolator）</strong></li></ol><p>前面的动画属性的变换都是均匀变换，可以通过<code>差值器（Interpolator）</code>来控制值变化的速率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ImageView</span> <span class="variable">imageView</span> <span class="operator">=</span> findViewById(R.id.imageView);</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">animator</span> <span class="operator">=</span> ObjectAnimator.ofFloat(imageView, <span class="string">&quot;alpha&quot;</span>,  <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">animator.setDuration(<span class="number">5000</span>);</span><br><span class="line"><span class="comment">//加速查值器，参数越大，速度越来越快</span></span><br><span class="line">animator.setInterpolator(<span class="keyword">new</span> <span class="title class_">AccelerateInterpolator</span>(<span class="number">5</span>));</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure><p>系统提供，也可自定义</p><table><thead><tr><th align="center">动画名称</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">AccelerateInterpolator</td><td align="center">加速查值器，参数越大，速度越来越快</td></tr><tr><td align="center">DecelerateInterpolator</td><td align="center">减速差值起，和加速查值器相反</td></tr><tr><td align="center">AccelerateDecelerateInterpolator</td><td align="center">先加速后减速</td></tr><tr><td align="center">AnticipateInterpolator</td><td align="center">先后退在加速前进</td></tr><tr><td align="center">AnticipateOvershootInterpolator</td><td align="center">以X&#x2F;Y轴为轴的旋转度数</td></tr><tr><td align="center">BounceInterpolator</td><td align="center">弹球效果插值</td></tr><tr><td align="center">CycleInterpolator</td><td align="center">周期运动插值</td></tr><tr><td align="center">LinearInterpolator</td><td align="center">匀速插值</td></tr><tr><td align="center">OvershootInterpolator</td><td align="center">先快速完成动画，再回到结束样式</td></tr></tbody></table><p>​</p><ol start="6"><li><strong>估值器（TypeEvaluator）</strong><br>在前面的值动画（ValueAnimator）中和对象动画（ObjectAnimator）有一个传对象的方法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator  <span class="title function_">ofObject</span><span class="params">(TypeEvaluator evaluator, Object... values)</span></span><br><span class="line">ObjectAnimator <span class="title function_">ofObject</span><span class="params">(Object target, String propertyName,</span></span><br><span class="line"><span class="params">            TypeEvaluator evaluator, Object... values)</span></span><br></pre></td></tr></table></figure><p>这些方法动都需要传一个TypeEvaluator，我们先来看下这个类的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TypeEvaluator</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">evaluate</span><span class="params">(<span class="type">float</span> fraction, T startValue, T endValue)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从TypeEvaluator估值器的源码可以看出该类的作用就是告诉动画，如何从起始值过度到结束值。<br>Android源码中有好几个类实现来该接口，也就是系统提供的一些默认估值器， 我们以FloatEvaluator为例看下其实现代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FloatEvaluator</span> <span class="keyword">implements</span> <span class="title class_">TypeEvaluator</span>&lt;Number&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Float <span class="title function_">evaluate</span><span class="params">(<span class="type">float</span> fraction, Number startValue, Number endValue)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">startFloat</span> <span class="operator">=</span> startValue.floatValue();</span><br><span class="line">        <span class="keyword">return</span> startFloat + fraction * (endValue.floatValue() - startFloat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从FloatEvaluator的实现可以看出在evaluate方法中用结束值减去初始值，算出它们之间的差值，然后乘以fraction这个系数，再加上初始值，那么就得到当前动画的值了</p><p>我们也可以以该方法为例 实现一个自定义的估值器实现一个背景颜色值的变化</p><p>我们先定义一个默认估值器类MyTypeEvaluator,该类自定义了颜色过渡的方式</p><p>​<br>​     package com.lucashu.animation;<br>​<br>​    import android.animation.TypeEvaluator;<br>​<br>​    public class MyTypeEvaluator implements TypeEvaluator<String> {<br>​        private int mCurrentRed &#x3D; -1;<br>​        private int mCurrentGreen &#x3D; -1;<br>​        private int mCurrentBlue &#x3D; -1;<br>​    @Override<br>​    public String evaluate(float fraction, String startValue, String endValue) {<br>​        int startRed &#x3D; Integer.parseInt(startValue.substring(1, 3), 16);<br>​        int startGreen &#x3D; Integer.parseInt(startValue.substring(3, 5), 16);<br>​        int startBlue &#x3D; Integer.parseInt(startValue.substring(5, 7), 16);<br>​        int endRed &#x3D; Integer.parseInt(endValue.substring(1, 3), 16);<br>​        int endGreen &#x3D; Integer.parseInt(endValue.substring(3, 5), 16);<br>​        int endBlue &#x3D; Integer.parseInt(endValue.substring(5, 7), 16);<br>​        &#x2F;&#x2F; 初始化颜色的值<br>​        if (mCurrentRed &#x3D;&#x3D; -1) {<br>​            mCurrentRed &#x3D; startRed;<br>​        }<br>​        if (mCurrentGreen &#x3D;&#x3D; -1) {<br>​            mCurrentGreen &#x3D; startGreen;<br>​        }<br>​        if (mCurrentBlue &#x3D;&#x3D; -1) {<br>​            mCurrentBlue &#x3D; startBlue;<br>​        }<br>​        &#x2F;&#x2F; 计算初始颜色和结束颜色之间的差值<br>​        int redDiff &#x3D; Math.abs(startRed - endRed);<br>​        int greenDiff &#x3D; Math.abs(startGreen - endGreen);<br>​        int blueDiff &#x3D; Math.abs(startBlue - endBlue);<br>​        int colorDiff &#x3D; redDiff + greenDiff + blueDiff;<br>​        if (mCurrentRed !&#x3D; endRed) {<br>​            mCurrentRed &#x3D; getCurrentColor(startRed, endRed, colorDiff, 0,<br>​                    fraction);<br>​        } else if (mCurrentGreen !&#x3D; endGreen) {<br>​            mCurrentGreen &#x3D; getCurrentColor(startGreen, endGreen, colorDiff,<br>​                    redDiff, fraction);<br>​        } else if (mCurrentBlue !&#x3D; endBlue) {<br>​            mCurrentBlue &#x3D; getCurrentColor(startBlue, endBlue, colorDiff,<br>​                    redDiff + greenDiff, fraction);<br>​        }<br>​        &#x2F;&#x2F; 将计算出的当前颜色的值组装返回<br>​        String currentColor &#x3D; “#” + getHexString(mCurrentRed)<br>​                + getHexString(mCurrentGreen) + getHexString(mCurrentBlue);<br>​        return currentColor;<br>​    }<br>​    &#x2F;**<br>​     * 根据fraction值来计算当前的颜色。<br>​     <em>&#x2F;<br>​    private int getCurrentColor(int startColor, int endColor, int colorDiff,<br>​                                int offset, float fraction) {<br>​        int currentColor;<br>​        if (startColor &gt; endColor) {<br>​            currentColor &#x3D; (int) (startColor - (fraction * colorDiff - offset));<br>​            if (currentColor &lt; endColor) {<br>​                currentColor &#x3D; endColor;<br>​            }<br>​        } else {<br>​            currentColor &#x3D; (int) (startColor + (fraction * colorDiff - offset));<br>​            if (currentColor &gt; endColor) {<br>​                currentColor &#x3D; endColor;<br>​            }<br>​        }<br>​        return currentColor;<br>​    }<br>​<br>​    &#x2F;</em>*<br>​     * 将10进制颜色值转换成16进制。<br>​     *&#x2F;<br>​    private String getHexString(int value) {<br>​        String hexString &#x3D; Integer.toHexString(value);<br>​        if (hexString.length() &#x3D;&#x3D; 1) {<br>​            hexString &#x3D; “0” + hexString;<br>​        }<br>​        return hexString;<br>​    }<br>​    }</p><p>再自定义一个View，在该类中画一个矩形框</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyView</span> <span class="keyword">extends</span> <span class="title class_">View</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String color;</span><br><span class="line"><span class="keyword">private</span> Paint mPaint;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(context, attrs);</span><br><span class="line">    mPaint = <span class="keyword">new</span> <span class="title class_">Paint</span>(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(Color.WHITE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">    mPaint.setColor(Color.parseColor(color));</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onDraw(canvas);</span><br><span class="line">    canvas.drawRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>,<span class="number">500</span>, mPaint);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自顶一个View在布局文件中添加如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.lucashu.animation.MyView</span><br><span class="line">    android:id=<span class="string">&quot;@+id/myview&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;200dp&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;200dp&quot;</span></span><br><span class="line">    android:layout_marginBottom=<span class="string">&quot;100dp&quot;</span></span><br><span class="line">    app:layout_constraintBottom_toBottomOf=<span class="string">&quot;parent&quot;</span></span><br><span class="line">    app:layout_constraintEnd_toEndOf=<span class="string">&quot;parent&quot;</span></span><br><span class="line">    app:layout_constraintStart_toStartOf=<span class="string">&quot;parent&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>将在估值器加到动画中，该动画作用在我们自定义的View上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyView</span> <span class="variable">imageView</span> <span class="operator">=</span> findViewById(R.id.myview);</span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">anim</span> <span class="operator">=</span> ObjectAnimator.ofObject(</span><br><span class="line">        imageView,<span class="string">&quot;color&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyTypeEvaluator</span>(),</span><br><span class="line">        <span class="string">&quot;#0000FF&quot;</span>,<span class="string">&quot;#FF0000&quot;</span>);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><h3 id="Handler和Runable"><a href="#Handler和Runable" class="headerlink" title="Handler和Runable"></a>Handler和Runable</h3><h4 id="启动页"><a href="#启动页" class="headerlink" title="启动页"></a>启动页</h4><p>安卓启动app会自带一个页面，这个页面会加载app，之后才会加载自己设置的启动页面，如果启动页面的逻辑很快过去就会显得欢迎页面一闪而过切有滑动显示自带启动页情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler延时        </span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> <span class="title class_">Intent</span>(WelcomeActivity.<span class="built_in">this</span>, MainActivity.class));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line">        handler.postDelayed(runnable,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p><strong>冷启动背景</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppTheme.Launcher&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.AppCompat.Light.NoActionBar&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@drawable/bg_splash<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.ui.activity.SplashActivity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/AppTheme.Launcher&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Handler消息机制"><a href="#Handler消息机制" class="headerlink" title="Handler消息机制"></a>Handler消息机制</h4><p><a href="https://blog.csdn.net/ly0724ok/article/details/117324053/">(28条消息) Android——Handler详解_android handler_Yawn__的博客-CSDN博客</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*主线程创建Handler（属于主线程，Looper.myLooper()），之后子线程调用这个Handler传消息*/</span></span><br><span class="line">  mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.myLooper())&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">          <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">          <span class="keyword">if</span> (msg.what==<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="type">Boolean</span> <span class="variable">isStart</span> <span class="operator">=</span> (Boolean) msg.obj;</span><br><span class="line">              <span class="keyword">if</span> (isStart)&#123;</span><br><span class="line">                  startActivity(<span class="keyword">new</span> <span class="title class_">Intent</span>(WelcomeActivity.<span class="built_in">this</span>,HomeActivity.class));</span><br><span class="line">                  finish();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/*子线程读数据*/</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">          message.what = <span class="number">0</span>;<span class="comment">//what表示是哪个子线程发的消息</span></span><br><span class="line">          message.arg1 = <span class="number">0</span>;<span class="comment">//arg1和arg2内置标识用的</span></span><br><span class="line">          message.arg2 = <span class="number">1</span>;</span><br><span class="line">          message.obj = <span class="literal">true</span>;<span class="comment">//传其他类型就用org这个参数，为Object类，什么都能传</span></span><br><span class="line">          mHandler.sendMessage(message);<span class="comment">//还有许多传消息的方法</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;).start();</span><br></pre></td></tr></table></figure><h3 id="Material-Design设计语言"><a href="#Material-Design设计语言" class="headerlink" title="Material Design设计语言"></a>Material Design设计语言</h3><p>Material Design（中文名：材料设计语言），是由Google推出的<strong>设计语言</strong>，这种设计语言旨在为手机、平板电脑、台式机和“其他平台<em>”提供更一致、更广泛的“外观和感觉”</em>。</p><p>那为什么谷歌会觉得Material Design可以解决Android平台界面风格不统一的问题呢？</p><p>一言蔽之——好看。</p><h4 id="Toolbar-顶部导航，常用"><a href="#Toolbar-顶部导航，常用" class="headerlink" title="Toolbar(顶部导航，常用)"></a><code>Toolbar</code>(顶部导航，常用)</h4><p>我们平常建立一个项目，原生的顶上标题栏<code>Actionbar</code>都是深紫色的标题栏，而且<code>ActionBar</code>是一个只能位于活动的顶部的标题栏。</p><p><code>ActionBar</code>弃用了，可以用<code>ToolBar</code>实现一样的功能</p><p><strong>替代<code>ActionBar</code></strong></p><p>主题改成<code>&lt;style name=&quot;Theme.MyApplication&quot; parent=&quot;Theme.MaterialComponents.DayNight.NoActionBar.Bridge&quot;&gt;</code>,在xml使用<code>Toolbar</code>控件即可，要显示什么标题在<code>AndroidManifest.xml</code>设置<code>android:label=&quot;Fruits&quot;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;?attr/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:popupTheme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Toolbar</span> <span class="variable">toolbar</span> <span class="operator">=</span> (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">setSupportActionBar(toolbar);</span><br></pre></td></tr></table></figure><p><strong>自定义<code>ToolBar</code>菜单</strong></p><p>先在<code>res</code>下新建<code>menu</code>资源文件夹,例子如下，<code>item</code>标签表示一个新建选项，<code>icon</code>为图标，<code>title</code>标题，<code>showAction</code>为显示方式，<code>showAsAction</code> 主要有以下几种值可选:always表示永远显示在 <code>Toolbar</code>中，如果屏幕空间不够则不显示;<code>ifRoom</code>表示屏幕空间足够的情况下显示在<code>Toolbar</code>中，不够的话就显示在菜单当中;<code>never</code> 则表示水远显示在菜单当中。在菜单中的项没有图标，即使设置了图标，只显示文字，菜单为收起形式，点击展开</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/backup&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/backup&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;Backup&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;always&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/delete&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/delete&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;Backup&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;ifRoom&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/settings&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/settings&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;Backup&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;never&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在Java中重写两个方法来导入menu和使用，在<code>onOptionsItemMenu()</code>方法中加载了菜单文件，然后<code>onOptionsItemSelected()</code>方法中处理<code>ActionBar</code>各个按钮的点击事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreateOptionsMenu</span><span class="params">(Menu menu)</span>&#123;</span><br><span class="line">    getMenuInflater().inflate(R.menu.toolbar,menu);<span class="comment">//在这里加载了toolbar.xml这个菜单文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onOptionsItemSelected</span><span class="params">(MenuItem item)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (item.getItemId())&#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.backup:</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>,<span class="string">&quot;You clicked Backup &quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.delete:</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>,<span class="string">&quot;You clicked Delete &quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.settings:</span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>,<span class="string">&quot;You clicked Settings &quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 反射使item属性为never时使icon和title同时可见</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onMenuOpened</span><span class="params">(<span class="type">int</span> featureId, Menu menu)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (menu != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (menu.getClass().getSimpleName().equalsIgnoreCase(<span class="string">&quot;MenuBuilder&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> menu.getClass().getDeclaredMethod(<span class="string">&quot;setOptionalIconsVisible&quot;</span>, Boolean.TYPE);</span><br><span class="line">                method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                method.invoke(menu, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.onMenuOpened(featureId, menu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="滑动菜单（右滑显示，如QQ）"><a href="#滑动菜单（右滑显示，如QQ）" class="headerlink" title="滑动菜单（右滑显示，如QQ）"></a>滑动菜单（右滑显示，如QQ）</h4><h5 id="DrawerLayout（抽屉，常用）"><a href="#DrawerLayout（抽屉，常用）" class="headerlink" title="DrawerLayout（抽屉，常用）"></a><code>DrawerLayout</code>（抽屉，常用）</h5><p>这个控件中允许有2个子布局（控件），第一个显示在外面，第二个为折叠起来，右滑展开，其中第二个控件中的<code>layout_gravity</code>是必须需要指定的，其中<code>left</code>表示菜单在左边，<code>start</code>表示会根据系统语言进行判断，如果系统语言是从左到右的，则滑动菜单在左边。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.drawerlayout.widget.DrawerLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/draw_layout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;?attr/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popupTheme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;300dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;start&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#FFF&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;This is menu&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.drawerlayout.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了让隐藏菜单更容易被触发，我们在<code>Toolbar</code>上加一个导航按钮，点击它也可以打开滑动菜单(防止用户不知道左滑能打开东西，参考QQ设计)。<strong>注:<code>HomeAsUp</code>默认为返回按钮，图标为箭头，这里就把这个按钮替换了图标和功能罢了。</strong><code>GravityCompat.START</code>和xml定义一样，xml布局里面在菜单中的子布局<code>android:layout_gravity=&quot;start&quot;</code>属性一样，还有<code>GravityCompat.END</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ActionBar自带功能加按钮（上面使用了ToolBar替代了ActionBar，但实体还是ActionBar）      </span></span><br><span class="line"><span class="type">ActionBar</span> <span class="variable">actionBar</span> <span class="operator">=</span> getSupportActionBar()<span class="comment">//获取对象</span></span><br><span class="line">        <span class="keyword">if</span> (actionBar!=<span class="literal">null</span>)&#123;</span><br><span class="line">            actionBar.setDisplayHomeAsUpEnabled(<span class="literal">true</span>);<span class="comment">//导航按钮显示</span></span><br><span class="line">            actionBar.setHomeAsUpIndicator(R.drawable.ic_menu);<span class="comment">//设置导航按钮图标</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//onOptionsItemSelected方法中监听导航按钮，id如下</span></span><br><span class="line"><span class="keyword">case</span> android.R.id.home:</span><br><span class="line">                mDrawerLayout.openDrawer(GravityCompat.START);</span><br><span class="line"><span class="comment">//使得滑动显示出来，传入一个Gravity参数，GravityCompat.START和xml定义一样</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h5 id="NavigationView优化滑动呼出菜单-自带免设计罢了-（包含图片圆形化库）"><a href="#NavigationView优化滑动呼出菜单-自带免设计罢了-（包含图片圆形化库）" class="headerlink" title="NavigationView优化滑动呼出菜单(自带免设计罢了)（包含图片圆形化库）"></a><code>NavigationView</code>优化滑动呼出菜单(自带免设计罢了)（包含图片圆形化库）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation<span class="string">&#x27;com.google.android.material:material:1.0.0&#x27;</span><span class="comment">//Design Support库（包含NavigationeView），现在默认生成</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation<span class="string">&#x27;de.hdodenhof:circleimageview:3.0.1&#x27;</span><span class="comment">//一个开源库，轻松实现图片圆形化</span></span><br></pre></td></tr></table></figure><p>准备两个部分的东西，menu菜单（NavigationView中的选项菜单）和headerLayout（NavigationView中的头部布局）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--menu--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:checkableBehavior</span>=<span class="string">&quot;single&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        group 代表一个组，checkableBehavior指定为single表示组内所有菜单项只能单选--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/nav_call&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/nav_call&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">&quot;Call&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        菜单单项显示的文字--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/nav_friend&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/nav_friend&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">&quot;Friend&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/nav_location&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/nav_location&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">&quot;Location&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/nav_mail&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/nav_mail&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">&quot;Mail&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/nav_task&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/nav_task&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">&quot;Task&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//headerLayout</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;180dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;?attr/colorPrimary&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">de.hdodenhof.circleimageview.CircleImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/icon_image&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;70dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;70dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">&quot;@drawable/icon&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/username&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentBottom</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;wendy&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#FFF&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;14sp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/mail&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_above</span>=<span class="string">&quot;@id/username&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;1111@qq&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#FFF&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;14sp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.navigation.NavigationView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_gravity</span>=<span class="string">&quot;start&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>这里layout_gravity一定要有，不然会阻挡整个屏幕，toolbar会不见掉</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      <span class="type">NavigationView</span> <span class="variable">navigationView</span> <span class="operator">=</span> findViewById(R.id.nav_view);</span><br><span class="line">      navigationView.setCheckedItem(R.id.nav_call);<span class="comment">//设置默认选中按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">      navigationView.setNavigationItemSelectedListener(<span class="keyword">new</span> <span class="title class_">NavigationView</span>.OnNavigationItemSelectedListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onNavigationItemSelected</span><span class="params">(<span class="meta">@NonNull</span> MenuItem item)</span> &#123;</span><br><span class="line">              mDrawerLayout.closeDrawers();</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击事件</span></span><br><span class="line">nav_home = (NavigationView) findViewById(R.id.nav_home);</span><br><span class="line">      <span class="type">CardView</span> <span class="variable">cardView</span> <span class="operator">=</span> nav_home.getHeaderView(<span class="number">0</span>).findViewById(R.id.cv_exit);</span><br><span class="line">      cardView.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">              Toast.makeText(HomeActivity.<span class="built_in">this</span>, <span class="string">&quot;ddd&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><h4 id="悬浮按钮和可交互提示"><a href="#悬浮按钮和可交互提示" class="headerlink" title="悬浮按钮和可交互提示"></a>悬浮按钮和可交互提示</h4><p>立面设计是Material Design中的一条重要设计思想，而悬浮按钮就是最具有代表性的立面设计了，这种按钮不属于主界面平面的一部分而是位于另外一个维度。同时我们也学习一种可交互式的提示。</p><h5 id="FloatingActionButton"><a href="#FloatingActionButton" class="headerlink" title="FloatingActionButton"></a><code>FloatingActionButton</code></h5><p><code> android:elevation=&quot;100dp&quot;</code>设置悬浮高度，下面有阴影</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.floatingactionbutton.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/fab&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_gravity</span>=<span class="string">&quot;bottom|end&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_margin</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:elevation</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_done&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这个控件监听方法同平台button</p><h5 id="Snackbar可交互提示"><a href="#Snackbar可交互提示" class="headerlink" title="Snackbar可交互提示"></a><code>Snackbar</code>可交互提示</h5><p>首先明确<code>Snackbar</code>和<code>Toast</code>有各自的应用场景，<code>Snackbark</code>可以给用户提供了一个可交互按钮，给用户提供一些额外操作。基本同<code>Toast</code>，toast只是为了发出一个提示给用户罢了，有些如删除数据的场景就可以用这种带交互的好，可以允许用户取消删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">floatingActionButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                Snackbar.make(v,<span class="string">&quot;toast&quot;</span>,Snackbar.LENGTH_SHORT)</span><br><span class="line">                        .setAction(<span class="string">&quot;Undo&quot;</span>, <span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                                Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;取消&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h5 id="CoordinatorLayout布局"><a href="#CoordinatorLayout布局" class="headerlink" title="CoordinatorLayout布局"></a><code>CoordinatorLayout</code>布局</h5><p><code>CoordinatorLayout</code>可以说是加强版的<code>FrameLayout</code>（帧布局），也是Design Support库提供的，它在普通情况下和<code>FrameLayout</code>作用基本一致。不一样的是<code>CoordinatorLayout</code>可以监听其子控件的各种事件，然后自动帮助我们做出最为合理的响应。</p><p>举个例子，刚刚弹出来的Snackbar提示把悬浮按钮遮挡住了，这时让CoordinatorLayout监听到Snackbar的弹出事件，它就会自动让FloatingActionButton向上偏移。</p><p>直接在代码中将<code>FrameLayout</code>替换一下就可以</p><h4 id="卡片式布局（包含Glide库）"><a href="#卡片式布局（包含Glide库）" class="headerlink" title="卡片式布局（包含Glide库）"></a>卡片式布局（包含Glide库）</h4><h5 id="CardView（类FrameLayout）"><a href="#CardView（类FrameLayout）" class="headerlink" title="CardView（类FrameLayout）"></a><code>CardView</code>（类<code>FrameLayout</code>）</h5><p>CardView是实现卡片上布局的重要控件。它实际上也是一个FrameLayout，只是额外提供了圆角和阴影的效果，看上去会有立体的感觉。</p><p>1、cardBackgroundColor 设置背景色</p><p>CardView是View的子类，View一般使用Background设置背景色，为什么还要单独提取出一个属性让我们来设置背景色呢？</p><p>为了实现阴影效果，内部已经消耗掉了 Background 属性</p><p>2、cardCornerRadius 设置圆角半径</p><p>3、contentPadding 设置内部padding</p><p>View提供了padding设置间距，为什么还要单独提取出一个属性？</p><p>相同的原因，内部消耗掉了 padding 属性</p><p>4、cardElevation 设置阴影大小</p><p>5、cardUseCompatPadding</p><p>默认为false，用于5.0及以上，true则添加额外的 padding 绘制阴影</p><p>6、cardPreventCornerOverlap</p><p>默认为true，用于5.0及以下，添加额外的 padding，防止内容和圆角重叠</p><p><strong>Glide</strong>是一个超级强大的图片加载库，可以加载本地图片、网络图片、gif图片，甚至本地视频。而且Glide的用法也很简单，只用一行代码我们会在下面进行设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">implementation<span class="string">&#x27;com.github.bumptech.glide:glide:4.9.0&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*直接按照提示用最新的库，库版本过低还未迁移到AndroidX，会有警告，低版本在gradle.properties</span></span><br><span class="line"><span class="comment">    加android.enableJetifier=true*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context)</span><br><span class="line">                .load(path.toString())</span><br><span class="line">                .error(R.mipmap.menu_cancellation)<span class="comment">//图片加载失败后，显示的图片</span></span><br><span class="line">                .diskCacheStrategy(DiskCacheStrategy.RESULT) <span class="comment">//缓存图片</span></span><br><span class="line">                .into(imageView);</span><br></pre></td></tr></table></figure><h5 id="AppBarLayout解决CoordinatorLayou默认左上角放置重叠问题"><a href="#AppBarLayout解决CoordinatorLayou默认左上角放置重叠问题" class="headerlink" title="AppBarLayout解决CoordinatorLayou默认左上角放置重叠问题"></a><code>AppBarLayout</code>解决<code>CoordinatorLayou</code>默认左上角放置重叠问题</h5><p>运行后我们发现，先前的<code>Toolbar</code>被遮挡了，这是因为<code>CoordinatorLayou</code>是和<code>FrameLayout</code>一样，在没有进行明确定位时，默认都会摆放在布局的左上角，所以产生了遮挡。那除了对<code>RecyclerView</code>进行偏移，我们还可以借助Design Support库中提供的另外一个工具——<code>AppBarLayout</code>来解决遮挡。**<code>AppBarLayout</code>实际上是一个垂直方向的<code>LinearLayout</code>**，它在内部做了很多滚动事件的封装，并应用了一些Material Design的设计理念。<code>AppBarLayout</code>又必须是<code>CoordinatorLayout</code>的子布局</p><p>包住冲突事件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.appbar.AppBarLayout</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;?attr/colorPrimary&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:popupTheme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">com.google.android.material.appbar.AppBarLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再另外给**<code>RecyclerView</code>**指定一个布局行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_behavior=<span class="string">&quot;@string/appbar_scrolling_view_behavior&quot;</span></span><br></pre></td></tr></table></figure><p>运行看效果</p><p>那现在我们只是用AppBarLayout解决了遮挡问题，那应用了一些Material Design的设计理念是怎么体现的呢？其实这时RecyclerView已经将滚动事件通知了AppBarLayout，但是我们还没有进行处理，我们在<strong>Toolbar</strong>添加以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_scrollFlags=<span class="string">&quot;scroll|enterAlways|snap&quot;</span></span><br></pre></td></tr></table></figure><p><code>scroll</code>表示当<code>RecyclerView</code>向上滚动时，<code>Toolbar</code>会跟着向上滚动并隐藏；<code>enterAlways</code>表示当<code>RecyclerView</code>向下滚动时，<code>Toolbar</code>会跟着向下滚动并重新显示。<code>snap</code>表示<code>Toolbar</code>还没有完全隐藏或显示的时候，会根据当前滚动距离，自动选择是隐藏还是显示。运行看一下。</p><h4 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h4><h5 id="swiperefreshlayout"><a href="#swiperefreshlayout" class="headerlink" title="swiperefreshlayout"></a><code>swiperefreshlayout</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.swiperefreshlayout:swiperefreshlayout:1.1.0&quot;</span></span><br></pre></td></tr></table></figure><p>包在<code>RecyclerView</code>外面使用，这时候<code>RecyclerView</code>添加的滚动行为要放到刷新控件中，不然刷新控件不生效，会被挡住</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mSwipeRefreshLayout = findViewById(R.id.refresh);</span><br><span class="line">        mSwipeRefreshLayout.setColorSchemeResources(R.color.black);</span><br><span class="line">        mSwipeRefreshLayout.setOnRefreshListener(<span class="keyword">new</span> <span class="title class_">SwipeRefreshLayout</span>.OnRefreshListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        runOnUiThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                                initFruits();</span><br><span class="line">                                adapter.notifyDataSetChanged();</span><br><span class="line">                                mSwipeRefreshLayout.setRefreshing(<span class="literal">false</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h4 id="可折叠标题栏"><a href="#可折叠标题栏" class="headerlink" title="可折叠标题栏"></a>可折叠标题栏</h4><h5 id="CollapsingToolbarLayout"><a href="#CollapsingToolbarLayout" class="headerlink" title="CollapsingToolbarLayout"></a><code>CollapsingToolbarLayout</code></h5><p>顾名思义，<code>CollapsingToolbarLayout</code>是一个作用于<code>Toolbar</code>基础之上的布局，被限定只能作为<code>AppBarLayout</code>的直接子布局来使用，而<code>AppBarLayout</code>又必须是<code>CoordinatorLayout</code>的子布局。</p><p><strong>充分利用系统状态栏空间</strong></p><p><code>android:fitsSystemWindows=&quot;true&quot;</code></p><p>因为我们现在写的是嵌套结构，所以为了实现这种效果，我们需要分别在<code>CoordinatorLayout</code>、<code>AppBarLayout</code>和<code>CollapsingToolbarLayout</code>设置其<code>android:fitsSystemWindows</code>属性为<code>ture</code>，就表示该控件ImageView会出现在系统状态栏上。除了这些我们还要将状态栏的颜色去设置成透明色才行。具体怎么实现大家有兴趣的可以去看书里的具体做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> <span class="title class_">ObservableOnSubscribe</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        emitter.onNext(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对发射的字符串进行转换，这里简单地在字符串后面加上 &quot; RxJava&quot;</span></span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">&quot; RxJava&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribe(<span class="keyword">new</span> <span class="title class_">Observer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Disposable d)</span> &#123;</span><br><span class="line">        <span class="comment">// 订阅时的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(String result)</span> &#123;</span><br><span class="line">        <span class="comment">// 接收到转换后的事件，result 是 &quot;Hello RxJava&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        <span class="comment">// 发生错误时的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 完成时的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.derry.rxjavastudy.simple01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.ProgressDialog;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.derry.rxjavastudy.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.reactivex.Observable;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.Observer;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.annotations.NonNull;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.disposables.Disposable;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.functions.Consumer;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.functions.Function;</span><br><span class="line"><span class="keyword">import</span> io.reactivex.schedulers.Schedulers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印logcat日志的标签</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> MainActivity.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网络图片的链接地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">PATH</span> <span class="operator">=</span> <span class="string">&quot;http://pic1.win4000.com/wallpaper/c/53cdd1f7c1f21.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹出加载框（正在加载中...）</span></span><br><span class="line">    <span class="keyword">private</span> ProgressDialog progressDialog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ImageView控件，用来显示结果图像</span></span><br><span class="line">    <span class="keyword">private</span> ImageView image;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        image = findViewById(R.id.image);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片显示加载功能</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImageAction</span><span class="params">(View view)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果我们采用传统方式 完成此功能，每位开发者的思想都不一样 （思维不同 ）</span></span><br><span class="line"><span class="comment">         * A同学 线程池</span></span><br><span class="line"><span class="comment">         * B同学 new Thread + Handler</span></span><br><span class="line"><span class="comment">         * C同学 xxx</span></span><br><span class="line"><span class="comment">         * D同学 古老的方式</span></span><br><span class="line"><span class="comment">         * ....</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果采用传统开发方式，我们后面的开发者接手前面开发者的代码，就很痛苦（弊端）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * TODO　RX思维</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 起点 和 终点</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RxJava RXJS RxXXX  RX系列框架 为什么把所有函数都成为操作符 因为我们的函数要去操作  从起点 流向 终点7</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 第二步</span></span><br><span class="line">        <span class="comment">// 起点</span></span><br><span class="line">        Observable.just(PATH)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// TODO 第三步</span></span><br><span class="line">                <span class="comment">// 需求：001 图片下载需求  PATH ---》 Bitmap</span></span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Bitmap&gt;() &#123;</span><br><span class="line">                    <span class="meta">@NonNull</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Bitmap <span class="title function_">apply</span><span class="params">(<span class="meta">@NonNull</span> String path)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                            Thread.sleep(2000); // 睡眠2秒钟</span></span><br><span class="line"></span><br><span class="line">                            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(path);</span><br><span class="line">                            <span class="type">HttpURLConnection</span> <span class="variable">httpURLConnection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">                            httpURLConnection.setConnectTimeout(<span class="number">5000</span>); <span class="comment">// 设置请求连接时长 5秒</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">responseCode</span> <span class="operator">=</span> httpURLConnection.getResponseCode(); <span class="comment">// 才开始 request    拿到服务器的响应  200成功  404有问题 ...</span></span><br><span class="line">                            <span class="keyword">if</span> (responseCode == HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">                                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> httpURLConnection.getInputStream();</span><br><span class="line">                                <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeStream(inputStream);</span><br><span class="line">                                <span class="keyword">return</span> bitmap;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 需求：002 加水印</span></span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Bitmap, Bitmap&gt;() &#123;</span><br><span class="line">                    <span class="meta">@NonNull</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Bitmap <span class="title function_">apply</span><span class="params">(<span class="meta">@NonNull</span> Bitmap bitmap)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="type">Paint</span> <span class="variable">paint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">                        paint.setColor(Color.RED);</span><br><span class="line">                        paint.setTextSize(<span class="number">88</span>);</span><br><span class="line">                        <span class="type">Bitmap</span> <span class="variable">shuiyingBitmap</span> <span class="operator">=</span> drawTextToBitmap(bitmap, <span class="string">&quot;韭菜盖饭&quot;</span>, paint, <span class="number">88</span>, <span class="number">88</span>);</span><br><span class="line">                        <span class="keyword">return</span> shuiyingBitmap;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 需求：003 日志记录需求</span></span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Bitmap, Bitmap&gt;() &#123;</span><br><span class="line">                    <span class="meta">@NonNull</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Bitmap <span class="title function_">apply</span><span class="params">(<span class="meta">@NonNull</span> Bitmap bitmap)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        Log.e(TAG, <span class="string">&quot;什么时候下载了图片 apply: &quot;</span> + System.currentTimeMillis() );</span><br><span class="line">                        <span class="keyword">return</span> bitmap;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 给上面的分配异步线程（图片下载操作）</span></span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 终点分配 Android主线程</span></span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line"></span><br><span class="line">                <span class="comment">// TODO 导火索 点燃了  开始执行</span></span><br><span class="line">                <span class="comment">// 关联：观察者设计模式   关联 起点 和 终点  ==  订阅</span></span><br><span class="line">                .subscribe(</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 终点</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Observer</span>&lt;Bitmap&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// TODO 第一步</span></span><br><span class="line">                            <span class="comment">// 订阅成功</span></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Disposable d)</span> &#123;</span><br><span class="line">                                <span class="comment">// 显示加载框</span></span><br><span class="line">                                progressDialog = <span class="keyword">new</span> <span class="title class_">ProgressDialog</span>(MainActivity.<span class="built_in">this</span>);</span><br><span class="line">                                progressDialog.setTitle(<span class="string">&quot;RXJava Derry run 正在加载中..&quot;</span>);</span><br><span class="line">                                progressDialog.show();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// TODO 第四步 显示图片   水印的Bitmap</span></span><br><span class="line">                            <span class="comment">// 上一层给我的响应</span></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">                                image.setImageBitmap(bitmap); <span class="comment">// 显示到控件上</span></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 链条思维发生了异常</span></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// TODO 第五步 整个链条思维全部结束</span></span><br><span class="line">                            <span class="comment">// 整个链条全部结束</span></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">                                <span class="comment">// 隐藏加载框</span></span><br><span class="line">                                <span class="keyword">if</span> (progressDialog != <span class="literal">null</span>)</span><br><span class="line">                                    progressDialog.dismiss();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图片上绘制文字 加水印</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Bitmap <span class="title function_">drawTextToBitmap</span><span class="params">(Bitmap bitmap, String text, Paint paint, <span class="type">int</span> paddingLeft, <span class="type">int</span> paddingTop)</span> &#123;</span><br><span class="line">        Bitmap.<span class="type">Config</span> <span class="variable">bitmapConfig</span> <span class="operator">=</span> bitmap.getConfig();</span><br><span class="line"></span><br><span class="line">        paint.setDither(<span class="literal">true</span>); <span class="comment">// 获取跟清晰的图像采样</span></span><br><span class="line">        paint.setFilterBitmap(<span class="literal">true</span>);<span class="comment">// 过滤一些</span></span><br><span class="line">        <span class="keyword">if</span> (bitmapConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">            bitmapConfig = Bitmap.Config.ARGB_8888;</span><br><span class="line">        &#125;</span><br><span class="line">        bitmap = bitmap.copy(bitmapConfig, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">Canvas</span> <span class="variable">canvas</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Canvas</span>(bitmap);</span><br><span class="line"></span><br><span class="line">        canvas.drawText(text, paddingLeft, paddingTop, paint);</span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常用操作符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(View view)</span> &#123;</span><br><span class="line"></span><br><span class="line">        String[] strings = &#123;<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for</span></span><br><span class="line">        <span class="comment">/*for (String string : strings) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 起点</span></span><br><span class="line">        Observable.fromArray(strings)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 订阅：起点 和 终点</span></span><br><span class="line">                .subscribe(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 终点</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(<span class="meta">@NonNull</span> String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">&quot;accept: &quot;</span> + s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_50709355/article/details/127176797?ops_request_misc=%7B%22request_id%22:%22170123531316800184156037%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170123531316800184156037&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-127176797-null-null.nonecase&utm_term=rxjava&spm=1018.2226.3001.4450">RXJAVA从入门到精通-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发常用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发常用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

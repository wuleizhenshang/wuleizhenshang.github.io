<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java知识秘籍 | Blog-无泪真伤</title><meta name="author" content="无泪真伤"><meta name="copyright" content="无泪真伤"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="总结自下面链接，转载请使用大佬的博客地址https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_29966203&#x2F;article&#x2F;details&#x2F;105455615?spm&#x3D;1001.2014.3001.5502 第一章 面向对象 面向对象三大特性？ 对this和super的认识？ 谈谈权限修饰符的特性？ 对java多态的理解 &#x2F;Java中实现多态的机制是什么？ 静态属性和静态方法能被继承吗？">
<meta property="og:type" content="article">
<meta property="og:title" content="Java知识秘籍">
<meta property="og:url" content="https://www.wuleizhenshang.love/2025/01/03/java%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/index.html">
<meta property="og:site_name" content="Blog-无泪真伤">
<meta property="og:description" content="总结自下面链接，转载请使用大佬的博客地址https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_29966203&#x2F;article&#x2F;details&#x2F;105455615?spm&#x3D;1001.2014.3001.5502 第一章 面向对象 面向对象三大特性？ 对this和super的认识？ 谈谈权限修饰符的特性？ 对java多态的理解 &#x2F;Java中实现多态的机制是什么？ 静态属性和静态方法能被继承吗？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2025/01/03/K2M9njOwagHpfIs.jpg">
<meta property="article:published_time" content="2025-01-03T12:18:23.000Z">
<meta property="article:modified_time" content="2025-02-05T11:20:43.117Z">
<meta property="article:author" content="无泪真伤">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2025/01/03/K2M9njOwagHpfIs.jpg"><link rel="shortcut icon" href="/img/86634.jpg"><link rel="canonical" href="https://www.wuleizhenshang.love/2025/01/03/java%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 无泪真伤","link":"链接: ","source":"来源: Blog-无泪真伤","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java知识秘籍',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-05 19:20:43'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/65582252c458853aeff7c6f5.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2025/01/03/K2M9njOwagHpfIs.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog-无泪真伤"><span class="site-name">Blog-无泪真伤</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java知识秘籍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-03T12:18:23.000Z" title="发表于 2025-01-03 20:18:23">2025-01-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-05T11:20:43.117Z" title="更新于 2025-02-05 19:20:43">2025-02-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android%E9%9D%A2%E8%AF%95/">Android面试</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android%E9%9D%A2%E8%AF%95/Java%E7%9F%A5%E8%AF%86/">Java知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">65.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>233分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java知识秘籍"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>总结自下面链接，转载请使用大佬的博客地址<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29966203/article/details/105455615?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_29966203/article/details/105455615?spm=1001.2014.3001.5502</a></strong></p>
<h1 id="第一章-面向对象"><a href="#第一章-面向对象" class="headerlink" title="第一章 面向对象"></a>第一章 面向对象</h1><ul>
<li>面向对象三大特性？</li>
<li>对this和super的认识？</li>
<li>谈谈权限修饰符的特性？</li>
<li>对java多态的理解 &#x2F;Java中实现多态的机制是什么？</li>
<li>静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？</li>
</ul>
<h2 id="面向对象三大特性？"><a href="#面向对象三大特性？" class="headerlink" title="面向对象三大特性？"></a>面向对象三大特性？</h2><p>面向对象的三大特性包括：封装、继承、多态。</p>
<ul>
<li>封装<br>封装是给对象提供了隐藏内部属性和行为的能力。通过public,protected,private修饰符来给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。它可以通过隐藏对象的属性来保护对象内部的状态，并且可以防止对象之间的不良交互，提高安全性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对成员变量设置私有访问权限，对信息进行隐藏</span></span><br><span class="line"><span class="comment">// 为每个成员变量提供对外公共方法访问（getter/setter）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>继承<br>继承就是子类继承父类的特征和行为，使得子类对象具有父类的属性和方法。子类可以通过继承父类的属性和方法，从而避免存在重复的代码，代码更加简洁，并提高代码的维护性、复用性。Java中使用extends和implements实现继承，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动物类（父类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String myName, <span class="type">int</span> myid)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">        name = myName; </span><br><span class="line">        id = myid;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">        System.out.println(name+<span class="string">&quot;正在吃&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        System.out.println(name+<span class="string">&quot;正在睡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 企鹅类（子类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Penguin</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Penguin</span><span class="params">(String myName, <span class="type">int</span> myid)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">        <span class="built_in">super</span>(myName, myid); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>多态<br>多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的对象而执行不同操作。多态分为编译时多态和运行时多态：编译时多态指方法的重载；运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定。运行时多态的三个必要条件：（1）继承（2）重写（3）父类引用指向子类对象。多态可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  <span class="comment">// 向上转型  </span></span><br><span class="line">      a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>重写与重载的区别？<br>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>
<table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>重写(overriding)</th> 
   <th>重载(overloading)</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>定义</td> 
   <td>子类根据需要定义新特性，可对父类的方法进行扩展</td> 
   <td>让类以统一的方式处理不同类型参数的一种手段，通过传递参数的个数和类型选择具体调用哪种方法</td> 
  </tr> 
  <tr> 
   <td>范围</td> 
   <td>继承类</td> 
   <td>同一类</td> 
  </tr> 
  <tr> 
   <td>区别</td> 
   <td>方法名称、返回值、参数等均相同</td> 
   <td>方法名称相同，参数列表不同（每个重载方法都有独一无二的参数列表）</td> 
  </tr> 
 </tbody> 
</table>




<h2 id="对this和super的认识？"><a href="#对this和super的认识？" class="headerlink" title="对this和super的认识？"></a>对this和super的认识？</h2><p>this：就是类中指向对象本身的一个特殊引用。<br>super：向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p>
<h2 id="谈谈权限修饰符的特性？"><a href="#谈谈权限修饰符的特性？" class="headerlink" title="谈谈权限修饰符的特性？"></a>谈谈权限修饰符的特性？</h2><table> 
 <thead> 
  <tr> 
   <th>权限修饰符</th> 
   <th>特点</th> 
   <th>本类</th> 
   <th>子类</th> 
   <th>同包类</th> 
   <th>其他类</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>public</td> 
   <td>公共访问</td> 
   <td>√</td> 
   <td>√</td> 
   <td>√</td> 
   <td>√</td> 
  </tr> 
  <tr> 
   <td>protected</td> 
   <td>保护（继承+包）访问</td> 
   <td>√</td> 
   <td>√</td> 
   <td>√</td> 
   <td>×</td> 
  </tr> 
  <tr> 
   <td>private</td> 
   <td>私有（无法）访问</td> 
   <td>√</td> 
   <td>×</td> 
   <td>×</td> 
   <td>×</td> 
  </tr> 
 </tbody> 
</table>


<h2 id="对java多态的理解-Java中实现多态的机制是什么？"><a href="#对java多态的理解-Java中实现多态的机制是什么？" class="headerlink" title="对java多态的理解 &#x2F;Java中实现多态的机制是什么？"></a>对java多态的理解 &#x2F;Java中实现多态的机制是什么？</h2><ul>
<li>多态是什么？<br>多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的对象而执行不同操作。</li>
<li>多态分类？<br>本质上多态分为两种：</li>
</ul>
<ol>
<li>编译时多态（静态绑定），如重载方法。</li>
<li>运行时多态（动态绑定），如重写方法。</li>
</ol>
<p>编译时多态即在程序执行前方法已经被绑定，发生在编译阶段，由编译器实现，绑定的是类信息。java中的方法，只有final，static，private，重载方法和构造方法是静态绑定；所有的变量都是静态绑定。<br>运行时多态时编译时不确定具体调用哪个具体方法，直到运行时，根据传入的对象信息，才进行绑定相应的方法。发生在运行阶段，绑定的是对象信息。运行时多态通常有两种实现方法：1、子类继承父类（extends）2、类实现接口（implements）。使用多态应该遵循的原则是：声明和定义方法参数时总是优先使用父类类型或接口类型，创建的是实际类型。这样做可以减少代码的耦合，提高代码的可维护性。<br>运行时多态的必要条件有：继承、重写、父类引用指向子类对象。</p>
<ul>
<li>多态动态绑定机制？<br>类对象方法的调用必须在运行过程中采用动态绑定机制。动态绑定的解题思路：<br>首先，根据对象的声明类型(对象引用的类型)找到“合适”的方法。具体步骤如下：</li>
</ul>
<ol>
<li>编译器检查对象的声明类型和方法名称（p.method()）<br>若p的声明类型为Child类，则编译器会列举出Child类中所有名为method方法和父类继承的method方法，如果子类重写父类方法，则被覆盖；<br>若p的声明类型为Parent类，并指向子类对象，则编译器会列举出Parent类中所有名为method方法，如果子类重写父类方法，则被覆盖；</li>
<li>如果能在声明类型中匹配到方法签名完全一样(参数类型一致)的方法，那么这个方法是最合适的。</li>
<li>在上一条不能满足的情况下，寻找可以“凑合”的方法。标准就是通过将参数类型进行自动转型之后再进行匹配。</li>
</ol>
<blockquote>
<p>自动转型会匹配最精确的一个参数列表，当一个方法可以接受传递给另一个方法的任何参数，则第二个方法比第一个方法更加精确。</p>
</blockquote>
<ol>
<li>如果仍然在声明类型中找不到“合适”的方法，则编译阶段就无法通过。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(D obj)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	    	<span class="comment">// 方法一</span></span><br><span class="line">	    		<span class="keyword">return</span> (<span class="string">&quot;A and D&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(A obj)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	    	<span class="comment">// 方法二</span></span><br><span class="line">	        <span class="keyword">return</span> (<span class="string">&quot;A and A&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(B obj)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	    	<span class="comment">// 方法三</span></span><br><span class="line">	        <span class="keyword">return</span> (<span class="string">&quot;B and B&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(A obj)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	    	<span class="comment">// 方法四</span></span><br><span class="line">	        <span class="keyword">return</span> (<span class="string">&quot;B and A&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span></span><br><span class="line">	<span class="title class_">B</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaStudy</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();	<span class="comment">// 创建A类对象，故a1拥有调用方法一和方法二的能力</span></span><br><span class="line">	        <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();	<span class="comment">// 创建A类引用，指向B类对象，故a2拥有调用方法一和方法四的能力；但向上转型不能调用子类中有而父类中没有的方法，故不能调用方法三</span></span><br><span class="line">	        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();	<span class="comment">// 创建B类对象（继承A），方法四重写方法二，故b拥有调用方法一、方法三和方法四的能力</span></span><br><span class="line">	        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">	        <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">	        System.out.println(<span class="string">&quot;1--&quot;</span> + a1.show(b));	<span class="comment">// 1--A and A 调用方法一</span></span><br><span class="line">	        System.out.println(<span class="string">&quot;2--&quot;</span> + a1.show(c));	<span class="comment">// 2--A and A 调用方法一</span></span><br><span class="line">	        System.out.println(<span class="string">&quot;3--&quot;</span> + a1.show(d));	<span class="comment">// 3--A and D 调用方法二</span></span><br><span class="line">	        System.out.println(<span class="string">&quot;4--&quot;</span> + a2.show(b));	<span class="comment">// 4--B and A 调用方法四</span></span><br><span class="line">	        System.out.println(<span class="string">&quot;5--&quot;</span> + a2.show(c));	<span class="comment">// 5--B and A 调用方法四</span></span><br><span class="line">	        System.out.println(<span class="string">&quot;6--&quot;</span> + a2.show(d));	<span class="comment">// 6--A and D 调用方法一</span></span><br><span class="line">	        System.out.println(<span class="string">&quot;7--&quot;</span> + b.show(b));		<span class="comment">// 7--B and B 调用方法三</span></span><br><span class="line">	        System.out.println(<span class="string">&quot;8--&quot;</span> + b.show(c));		<span class="comment">// 8--B and B 调用方法三</span></span><br><span class="line">	        System.out.println(<span class="string">&quot;9--&quot;</span> + b.show(d));		<span class="comment">// 9--A and D 调用方法一</span></span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？"><a href="#静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？" class="headerlink" title="静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？"></a>静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？</h2><p>静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向不同子类的对象。<br>非静态方法可以被继承和重写，因此可以实现多态。<br>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticStr</span> <span class="operator">=</span> <span class="string">&quot;A静态属性&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">nonStaticStr</span> <span class="operator">=</span> <span class="string">&quot;A非静态属性&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A非静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;<span class="comment">//子类B</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticStr</span> <span class="operator">=</span> <span class="string">&quot;B改写后的静态属性&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">nonStaticStr</span> <span class="operator">=</span> <span class="string">&quot;B改写后的非静态属性&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B改写后的静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nonStaticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B改写后的非静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.nonStaticStr); <span class="comment">// A非静态属性</span></span><br><span class="line">        System.out.println(a.staticStr);	<span class="comment">// A静态属性</span></span><br><span class="line">        a.staticMethod();	<span class="comment">// A静态方法</span></span><br><span class="line">        a.nonStaticMethod(); <span class="comment">// B改写后的非静态方法</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(b.nonStaticStr); <span class="comment">// B改写后的非静态属性</span></span><br><span class="line">        System.out.println(b.staticStr);	<span class="comment">// B改写后的静态属性</span></span><br><span class="line">        b.staticMethod();	<span class="comment">// B改写后的静态方法</span></span><br><span class="line">        b.nonStaticMethod(); <span class="comment">// B改写后的非静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="第二章-字符串String-数组-数据类型"><a href="#第二章-字符串String-数组-数据类型" class="headerlink" title="第二章 字符串String &amp; 数组 &amp; 数据类型"></a>第二章 字符串String &amp; 数组 &amp; 数据类型</h1><ul>
<li>说说Java中的8大基本类型 &amp; 内存中占有的字节 &amp; 初始值？</li>
<li>知道float和double类型为什么会出现精度丢失的情况吗？</li>
<li>JAVA基本数据类型与封装类型的区别？</li>
<li>什么是拆箱 &amp; 装箱，能给我举栗子吗？</li>
<li>能说说多维数组在内存上是怎么存储的吗？</li>
<li>你对数组二次封装过吗？说说封装了什么？</li>
<li>String</li>
<li><ul>
<li>原理 &amp; 不可变性</li>
<li>String &amp;&amp; StringBuilder &amp;&amp; StringBuffer</li>
<li>内存中存储</li>
<li>字符串拼接方式 &amp; 比较</li>
<li>String a &#x3D; “a”+”b”+”c”;在内存中创建了几个对象？</li>
</ul>
</li>
</ul>
<h2 id="说说Java中的8大基本类型-内存中占有的字节-初始值？"><a href="#说说Java中的8大基本类型-内存中占有的字节-初始值？" class="headerlink" title="说说Java中的8大基本类型 &amp; 内存中占有的字节 &amp; 初始值？"></a>说说Java中的8大基本类型 &amp; 内存中占有的字节 &amp; 初始值？</h2><p>bit(位):表示信息的最小单位，是二进制数的一位包含的信息;<br>byte(字节)：用来计量存储容量的一种计量单位；<br>1 byte &#x3D; 8 bit(1个字节等于8位);</p>
<table> 
 <thead> 
  <tr> 
   <th>基本类型</th> 
   <th>占据空间大小</th> 
   <th>取值范围</th> 
   <th>默认值</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>布尔型——boolean</td> 
   <td>不确定</td> 
   <td>true/false</td> 
   <td>false</td> 
  </tr> 
  <tr> 
   <td>字节型——byte</td> 
   <td>1个字节</td> 
   <td>-128~127</td> 
   <td>0</td> 
  </tr> 
  <tr> 
   <td>整型——int</td> 
   <td>4个字节</td> 
   <td>-2^31 ~ 2^31-1（-2147483648～2147483647）</td> 
   <td>0</td> 
  </tr> 
  <tr> 
   <td>短整型——short</td> 
   <td>2个字节</td> 
   <td>-2^15 ~ 2^15-1（-32768～32767）</td> 
   <td>0</td> 
  </tr> 
  <tr> 
   <td>长整型——long</td> 
   <td>8个字节</td> 
   <td>-2^63 ~ 2^63-1（-9223372036854775808 ~ 9223372036854775807）</td> 
   <td>0</td> 
  </tr> 
  <tr> 
   <td>字符型——char</td> 
   <td>2个字节</td> 
   <td>0~2^16-1（0 ~ 65535无符号）</td> 
   <td>\u0000</td> 
  </tr> 
  <tr> 
   <td>单精度浮点型——float</td> 
   <td>4个字节</td> 
   <td>-2^128 ~ 2^128</td> 
   <td>0.0F</td> 
  </tr> 
  <tr> 
   <td>双精度浮点型——double</td> 
   <td>8个字节</td> 
   <td>-2^1024 ~ 2^1024</td> 
   <td>0.0D</td> 
  </tr> 
 </tbody> 
</table>

<p>（1）带符号数（正数&#x2F;负数）在计算机中存储方式？<br>原码：原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。<br>补码：正数的补码就是其本身。负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)<br>补码是计算机存储带符号数的方式，可以解决0的符号问题以及两个编码问题。<br>[为什么byte类型（8位二进制表示）的取值范围为-128<del>127？][byte_8_-128_127]<br>0用[0000 0000]表示，-128用[1000 0000]表示。byte类型1个字节，8位二进制，范围为[1000 0000]</del>[0111 1111]</p>
<p>（2）浮点数（小数）在计算机中存储方式？</p>
<ol>
<li>小数（浮点数）的二进制转换<br>78.375 的整数部分：<br><img src="https://mark.cuckooing.cn/pics/pic_ee10e58d.png" alt="pic_ee10e58d.png"><br>小数部分：<br><img src="https://mark.cuckooing.cn/pics/pic_aaa49e2a.png" alt="pic_aaa49e2a.png"><br>所以，78.375 的二进制形式就是 1001110.011<br>然后，使用二进制科学记数法，有<br><img src="https://mark.cuckooing.cn/pics/pic_134a8cf3.png" alt="pic_134a8cf3.png"><br>注意，转换后用二进制科学记数法表示的这个数，有底有指数有小数部分，这个就叫做浮点数。</li>
<li>浮点数在计算机中存储<br>在计算机中，保存这个数使用的是浮点表示法，分为三大部分：<br>第一部分用来存储符号位（sign），用来区分正负，这里是 0，表示正数<br>第二部分用来存储指数（exponent），这里的指数是十进制的 6<br>第三部分用来存储小数（fraction），这里的小数部分是 001110011<br><img src="https://mark.cuckooing.cn/pics/pic_7f0e5e93.png" alt="pic_7f0e5e93.png"><br>指数位决定了大小范围，因为指数位能表示的数越大则能表示的数越大，而小数位决定了计算精度，因为小数位能表示的数越大，则能计算的精度越大。</li>
</ol>
<ul>
<li>float类型是32位，是单精度浮点表示法：<br>符号位占用1位，指数位占用 8 位，小数位占用 23 位。<br>float 的小数位只有 23 位，即二进制的 23 位，能表示的最大的十进制数为 2 的 23 次方，即 8388608，即十进制的 7 位，严格点，精度只能百分百保证十进制的 6 位运算。</li>
<li>double 类型是 64 位，是双精度浮点表示法：<br>符号位占用 1 位，指数位占用 11 位，小数位占用 52 位。<br>double 的小数位有 52 位，对应十进制最大值为 4 503 599 627 370 496，这个数有 16 位，所以计算精度只能百分百保证十进制的 15 位运算。</li>
</ul>
<ol>
<li>指数位的偏移与无符号表示<br>float 的指数部分是 8 位，则指数的取值范围是 -126 到 +127，为了消除负数带来的实际计算上的影响（比如比较大小，加减法等），可以在实际存储的时候，需要把指数转换为无符号整数，即给指数做一个简单的映射，加上一个偏移量，比如float的指数偏移量为 127，这样就不会有负数出现了。比如：指数如果是 6，则实际存储的是 6+127&#x3D;133，即把 133 转换为二进制之后再存储。<br>对应的 double 类型，存储的时候指数偏移量是 1023。</li>
<li>举例求78.375浮点数表示<br>所以用float类型来保存十进制小数78.375的话，需要先转换成浮点数，得到符号位和指数和小数部分。符号位是0，指数位是6+127&#x3D;133，二进制表示为10 000 101，小数部分是001110011，不足部分请自动补0。<br>连起来用 float 表示，加粗部分是指数位，最左边是符号位 0，代表正数：<br>0 10000101 001110011 00000 00000 0000</li>
</ol>
<h2 id="知道float和double类型为什么会出现精度丢失的情况吗？"><a href="#知道float和double类型为什么会出现精度丢失的情况吗？" class="headerlink" title="知道float和double类型为什么会出现精度丢失的情况吗？"></a>知道float和double类型为什么会出现精度丢失的情况吗？</h2><p>（1）浮点型数据精度丢失的原因<br>将十进制浮点数转换为二进制浮点数时，小数的二进制有时也是不可能精确的。<br>就如同十进制不能准确表示1&#x2F;3，二进制也无法准确表示1&#x2F;10，而double类型存储尾数部分最多只能存储52位，于是，计算机在存储该浮点型数据时，便出现了精度丢失。<br>例：十进制小数如何转化为二进制数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">算法是乘以<span class="number">2</span>直到没有了小数为止。举个例子，<span class="number">0.9</span>表示成二进制数</span><br><span class="line"><span class="number">0.9</span>*<span class="number">2</span>=<span class="number">1.8</span>   取整数部分 <span class="number">1</span></span><br><span class="line"><span class="number">0.8</span>(<span class="number">1.8</span>的小数部分)*<span class="number">2</span>=<span class="number">1.6</span>    取整数部分 <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span>*<span class="number">2</span>=<span class="number">1.2</span>   取整数部分 <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span>*<span class="number">2</span>=<span class="number">0.4</span>   取整数部分 <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span>*<span class="number">2</span>=<span class="number">0.8</span>   取整数部分 <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span>*<span class="number">2</span>=<span class="number">1.6</span> 取整数部分 <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span>*<span class="number">2</span>=<span class="number">1.2</span>   取整数部分 <span class="number">0</span></span><br><span class="line"> .........   </span><br><span class="line"><span class="number">0.9</span>二进制表示为(从上往下): <span class="number">1100100100100.</span>.....</span><br></pre></td></tr></table></figure>

<p>注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。<br>因此将11.9化为二进制后大约是” 1011. 1110011001100110011001100…”。<br>（2）浮点型数据精度丢失的解决方法<br>商业运算中应用场景：例如某用户有10块钱，买了一件商品花了8.8，理应剩下1.2元。但却无法继续购买价格为1.2元的商品。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">8.8</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> d1 - d2;</span><br><span class="line">System.out.println(<span class="string">&quot;d1 - d2 = &quot;</span>+c);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">d1 - d2 = <span class="number">1.1999999999999993</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解决方法1<br>在设计数据库表的时候可以将price字段类型设置为int(oracle应设置为number)类型，而在实体中对应的属性单位应该表示为分（即精确到0.00）或者角(即0.0),但一般情况下money会精确到分。<br>如：商品的价格为12.53元(精确到分)，在数据库中price字段对应的数据为应该为1253。使用这种方法需要编程人员自己在程序中收懂转换，当然也可以封装为一个工具类。</li>
<li>解决方法2<br>使用java提供的BigDecimal类。该类封装在java.math.BigDecimal中。该类的构造器有很多，但在使用浮点类型计算时一定要使用String构造器来实例BigDecimal对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title function_">add</span><span class="params">(<span class="type">double</span> v1,<span class="type">double</span> v2)</span>&#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(Double.toString(v1));<span class="comment">//这里使用的是String构造器，将double转换为String类型</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(Double.toString(v2));</span><br><span class="line">        <span class="keyword">return</span> b1.add(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title function_">sub</span><span class="params">(<span class="type">double</span> v1,<span class="type">double</span> v2)</span>&#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(Double.toString(v1));<span class="comment">//同上</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(Double.toString(v2));</span><br><span class="line">        <span class="keyword">return</span> b1.subtract(b2);<span class="comment">//这是b1-b2,可以理解为从b1截取b2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title function_">mul</span><span class="params">(<span class="type">double</span> v1,<span class="type">double</span> v2)</span>&#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(Double.toString(v1));<span class="comment">//同上</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(Double.toString(v2));</span><br><span class="line">        <span class="keyword">return</span> b1.multiply(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title function_">div</span><span class="params">(<span class="type">double</span> v1,<span class="type">double</span> v2)</span>&#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(Double.toString(v1));</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(Double.toString(v2));</span><br><span class="line">        <span class="keyword">return</span> b1.divide(b2,<span class="number">2</span>,BigDecimal.ROUND_HALF_UP);	<span class="comment">//四舍五入,保留2位小数，除不尽的情况</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="JAVA基本数据类型与封装类型的区别？"><a href="#JAVA基本数据类型与封装类型的区别？" class="headerlink" title="JAVA基本数据类型与封装类型的区别？"></a>JAVA基本数据类型与封装类型的区别？</h2><p>封装类（如Integer）是基本数据类型（如int）的包装类。</p>
<table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>封装类（Integer）</th> 
   <th>基本类型（int）</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>存储数据</td> 
   <td>封装类本质是对象的引用，需实例化后使用。实际上是生成一个指向该对象的引用（存储对象地址）</td> 
   <td>值（基本数据类型是一个变量，直接存放数值）</td> 
  </tr> 
  <tr> 
   <td>属性和方法</td> 
   <td>封装类有属性和方法，利用这些方法和属性来处理数据，如Integer.parseInt(Strings)</td> 
   <td>基本数据类型都是final修饰的，不能继承扩展新的类、新的方法</td> 
  </tr> 
  <tr> 
   <td>默认值</td> 
   <td>null</td> 
   <td>0</td> 
  </tr> 
  <tr> 
   <td>存储位置</td> 
   <td>封装类的对象引用存储在栈中，实际的对象存储在堆中</td> 
   <td>栈</td> 
  </tr> 
  <tr> 
   <td>使用场景</td> 
   <td>更好地处理数据之间的转换</td> 
   <td>速度快（不涉及对象的构造与回收）</td> 
  </tr> 
 </tbody> 
</table>

<h2 id="什么是拆箱-装箱，能给我举栗子吗？"><a href="#什么是拆箱-装箱，能给我举栗子吗？" class="headerlink" title="什么是拆箱 &amp; 装箱，能给我举栗子吗？"></a>什么是拆箱 &amp; 装箱，能给我举栗子吗？</h2><p>封装类（如Integer）是基本数据类型（如int）的包装类。装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。</p>
<ol>
<li>装箱（基本数据类型-&gt;封装类）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 实际上执行Integer.valueOf(10);</span></span><br></pre></td></tr></table></figure>

<ol>
<li>拆箱（封装类-&gt;基本数据类型）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//装箱 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> i; <span class="comment">//拆箱，实际上执行了 int t = i.intValue();</span></span><br></pre></td></tr></table></figure>

<h2 id="能说说多维数组在内存上是怎么存储的吗？"><a href="#能说说多维数组在内存上是怎么存储的吗？" class="headerlink" title="能说说多维数组在内存上是怎么存储的吗？"></a>能说说多维数组在内存上是怎么存储的吗？</h2><p>在java中数组也是对象。因此，对象存放在内存中的原理同样适用于数组。<br>当创建一个数组时，在堆中会为数组对象分配一段内存空间，并返回一个引用。数组对象的引用存放在栈中，实际的数组对象存放在堆中。<br>多维数组在内存中存储方式：<br><img src="https://mark.cuckooing.cn/pics/pic_131587cd.png" alt="pic_131587cd.png"></p>
<h2 id="你对数组二次封装过吗？说说封装了什么？"><a href="#你对数组二次封装过吗？说说封装了什么？" class="headerlink" title="你对数组二次封装过吗？说说封装了什么？"></a>你对数组二次封装过吗？说说封装了什么？</h2><p>使用Java一维数组，仿照ArrayList源码，封装相关构造、获取元素个数、容量大小、判空、增删查改等功能。<br>[对Java一维数组E[]自定义ArrayList集合][Java_E_ArrayList]<br>下面是部分实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过对数组封装实现自己的Array类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="keyword">private</span> E[] data; <span class="comment">// 定义一个整型的一维数组的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// 数组中元素个数</span></span><br><span class="line">	<span class="comment">// 获取数组中元素的个数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断数组是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向数组的第index位置插入元素e</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E e)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    	<span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Add failed. Require index &gt;= 0 and index &lt;= size.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size - data.length &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> data.length + (data.length &gt;&gt; <span class="number">1</span>);	<span class="comment">// 扩容1.5倍</span></span><br><span class="line">            resize(newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= index; i--)</span><br><span class="line">            data[i + <span class="number">1</span>] = data[i];</span><br><span class="line"></span><br><span class="line">        data[index] = e;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态数组扩容 newCapacity 扩容长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapactity)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        E[] newData = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newCapactity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            newData[i] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        data = newData;</span><br><span class="line">        newData = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="原理-不可变性"><a href="#原理-不可变性" class="headerlink" title="原理 &amp; 不可变性"></a>原理 &amp; 不可变性</h3><ul>
<li>内部<br>在 Java 8 中，String 内部使用 char 数组存储数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不可变性<br>String对象是不可变的，即对象的状态（成员变量）在对象创建之后不再改变。<br>（一）不可变性实现<br>由String内部构造：<br>（1）String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）<br>（2）value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。<br>（3）String 内部没有改变 value 数组的方法。<br>可知String是不可变的。</li>
</ul>
<blockquote>
<p>补充：不可变的实现：<br>String类被final修饰，保证类不被继承。<br>String内部所有成员都设置为私有变量，并且用final修饰符修饰，保证成员变量初始化后不被修改。<br>不提供setter方法改变成员变量，即避免外部通过其他接口修改String的值。<br>通过构造器初始化所有成员（value[]）时，对传入对象进行深拷贝（deep copy），避免用户在String类以外通过改变这个对象的引用来改变其内部的值。<br>在getter方法中，不要直接返回对象引用，而时返回对象的深拷贝，防止对象外泄。</p>
</blockquote>
<p>（二）不可变的好处</p>
<ol>
<li>满足字符串常量池的需要（有助于共享）<br>可以将字符串对象保存在字符串常量池中以供与字面值相同字符串对象共享。<br>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。<br>如果String对象是可变的，那就不能这样共享，因为一旦对某一个String类型变量引用的对象值改变，将同时改变一起共享字符串对象的其他 String类型变量所引用的对象的值。</li>
<li>线程安全考虑<br>同一个字符串实例可以被多个线程共享。字符串的不变性保证字符串本身便是线程安全的。</li>
<li>支持hash映射和缓存<br>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得String很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</li>
</ol>
<p>缺点：String对象不适用于经常发生修改的场景，会创建大量的String对象。<br>（三）String 的 “改变”？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;ABCDEF&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line">    </span><br><span class="line">    s = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String的改变实际上是创建了一个新的String对象”123456”，并将引用指向了这个新的对象，同时原来的String对象”ABCDEF”并没有发生改变，仍保存在内存中。<br><img src="https://mark.cuckooing.cn/pics/pic_a0c7532e.png" alt="pic_a0c7532e.png"><br>（四）String 的不可变 真的不可变？<br>通过反射获取value数组直接改变内存数组中的数据是可以修改所谓的”不可变”对象的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reflectString</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">// 创建字符串&quot;ABCDEF&quot;并赋给引用s</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;ABCDEF&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;s = &quot;</span> + s);	<span class="comment">// s = ABCDEF</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">valueField</span> <span class="operator">=</span> s.getClass().getDeclaredField(<span class="string">&quot;value&quot;</span>);    <span class="comment">// 获取String类中value字段</span></span><br><span class="line">    valueField.setAccessible(<span class="literal">true</span>);    <span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">    <span class="type">char</span>[] value = (<span class="type">char</span>[]) valueField.get(s);		<span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line">    value[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;		<span class="comment">// 改变value所引用的数组中的某个位置字符</span></span><br><span class="line">    value[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    value[<span class="number">4</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;s = &quot;</span> + s);	<span class="comment">// s = aBcDeF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String-StringBuilder-StringBuffer"><a href="#String-StringBuilder-StringBuffer" class="headerlink" title="String &amp;&amp; StringBuilder &amp;&amp; StringBuffer"></a>String &amp;&amp; StringBuilder &amp;&amp; StringBuffer</h3><ul>
<li>可变性<br>String 不可变<br>StringBuffer 和 StringBuilder 可变</li>
<li>线程安全<br>String 不可变，因此是线程安全的<br>StringBuilder 不是线程安全的<br>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<table> 
 <tbody> 
  <tr> 
   <td></td> 
   <td>String</td> 
   <td>StringBuffer</td> 
   <td>StringBuilder</td> 
  </tr> 
  <tr> 
   <td>可变性</td> 
   <td>String</td> 
   <td>StringBuffer</td> 
   <td>StringBuilder</td> 
  </tr> 
  <tr> 
   <td>线程安全</td> 
   <td>安全（不可变）</td> 
   <td>安全（Synchronized）</td> 
   <td>不安全</td> 
  </tr> 
  <tr> 
   <td>执行效率</td> 
   <td>高</td> 
   <td>低（Synchronized）</td> 
   <td>高</td> 
  </tr> 
  <tr> 
   <td>适用场景</td> 
   <td>操作少量的数据，不需要频繁拼接</td> 
   <td>多线程操作大量数据<br>只有在对线程安全要求高的情况下使用StringBuffer</td> 
   <td>单线程操作大量数据</td> 
  </tr> 
  <tr> 
   <td>备注</td> 
   <td colspan="3">在字符串修改/拼接时，String是不可变的对象, 因此在每次对String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。不仅效率低下，还会大量浪费内存空间。 使用 StringBuffer/StringBuilder 类时，每次都会对 StringBuffer/StringBuilder 对象本身进行修改操作，而不产生新的未使用对象。</td> 
  </tr> 
 </tbody> 
</table>

<table></table>

<h3 id="内存中存储"><a href="#内存中存储" class="headerlink" title="内存中存储"></a>内存中存储</h3><p>对于String，其对象的引用都是存储在栈中的。<br>java中对String对象特殊对待，所以在heap区域分成了两块，一块是字符串常量池(String constant pool)，用于存储java字符串常量对象，另一块用于存储普通对象及字符串对象。</p>
<ol>
<li>“abc”字符串常量&#x2F;s.intern()——StringPool<br>编译期已经创建好(直接用双引号定义的”abc”)的就存储在字符串常量池中。即jvm会在String constant pool中创建对象。字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。String Pool用于共享字符串字面量，防止产生大量String对象导致OOM。<br>jvm会首先在String constant pool 中寻找是否已经存在（equals）“abc”常量，如果没有则创建该常量，并且将此常量的引用返回给String a；如果已有”abc” 常量，则直接返回String constant pool 中“abc” 的引用给String a。<br>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。<br>equals相等（指向同一引用）的字符串在常量池中永远只有一份。</li>
</ol>
<blockquote>
<p>intern() 方法返回字符串对象的规范化表示形式，即一个字符串，内容与此字符串相同，但一定取自具有唯一字符串的池。<br>它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() &#x3D;&#x3D; t.intern() 才为 true。</p>
</blockquote>
<ol>
<li>new String(“abc”)<br>运行期（new出来的 new String(s)）才能确定的就存储在堆中。即jvm会直接在heap中非String constant pool 中创建字符串对象，然后把该对象引用返回给String b（并且不会把”abc” 加入到String constant pool中）。<br>new就是在堆中创建一个新的String对象，不管”abc”在内存中是否存在，都会在堆中开辟新空间。<br>equals相等的字符串在堆中可能有多份。<br>对于 new String(“abc”)，使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。这两个字符串对象指向同一个value数组。</li>
</ol>
<ul>
<li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false，指向堆内不同引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true，指向字符串常量池中相同引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s5 == s6);  			<span class="comment">// true，指向字符串常量池中相同引用</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接方式-比较"><a href="#字符串拼接方式-比较" class="headerlink" title="字符串拼接方式 &amp; 比较"></a>字符串拼接方式 &amp; 比较</h3><ul>
<li>拼接方式</li>
</ul>
<ol>
<li>“+” 拼接<br>加号拼接字符串jvm底层其实是调用StringBuilder来实现的，也就是说”a” + “b” + “c”等效于下面的代码片。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String d = &quot;a&quot;+&quot;b&quot;+&quot;c&quot;;等效于</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>).toString();</span><br></pre></td></tr></table></figure>

<p>但并不是说直接用“+”号拼接就可以达到StringBuilder的效率了，因为每次使用 “+”拼接 都会新建一个StringBuilder对象，并且最后toString()方法还会生成一个String对象。在循环拼接十万次的时候，就会生成十万个StringBuilder对象，会产生大量内存消耗。</p>
<ol>
<li>concat 拼接<br>concat其实就是申请一个char类型的buf数组，将需要拼接的字符串都放在这个数组里，最后再创建并返回一个新的String对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">otherLen</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>StringBuilder&#x2F;StringBuffer append<br>这两个类实现append的方法都是调用父类AbstractStringBuilder的append方法，只不过StringBuffer是的append方法加了sychronized关键字，因此是线程安全的。append代码如下，他主要也是利用char数组保存字符，通过ensureCapacityInternal方法来保证数组容量可用还有扩容。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>他扩容的方法的代码如下，可见，当容量不够的时候，数组容量右移1位（也就是翻倍）再加2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            ? hugeCapacity(minCapacity)</span><br><span class="line">            : newCapacity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>拼接比较</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>拼接方式</th> 
   <th>+</th> 
   <th>concat</th> 
   <th>StringBuilder/StringBuffer</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>原理</td> 
   <td>jvm采用append优化，每次执行都会新建一个StringBuilder和String对象</td> 
   <td>申请一个char类型的buf数组，将需要拼接的字符串都放在这个数组里，最后再创建并返回一个新的String对象</td> 
   <td>利用char数组保存字符，对Stringbuilder/StringBuffer直接修改，不生成新的String对象</td> 
  </tr> 
  <tr> 
   <td>比较</td> 
   <td>最慢且效率最低，适用于书写方便场景</td> 
   <td>适用于少量字符串拼接（会新建String对象）</td> 
   <td>适用于多个字符串拼接，当不考虑线程的情况下,StringBuilder效率比StringBuffer（Synchronized）高</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="String-a-“a”-“b”-“c”-在内存中创建了几个对象？"><a href="#String-a-“a”-“b”-“c”-在内存中创建了几个对象？" class="headerlink" title="String a &#x3D; “a”+“b”+“c”;在内存中创建了几个对象？"></a>String a &#x3D; “a”+“b”+“c”;在内存中创建了几个对象？</h3><ol>
<li>String a&#x3D;“a”+“b”+”c”在内存中创建几个对象？——1个对象<br>String a &#x3D; “a”+“b”+”c”经过编译器优化后得到的效果为String a &#x3D; “abc”<br>java编译期会进行常量折叠，全字面量字符串相加是可以折叠为一个字面常量，而且是进入常量池的。<br>在JAVA虚拟机（JVM）中存在着一个字符串池，其中保存着很多String对象，并且可以被共享使用，因此它提高了效率。由于String类是final的，它的值一经创建就不可改变，因此我们不用担心String对象共享而带来程序的混乱。字符串池由String类维护，我们可以调用intern()方法来访问字符串池。<br>对于String a&#x3D;“abc”;，这行代码被执行的时候，JAVA虚拟机首先在字符串池中查找是否已经存在了值为”abc”的这么一个对象，它的判断依据是String类equals(Object obj)方法的返回值。如果有，则不再创建新的对象，直接返回已存在对象的引用；如果没有，则先创建这个对象，然后把它加入到字符串池中，再将它的引用返回。<br>字符串内部拼接：只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中，</li>
<li>String s&#x3D;new String(“abc”)创建了几个对象？——2个对象<br>new String(“abc”)可看成”abc”（创建String对象）和new String(String original)（String构造器，创建String对象）2个对象。<br>我们正是使用new调用了String类的上面那个构造器方法创建了一个对象，并将它的引用赋值给了str变量。同时我们注意到，被调用的构造器方法接受的参数也是一个String对象，这个对象正是”abc”。</li>
</ol>
<h1 id="第三章-Java特性与基本语法-1"><a href="#第三章-Java特性与基本语法-1" class="headerlink" title="第三章 Java特性与基本语法(1)"></a>第三章 Java特性与基本语法(1)</h1><ul>
<li><p>Objct通用方法？</p>
</li>
<li><ul>
<li>Object.equals()</li>
<li>Object.hashCode()</li>
<li>Object.toString()</li>
<li>Object.clone()</li>
</ul>
</li>
<li><p>[序列化</p>
<ul>
<li>Serializable接口<ul>
<li>transient 关键字</li>
</ul>
</li>
</ul>
<ul>
<li>Parcelable接口</li>
</ul>
</li>
<li><p>内部类</p>
</li>
<li><p>Java 异常</p>
</li>
<li><ul>
<li>Java 异常关键字</li>
<li>Java 异常体系</li>
<li>自定义Java异常</li>
</ul>
</li>
</ul>
<h2 id="Objct通用方法？"><a href="#Objct通用方法？" class="headerlink" title="Objct通用方法？"></a>Objct通用方法？</h2><h3 id="Object-equals"><a href="#Object-equals" class="headerlink" title="Object.equals()"></a>Object.equals()</h3><p>（1）equals 定义 &amp; equals 与 &#x3D;&#x3D; 区别（等价 与 值相等）</p>
<ul>
<li>&#x3D;&#x3D;<br>基本数据类型（byte,short,char,int,long,float,double,boolean）用比较的是两个数据的值是否相等。<br>引用类型（类、接口、数组）用比较的是它们在内存中的存放地址是否相等（两个变量是否引用同一个对象）。<br>对象是存放在堆中的，栈中存放的是对象的引用（地址）。因此&#x3D;&#x3D;是对栈中的值进行比较的。如果要比较堆中对象的内容是否相同，那么就要重写equals方法了。</li>
<li>Object.equals(Object obj)<br>Object的equals方法主要用于判断引用的对象是否等价（内容相等）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>（2）equals 的默认实现 &amp; 重写<br>默认实现：</p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualExample</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EqualExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">EqualExample</span> <span class="variable">that</span> <span class="operator">=</span> (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>覆盖equals方法一般通过比较对象的内容是否相等来判断对象是否相等。如下为String类对equals方法进行重写。（不同类有不同等价方法的实现）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;   <span class="comment">// 参数是否为这个对象的引用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;				<span class="comment">// 若A==B，即是同一个String对象，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;	<span class="comment">//参数是否为正确的类型（若对比对象是String类型则继续）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">	<span class="comment">//获取关键域，判断关键域是否匹配</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> count;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.count) &#123;		<span class="comment">//	判断A、B长度是否一样，不一样则返回false</span></span><br><span class="line">        <span class="type">char</span> v1[] = value;</span><br><span class="line">        <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> offset;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> anotherString.offset;</span><br><span class="line">        <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;		<span class="comment">//逐个字符比较，若有不相等字符，则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (v1[i++] != v2[j++])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Object-hashCode"><a href="#Object-hashCode" class="headerlink" title="Object.hashCode()"></a>Object.hashCode()</h3><p>（1）定义 &amp; 散列集合 唯一性原理<br>hashCode方法返回一个hash码（int），主要作用是在对对象进行散列时作为key输入，因此需要每个对象的hashCode尽可能不同，这样才能保证散列的存取性能。事实上，Object类提供的默认实现确保每个对象的hash码不同（在对象的内存地址基础上经过特定算法返回一个hashCode）<br>hashCode用于配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。散列集合中元素不可重复，Java则依据元素的hashCode来判断两个元素是否重复。当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了（放入对象的hashcode与集合中任一元素的hashcode不相等）；如果这个位置上已经有元素了（hashcode相等），就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就散列其它的地址。（通过调用equals解决冲突）<br>[Set&#x2F;HashSet如何确保它的唯一性？][Set_HashSet]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     ... &#125;</span><br></pre></td></tr></table></figure>

<p>（2）equals 与 hashCode 重写</p>
<ul>
<li>等价的两个对象散列值一定相同<br>若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。</li>
<li>散列值相同的两个对象不一定等价<br>如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。<br>为了满足上述规范，覆盖equals方法时总要覆盖hashCode，这样该类才能结合所有基于散列的集合（如HashMap、HashSet、HashTable）一起正常运作。<br>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hashCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EqualExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualExample</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">EqualExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EqualExample</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size());   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>重写实例：Student类同时覆盖hashCode与equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; </span><br><span class="line">	<span class="comment">// 重写hashCode保证相同的对象（equals）的hashCode相同，不重复存入集合</span></span><br><span class="line">	<span class="comment">// 采用数字31作为优质乘子</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 对所有关键域与优质乘子进行运算</span></span><br><span class="line">		result = prime * result + age;</span><br><span class="line">		result = prime * result + ((name == <span class="literal">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">		System.out.println(<span class="string">&quot;hashCode : &quot;</span>+ result);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">	<span class="comment">// 重写equals保证姓名、年龄相等为同一对象</span></span><br><span class="line">	<span class="comment">// 引用相等 =&gt; 相等</span></span><br><span class="line">	<span class="comment">// 类型相等 &amp;&amp; 所有关键域相等 =&gt;相等</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">other</span> <span class="operator">=</span> (Student) obj;</span><br><span class="line">		<span class="keyword">if</span> (age != other.age)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (other.name != <span class="literal">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）散列函数构造<br>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。<br>一个数与 31 相乘可以转换成移位和减法：31*x &#x3D;&#x3D; (x&lt;&lt;5)-x，编译器会自动进行这个优化。<br>String hashCode 方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line"><span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">char</span> val[] = value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        h = <span class="number">31</span> * h + val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h;</span><br></pre></td></tr></table></figure>

<h3 id="Object-toString"><a href="#Object-toString" class="headerlink" title="Object.toString()"></a>Object.toString()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToStringExample</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ToStringExample</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用实现</span></span><br><span class="line"><span class="type">ToStringExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToStringExample</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(example.toString());</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</span></span><br><span class="line">ToStringExample@4554617c</span><br></pre></td></tr></table></figure>

<h3 id="Object-clone"><a href="#Object-clone" class="headerlink" title="Object.clone()"></a>Object.clone()</h3><p>（1）使用</p>
<ul>
<li>重写clone()方法<br>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</li>
<li>实现Cloneable接口<br>Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）浅拷贝 &amp; 深拷贝<br><img src="https://mark.cuckooing.cn/pics/pic_eb9987d2.png" alt="pic_eb9987d2.png"></p>
<ul>
<li>浅拷贝（super.clone()）<br>拷贝对象和原始对象的引用类型引用同一个对象。<br>创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型（基本类型）的，那么对该字段值执行复制；如果该字段是引用类型（对象、String）的话，则复制引用但不复制引用的对象。因此，原始对象及其副本对象引用同一个对象，如果其中一个对象改变了这个地址，就会影响到另一个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ShallowCloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ShallowCloneExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShallowCloneExample</span>();</span><br><span class="line"><span class="type">ShallowCloneExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure>

<p>可以看出e1与e2的arr指向了同一个对象</p>
<ul>
<li>深拷贝（clone() 代替方案）<br>拷贝对象和原始对象的引用类型引用不同对象。<br>深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。<br>（1）实现Cloneable接口进行深拷贝<br>实现clone方法，并且在clone方法内部，把该对象引用的其他对象也要clone一份 ， 这就要求这个被引用的对象必须也要实现Cloneable接口并且实现clone方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rotected Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            person = (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            person.setEmail(<span class="keyword">new</span> <span class="title class_">Email</span>(person.getEmail().getObject(),person.getEmail().getContent()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（2）自定义拷贝函数<br>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneConstructorExample</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneConstructorExample</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 为引用类型重新在堆中分配内存</span></span><br><span class="line">        <span class="comment">// 使拷贝对象与原始对象的引用类型指向不同的对象</span></span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">CloneConstructorExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneConstructorExample</span>();</span><br><span class="line"><span class="type">CloneConstructorExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneConstructorExample</span>(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>（3）利用序列化完成对象深拷贝<br>将原对象（需要实现Serializable接口）写入到一个字节流中（outputStream.writeObject），再从字节流中将其读取出来创建一个新的对象（inputStream.readObject）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneUtils</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Serializable</span>&gt; T <span class="title function_">clone</span><span class="params">(T obj)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">T</span> <span class="variable">cloneObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//写入字节流</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">obs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out);</span><br><span class="line">            obs.writeObject(obj);</span><br><span class="line">            obs.close();</span><br><span class="line">            <span class="comment">//分配内存，写入原始对象，生成新对象</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">ios</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(out.toByteArray());</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(ios);</span><br><span class="line">            <span class="comment">//返回生成的新对象</span></span><br><span class="line">            cloneObj = (T) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）如何深拷贝一个List集合<br>Json拷贝法：将List集合映射为一个Json字符串，再解析成一个List集合<br>序列化法：将List集合写入字节流，再读取出来解析成一个List集合<br>重写clone法：重写clone方法并遍历即可</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化是一种处理对象流的机制，用于将对象状态转换为字节流，即将对象转换为可存储或可传输的状态。我们可以对流化后的对象进行读写操作，或在网络中传输。从字节流转换为对象的过程称为反序列化。<br>序列化的方式包括两种：</p>
<ol>
<li>实现Serializable接口（Java自带）</li>
<li>实现Parcelable接口（Android专用、效率更高）<br>Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，从而实现传递对象的功能。</li>
</ol>
<p>序列化常用场景：</p>
<ol>
<li>将对象状态存储到文件或数据库中</li>
<li>在网络上传输对象</li>
<li>在Activity&#x2F;Fragment之间通过Intent传递对象（Android）</li>
</ol>
<p>注意：</p>
<ol>
<li>静态成员变量属于类不属于对象，所以不会参与序列化(对象序列化保存的是对象的“状态”，也就是它的成员变量，因此序列化不会关注静态变量)</li>
<li>用transient关键字标记的成员变量不参与序列化(在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null)</li>
</ol>
<h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentSerializable</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定serialVersionUID，</span></span><br><span class="line">    <span class="comment">// 因为原则上序列化后的数据中的serialVersionUID只有和当前类的serialVersionUID相同时才能被正常的反序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">10000000000000000L</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> Uid;</span><br><span class="line">    <span class="keyword">private</span> String Name ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUid</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> Uid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUid</span><span class="params">(<span class="type">int</span> uid)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;StudentSerializable [Uid=&quot;</span> + Uid + <span class="string">&quot;, Name=&quot;</span> + Name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 文件传输</span></span><br><span class="line">oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fullFilename.getAbsoluteFile()));</span><br><span class="line">oos.writeObject(stu);</span><br><span class="line"></span><br><span class="line">ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fullFilename.getAbsoluteFile()));</span><br><span class="line"><span class="type">StudentSerializable</span> <span class="variable">newStu</span> <span class="operator">=</span> (StudentSerializable) ois.readObject();</span><br></pre></td></tr></table></figure>

<h4 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h4><p>只要一个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。<br>为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p>
<ul>
<li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li>
<li>transient关键字只能修饰变量，而不能修饰方法、类。</li>
<li>一个静态变量不管是否被transient修饰，均不能被序列化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 使用transient关键字不序列化某个变量</span></span><br><span class="line"><span class="comment"> *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransientTest</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;Alexia&quot;</span>);</span><br><span class="line">        user.setPasswd(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;read before Serializable: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;username: &quot;</span> + user.getUsername());</span><br><span class="line">        System.err.println(<span class="string">&quot;password: &quot;</span> + user.getPasswd());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:/user.txt&quot;</span>));</span><br><span class="line">            os.writeObject(user); <span class="comment">// 将User对象写进文件</span></span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// 在反序列化之前改变username的值</span></span><br><span class="line">            User.username = <span class="string">&quot;jmwang&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(</span><br><span class="line">                    <span class="string">&quot;C:/user.txt&quot;</span>));</span><br><span class="line">            user = (User) is.readObject(); <span class="comment">// 从流中读取User的数据</span></span><br><span class="line">            is.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;\nread after Serializable: &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;username: &quot;</span> + user.getUsername());</span><br><span class="line">            System.err.println(<span class="string">&quot;password: &quot;</span> + user.getPasswd());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8294180014912103005L</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passwd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPasswd</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPasswd</span><span class="params">(String passwd)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read before Serializable: </span><br><span class="line">username: Alexia</span><br><span class="line">password: <span class="number">123456</span></span><br><span class="line"></span><br><span class="line">read after Serializable: </span><br><span class="line">username: jmwang</span><br><span class="line">password: <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h3 id="Parcelable接口"><a href="#Parcelable接口" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentParcelable</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> Uid;</span><br><span class="line">    <span class="keyword">private</span> String Name ;</span><br><span class="line">    <span class="keyword">private</span> Book book ;</span><br><span class="line">   </span><br><span class="line">	<span class="comment">// 省略 构造函数 &amp; getter &amp; setter</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//功能：返回当前对象的内容描述，如果含有文件描述符，返回1</span></span><br><span class="line">    <span class="comment">//即CONTENTS_FILE_DESCRIPTOR</span></span><br><span class="line">    <span class="comment">//几乎所有情况都会返回0</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">describeContents</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化功能由writeToParcel完成，最终通过Parcel的一系列Write方法完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//功能：将当前对象写入序列化结构中，其中flags标识有两种值，0或1</span></span><br><span class="line">    <span class="comment">//为1时标识当前对象需要作为返回值返回，不能立刻释放资源，即PARCELABLE_WRITE_RETURN_VALUE</span></span><br><span class="line">    <span class="comment">//不过几乎所有情况都为0</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        dest.writeInt(Uid);</span><br><span class="line">        dest.writeString(Name);</span><br><span class="line">        dest.writeParcelable(book, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化由CREATOR来完成，其内部标明了如何创建序列化对象和数组</span></span><br><span class="line"><span class="comment">     * 并通过Parcel的一系列read方法来完成反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentParcelable</span><span class="params">(Parcel source)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Uid = source.readInt();</span><br><span class="line">        Name = source.readString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意：book是一个可序列化对象，所以它的反序列化过程需要传递当前线程的上下文类加载器</span></span><br><span class="line">        <span class="comment">//否则会报找不到类的错误</span></span><br><span class="line">        book = source.readParcelable(Thread.currentThread().getContextClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;StudentParcelable&gt; CREATOR = <span class="keyword">new</span> <span class="title class_">Parcelable</span>.Creator&lt;StudentParcelable&gt;() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="comment">//功能： 从Parcel容器中读取传递数据值，封装成Parcelable对象返回逻辑层。</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> StudentParcelable <span class="title function_">createFromParcel</span><span class="params">(Parcel source)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentParcelable</span>(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//功能：创建一个类型为T，长度为size的数组，仅一句话（return new T[size])即可。方法是供外部类反序列化本类数组使用。</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> StudentParcelable[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentParcelable</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 使用 组件间（Activity）数据传输</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>,Second.class);</span><br><span class="line"><span class="type">StudentParcelable</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentParcelable</span>(<span class="number">001</span>,<span class="string">&quot;fish&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;student&quot;</span>, stu);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="type">StudentParcelable</span> <span class="variable">stu</span> <span class="operator">=</span> (StudentParcelable) intent.getParcelableExtra(<span class="string">&quot;student&quot;</span>);</span><br></pre></td></tr></table></figure>

<table> 
 <thead> 
  <tr> 
   <th>序列化接口</th> 
   <th>Serializable</th> 
   <th>Parcelable</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>作用</td> 
   <td>为了保存对象的属性到本地文件、数据库、网络流、rmi以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的</td> 
   <td>因为Serializable效率过慢，为了在程序内不同组件间以及不同Android程序间(AIDL)高效的传输数据而设计，这些数据仅在内存中存在，Parcelable是通过IBinder通信的消息的载体</td> 
  </tr> 
  <tr> 
   <td>性能 &amp; 场景</td> 
   <td>Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable</td> 
   <td>Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据</td> 
  </tr> 
  <tr> 
   <td>实现</td> 
   <td>类只需要实现Serializable接口，并提供一个序列化版本id(serialVersionUID)即可对类的所有属性和方法自动序列化</td> 
   <td>需要实现writeToParcel、describeContents函数以及静态的CREATOR变量，实际上就是将如何打包和解包的工作自己来定义，而序列化的这些操作完全由底层实现</td> 
  </tr> 
  <tr> 
   <td>高级功能</td> 
   <td>不保存静态变量，可以使用Transient关键字对部分字段不进行序列化，也可以覆盖writeObject、readObject方法以实现序列化过程自定义</td> 
   <td></td> 
  </tr> 
 </tbody> 
</table>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>[菜鸟教程：Java 内部类详解][Java 4]<br>在Java中，定义在类内部的类被称为内部类。设计内部类的好处是：</p>
<ul>
<li>更好地封装：内部类中的属性和方法与其他类隔离，且即时是外部类也不能直接访问，相反内部类可以直接访问外部类的属性和方法。</li>
<li>实现多继承：每个内部类都能独立地实现接口。无论外部类是否已实现了某个接口，对内部类都没有影响。</li>
</ul>
<p>内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p>
<ol>
<li>成员内部类：成员内部类定义为位于另一个类的内部，类似于一个成员。成员内部类可以无条件访问外部类的所有成员属性和成员方法（内部类编译后会默认持有外部类对象的一个引用，因此可以在成员内部类中随意访问外部类的成员。）。成员内部类是依附外部类而存在的，因此要创建成员内部类的对象，前提是必须存在一个外部类的对象（否则所持有的外部类对象的引用无法初始化赋值，也无法创建内部类对象）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     	<span class="comment">// 外部类</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">        <span class="comment">// 外部类如果想调用内部类的成员方法，必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">        getDrawInstance().drawSahpe();   </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Draw <span class="title function_">getDrawInstance</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Draw</span>();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">          <span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSahpe</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(radius);  <span class="comment">//成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//成员内部类是依附外部类而存在的，因此要创建成员内部类的对象，前提是必须存在一个外部类的对象</span></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>);</span><br><span class="line">        Circle.<span class="type">Draw</span> <span class="variable">draw</span> <span class="operator">=</span> circle.<span class="keyword">new</span> <span class="title class_">Draw</span>();</span><br><span class="line">        draw.drawShape();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件：<br><img src="https://mark.cuckooing.cn/pics/pic_09a296f8.png" alt="pic_09a296f8.png"><br>反编译 Outter$Inner.class 文件得到下面信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器会默认为成员内部类添加了一个指向外部类对象的引用</span></span><br><span class="line"><span class="keyword">final</span> com.cxh.test2.Outter <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line"><span class="comment">// 编译器会为内部类的构造方法默认添加一个参数，该参数的类型为指向外部类对象的一个引用</span></span><br><span class="line"><span class="comment">// 所以成员内部类中的 Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。</span></span><br><span class="line"><span class="keyword">public</span> com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);</span><br></pre></td></tr></table></figure>

<ol>
<li>局部内部类：局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> People <span class="title function_">getWoman</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Woman</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么局部内部类访问局部变量需要final?<br>局部内部类引用局部变量，不添加final，会出现生命周期不同，导致非法引用问题。因为非final的局部变量的生命周期比局部内部类的生命周期短，当方法执行结束，非final的局部变量会被销毁，而局部内部类对局部变量的引用依然存在，当局部内部类调用局部变量时，会出错，出现非法引用。<br>而且直接拷贝会出现数据不同步问题，所以使用final（若定义为final，即拷贝了一个变量的副本，提供给局部内部类，这个副本的生命周期和局部内部类一样长，并且这个副本不可修改，保证了数据的同步）。<br>故使用final可以保证合法引用，而且数据不可修改。</li>
</ul>
<ol>
<li>匿名内部类：匿名内部类是直接使用 new 来生成一个对象的引用，创建匿名内部类时它会立即创建一个该类的实例，且仅能被使用一次，所以匿名内部类是不能够被重复使用;</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scan_bt.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>静态内部类：用static修饰的内部类。静态内部类是不需要依赖于外部类的，不需要创建外部类，便能创建内部类。并且它不能使用外部类的非static成员变量或者方法，因为外部类的非static成员必须依附于具体的对象。（不持有外部类对象的引用）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 不需要存在外部类对象</span></span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outter</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-异常"><a href="#Java-异常" class="headerlink" title="Java 异常"></a>Java 异常</h2><p>Java中异常体系是Java提供的一种定位错误以及响应错误的一种机制。<br>Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。</p>
<h3 id="Java-异常关键字"><a href="#Java-异常关键字" class="headerlink" title="Java 异常关键字"></a>Java 异常关键字</h3><ul>
<li>try<br>用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li>
<li>catch<br>用于捕获异常。catch用来捕获try语句块中发生的异常。</li>
<li>finally<br>finally语句块总是会被执行。它主要用于回收在try块里打开的物理资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。<br>（1）被finally控制的语句体一定会执行（特殊情况：在执行到finally之前jvm退出，如：System.exit(0)），用于释放资源，在IO流操作和数据库操作中会见到。<br>（2）finally块中的内容会先于try中的return语句执行（return执行前会将finally语句执行完再执行return 进行返回）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">              System.out.println(<span class="string">&quot;i=&quot;</span>+i); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">              System.out.println(<span class="string">&quot;Caught Exception&quot;</span>); </span><br><span class="line">            System.out.println(<span class="string">&quot;e.getMessage(): &quot;</span> + e.getMessage()); </span><br><span class="line">            System.out.println(<span class="string">&quot;e.toString(): &quot;</span> + e.toString()); </span><br><span class="line">            System.out.println(<span class="string">&quot;e.printStackTrace():&quot;</span>);</span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			System.out.println(<span class="string">&quot;run finally&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Caught Exception</span><br><span class="line">e.getMessage(): / by zero</span><br><span class="line">e.toString(): java.lang.ArithmeticException: / by zero</span><br><span class="line">e.printStackTrace():</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">    at Demo1.main(Demo1.java:<span class="number">6</span>)</span><br><span class="line">run <span class="keyword">finally</span></span><br></pre></td></tr></table></figure>

<p>在try语句块中有除数为0的操作，该操作会抛出java.lang.ArithmeticException异常。通过catch，对该异常进行捕获。<br>观察结果我们发现，并没有执行System.out.println(“i&#x3D;”+i)。这说明try语句块发生异常之后，try语句块中的剩余内容就不会再被执行了。<br>finally语句块中的语句总是会执行。</p>
<blockquote>
<ul>
<li>面试：final&#x2F;finally&#x2F;finalize的作用？</li>
<li>finally修饰符（关键字）<br>在Java中，final关键字可以用来修饰类、方法和变量。</li>
</ul>
<ol>
<li>修饰类<br>当用final修饰一个类时，表明这个类不能被继承。</li>
<li>修饰方法<br>当用final修饰一个方法时，该方法是不能被子类所覆盖的。</li>
<li>修饰变量<br>当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。<br>final变量必须要初始化，其初始化可在变量定义时直接赋值，也可在构造函数中赋值或者作为参数传递。且在之后的引用中只读取使用，无法修改。</li>
</ol>
<ul>
<li>finally（异常处理）<br>finally关键字一般用于异常处理中。finally结构使代码总会执行，不关有无异常发生。<br>finally在try,catch中可以有，可以没有。如果trycatch中有finally则必须执行finally块中的操作。一般情况下，用于关闭文件的读写操作，或者是关闭数据库的连接等等。</li>
<li>finalize（垃圾回收）<br>finalize方法是Object提供的的实例方法，通过调用finalize()方法在垃圾收集器将对象从内存中清理出去之前做必要的清理工作。<br>finaliza方法执行流程：<br>当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖或finalize()方法已被调用，则直接将其回收（没有必要执行）。否则，将该对象放入F-Queue队列，由一低优先级Finalizer线程执行该队列中对象的finalize方法。（但并不承诺等待运行结束）执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。<br>对象”复活”： finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那么在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那么基本上它就真的被回收了。<br>因此，finalize()并不是必须要执行的，它只能执行一次或者0次。如果在finalize中建立对象关联，则当前对象可以复活一次。</li>
</ul>
</blockquote>
<ul>
<li>throw<br>throw是语句抛出一个异常，一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;abc&quot;</span>)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NumberFormatException</span>(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">      System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//function(); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>throws<br>当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testThrows</span>()&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span> <span class="keyword">throws</span> NumberFormatException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">	<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">	<span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(s); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">		function(); </span><br><span class="line">	&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">		System.err.println(<span class="string">&quot;非数据类型不能强制类型转换。&quot;</span>); </span><br><span class="line">		<span class="comment">//e.printStackTrace(); </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table> 
 <tbody> 
  <tr> 
   <td></td> 
   <td>throws</td> 
   <td>throw</td> 
  </tr> 
  <tr> 
   <td>位置</td> 
   <td>函数头</td> 
   <td>函数体</td> 
  </tr> 
  <tr> 
   <td>是否发生异常</td> 
   <td>表示出现异常的一种可能性，并不一定会发生这些异常</td> 
   <td>throw则是抛出了异常，执行throw则一定抛出了某种异常对象</td> 
  </tr> 
  <tr> 
   <td>相同</td> 
   <td colspan="2">两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="Java-异常体系"><a href="#Java-异常体系" class="headerlink" title="Java 异常体系"></a>Java 异常体系</h3><p><img src="https://mark.cuckooing.cn/pics/pic_dfb8439a.png" alt="pic_dfb8439a.png"><br>Java异常以Throwable开始，扩展出Error和Exception。</p>
<ul>
<li>Throwable<br>Throwable是 Java 语言中所有错误或异常的超类。Throwable包含两个子类: Error 和 Exception。它们通常用于指示发生了异常情况。<br>Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。</li>
<li>Error<br>Error是程序代码无法处理的错误，当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。比如OutOfMemoryError、ThreadDeath等。和运行时异常一样，编译器也不会对错误进行检查。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止退出，其表示程序在运行期间出现了十分严重、不可恢复的错误，应用程序只能中止运行。</li>
<li>Exception<br>Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。分为运行时异常和非运行时异常：</li>
<li>运行时异常（不检查异常）<br>运行时异常都是RuntimeException类及其子类异常，是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。编译器不会检查RuntimeException。程序代码中自行选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序代码应该从逻辑角度尽可能避免这类异常的发生。<br>举例常见运行时异常</li>
</ul>
<ol>
<li>java.lang.NullPointerException<br>空指针异常，调用了未经初始化的对象或者是不存在的对象（null对象）。</li>
<li>java.lang.ClassNotFoundException<br>指定的类不存在异常，一般类的名称和路径不正确。</li>
<li>java.lang.ArrayIndexOutOfBoundsException<br>数组下标越界异常，调用的下标超出了数组的范围。</li>
<li>java.lang.NoSuchMethodError<br>方法不存在错误，当应用试图调用某类未定义的某个方法。</li>
<li>java.lang.IndexOutOfBoundsException<br>索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</li>
<li>java.lang.NumberFormatException（extends IllegalArgumentException ）<br>数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</li>
<li>java.sql.SQLException<br>Sql语句执行异常</li>
<li>java.io.IOException<br>输入输出异常</li>
<li>java.lang.IllegalArgumentException<br>方法参数错误</li>
<li>java.lang.IllegalAccessException<br>无访问权限异常</li>
</ol>
<ul>
<li>非运行时异常（检查异常）<br>所有继承Exception且不是RuntimeException的异常都是非运行时异常，也称检查异常，如上图中的IOException和ClassNotFoundException，编译器会对其作检查，故程序中一定会对该异常进行处理，处理方法要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译。</li>
</ul>
<h3 id="自定义Java异常"><a href="#自定义Java异常" class="headerlink" title="自定义Java异常"></a>自定义Java异常</h3><ul>
<li>为这个异常找一个近似的类作为父类；</li>
<li>再该类中编写两个构造器：（1）默认构造器（2）带message参数的构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            test();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;Catch My Exception&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> MyException&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">              System.out.println(<span class="string">&quot;i=&quot;</span>+i); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;This is MyException&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="第三章-Java特性与基本语法-2"><a href="#第三章-Java特性与基本语法-2" class="headerlink" title="第三章 Java特性与基本语法(2)"></a>第三章 Java特性与基本语法(2)</h1><ul>
<li>反射</li>
<li><ul>
<li>简介 &amp; 功能 &amp; 应用场景</li>
<li>基本使用</li>
<li><ul>
<li>通过Java反射查看类信息</li>
<li>通过Java反射生成并操作对象</li>
</ul>
</li>
<li>Java反射机制 与 动态代理</li>
<li>Java反射机制 与 泛型</li>
<li>反射在项目中的应用</li>
<li>反射效率低 原因 &amp; 解决</li>
</ul>
</li>
<li>注解（Annotation）</li>
<li><ul>
<li>简介</li>
<li>工作机制</li>
<li>JDK注解 &#x2F; 自定义注解</li>
<li>如何解析注解</li>
</ul>
</li>
<li>控制反转（IOC）&#x2F;依赖注入（DI）</li>
<li><ul>
<li>ButterKnife用法 &amp; 原理？</li>
</ul>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="简介-功能-应用场景"><a href="#简介-功能-应用场景" class="headerlink" title="简介 &amp; 功能 &amp; 应用场景"></a>简介 &amp; 功能 &amp; 应用场景</h3><ul>
<li>Java反射机制定义<br>Java 反射机制是在运行状态中，对于任意一个类，都能够获得这个类的所有属性和方法；对于任意一个对象都能够调用它的任意一个属性和方法。这种在运行时动态的获取类信息以及动态调用对象的方法的功能称为Java 的反射机制。</li>
<li>Java 反射机制的功能</li>
</ul>
<ol>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时调用任意一个对象的方法。</li>
<li>生成动态代理。</li>
</ol>
<ul>
<li>Java 反射机制的应用场景</li>
</ul>
<ol>
<li>逆向代码 ，例如反编译</li>
<li>与注解相结合的框架 例如Retrofit</li>
<li>单纯的反射机制应用框架 例如EventBus</li>
<li>动态生成类框架 例如Gson</li>
</ol>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="通过Java反射查看类信息"><a href="#通过Java反射查看类信息" class="headerlink" title="通过Java反射查看类信息"></a>通过Java反射查看类信息</h4><p>（1）获取Class类对象——描述.class字节码文件<br>每个类被加载之后，系统就会为该类生成一个对应的Class对象。通过该Class对象就可以访问到JVM中的这个类。<br>在Java程序中获得Class对象通常有如下三种方式：</p>
<ol>
<li>使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定名（必须添加完整包名）。</li>
<li>调用某个类的class属性来获取该类对应的Class对象。</li>
<li>调用某个对象的getClass()方法。该方法是java.lang.Object类中的一个方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式 通过Class类的静态方法——forName()来实现</span></span><br><span class="line">class1 = Class.forName(<span class="string">&quot;com.lvr.reflection.Person&quot;</span>);</span><br><span class="line"><span class="comment">//第二种方式 通过类的class属性</span></span><br><span class="line">class1 = Person.class;</span><br><span class="line"><span class="comment">//第三种方式 通过对象getClass方法</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">Class&lt;?&gt; class1 = person.getClass();</span><br></pre></td></tr></table></figure>

<p>（2）类成员变量的反射</p>
<ol>
<li>获取类成员变量：</li>
</ol>
<ul>
<li>Field[] getFields()：获取所有public 修饰的成员变量</li>
<li>Field getField(String name)：获取指定名称的public修饰的成员变量</li>
<li>Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符</li>
<li>Filed getDeclaredField(String name)：获取指定名称的成员变量，不考虑修饰符</li>
</ul>
<ol>
<li>Filed：成员变量</li>
</ol>
<ul>
<li>get(Object object) ：获取值</li>
<li>void set(Object obj, Object value)：设置值</li>
<li>setAccessible(true) ：忽略访问权限修饰符的安全检查，用于暴力反射，修改私有成员变量的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field[] allFields = class1.getDeclaredFields();<span class="comment">//获取class对象的所有属性</span></span><br><span class="line">Field[] publicFields = class1.getFields();<span class="comment">//获取class对象的public属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> class1.getDeclaredField(<span class="string">&quot;age&quot;</span>);<span class="comment">//获取class指定属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">desField</span> <span class="operator">=</span> class1.getField(<span class="string">&quot;des&quot;</span>);<span class="comment">//获取class指定的public属性</span></span><br></pre></td></tr></table></figure>

<p>（3）类成员方法的反射</p>
<ol>
<li>获取类成员方法：</li>
</ol>
<ul>
<li>Method[] getMethods()：获取所有public修饰的成员方法</li>
<li>Method getMethod(String name,类&lt;?&gt;… parameterTypes)：获取指定的public修饰的成员方法，name 为方法名，parameterTypes为参数列表（重载）</li>
<li>Method[] getDeclaredMethods()：获取所有成员方法</li>
<li>Method getDeclaredMethod(String name,类&lt;?&gt;… parameterTypes)：获取指定的成员方法，name 为方法名，parameterTypes为参数列表（重载）</li>
</ul>
<ol>
<li>Method</li>
</ol>
<ul>
<li>invoke(obj … args)：执行方法</li>
<li>setAccessible(true) ：忽略访问权限修饰符的安全检查，用于暴力反射，修改私有成员方法的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = class1.getDeclaredMethods();<span class="comment">//获取class对象的所有声明方法</span></span><br><span class="line">Method[] allMethods = class1.getMethods();<span class="comment">//获取class对象的所有public方法 包括父类的方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> class1.getMethod(<span class="string">&quot;info&quot;</span>, String.class);<span class="comment">//返回次Class对象对应类的、带指定形参列表的public方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">declaredMethod</span> <span class="operator">=</span> class1.getDeclaredMethod(<span class="string">&quot;info&quot;</span>, String.class);<span class="comment">//返回次Class对象对应类的、带指定形参列表的方法</span></span><br></pre></td></tr></table></figure>

<p>（4）类构造方法的反射</p>
<ol>
<li>获取类构造方法：</li>
</ol>
<ul>
<li>Constructor[] getConstructors()：获取public修饰的构造方法</li>
<li>Constructor getConstructor(类&lt;?&gt;… parameterTypes)：获取指定的public修饰的构造方法（构造方法的方法名 &#x3D; 类名），parameterTypes为参数列表</li>
<li>Constructor[] getDeclaredConstructors()：获取所有构造方法</li>
<li>Constructor getDeclaredConstructor(类&lt;?&gt;… parameterTypes)：获取指定的构造方法，name为方法名（构造方法的方法名 &#x3D; 类名），parameterTypes为参数列表</li>
</ul>
<ol>
<li>Constructor：构造方法</li>
</ol>
<ul>
<li>T.newInstance(Object… init args)：创建对象</li>
<li>Class.newInstance()：如果使用空参数构造方法创建对象，操作可以简化为：Class对象的newInstance方法</li>
<li>setAccessible(true) ：忽略访问权限修饰符的安全检查，用于暴力反射，修改私有构造方法的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] allConstructors = class1.getDeclaredConstructors();<span class="comment">//获取class对象的所有声明构造函数</span></span><br><span class="line">Constructor&lt;?&gt;[] publicConstructors = class1.getConstructors();<span class="comment">//获取class对象public构造函数</span></span><br><span class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);<span class="comment">//获取指定声明构造函数</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">publicConstructor</span> <span class="operator">=</span> class1.getConstructor(String.class);<span class="comment">//获取指定声明的public构造函数</span></span><br></pre></td></tr></table></figure>

<h4 id="通过Java反射生成并操作对象"><a href="#通过Java反射生成并操作对象" class="headerlink" title="通过Java反射生成并操作对象"></a>通过Java反射生成并操作对象</h4><ul>
<li>生成类的实例对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式 Class对象调用newInstance()方法生成</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> class1.newInstance();</span><br><span class="line"><span class="comment">//第二种方式 对象获得对应的Constructor对象，再通过该Constructor对象的newInstance()方法生成</span></span><br><span class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);<span class="comment">//获取指定声明构造函数</span></span><br><span class="line">obj = constructor.newInstance(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>调用类的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成新的对象：用newInstance()方法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> class1.newInstance();</span><br><span class="line"><span class="comment">//首先需要获得与该方法对应的Method对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> class1.getDeclaredMethod(<span class="string">&quot;setAge&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line"><span class="comment">//开启调用该方法的权限</span></span><br><span class="line">method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//调用指定的函数并传递参数</span></span><br><span class="line">method.invoke(obj, <span class="number">28</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>访问成员变量值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成新的对象：用newInstance()方法 </span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> class1.newInstance();</span><br><span class="line"><span class="comment">//获取age成员变量</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> class1.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="comment">//将obj对象的age的值设置为10</span></span><br><span class="line">field.setInt(obj, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//获取obj对象的age的值</span></span><br><span class="line">field.getInt(obj);</span><br></pre></td></tr></table></figure>

<h3 id="Java反射机制-与-动态代理"><a href="#Java反射机制-与-动态代理" class="headerlink" title="Java反射机制 与 动态代理"></a>Java反射机制 与 动态代理</h3><p>[第七章 设计模式 —— 动态代理][_ _ 1]</p>
<ul>
<li>静态代理<br>在程序运行前就已经存在代理类的.class文件，已经确定代理类和委托类的关系。</li>
<li>动态代理<br>通过动态代码可实现对不同类、不同方法的代理。动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件（.class）。代理类和委托类的关系在程序运行时确定。<br>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。而且动态代理提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。（而每个静态代理只能为一个接口服务）</li>
<li>实现原理 —— 反射</li>
</ul>
<ol>
<li>动态代理类只能代理接口，需创建一个实现接口InvocationHandler的调用处理器，它必须实现invoke方法。invoke方法是调用代理接口所有方法都要调用，返回值是被代理接口的一个实现类（动态代理类）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 目标对象  </span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;  </span><br><span class="line">    <span class="comment">//绑定关系，也就是关联到哪个接口（与具体的实现类绑定）的哪些方法将被调用时，执行invoke方法。              </span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">newProxyInstance</span><span class="params">(Object targetObject)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        <span class="built_in">this</span>.targetObject=targetObject;  </span><br><span class="line">        <span class="comment">//该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例    </span></span><br><span class="line">        <span class="comment">//第一个参数指定产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器  </span></span><br><span class="line">        <span class="comment">//第二个参数要实现和目标对象一样的接口，所以只需要拿到目标对象的实现接口  </span></span><br><span class="line">        <span class="comment">//第三个参数表明这些被拦截的方法在被拦截时需要执行哪个InvocationHandler的invoke方法  </span></span><br><span class="line">        <span class="comment">//根据传入的目标返回一个代理对象  </span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),  </span><br><span class="line">                targetObject.getClass().getInterfaces(),<span class="built_in">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="comment">//关联的这个实现类的方法被调用时将被执行  </span></span><br><span class="line">    <span class="comment">/*InvocationHandler接口的方法，proxy表示代理，method表示原对象被调用的方法，args表示方法的参数*/</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  </span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="string">&quot;start--&gt;&gt;&quot;</span>);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">            System.out.println(args[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        Object ret=<span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">            <span class="comment">/*原对象方法调用前处理日志信息*/</span>  </span><br><span class="line">            System.out.println(<span class="string">&quot;satrt--&gt;&gt;&quot;</span>);  </span><br><span class="line">              </span><br><span class="line">            <span class="comment">//调用目标方法  </span></span><br><span class="line">            ret=method.invoke(targetObject, args);  </span><br><span class="line">            <span class="comment">/*原对象方法调用后处理日志信息*/</span>  </span><br><span class="line">            System.out.println(<span class="string">&quot;success--&gt;&gt;&quot;</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            System.out.println(<span class="string">&quot;error--&gt;&gt;&quot;</span>);  </span><br><span class="line">            <span class="keyword">throw</span> e;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建接口及具体实现类（委托类）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserManager</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String userId, String userName)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delUser</span><span class="params">(String userId)</span> ;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">findUser</span><span class="params">(String userId)</span> ;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyUser</span><span class="params">(String userId, String userName)</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现类（委托类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String userId, String userName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="string">&quot;UserManagerImpl.addUser&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delUser</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="string">&quot;UserManagerImpl.delUser&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUser</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="string">&quot;UserManagerImpl.findUser&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;张三&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyUser</span><span class="params">(String userId, String userName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="string">&quot;UserManagerImpl.modifyUser&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过动态代理类调用Proxy的静态方法newProxyInstance，提供ClassLoader和代理接口类型数组动态创建一个代理类，并通过代理调用方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        LogHandler logHandler=<span class="keyword">new</span> <span class="title class_">LogHandler</span>();  </span><br><span class="line">        UserManager userManager=(UserManager)logHandler.newProxyInstance(<span class="keyword">new</span> <span class="title class_">UserManagerImpl</span>());  </span><br><span class="line">        <span class="comment">// 获取动态代理对象</span></span><br><span class="line">        userManager.addUser(<span class="string">&quot;1111&quot;</span>, <span class="string">&quot;张三&quot;</span>);  <span class="comment">// 调用动态代理的addUser方法，该调用会转发到logHandler的invoke上，从而达到动态代理的效果</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们可以通过LogHandler代理不同类型的对象，如果我们把对外的接口都通过动态代理来实现，那么所有的函数调用最终都会经过invoke函数的转发，因此我们就可以在这里做一些自己想做的操作，比如日志系统、事务、拦截器、权限控制等。这也就是AOP(面向切面编程)的基本原理。</p>
<blockquote>
<p>AOP（AspectOrientedProgramming）：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码—解耦。</p>
</blockquote>
<h3 id="Java反射机制-与-泛型"><a href="#Java反射机制-与-泛型" class="headerlink" title="Java反射机制 与 泛型"></a>Java反射机制 与 泛型</h3><h3 id="反射在项目中的应用"><a href="#反射在项目中的应用" class="headerlink" title="反射在项目中的应用"></a>反射在项目中的应用</h3><p>应用一：简单工厂创建对象</p>
<ul>
<li>需求<br>通过一个工厂类创建不同类型的实例。</li>
<li>解决方案</li>
</ul>
<ol>
<li>在配置文件中配置需要创建对象的信息</li>
<li>通过类加载器加载配置文件</li>
<li>获取类对象，通过类的全限定名创建实例对象</li>
</ol>
<ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicFactory</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BasicFactory</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">BasicFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicFactory</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        pro = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">         </span><br><span class="line">            <span class="comment">//通过类加载器加载配置文件</span></span><br><span class="line">            pro.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(BasicFactory.class.getClassLoader().</span><br><span class="line">                    getResource(<span class="string">&quot;config.properties&quot;</span>).getPath()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BasicFactory <span class="title function_">getFactory</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> bf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用泛型获得通用的对象</span></span><br><span class="line">    <span class="keyword">public</span>  &lt;T&gt; T <span class="title function_">newInstance</span><span class="params">(Class&lt;T&gt; clazz)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">String</span> <span class="variable">cName</span> <span class="operator">=</span> clazz.getSimpleName();   <span class="comment">//获得字节码对象的类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">clmplName</span> <span class="operator">=</span> pro.getProperty(cName);   <span class="comment">//根据字节码对象的类名通过配置文件获得类的全限定名</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> (T)Class.forName(clmplName).newInstance();   <span class="comment">//根据类的全限定名创建实例对象</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用二：过滤符合输入关键字的数据</p>
<ul>
<li>需求<br>输入关键字检索通过网络请求加载好的列表数据，过滤出符合过滤条件（包含关键字）的数据项。</li>
<li>为何使用反射<br>一般解决方案为，遍历存放数据的List，然后每项对比关键字，将过滤后的数据存入一个新的List中，返回给RecyclerView的Adapter进行数据刷新。<br>有2个问题：</li>
</ul>
<ol>
<li>List获取的数据由于业务不同，其泛型也不同，且泛型没有关联性</li>
<li>每一个泛型都是一个Bean，要对Bean中的属性尽兴过滤，属性是不确定的<br>由于列表数据过滤在项目中很常用，几乎每个列表项都有过滤功能，如果对于每种列表都采用硬编码进行封装，代码的复用性很低，且项目不易维护。</li>
</ol>
<ul>
<li>解决方案<br>采用反射机制<br>主要是getClassInfo获取某个类需要过滤的数据项，并与关键字对比并过滤。</li>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListFilter</span>&lt;T&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤ArrayList中的关键字数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> models 网络获取到的数据列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> query 过滤关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propertyName 泛型的数据过滤项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回过滤后的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;T&gt; <span class="title function_">filter</span><span class="params">(ArrayList&lt;T&gt; models, String query, String propertyName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        ArrayList&lt;T&gt; filteredModelList = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//实例化这个类赋给o</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            query = query.toLowerCase();</span><br><span class="line">            filteredModelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (T model : models) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> getClassInfo(model,model.getClass().getName(),propertyName).toLowerCase();</span><br><span class="line">                <span class="keyword">if</span> (text.contains(query)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    filteredModelList.add(model);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filteredModelList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获取类的属性值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 类实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classNameString 类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propertyNameString 获取的属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  String <span class="title function_">getClassInfo</span><span class="params">(Object obj,String classNameString,String propertyNameString)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        String returnString=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="type">Class</span> <span class="variable">classInfo</span> <span class="operator">=</span> Class.forName(classNameString);</span><br><span class="line">            <span class="keyword">if</span>(!(classInfo.isInstance(obj)))&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                L.e(<span class="string">&quot;传入的java实例与配置的java对象类型不符！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> returnString;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> classInfo.getDeclaredField(propertyNameString);</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            returnString=field.get(obj).toString();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射效率低-原因-解决"><a href="#反射效率低-原因-解决" class="headerlink" title="反射效率低 原因 &amp; 解决"></a>反射效率低 原因 &amp; 解决</h3><p>导致反射效率慢的因素及解决：</p>
<ol>
<li>获取Class对象时使用Class.forName效率低，耗时。把Class.forName返回的Class对象缓存起来，下一次使用的时候直接从缓存里面获取，这样就极大的提高了获取Class的效率。</li>
<li>同理，在项目启动时将反射需要的相关配置和数据（Field、Method、Constructor等）加载进内存，在运行时直接从缓存中取这些元数据进行反射操作。</li>
<li>调用method.setAccessible(true)<br>jdk在设置获取字段，调用方法的时候会执行安全访问检查，而此类操作会比较耗时，所以通过setAccessible(true)的方式可以关闭安全检查，从而提升反射效率。</li>
<li>采用高性能的反射工具包，如ReflectASM。</li>
<li>使用高版本JDK，提高反射性能。</li>
<li>反射效率慢，但速度也是可以接受的。所以对于反射不应该因为速度慢而对其”望而却步”。</li>
</ol>
<h2 id="注解（Annotation）"><a href="#注解（Annotation）" class="headerlink" title="注解（Annotation）"></a>注解（Annotation）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>注解（元数据）是一种代码级别的说明。是JDK 5.0 后引入的新特性。注解作为程序的元数据嵌入到程序中，声明在类、成员变量、成员方法等前面，用来对这些元素进行说明，注释。注解可以被解析工具&#x2F;编译工具解析。<br>Annotation的作用可分为3类：</p>
<ol>
<li>编写文档：通过代码里标识的注解生成文档</li>
<li>代码分析：通过反射获取注解信息并对代码进行分析</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;ReflectTest&gt; reflectTestClass = ReflectTest.class;	<span class="comment">// 1.通过反射获取字节码文件对象</span></span><br><span class="line"><span class="type">Pro</span> <span class="variable">an</span> <span class="operator">=</span> reflectTestClass.getAnnotation(Pro.class);	<span class="comment">// 2.调用getAnnotation(class)获取注解对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> an.className();</span><br><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> an.methodName();	<span class="comment">// 3.调用注解对象中定义的抽象方法，获取返回值（返回值即注解信息）</span></span><br></pre></td></tr></table></figure>

<ol>
<li>编译检查：如@override 用于检测被该注解标注的方法是否是继承自父类（接口）</li>
</ol>
<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。</p>
<h3 id="JDK注解-自定义注解"><a href="#JDK注解-自定义注解" class="headerlink" title="JDK注解 &#x2F; 自定义注解"></a>JDK注解 &#x2F; 自定义注解</h3><ul>
<li>JDK —— 编译检查</li>
</ul>
<ol>
<li>@Override<br>用于检测被该注解标注的方法是否是继承自父类（接口）的。<br>如果某个方法带有该注解但并没有覆写超类相应的方法，则编译器会生成一条错误信息。如果父类没有这个要覆写的方法，则编译器也会生成一条错误信息。<br>@Override可适用元素为方法，仅仅保留在java源文件中。</li>
<li>@Deprecated<br>用于标注已经过时的方法。<br>用于告知编译器，某一程序元素(比如方法，成员变量)不建议使用了（即过时了）。编译器会出现警告。<br>@Deprecated可适合用于除注解类型声明之外的所有元素，保留时长为运行时。</li>
<li>@SuppressWarnnings<br>用于通知java编译器禁止特定的编译警告。<br>@SuppressWarnings可适合用于除注解类型声明和包名之外的所有元素，仅仅保留在java源文件中。</li>
</ol>
<ul>
<li>自定义注解 —— 代码分析&#x2F;编写文档</li>
<li>自定义注解的格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	... 属性列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotataion&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">website</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">revision</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationDemo</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 当注解中有成员变量时，若没有默认值，需要在使用注解时，指定成员变量的值。</span></span><br><span class="line">	<span class="meta">@MyAnnotataion(name=&quot;lvr&quot;, website=&quot;hello&quot;, revision=2)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        System.out.println(<span class="string">&quot;I am demo method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>元注解<br>通过元注解注解其他注解。Java提供了4个标准元注解：<br>（1）Target：描述注解作用位置，如CONSTRUCTOR、FIELD、METHOD、TYPE等等<br>（2）Retention：描述注解保留的阶段，包括SOURCE、CLASS、RUNTIME<br>（3）Documented：描述注解是否被抽取到生成的API文档中<br>（4）Inherited：描述注解是否被子类继承</li>
<li>属性列表<br>接口中的抽象方法被称为注解的属性。每一个抽象方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数类型。</li>
</ul>
<h3 id="如何解析注解"><a href="#如何解析注解" class="headerlink" title="如何解析注解"></a>如何解析注解</h3><ul>
<li>通过反射技术解析自定义注解<br>关于反射类位于包java.lang.reflect，其中有一个接口AnnotatedElement。该接口定义了注释相关的几个核心方法，如下：<br><img src="https://mark.cuckooing.cn/pics/pic_8790c743.png" alt="pic_8790c743.png"><br>因此，当获取了某个类的Class对象，然后获取其Field,Method等对象，通过上述4个方法提取其中的注解，然后获得注解的详细信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationParser</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SecurityException, ClassNotFoundException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">String</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="string">&quot;com.lvr.annotation.AnnotationDemo&quot;</span>;</span><br><span class="line">        Method[]  demoMethod = AnnotationParser.class</span><br><span class="line">                .getClassLoader().loadClass(clazz).getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : demoMethod) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(MyAnnotataion.class)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                 <span class="type">MyAnnotataion</span> <span class="variable">annotationInfo</span> <span class="operator">=</span> method.getAnnotation(MyAnnotataion.class);</span><br><span class="line">                 System.out.println(<span class="string">&quot;method: &quot;</span>+ method);</span><br><span class="line">                 System.out.println(<span class="string">&quot;name= &quot;</span>+ annotationInfo.name() +</span><br><span class="line">                         <span class="string">&quot; , website= &quot;</span>+ annotationInfo.website()</span><br><span class="line">                        + <span class="string">&quot; , revision= &quot;</span>+annotationInfo.revision());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解解析案例：实现反射动态加载类</li>
</ul>
<ol>
<li>通过反射获取注解定义位置的对象（Class，Method，Field）</li>
<li>获取指定的注解：getAnnotation（Class）其实就是在内存中生成了一个该注解接口的子类实现对象</li>
<li>调用注解中的抽象方法获取配置的属性值</li>
</ol>
<p>Pro.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解配置文件:描述需要执行的类名和方法名</span></span><br><span class="line"><span class="meta">@Target</span> (&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Pro&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	String <span class="title function_">className</span><span class="params">()</span>;</span><br><span class="line">	String <span class="title function_">methodName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReflectTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">// 前提：不能改变该类的任何代码，可以创建任意类的对象，可以执行任意方法</span></span><br><span class="line">		<span class="comment">// 1. 解析注解</span></span><br><span class="line">		<span class="comment">// 1.1 获取该类的字节码文件对象</span></span><br><span class="line">		Class&lt;ReflectTest&gt; reflectTestClass = ReflectTest.class;</span><br><span class="line">		<span class="comment">// 2.获取上边的注解对象，起始就是在内存中生成了一个注解接口的子类实现对象</span></span><br><span class="line">		<span class="comment">// public class ProImpl implements Pro&#123;</span></span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">//	public String className()&#123;</span></span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">//		return &quot;cn.itcast.annotation.Demo1&quot;;</span></span><br><span class="line">		<span class="comment">// 	&#125;</span></span><br><span class="line">		<span class="comment">// 	public String methodName()&#123;</span></span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="comment">//		return &quot;show&quot;;</span></span><br><span class="line">		<span class="comment">//	&#125;</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		<span class="type">Pro</span> <span class="variable">an</span> <span class="operator">=</span> reflectTestClass.getAnnotation(Pro.class);</span><br><span class="line">		<span class="comment">// 3.调用注解对象中定义的抽象方法，获取返回值</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> an.className();</span><br><span class="line">		<span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> an.methodName();</span><br><span class="line">		<span class="comment">// 4. 加载该类进内存</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">		<span class="comment">// 5. 创建对象</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">		<span class="comment">// 6. 获取方法对象</span></span><br><span class="line">		<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">		<span class="comment">// 7. 执行方法</span></span><br><span class="line">		method.invoke(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="控制反转（IOC）-依赖注入（DI）"><a href="#控制反转（IOC）-依赖注入（DI）" class="headerlink" title="控制反转（IOC）&#x2F;依赖注入（DI）"></a>控制反转（IOC）&#x2F;依赖注入（DI）</h2><ul>
<li>依赖（Dependency）<br>依赖是类与类之间的相互联系，如人（Person）出行可以使用自行车Bike、轿车Car或火车（Train），因此Person类可以依赖Bike类、Car类和Train类。<br>每次出行都需要修改Person类代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bike mBike;</span><br><span class="line">    <span class="keyword">private</span> Car mCar;</span><br><span class="line">    <span class="keyword">private</span> Train mTrain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        mBike = <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line">        <span class="comment">// mCar = new Car();</span></span><br><span class="line">        <span class="comment">// mTrain = new Train();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goOut</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        System.out.println(<span class="string">&quot;出游&quot;</span>);</span><br><span class="line">        mBike.drive();</span><br><span class="line">        <span class="comment">// mCar.drive();</span></span><br><span class="line">        <span class="comment">// mTrain.drive();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>依赖反转（IOC）<br>IOC对上层模块与底层模块进行了进一步的解耦。控制反转的意思是反转了上层模块对于底层模块的依赖控制。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person2</span><span class="params">(Driveable driveable)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.mDriveable = driveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goOut</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        System.out.println(<span class="string">&quot;出门啦&quot;</span>);</span><br><span class="line">        mDriveable.drive();</span><br><span class="line">        <span class="comment">// mCar.drive();</span></span><br><span class="line">        <span class="comment">// mTrain.drive();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="type">Person2</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person2</span>(<span class="keyword">new</span> <span class="title class_">Car</span>());</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>依赖注入（DI）<br>DI是指在外部将依赖实例化并赋值给IOC容器。依赖注入有3种方式：构造函数注入、setter方式注入、接口注入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DepedencySetter</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Driveable driveable)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person2</span>  <span class="keyword">implements</span> <span class="title class_">DepedencySetter</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//接口方式注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Driveable driveable)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.mDriveable = mDriveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Driveable mDriveable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person2</span><span class="params">(Driveable driveable)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.mDriveable = driveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//setter 方式注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDriveable</span><span class="params">(Driveable mDriveable)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.mDriveable = mDriveable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goOut</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        System.out.println(<span class="string">&quot;出门啦&quot;</span>);</span><br><span class="line">        mDriveable.drive();</span><br><span class="line">        <span class="comment">//mCar.drive();</span></span><br><span class="line"><span class="comment">//        mTrain.drive();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">        <span class="type">Person2</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person2</span>(<span class="keyword">new</span> <span class="title class_">Car</span>());</span><br><span class="line">        person.goOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ButterKnife用法-原理？"><a href="#ButterKnife用法-原理？" class="headerlink" title="ButterKnife用法 &amp; 原理？"></a>ButterKnife用法 &amp; 原理？</h3><p>ButterKnife:是视图注入中相对简单易懂的开源框架，其优势在于：</p>
<ol>
<li>强大的View绑定和Click事件处理功能,简单代码,提高开发效率</li>
<li>方便的处理Adapter和ViewHolder绑定问题</li>
<li>提高APP运行效率,使用配置方便</li>
<li>代码清晰,可读性强</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InjectView(R.id.listview)</span></span><br><span class="line">ListView mListview;</span><br><span class="line"><span class="meta">@OnItemClick(R.id.listview)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onItemClick</span><span class="params">(<span class="type">int</span> position)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     Toast.makeText(getBaseContext(), <span class="string">&quot;item&quot;</span>+position, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="第四章-抽象类与接口"><a href="#第四章-抽象类与接口" class="headerlink" title="第四章 抽象类与接口"></a>第四章 抽象类与接口</h1><ul>
<li>抽象类&amp;接口？区别？优缺点？适用场景？</li>
</ul>
<h2 id="抽象类-接口？区别？优缺点？适用场景？"><a href="#抽象类-接口？区别？优缺点？适用场景？" class="headerlink" title="抽象类&amp;接口？区别？优缺点？适用场景？"></a>抽象类&amp;接口？区别？优缺点？适用场景？</h2><p>[菜鸟教程：抽象类 &amp; 接口][Link 2]</p>
<ul>
<li>抽象类 &amp; 接口</li>
<li>抽象类<br>不能实例化对象的类。通过abstract class来定义抽象类。抽象类必须被继承，才能被使用。abstract可声明抽象方法，抽象方法只包含方法名，没有方法体，具体实现由它的子类确定。抽象方法有两条规则：<br>（1）包含抽象方法的类必定是抽象类（但抽象类不一定有抽象方法）<br>（2）任何子类必须重写父类的抽象方法，或者声明自身为抽象类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, String address)</span></span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      System.out.println(<span class="string">&quot;Constructing an Employee&quot;</span>);</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.address = address;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 一般成员方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     <span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> name;&#125;</span><br><span class="line">   <span class="comment">// 抽象成员方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="keyword">void</span> <span class="title function_">computePay</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类继承抽象类，具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Salary</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> salary; <span class="comment">// Annual salary</span></span><br><span class="line">  <span class="comment">// 必须实现抽象成员方法 computePay</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      System.out.println(<span class="string">&quot;Computing salary pay for &quot;</span> + getName());</span><br><span class="line">      <span class="keyword">return</span> salary/<span class="number">52</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口<br>接口不是类，是抽象方法的集合。通过Interface来声明接口。一个类通过implements关键字来实现接口中的抽象方法。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MammalInt</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal eats&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">travel</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      System.out.println(<span class="string">&quot;Mammal travels&quot;</span>);</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">noOfLegs</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>联系 &amp; 区别</li>
</ul>
<table> 
 <tbody> 
  <tr> 
   <td></td> 
   <td>抽象类<br>abstract</td> 
   <td>接口<br>interface</td> 
  </tr> 
  <tr> 
   <td>定义</td> 
   <td>不能实例化对象的类。通过abstract class来定义抽象类。抽象类必须被继承，才能被使用。一个类通过extends关键字来继承抽象类。</td> 
   <td>接口不是类，是抽象方法的集合。通过Interface来声明接口。一个类通过implements关键字来实现接口中的抽象方法。</td> 
  </tr> 
  <tr> 
   <td>作用</td> 
   <td>is-a关系<br>是什么</td> 
   <td>like-a<br>能做什么</td> 
  </tr> 
  <tr> 
   <td>描述</td> 
   <td>描述对象的属性和方法，关注的是事物本身的抽象</td> 
   <td>声明类要实现的方法，关注的是操作行为的规范</td> 
  </tr> 
  <tr> 
   <td>相同点</td> 
   <td colspan="2">均不可实例化<br>均需要子类继承/实现对应的抽象方法</td> 
  </tr> 
  <tr> 
   <td>成员方法</td> 
   <td>抽象类的方法有方法体，可以实现方法的具体功能</td> 
   <td>接口中只有方法的声明，没有方法体（接口中的方法默认public abstract类型）</td> 
  </tr> 
  <tr> 
   <td>成员变量</td> 
   <td>抽象类的成员变量可以是各种类型</td> 
   <td>接口中只成员变量只能是public static final类型（公共静态常量）</td> 
  </tr> 
  <tr> 
   <td>static修饰符</td> 
   <td>抽象类可以有静态代码块和静态方法</td> 
   <td>接口中没有静态代码块以及静态方法</td> 
  </tr> 
  <tr> 
   <td>继承关系</td> 
   <td>一个类只能继承一个抽象类</td> 
   <td>一个类可以实现多个接口</td> 
  </tr> 
  <tr> 
   <td>优缺点</td> 
   <td>优点：实现公共特性的提取，使具体类可以从抽象类自动得到缺省实现，复用性强，简化代码<br>缺点：单继承，使子类的功能的扩展性大打折扣</td> 
   <td>优点：一个类可以实现多个接口，接口可以使这个类不仅具有主类型的行为，而且具有其他的次要行为，比如 HashMap主要类型是Map,而Cloneable接口使它具有一个次要类型，这个类型说明它可以安全的克隆</td> 
  </tr> 
  <tr> 
   <td>使用建议</td> 
   <td colspan="2">抽象类用于给子类提供一个抽象的描述，用作主要类型的说明<br>接口用于给子类提供多个功能的补充，用作次要类型的说明</td> 
  </tr> 
 </tbody> 
</table>




<h1 id="第五章-JVM、垃圾回收（GC）"><a href="#第五章-JVM、垃圾回收（GC）" class="headerlink" title="第五章 JVM、垃圾回收（GC）"></a>第五章 JVM、垃圾回收（GC）</h1><ul>
<li>Java代码执行流程&#x2F;Java虚拟机工作原理？</li>
<li>Java内存结构 &#x2F; 运行时数据区域？</li>
<li>对象的创建、内存布局 和 访问定位</li>
<li><ul>
<li>对象的创建</li>
<li>对象的内存布局</li>
<li>对象的访问定位</li>
</ul>
</li>
<li>类加载机制</li>
<li><ul>
<li>什么是class文件？</li>
<li>类加载机制</li>
<li>类的生命周期</li>
<li>触发类加载的条件</li>
<li>类加载的具体过程</li>
<li>类加载器</li>
<li><ul>
<li>类加载器分类</li>
<li>双亲委派模型</li>
</ul>
</li>
</ul>
</li>
<li>垃圾回收机制</li>
<li><ul>
<li>如何判断对象是否会被垃圾回收机制处理掉？</li>
<li>说说Java种的4种引用以及用法？</li>
<li>GC回收算法有哪些？优缺点？</li>
<li>GC回收机制？</li>
<li>GC是什么时候触发的？</li>
<li>垃圾收集器？</li>
</ul>
</li>
<li>面试</li>
<li><ul>
<li>对象的生命周期?</li>
<li>谈谈static关键字&#x2F;谈谈static编译运行时的流程，在虚拟机中如何保存的？</li>
</ul>
</li>
</ul>
<h2 id="Java代码执行流程-Java虚拟机工作原理？"><a href="#Java代码执行流程-Java虚拟机工作原理？" class="headerlink" title="Java代码执行流程&#x2F;Java虚拟机工作原理？"></a>Java代码执行流程&#x2F;Java虚拟机工作原理？</h2><p>Java 代码执行流程主要划分为以下5个步骤：编辑源代码、编译生成class文件、加载class文件、运行class文件、垃圾回收。</p>
<ol>
<li>源码编写<br>编辑源代码，并命名为Student.java。</li>
<li>编译<br>输入javac Student.java&#x2F;使用Java源码编译器编译。将源代码文件编译生成student.class字节码文件。字节码文件存放了这个类的字段、方法、父类、实现的接口等各种信息。</li>
<li>类加载<br>通过类加载器将.class二进制数据读入内存中。即读取student.class文件中数据并存储在方法区中，并建立一个Class对象，作为运行时方法Student类各种数据的接口。</li>
</ol>
<blockquote>
<blockquote>
<p>一个类文件加载到方法区，一些符号引用被解析（静态解析：如class文件的常量池被加载到方法区运行时常量池，各种其他静态存储结构被加载为方法区运行时数据结构等等）为直接引用或等到运行时分派（动态绑定），经过一系列加载过程后，程序可以通过Class对象方法方法区各种类型数据。</p>
</blockquote>
</blockquote>
<ol>
<li>JVM执行<br>JVM执行.class文件。执行引擎找到main()入口方法，即在栈里创建一个栈帧，逐行执行方法中的字节码指令。操作完成后方法返回给调用方，栈帧出栈。</li>
</ol>
<blockquote>
<blockquote>
<p>当前正在运行的方法的栈帧位于栈顶。若当前方法返回，则当前方法对应的栈帧出栈；当前方法的方法体中若是调用了其他方法，则为被调用方法创建栈帧，并将其压入栈顶。</p>
</blockquote>
</blockquote>
<ol>
<li>垃圾回收<br>内存空间通过JVM垃圾回收机制GC</li>
</ol>
<h2 id="Java内存结构-运行时数据区域？"><a href="#Java内存结构-运行时数据区域？" class="headerlink" title="Java内存结构 &#x2F; 运行时数据区域？"></a>Java内存结构 &#x2F; 运行时数据区域？</h2><p>Java内存结构描述的是Java程序执行过程中, 由JVM管理的不同的数据区域。包括以下5部分：<br>堆内存（heap）、方法区（method）、程序计数器、栈内存（stack）、本地方法栈（java中JNI调用）</p>
<ol>
<li>堆内存（线程共享）：JVM所管理的内存中最大一块。唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。异常状态 OutOfMemoryError</li>
<li>方法区（线程共享）：方法区是被所有线程共享的区域。用于存放类的所有信息（字段、方法、构造函数等）、静态变量、常量。异常状态 OutOfMemoryError<br>包含运行时常量池：存放编译器生成的各种字面量和符号引用</li>
<li>（虚拟机）栈内存（线程私有）：一个线程对应一个栈，生命周期与线程相同。描述的是java方法执行的内存模型：每个方法执行时会创建一个栈帧，用于存放局部变量、操作数栈、方法出口等信息。每一个方法从调用直至完成的过程，对应着一个栈帧在虚拟机中入栈到出栈的过程。异常状态 OutOfMemoryError StackOverflowError</li>
<li>本地方法栈（线程私有）：与虚拟机栈作用相似，区别在于本地方法栈用于支持Native方法执行，存储了每个Native方法调用的状态。</li>
<li>程序计数器（线程私有）：可看做当前线程所执行的字节码的行号指示器。指向方法区方法字节码（下一个指令的地址），并由执行引擎读取并执行下一指令。<br><img src="https://mark.cuckooing.cn/pics/pic_172a6b7c.png" alt="pic_172a6b7c.png"></li>
</ol>
<blockquote>
<p>Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。<br>所谓静态常量池，即*.class文件中的常量池，这种常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)<br>字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等。<br>符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：<br>（1）类和接口的全限定名<br>（2）字段名称和描述符<br>（3）方法名称和描述符<br>而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。  </p>
<p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p>
</blockquote>
<h2 id="对象的创建、内存布局-和-访问定位"><a href="#对象的创建、内存布局-和-访问定位" class="headerlink" title="对象的创建、内存布局 和 访问定位"></a>对象的创建、内存布局 和 访问定位</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>1.虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用；<br>2.检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，那必须先执行响应的类加载过程；<br>3.在类加载检查功通过后，为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>分为3个区域：对象头，实例数据，对齐填充。<br>对象头：<br>包括两部分信息，第一部分：对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32 bit和64 bit，官方称它为“Mark Word”。<br>第二部分：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个java数组，那在对象头中还必须有一块用于记录数组长度的数据。<br>实例数据：<br>是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。<br>对齐填充：<br>对齐填充不是必然存在的。HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的整数倍。因此，当对象实例数据部分没有对齐时，就需要通过对其补充来补全了。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序需要通过栈上了reference数据来操作堆上的具体对象。<br>目前主流的访问方式有使用句柄和直接指针两种。<br>句柄访问：<br>Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对实例数据与类型数据的各自具体的地址信息。<br><img src="https://mark.cuckooing.cn/pics/pic_0c4b52d7.png" alt="pic_0c4b52d7.png"><br>直接指针访问：<br>reference中存储的直接就是对象地址。<br><img src="https://mark.cuckooing.cn/pics/pic_3e91c735.png" alt="pic_3e91c735.png"></p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="什么是class文件？"><a href="#什么是class文件？" class="headerlink" title="什么是class文件？"></a>什么是class文件？</h3><p>Java的编译器在编译java类文件时，会将原有的文本文件（.java）翻译成二进制的字节码，并将这些字节码存储在.class文件。<br>也就是说java类文件中的属性、方法，以及类中的常量信息，都会被分别存储在.class文件中。当然还会添加一个公有的静态常量属性.class，这个属性记录了类的相关信息，即类型信息，是Class类的一个实例。<br>class文件存在的意义就是:跨平台。各种不同平台的虚拟机都统一使用这种相同的程序存储格式。不同平台的JVM运行相同的.class文件。</p>
<blockquote>
<p>Java为什么能跨平台运行？<br>因为每个平台都拥有自己的JVM。Java编译器会先将Java代码编译成二进制字节码的class文件，并使用不同平台的JVM解释运行这些字节码文件。因此Java语言能跨平台运行。</p>
</blockquote>
<h3 id="类加载机制-1"><a href="#类加载机制-1" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。<br>在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点来实现的。</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接。<br>这7个阶段发生顺序如下图：<br><img src="https://mark.cuckooing.cn/pics/pic_7a10fe35.png" alt="pic_7a10fe35.png"><br>加载，验证，准备，初始化，卸载这5个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化完成后在开始，这是为了支持Java语言的运行时绑定。<br>其中加载，验证，准备，解析及初始化是属于类加载机制中的步骤。注意此处的加载不等同于类加载。</p>
<h3 id="触发类加载的条件"><a href="#触发类加载的条件" class="headerlink" title="触发类加载的条件"></a>触发类加载的条件</h3><p>①.遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段的时候（被final修饰，已在编译期把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候。<br>②.使用java.lang.reflect包的方法对类进行反射调用的时候。<br>③.当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先出发父类的初始化。<br>④.当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。<br>⑤.当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出发初始化。</p>
<h3 id="类加载的具体过程"><a href="#类加载的具体过程" class="headerlink" title="类加载的具体过程"></a>类加载的具体过程</h3><p>加载:</p>
<p>①.通过一个类的全限定名来获取定义此类的二进制字节流<br>②.将这个字节流所代表的静态存储结构转换为方法区内的运行时数据结构<br>③.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。<br>验证：</p>
<p>是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br>包含四个阶段的校验动作<br>a.文件格式验证<br>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。<br>b.元数据验证<br>对类的元数据信息进行语义校验，是否不存在不符合Java语言规范的元数据信息<br>c.字节码验证<br>最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。<br>d.符号引用验证<br>最后一个阶段的校验发生在虚拟机将符号引用转换为直接引用的时候，这个转换动作将在连接的第三个阶段——解析阶段中发生。<br>符号验证的目的是确保解析动作能正常进行。<br>准备：</p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中分配。只包括类变量。初始值“通常情况”下是数据类型的零值。<br>“特殊情况”下，如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段变量的值就会被初始化为ConstantValue属性所指定的值。<br>解析：</p>
<p>虚拟机将常量池内的符号引用替换为直接引用的过程。<br>“动态解析”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。<br>初始化：</p>
<p>类加载过程中的最后一步。<br>初始化阶段是执行类构造器()方法的过程。<br>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。<br>()与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法已经执行完毕。<br>简单地说，初始化就是对类变量进行赋值及执行静态代码块。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>通过上述的了解，我们已经知道了类加载机制的大概流程及各个部分的功能。其中加载部分的功能是将类的class文件读入内存，并为之创建一个java.lang.Class对象。这部分功能就是由类加载器来实现的。</p>
<h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><p>不同的类加载器负责加载不同的类。主要分为两类。<br>启动类加载器（Bootstrap ClassLoader）： 由C++语言实现（针对HotSpot）,负责将存放在\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中，即负责加载Java的核心类。<br>其他类加载器： 由Java语言实现，继承自抽象类ClassLoader。如：<br>扩展类加载器（Extension ClassLoader）： 负责加载\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库，即负责加载Java扩展的核心类之外的类。<br>应用程序类加载器（Application ClassLoader）： 负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器，通过ClassLoader.getSystemClassLoader()方法直接获取。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。<br>以上2大类，3小类类加载器基本上负责了所有Java类的加载。下面我们来具体了解上述几个类加载器实现类加载过程时相互配合协作的流程。</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。<br><img src="https://mark.cuckooing.cn/pics/pic_616deb2a.png" alt="pic_616deb2a.png"><br>这样的好处是不同层次的类加载器具有不同优先级，比如所有Java对象的超级父类java.lang.Object，位于rt.jar，无论哪个类加载器加载该类，最终都是由启动类加载器进行加载，保证安全。即使用户自己编写一个java.lang.Object类并放入程序中，虽能正常编译，但不会被加载运行，保证不会出现混乱。<br>代码实现：ClassLoader中loadClass方法实现了双亲委派模型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//如果该类没有加载，则进入该分支</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name); <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个流程大致如下：<br>a.首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。<br>b.如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。<br>c.如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载（自定义加载器）。</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h3 id="如何判断对象是否会被垃圾回收机制处理掉？"><a href="#如何判断对象是否会被垃圾回收机制处理掉？" class="headerlink" title="如何判断对象是否会被垃圾回收机制处理掉？"></a>如何判断对象是否会被垃圾回收机制处理掉？</h3><ol>
<li>引用计数法</li>
</ol>
<ul>
<li>原理<br>假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器-1，如果对象A的计数器的值为0，说明A没有引用，可以被回收。</li>
<li>特点<br>无法解决循环引用问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">abc_test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        </span><br><span class="line">        MyObject object1=<span class="keyword">new</span> <span class="title class_">MyObject</span>();	<span class="comment">// object1 引用计数 1</span></span><br><span class="line">        MyObject object2=<span class="keyword">new</span> <span class="title class_">MyObject</span>();	<span class="comment">// object2 引用计数 1</span></span><br><span class="line">        </span><br><span class="line">        object1.object=object2;						<span class="comment">// object1 引用计数 2</span></span><br><span class="line">        object2.object=object1;						<span class="comment">// object2 引用计数 2</span></span><br><span class="line">        </span><br><span class="line">        object1=<span class="literal">null</span>;										<span class="comment">// object1 引用计数 1 ，无法回收</span></span><br><span class="line">        object2=<span class="literal">null</span>;										<span class="comment">// object2 引用计数 1 ，无法回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>可达性分析算法<br>可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC Root开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，可达的对象都是存活的。当所有的引用节点寻找完毕之后，剩余的不可达节点则被认为是没有被引用到的节点，即无用的节点（GC Root 不可达对象），无用的节点将会被判定为是可回收的对象。<br>在Java语言中，可作为GC Roots的对象包括下面几种：</li>
</ol>
<ul>
<li>虚拟机栈中引用的对象（栈帧中的本地变量表）</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（Native方法）引用的对象<br><img src="https://mark.cuckooing.cn/pics/pic_74470a99.png" alt="pic_74470a99.png"></li>
</ul>
<ol>
<li>finalize —— 对象死亡（被回收）前的最后一次挣扎&#x2F;自救计划<br>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。<br>第一次标记：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记；<br>第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。即：当对象没有被覆盖finalize()或者finalize()方法已经被虚拟机调用过了，虚拟机将这两种情况都是为没有必要执行。<br>第二次标记：当一个对象被判断为有必要执行finalize()方法，那么这个对象会被放置到F-Queue队列中，并且稍后JVM自动建立一个低优先级的Finalizer线程执行它，这里“执行”是虚拟机会触发这个方法，但不会承诺等待它运行结束（万一这个方法运行缓慢或者死循环，F-Queue队列其他对象岂不是永久等待）。finalize()是对象逃脱死亡的最后一次机会。稍后GC会对F-Queue进行第二次小规模标记。如果对象能在finalize()方法中重新与引用链上任何一个方法建立关联（例如把自己this关键字赋值给某个类变量或者对象的成员变量）。那么第二次标记时，将会移出即将回收的集合。否则，这个对象就会被回收了。</li>
</ol>
<h3 id="说说Java种的4种引用以及用法？"><a href="#说说Java种的4种引用以及用法？" class="headerlink" title="说说Java种的4种引用以及用法？"></a>说说Java种的4种引用以及用法？</h3><ol>
<li>强引用<br>被强引用关联的对象不会被垃圾回收器回收。使用 new 一个新对象的方式来创建强引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<ol>
<li>软引用<br>用来描述一些还有用但并非必须的对象。被软引用关联的对象只有在内存不够的情况下才会被回收。使用 SoftReference 类来创建软引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<ol>
<li>弱引用<br>用来描述无用对象的，被弱引用关联的对象只要被垃圾回收器扫描到，无论内存是否足够，就一定会回收，即被弱引用关联的对象只能生存到下一次垃圾收集发生之前。使用 WeakReference 类来创建弱引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>虚引用<br>也叫幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的唯一作用是能在这个对象被收集器回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj, <span class="literal">null</span>);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="GC回收算法有哪些？优缺点？"><a href="#GC回收算法有哪些？优缺点？" class="headerlink" title="GC回收算法有哪些？优缺点？"></a>GC回收算法有哪些？优缺点？</h3><ol>
<li>标记清除法</li>
</ol>
<ul>
<li>原理<br>标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除。<br>标记：从根节点开始标记引用的对象。清除：未被标记引用的对象是垃圾对象，可以被清理。<br><img src="https://mark.cuckooing.cn/pics/pic_9df3a0da.png" alt="pic_9df3a0da.png"><br>图一代表的是程序运行期间所有对象的状态，它们的标志位全部是0（即未标记，默认0是未标记，1为已标记），假设当前有效内存空间耗尽了，JVM将会停止应用程序的运行并开启GC线程，然后开始进行标记工作，按照根搜索算法，标记完以后，对象状态如图二。<br><img src="https://mark.cuckooing.cn/pics/pic_6ee87b45.png" alt="pic_6ee87b45.png"><br>图二可以看出，根据跟搜索算法，所有从root对象可达的对象都被标记为存活的对象。此时已完成了第一阶段的标记。接下来要执行第二阶段的清除，清除完后，剩下的对象及对象的状态如图三。<br><img src="https://mark.cuckooing.cn/pics/pic_ef6e711b.png" alt="pic_ef6e711b.png"><br>图三可以看出，没有被标记的对象将会回收清除掉，而被标记的对象将会留下，并且会将标记位重新归0。接下来唤醒停止的程序线程，让程序继续运行。</li>
</ul>
<blockquote>
<p>若有效内存空间耗尽，JVM会停止应用程序的运行并开启GC线程，再开始标记清除<br>防止产生新对象，新引用关系。导致标记时遍历所有对象时结果不准确（使存活对象也被垃圾回收）<br><img src="https://mark.cuckooing.cn/pics/pic_f794ebcc.png" alt="pic_f794ebcc.png"></p>
</blockquote>
<ul>
<li>特点<br>标记清除算法解决了循环引用问题（没有从root节点引用的对象都会被回收）<br>但通过清除算法清理出来的内存，碎片化较为严重。因为被回收的对象可能存在于内存的各个角落，所以清理后的空闲内存不连贯。</li>
</ul>
<ol>
<li>标记压缩法</li>
</ol>
<ul>
<li>原理<br>标记压缩算法是标记清除算法的基础上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标记对象，而是将存活的对象压缩到内存的一段，然后清理边界以外的垃圾，从而解决了碎片化的问题。<br><img src="https://mark.cuckooing.cn/pics/pic_1af6a9cb.png" alt="pic_1af6a9cb.png"></li>
<li>特点<br>解决了标记清除算法的碎片化问题。<br>但是标记压缩算法多了一步，对象移动内存位置的步骤，其效率有一定影响。</li>
</ul>
<ol>
<li>复制算法</li>
</ol>
<ul>
<li>原理<br>复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。<br>如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方法并且效率较高，反之，则不适合。<br><img src="https://mark.cuckooing.cn/pics/pic_4b8b2017.png" alt="pic_4b8b2017.png"></li>
<li>特点<br>适用于垃圾对象较多的情况，且清理后，内存无碎片。但不适用于垃圾对象少的情况（如老年代内存），且分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低。</li>
</ul>
<ol>
<li>分代算法<br>分代算法根据回收对象的特点进行选择，在jvm中，年轻代适合使用复制算法，老年代适合使用标记清除&#x2F;压缩算法。</li>
</ol>
<h3 id="GC回收机制？"><a href="#GC回收机制？" class="headerlink" title="GC回收机制？"></a>GC回收机制？</h3><p>（1）Java垃圾回收<br>程序的运行必然需要申请内存资源，无效的对象资源如果不及时处理就会一直占有内存资源，最终导致内存溢出。为了让程序员更专注于代码的实现，而不用过多考虑内存释放的问题（内存的释放由系统自动识别完成）。Java语言中有了自动的垃圾回收机制，即GC回收机制。<br>（2）JVM堆内存结构（分代模型）<br>（2.1）jdk1.7 堆内存模型<br><img src="https://mark.cuckooing.cn/pics/pic_3d08b55a.png" alt="pic_3d08b55a.png"></p>
<ul>
<li>Young 年轻代<br>年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个（Survivor_From）是被使用的，另一个（Survivor_To）留作垃圾收集时赋值对象使用。几乎所有新生成的对象首先是放在Eden区间。</li>
<li>Tenured 老年代<br>Tenured区主要保存生命周期长的对象，一般是一些存活时间长的对象（如较大的对象直接分配老年代），或当一些对象在Young区复制转移一定的次数以后，对象就会被转移到Tenured区。因此老年代对象存活时间比较长，存活率高。</li>
<li>Perm 永久代<br>Perm代主要保存class,method,field对象。</li>
</ul>
<p>（2.2）jdk1.8 堆内存模型<br><img src="https://mark.cuckooing.cn/pics/pic_ec1d6cdc.png" alt="pic_ec1d6cdc.png"><br>由上图可以看出，jdk 1.8 的内存模型由2部分组成，年轻代+老年代。<br>年轻代：Eden + 2*Survivor<br>年老代：Old<br>在jdk 1.8 中变化最大的Perm区，用Metaspace（元数据空间）进行了替换。其中，Metaspace所占用的内存空间不是在虚拟机内部，而是在本地内存空间中。（防止由于永久代内存经常不够用或发生内存泄露，改用本地内存空间）<br>（3）GC回收算法（分代算法）<br>分代收集，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，可以将不同生命周期的对象分代，不同的代采取不同的回收算法进行垃圾回收（GC），以便提高回收效率。</p>
<ul>
<li>Young 年轻代（复制算法）<br>由于年轻代垃圾对象较多，复制的对象较少，因此复制算法效率较高。年轻代划分为一块较大的Eden区和两块较小的Survivor区（Survivor_From、Survivor_To）</li>
</ul>
<ol>
<li>几乎所有新生成的对象首先是放在Eden区间。当Eden区间内存不足时，会发起一次GC。</li>
<li>在GC开始的时候，对象只会存在于Eden区和Survivor_From区，Survivor_To区是空的。</li>
<li>紧接着进行GC，Eden区所有存活对象都会复制到Survivor_To区，Survivor_From区中仍存活的对象根据他们的年龄决定去向，若年龄达到年龄阀值（MaxTenuringThreshold）的对象会移动到老年代，没有到达阀值的对象会复制到Survivor_To区。</li>
<li>清空Eden区和Survivor_From区。然后交换Survivor_To与Survivor_From区。使存活的对象均位于Survivor_From区域，Survivor_To区为空。</li>
<li>GC会一直重复上述过程，直到Survivor_To区被填满（Survivor_To区不足以存放Eden与Survivor_From区中存活的对象时），此时所有存活的对象移动到老年代。<br><img src="https://mark.cuckooing.cn/pics/pic_03cb5ade.png" alt="pic_03cb5ade.png"></li>
</ol>
<ul>
<li>Tenured 老年代（标记-清除&#x2F;压缩法）<br>由于老年代垃圾对象较少（对象存活率较高），因此适合使用标记-清除&#x2F;压缩法。<br>当老年代内存满时触发GC。</li>
</ul>
<h3 id="GC是什么时候触发的？"><a href="#GC是什么时候触发的？" class="headerlink" title="GC是什么时候触发的？"></a>GC是什么时候触发的？</h3><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Minor GC和Full GC。</p>
<ol>
<li>Minor GC<br>这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为年轻代对象存活时间很短，所以Minor GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。<br>触发条件：<br>一般情况下，当新对象生成，会在年轻代Eden上分配，若Eden区域已满，申请空间失败时，就会触发Minor GC：对Eden区域进行GC，在回收时，将 Eden 和 Survivor_From 中还存活着的对象全部复制到 Survivor_To 上，然后清理 Eden 和 Survivor_From，最后将Survivor_To中对象移动到 Survivor_From。</li>
<li>Full GC<br>对整个堆进行整理，包括回收年轻代、老年代和持久代。Full GC因为需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数。<br>触发条件：</li>
</ol>
<ul>
<li>年老代（Tenured）被写满；</li>
<li>持久代（Perm）被写满；</li>
<li>System.gc()被显示调用；</li>
<li>上一次GC之后Heap的各域分配策略动态变化；</li>
</ul>
<h3 id="垃圾收集器？"><a href="#垃圾收集器？" class="headerlink" title="垃圾收集器？"></a>垃圾收集器？</h3><p>[深入理解Java 垃圾收集器][Java]<br><img src="https://mark.cuckooing.cn/pics/pic_a6225384.png" alt="pic_a6225384.png"><br>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
<li>Serial 垃圾收集器<br>串行垃圾收集器，是指使用单线程进行垃圾回收。垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停，等待垃圾回收的完成。这种现象称之为STW（Stop-The-World）<br>对于交互性交强的应用而言，这种垃圾收集器是不能够接受的。一般在javaweb应用中是不会采用该收集器的。在G1的FULL GC采用Serial GC进行回收。<br>在程序运行参数中（VM options）添加-XX:+UseSerialGC 设置年轻代和老年代都使用串行垃圾收集器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置堆的初始和最大内存为16M</span></span><br><span class="line">-XX:+UseSerialGC -XX:+PrintGCDetails -Xms16m -Xmx16m</span><br></pre></td></tr></table></figure>

<p><img src="https://mark.cuckooing.cn/pics/pic_6ad55296.png" alt="pic_6ad55296.png"></p>
<ul>
<li>Parallel 垃圾收集器<br>并行垃圾收集器在串行垃圾收集器的基础上做了改进，将单线程改为了多线程进行垃圾回收，这样可以缩短垃圾回收的时间。并行垃圾收集器在收集的过程中也会暂停应用程序，与串行垃圾收集器是一样的，只是并行执行，速度更快，暂停时间更短。分为：</li>
<li>ParNew 垃圾收集器<br>ParNew收集器是工作在年轻代上的，只是将串行的垃圾收集器改为了并行。ParNew GC可以与CMS GC合作使用<br>在程序运行参数中（VM options）添加-XX:+UseParNewGC 设置年轻代使用ParNew回收器，老年代仍使用串行收集器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParNewGC -XX:+PrintGCDetails -Xms16m -Xmx16m</span><br></pre></td></tr></table></figure>

<p><img src="https://mark.cuckooing.cn/pics/pic_bc747b8a.png" alt="pic_bc747b8a.png"></p>
<ul>
<li>ParallelGC 垃圾收集器<br>ParallelGC收集器工作机制和ParNewGC收集器一样，不同在于新增了可以对老年代进行多线程垃圾回收，且增加了对吞吐量（&#x3D;运行用户代码时间 &#x2F; CPU总消耗时间（运行用户代码时间+垃圾收集时间））的控制。<br>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。<br>相关参数如下：<br>-XX:+UseParallelGC：年轻代使用ParallelGC垃圾回收器，老年代使用串行回收器<br>-XX:+UseParallelOldGC：年轻代使用ParallelGC垃圾回收器，老年代使用ParallelOldGC回收器<br>-XX:+MaxGCPauseMillis：设置最大的垃圾收集时的停顿时间，单位为毫秒（可能会调整堆的相关参数，对性能有影响，慎用）<br>-XX:+GCTimeRatio：设置垃圾回收时间占程序运行时间大的百分比<br>-XX:+UseAdaptiveSizePolicy：自适应GC模式，垃圾回收器将自动调整新生代，老年代等参数，达到吞吐量、堆大小、停顿时间的平衡。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC -XX:+UseParallelOldGC -XX:+MaxGCPauseMillis=<span class="number">100</span> -XX:+PrintGCDetails -Xms16m -Xmx16m</span><br></pre></td></tr></table></figure>

<p>此时年轻代和老年代都使用了ParallelGC垃圾回收器<br><img src="https://mark.cuckooing.cn/pics/pic_490682df.png" alt="pic_490682df.png"></p>
<ul>
<li>CMS 收集器<br>CMS全称Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，通过参数-XX:+UseConcMarkSweepGC进行设置。<br>CMS是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。<br>CMS垃圾回收器的执行过程如下：<br><img src="https://mark.cuckooing.cn/pics/pic_68cb34f0.png" alt="pic_68cb34f0.png"><br>（1）初始化标记 CMS Initial mark：会导致stw，标记一下GC Roots能直接关联到的对象，速度很快。<br>（2）并发标记 CMS-concurrent-mark：与用户线程同时运行，进行GC Roots Tracing的过程。<br>（3）预清理 CMS-concurrent-preclean：与用户线程同时运行，用于修正并发标记。<br>（4）重新标记 CMS Final Remark：会导致stw，重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象（产生新的&#x2F;释放旧的 对象或引用关系）的标记几率（这个阶段的停顿时间一般会比初始标记阶段稍长，但远比并发标记时间短）。<br>（5）并发清除 CMS-concurrent-sweep：与用户线程同时运行，清除标记对象（采用标记-清除）。<br>（6）调整堆大小，设置CMS在清理之后进行内存压缩，目的是清理内存中的碎片。<br>（7）并发重置状态 CMS-concurrent-reset：与用户线程同时运行，等待下次CMS的触发。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -Xms16m -Xmx16m</span><br></pre></td></tr></table></figure>

<p>年轻代默认使用ParNew收集器，老年代使用CMS收集器。</p>
<ul>
<li>G1 收集器（重要）<br>G1垃圾收集器是在jdk1.7中正式使用的全新的垃圾收集器，是一种面向服务端应用的垃圾收集器。oracle官方计划在jdk9中将G1编程默认的收集器，以代替CMS。<br>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步便可完成调优：<br>第一步：开启G1垃圾收集器<br>第二步：设置堆的最大内存<br>第三步：设置最大停顿时间<br>设置以下参数开启G1垃圾收集器并设置GC最大暂停时间为200ms</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=<span class="number">200</span> -XX:+PrintGCDetails -Xms16m -Xmx16m</span><br></pre></td></tr></table></figure>

<p>G1垃圾收集器的原理是：<br>相比其他收集器而言，最大的区别在于G1垃圾收集器取消了年轻代、老年代的物理划分，取而代之将堆划分为若干个区域（Regin），这些区域包含了有逻辑上的年轻代、老年代区域。<br>每个区域被标记了Eden、Survivor、Old和Humongous，在运行时充当相应的角色。H代表Humongous，用于存放占用空间超过分区容量50%以上的大对象。<br>每个Regin都有一个RememberSet，用来记录该Regin对象的引用对象所在Regin。通过使用Remember Set，在做可达性分析时可以避免全堆扫描。<br>G1取消了新生代、老年代物理空间的划分。这样我们再也不用单独地对每个代的空间进行设置，也不用担心每个代地内存是否足够。<br><img src="https://mark.cuckooing.cn/pics/pic_dcfc1a70.png" alt="pic_dcfc1a70.png"><br>G1垃圾收集器提供三种垃圾回收模式：</p>
<ul>
<li>Young GC<br>发生在年轻代的GC算法，一般对象（除了巨型对象）都是在Eden Region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次Young GC，采用复制算法，执行完一次Young GC，存活对象会被拷贝到Survivor Region或者晋升到Old Region中。</li>
<li>Mixed GC<br>当越来越多地对象晋升到老年代Old Regin时候，为了避免堆内存被耗尽，虚拟机会触发一个混合垃圾回收器，即Mixed GC。该算法除了回收整个Young Regin，还会回收一部分Old Regin。<br>Mixed GC触发通过设置参数XX:InitiatingHeapOccupancyPercent触发执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当老年代大小占整个堆大小百分比达到 80% 时，触发一次mixed gc</span></span><br><span class="line">-XX:InitiatingHeapOccupancyPercent = <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>Mixed GC执行过程分为以下几个步骤：<br>（1）初始标记 initial mark：STW，标记GC Roots直接关联对象<br>（2）并发标记 concurrent marking：与应用程序并发执行，在整个堆中查找从初始标记衍生出的存活对象<br>（3）最终标记 Remark：STW，修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录<br>（4）清除垃圾 Cleanup：STW，采用复制算法进行垃圾回收，将一部分Regin里的存活对象复制到另一部分Regin中。<br><img src="https://mark.cuckooing.cn/pics/pic_cd0fef39.png" alt="pic_cd0fef39.png"></p>
<ul>
<li>Full GC<br>如果对象内存分配速度过快，Mixed Gc来不及回收，导致老年代被填满，就会触发一次Full GC，G1的Full GC算法就是单线程执行的Serial GC，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免Full GC</li>
</ul>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期?"></a>对象的生命周期?</h3><ul>
<li>创建阶段(Created)<br>在创建阶段系统通过下面的几个步骤来完成对象的创建过程：<br>（1）为对象分配存储空间<br>（2）开始构造对象<br>（3）从超类到子类对static成员进行初始化<br>（4）超累成员变量按顺序初始化，递归调用超累的构造方法<br>（5）子类成员变量按顺序初始化，子类构造方法调用<br>一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到应用状态</li>
<li>应用阶段(In Use)<br>对象至少被一个强引用持有。</li>
<li>不可见阶段(Invisible)<br>当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。<br>简单说就是程序的执行已经超出了该对象的作用域了。</li>
<li>不可达阶段(Unreachable)<br>对象处于不可达阶段是指该对象不再被任何强引用所持有。<br>与“不可见阶段”相比，“不可见阶段”是指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。</li>
<li>收集阶段(Collected)<br>当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。</li>
<li>终结阶段(Finalized)<br>当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</li>
<li>对象空间重分配阶段(De-allocated)<br>垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</li>
</ul>
<h3 id="谈谈static关键字-谈谈static编译运行时的流程，在虚拟机中如何保存的？"><a href="#谈谈static关键字-谈谈static编译运行时的流程，在虚拟机中如何保存的？" class="headerlink" title="谈谈static关键字&#x2F;谈谈static编译运行时的流程，在虚拟机中如何保存的？"></a>谈谈static关键字&#x2F;谈谈static编译运行时的流程，在虚拟机中如何保存的？</h3><ol>
<li>static 关键字<br>被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类名直接访问静态变量/方法</span></span><br><span class="line">ClassName.propertyName</span><br><span class="line">ClassName.methodName(……)</span><br></pre></td></tr></table></figure>

<p>static方法<br>static方法一般称作静态方法，静态方法不依赖于任何对象就可以进行访问。因此静态方法不使用this，且在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为静态方法独立于任何对象实例，非静态成员方法&#x2F;变量都是必须依赖具体的对象才能够被调用，因此：<br>（1）静态方法仅能调用其他static方法<br>（2）静态方法仅能访问static数据<br>（3）静态方法不能引用this或super<br>static变量<br>静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，可以直接通过类名来访问它，同时类所有的实例都共享静态变量，所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。</p>
<ol>
<li>static 在内存中存储方式<br>Java把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象实例。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置（方法区：存放class被加载后的类信息、常量、静态变量等）开辟一个固定大小的内存区域（只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们），有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。</li>
</ol>
<table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>存放位置</th> 
   <th>生命周期</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>实例变量/方法</td> 
   <td>随着对象的创建存放于堆内存中</td> 
   <td>随对象的消失而消失</td> 
  </tr> 
  <tr> 
   <td>静态（类）变量/方法</td> 
   <td>随着类的加载存放于方法区</td> 
   <td>生命周期最长，随类的消失而消失</td> 
  </tr> 
 </tbody> 
</table>



<h1 id="第六章-Java容器类"><a href="#第六章-Java容器类" class="headerlink" title="第六章 Java容器类"></a>第六章 Java容器类</h1><ul>
<li>Java 集合框架</li>
<li><ul>
<li>Java 集合类继承关系</li>
<li>Java 集合类简介</li>
<li><ul>
<li>Collection （Interface）</li>
<li>Map （Interface）</li>
</ul>
</li>
</ul>
</li>
<li>HashMap</li>
<li><ul>
<li>存储结构</li>
<li>工作原理</li>
<li>源码解析</li>
<li>HashMap、HashSet、HashTable区别</li>
<li>面试</li>
</ul>
</li>
<li>List</li>
<li><ul>
<li>ArrayList</li>
<li>LinkedList</li>
</ul>
</li>
<li>红黑树</li>
<li>谈谈Java集合中那些线程安全的集合 &amp; 实现原理？</li>
</ul>
<h2 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h2><h3 id="Java-集合类继承关系"><a href="#Java-集合类继承关系" class="headerlink" title="Java 集合类继承关系"></a>Java 集合类继承关系</h3><p><img src="https://mark.cuckooing.cn/pics/pic_a0059b65.png" alt="pic_a0059b65.png"></p>
<h3 id="Java-集合类简介"><a href="#Java-集合类简介" class="headerlink" title="Java 集合类简介"></a>Java 集合类简介</h3><h4 id="Collection-（Interface）"><a href="#Collection-（Interface）" class="headerlink" title="Collection （Interface）"></a>Collection （Interface）</h4><p>Collection是最基本的集合接口，存储对象元素集合。一个Collection代表一组Object（元素）。<br>适用Iterator迭代器遍历集合元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Day&gt; days = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Day&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="type">Day</span> <span class="variable">day</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Day</span>(i,i*<span class="number">60</span>,i*<span class="number">3600</span>);</span><br><span class="line">            days.add(day);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取days集合的迭代器</span></span><br><span class="line">        Iterator&lt;Day&gt; iterator = days.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//判断是否有下一个元素</span></span><br><span class="line">            <span class="type">Day</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();<span class="comment">//取出该元素</span></span><br><span class="line">            <span class="comment">//逐个遍历，取得元素后进行后续操作</span></span><br><span class="line">            .....</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>List （Interface）<br>List是一个允许重复元素的指定索引、有序集合。集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。List集合默认按元素的添加顺序设置元素的索引，例如第一个添加的元素索引为0，第二个添加的元素索引为1…<br>从List接口的方法来看，List接口增加了面向位置的操作，允许在指定位置上插入&#x2F;访问元素。</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>List实现</th> 
   <th>数据特点</th> 
   <th>使用场景</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>ArrayList</td> 
   <td>实现了List接口的动态大小的数组</td> 
   <td>查找元素</td> 
  </tr> 
  <tr> 
   <td>LinkedSet</td> 
   <td>实现了List接口的链表维护的序列容器（双向链表）</td> 
   <td>插入/删除元素</td> 
  </tr> 
 </tbody> 
</table>

<ul>
<li>Set （Interface）<br>Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)&#x3D;false，Set最多有一个null元素。<br>如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add()方法返回false，且新元素不会被加入。</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>Set实现</th> 
   <th>数据特点</th> 
   <th>数据结构</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>HashSet</td> 
   <td>无序的、无重复的数据集合</td> 
   <td>基于HashMap（使用HashMap的key作为单个元素存储）</td> 
  </tr> 
  <tr> 
   <td>LinkedSet</td> 
   <td>维护次序的HashSet</td> 
   <td>基于LinkedHashMap</td> 
  </tr> 
  <tr> 
   <td>TreeSet</td> 
   <td>保持元素大小次序的集合，元素需要实现Comparable接口</td> 
   <td>基于TreeMap</td> 
  </tr> 
 </tbody> 
</table>

<ul>
<li>Set&#x2F;HashSet如何确保它的唯一性？<br>[Object.equals() &amp; Object.hashcode()][Object.equals_ _ Object.hashcode]<br>向Set中添加元素时需先判断是否有相同key的元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;... &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先判断set集合中是否有与新添加数据hashcode值一致的元素</li>
<li>如果有hashcode相同的元素，再调用equals方法进一步判断（若集合中没有与新添加数据hashcode值一致的元素，则不调用equals方法）</li>
</ol>
<p>因此，在Java运行时环境判断HashSet和HastMap中的两个对象相同或不同应该先判断hashcode是否相等，再判断是否equals。 只有两者均相同，才能保证对象的一致性。<br>为了保证HashSet中的对象不会出现重复值，在被存放元素的类中必须要重写hashCode()和equals()这两个方法。</p>
<blockquote>
<p>重写规范</p>
<ol>
<li>如果两个对象相同，那么他们的hashcode应该相等</li>
<li>如果两个对象不相同，他们的hashcode可能相同</li>
</ol>
</blockquote>
<ul>
<li>Queue （Interface）<br>Queue用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>Queue实现</th> 
   <th>数据特点</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>Deque（Interface）</td> 
   <td>扩展自Queue的双端队列，它支持在两端插入和删除元素，LinkedList实现Deque接口</td> 
  </tr> 
  <tr> 
   <td>PriorityQueue</td> 
   <td>一个基于优先级堆的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序</td> 
  </tr> 
 </tbody> 
</table>

<h4 id="Map-（Interface）"><a href="#Map-（Interface）" class="headerlink" title="Map （Interface）"></a>Map （Interface）</h4><p>Map是图接口，存储键值对映射的容器类。Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。</p>
<table> 
 <thead> 
  <tr> 
   <th>Map实现</th> 
   <th>使用场景</th> 
   <th>数据结构</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>HashMap</td> 
   <td>哈希表存储键值对,key不重复，无序</td> 
   <td>哈希散列表</td> 
  </tr> 
  <tr> 
   <td>LinkedHashMap</td> 
   <td>可以记录插入顺序的HashMap</td> 
   <td>Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序</td> 
  </tr> 
  <tr> 
   <td>TreeMap</td> 
   <td>具有元素排序功能的HashMap，即保持key的大小顺序</td> 
   <td>红黑树（中序遍历迭代输出有序序列）</td> 
  </tr> 
  <tr> 
   <td>WeakHashMap</td> 
   <td>弱键映射，映射之外无引用的键，可被垃圾回收</td> 
   <td>哈希散列表</td> 
  </tr> 
 </tbody> 
</table>

<ul>
<li>Map的遍历方式<br>Map集合提供3种遍历访问方法，</li>
</ul>
<ol>
<li>Set keySet() 获得所有key的集合然后通过key访问value</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; keySet = map.keySet();	<span class="comment">//先获取map集合的所有键的Set集合</span></span><br><span class="line">Iterator&lt;String&gt; it = keySet.iterator();	<span class="comment">//有了Set集合，就可以获取其迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> it.next();					<span class="comment">// 获取键值</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);		<span class="comment">// 有了键可以通过map集合的get方法获取其对应的值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>Collection values() 获得value的集合</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; collection = map.values();<span class="comment">//返回值是 值的Collection集合</span></span><br></pre></td></tr></table></figure>

<ol>
<li>Set&lt; Map.Entry&lt; K, V&gt;&gt; entrySet() 获得key-value键值对的集合</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过entrySet()方法将map集合中的映射关系取出（这个关系就是Map.Entry类型）</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="comment">//将关系集合entrySet进行迭代，存放到迭代器中                </span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = entrySet.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">       Map.Entry&lt;String, String&gt; me = it.next();<span class="comment">//获取Map.Entry关系对象me</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> me.getKey();<span class="comment">//通过关系对象获取key</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> me.getValue();<span class="comment">//通过关系对象获取value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Entry&lt;K,V&gt;为Map&lt;K,V&gt;的一个内部接口，其实每一个键值对都是一个Entry的实例关系对象，所以Map实际其实就是Entry的一个Collection。</p>
</blockquote>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap就是最基础最常用的一种Map，它无序，以散列表（数组+链表&#x2F;红黑树）的方式进行存储，存储内容是键值对映射。是一种非同步的容器类，故它的线程不安全。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul>
<li>内部原理<br>HashMap采用散列表（哈希表）存储。即由数组和单向链表共同完成，当链表长度超过8个时会转化为红黑树（实现查找时间复杂度O(logn)）<br>哈希表是通过哈希函数把特定的键值映射到表中一个位置来访问记录的数据结构，哈希函数用来维护键与值之间一一对应关系。<br>它的特点是查询快，时间复杂度是O(1)，插入和删除的操作比较慢，时间复杂度是O(n)</li>
<li>内部实现<br>内部包含了一个 Entry 类型的数组 table。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure>

<p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mark.cuckooing.cn/pics/pic_c5738fce.png" alt="pic_c5738fce.png"></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li>确认桶下标——计算hash &amp; 取模</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算hash值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line"><span class="comment">// 将 key 的 hash 值对桶个数取模：hash%capacity 得到下标</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line"><span class="comment">/* indexFor的实现：</span></span><br><span class="line"><span class="comment">   如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</span></span><br><span class="line"><span class="comment">   static int indexFor(int h, int length) &#123;</span></span><br><span class="line"><span class="comment">      return h &amp; (length-1);</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>HashMap中hash函数的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>高16bit不变，低16bit和高16bit做了一个异或。<br><img src="https://mark.cuckooing.cn/pics/pic_5a634072.png" alt="pic_5a634072.png"><br>主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p>
<blockquote>
<p>哈希函数的设计：保证将关键字均匀地分配到每个桶中<br>（1）计算结果为int类型<br>（2）数组长度范围内（0~length-1）<br>（3）尽可能充分利用数组中每一个位置</p>
<ul>
<li>除留余数法：用一个特定的质数来除所给定的关键字，所得余数即为该关键字的哈希值</li>
</ul>
</blockquote>
<ol>
<li>冲突处理——拉链法</li>
</ol>
<p>（1）查找</p>
<ul>
<li>计算键值对所在的桶下标</li>
<li>在链表上顺序查找，时间复杂度与链表长度成正比</li>
</ul>
<p>（2）插入</p>
<ul>
<li>采用链表头插法，也就是新的键值对插在链表的头部</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>哈希表冲突处理方法：</p>
<ul>
<li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）：发生哈希冲突，寻找另一个未被占用的数组地址；</li>
<li>链地址法（HashMap）：将新节点添加到对应哈希值所在链表链尾；</li>
<li>再哈希法：提供多个哈希函数，直到不再产生冲突；</li>
<li>建立公共溢出区：将哈希表分为基本表和溢出表，产生哈希冲突的节点放入移除表。</li>
</ul>
</blockquote>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><ul>
<li>put 解析</li>
</ul>
<ol>
<li>如果HashMap为空，则进行初始化；</li>
<li>调用哈希函数对Key求Hash值，然后再计算下标。并查找所在链表。</li>
<li>如果链表长度超过阈值（TREEIFY_THRESHOLD &#x3D;&#x3D; 8),就把链表转换成红黑树。</li>
<li>如果结点的键已经存在就替换旧值。否则用头插法插入新结点。</li>
<li>如果桶满了（容量+加载因子），就需要resize（双倍扩容，保证2的n次幂）进行扩容，并且为了使结点均匀分散，应该重新分配结点位置<br>if(++size&gt;threshold)resize();</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 1. HashMap 为空，则进行初始化</span></span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 2. 调用哈希函数对key求hash值，并取模得桶下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 3. 先找出是否已经存在键为 key 的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 注：散列类容器唯一性判断</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 4. 插入新键值对（如果碰撞了则头插法，没有碰撞则直接插在）</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</span></span><br><span class="line"><span class="comment">private V putForNullKey(V value) &#123;</span></span><br><span class="line"><span class="comment">    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</span></span><br><span class="line"><span class="comment">        if (e.key == null) &#123;</span></span><br><span class="line"><span class="comment">            V oldValue = e.value;</span></span><br><span class="line"><span class="comment">            e.value = value;</span></span><br><span class="line"><span class="comment">            e.recordAccess(this);</span></span><br><span class="line"><span class="comment">            return oldValue;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    modCount++;</span></span><br><span class="line"><span class="comment">    addEntry(0, null, value, 0);</span></span><br><span class="line"><span class="comment">    return null;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>get 解析</li>
</ul>
<ol>
<li>调用哈希函数对Key求Hash值，然后再计算Entry数组的索引i。</li>
<li>遍历table[i]为头结点的链表&#x2F;红黑树，如果发现有节点hash,key都相同的节点，则取出该节点的值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// bucket里的第一个节点，直接命中；</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 未命中（有冲突），则查找对应的entry</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// 若为树，则在树中查找对应Entry，O(logn)</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 若为链表，则在链表中查找对应Entry，O(n)</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>resize 解析（扩容+重新分配）<br>当put时，如果发现目前的bucket占用程度已经超过了Load Factor（负载因子）所希望的比例，那么就会发生resize。</li>
</ul>
<ol>
<li>将新结点加到链表后</li>
<li>bucket容量扩充为原来的两倍，然后对每个结点重新计算哈希值</li>
<li>这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要扩容时，令 capacity 为原来的两倍</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中（对每个结点重新计算hash值）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            src[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap、HashSet、HashTable区别"><a href="#HashMap、HashSet、HashTable区别" class="headerlink" title="HashMap、HashSet、HashTable区别"></a>HashMap、HashSet、HashTable区别</h3><table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>HashTable</th> 
   <th>HashMap</th> 
   <th>HashSet</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>接口</td> 
   <td>Map</td> 
   <td>Map</td> 
   <td>Set</td> 
  </tr> 
  <tr> 
   <td>存储类型</td> 
   <td>键值对</td> 
   <td>键值对</td> 
   <td>元素（HashSet的集合其实就是HashMap的key的集合）</td> 
  </tr> 
  <tr> 
   <td>线程安全</td> 
   <td>同步（synchronized）</td> 
   <td>不同步</td> 
   <td>不同步</td> 
  </tr> 
  <tr> 
   <td>是否可以插入NULL</td> 
   <td>不可以</td> 
   <td>可以</td> 
   <td>可以</td> 
  </tr> 
 </tbody> 
</table>

<h3 id="面试-1"><a href="#面试-1" class="headerlink" title="面试"></a>面试</h3><ol>
<li>什么时候会使用HashMap？他有什么特点？<br>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</li>
<li>你知道HashMap的工作原理吗？<br>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K&#x2F;V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</li>
<li>你知道get和put的原理吗？equals()和hashCode()的都有什么作用？<br>通过对key的hashCode()进行hashing，并计算下标( (n-1) &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</li>
<li>你知道hash的实现吗？为什么要这样实现？<br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h &#x3D; k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</li>
<li>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？<br>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</li>
</ol>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。<br>按数组下标访问元素—get(i)&#x2F;set(i,e) 的性能很高，这是数组的基本优势。<br>直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。</p>
<ul>
<li>ArrayList “动态数组” 扩容机制<br>ArrayList是基于数组实现的，添加元素时若数组的容量不够，ArrayList会自动扩容：</li>
</ul>
<ol>
<li>添加元素前判断数组容量是否足够，若不够，则先扩容</li>
<li>每次扩容都是按原容量的1.5倍进行扩容（新数组容量 &#x3D; 原数组容量*1.5 + 1）</li>
<li>原数组通过Arrays.copyOf()将原数据元素拷贝到心数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       <span class="comment">// 判断原数组容量是否足够，若不够</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">// 新数组长度为原数组1.5倍扩容</span></span><br><span class="line">     	elementData = Arrays.copyOf(elementData, newCapacity);  <span class="comment">//将原数组拷贝一份到新数组</span></span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>add方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在ArrayList中增加元素的时候，会使用add函数。他会将元素放到末尾。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 自动扩容机制的核心</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。</p>
<ul>
<li>set&#x2F;get方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先做index检查，然后执行赋值或访问操作</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>remove方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 把后面的往前移</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 把最后的置null</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>以双向链表（head、tail）实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。<br>按下标访问元素—get(i)&#x2F;set(i,e) 要悲剧的遍历链表将指针移动到位(如果i&gt;数组大小的一半，会从末尾移起)。<br>插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作—add()，addFirst()，removeLast()或用iterator()上的remove()能省掉指针的移动。</p>
<ul>
<li>set&#x2F;get()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数都调用了node函数，该函数会以O(n&#x2F;2)的性能去获取一个节点，具体实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是判断index是在前半区间还是后半区间，如果在前半区间就从head搜索，而在后半区间就从tail搜索。而不是一直从头到尾的搜索。如此设计，将节点访问的复杂度由O(n)变为O(n&#x2F;2)。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ul>
<li>红黑树特点</li>
</ul>
<p>二叉查找树（BST）特性：</p>
<ol>
<li>左子树上节点值均小于等于根节点的值</li>
<li>右子树上节点值均大于等于根节点的值</li>
<li>左右子树均为二叉排序树</li>
</ol>
<p>二叉查找树采用二分查找的思想，查找所需最大次数等同于二叉查找树的高度。<br>红黑树（Red Black Tree）是自平衡（防止高度过高）的二叉查找树，特性：</p>
<ol>
<li>节点是红色或黑色</li>
<li>根节点是黑色</li>
<li>叶子节点是黑色的空节点</li>
<li>每个红色节点的2个子结点都是黑色</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目黑色节点</li>
</ol>
<p><img src="https://mark.cuckooing.cn/pics/pic_6a0c86b7.png" alt="pic_6a0c86b7.png"></p>
<ul>
<li>红黑树操作<br>红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。<br>由于插入新结点后可能会破坏红黑树的规则，此时需要进行调整，包括变色和旋转，旋转包括左旋和右旋。</li>
<li>红黑树后继节点<br>a. 空节点，没有后继<br>b. 有右子树的节点，后继就是右子树的“最左节点”<br>c. 无右子树的节点，后继就是该节点所在左子树的第一个祖先节点<br>有右子树的节点，节点的下一个节点，肯定在右子树中，而右子树中“最左”的那个节点则是右子树中最小的一个，那么当然是右子树的“最左节点”，就好像下图所示：<br><img src="https://mark.cuckooing.cn/pics/pic_b16a0fce.png" alt="pic_b16a0fce.png"><br>无右子树的节点，先找到这个节点所在的左子树(右图)，那么这个节点所在的左子树的父节点(绿色节点)，就是下一个节点。<br><img src="https://mark.cuckooing.cn/pics/pic_66beb657.png" alt="pic_66beb657.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; <span class="title function_">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 有右子树的节点，后继节点就是右子树的“最左节点”</span></span><br><span class="line">        <span class="comment">// 因为“最左子树”是右子树的最小节点</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="literal">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 如果右子树为空，则寻找当前节点所在左子树的第一个祖先节点</span></span><br><span class="line">        <span class="comment">// 因为左子树找完了，根据LDR该D了</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="comment">// 保证左子树</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>红黑树应用<br>红黑树应用很多，其中JDK的集合类TreeMap和TreeSet底层使用红黑树实现，Java8中HashMap也是用红黑树实现。</li>
</ul>
<blockquote>
<p>参考：[漫画算法：什么是红黑树][Link 6]</p>
</blockquote>
<h2 id="谈谈Java集合中那些线程安全的集合-实现原理？"><a href="#谈谈Java集合中那些线程安全的集合-实现原理？" class="headerlink" title="谈谈Java集合中那些线程安全的集合 &amp; 实现原理？"></a>谈谈Java集合中那些线程安全的集合 &amp; 实现原理？</h2><ol>
<li>同步集合类<br>采用synchronized锁机制保证线程安全。<br>包括Hashtable、Vector、同步集合包装类，Collections.synchronizedMap()和Collections.synchronizedList()</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashTable 的 get、put方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>并发集合类<br>同步集合比并发集合会慢得多，主要原因是使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。</li>
</ol>
<ul>
<li>ConcurrentHashMap<br>ConcurrentHashMap通过使用分离锁，只针对某（键的hash值对应的）具体的Segment（而不是整个ConcurrentHashMap。因为插入键值对的操作只在这个Segment包含的桶中完成，因此不需要锁定整个ConcurrentHashMap。此时其他写进程对另外15个Segment加锁并不会因为对当前这个Segment加锁而阻塞。同时所有读线程几乎不会因本线程加锁而阻塞）进行加锁，同时允许多线程访问其他未上锁Segment。<br>相比较于 HashTable 和由同步包装器包装的 HashMap每次只能有一个线程执行读或写操作，ConcurrentHashMap 在并发访问性能上有了质的提高。在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</li>
<li>CopyOnWrite容器（CopyOnWriteArrayList、CopyOnWriteHashSet）<br>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。<br>CopyOnWrite并发容器用于读多写少的并发场景。</li>
</ul>
<h1 id="第八章-泛型"><a href="#第八章-泛型" class="headerlink" title="第八章 泛型"></a>第八章 泛型</h1><ul>
<li>语法糖</li>
<li>什么是泛型？能解决什么问题？</li>
<li>说一下Java泛型工作机制？什么是类型擦除？</li>
<li>泛型的使用</li>
<li>什么是泛型中的限定通配符和非限定通配符？</li>
</ul>
<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家Peter.J.Landin发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。</p>
<p>泛型的目的： Java 泛型就是把一种语法糖，通过泛型使得在编译阶段完成一些类型转换的工作，避免在运行时强制类型转换而出现ClassCastException，即类型转换异常。</p>
<h2 id="什么是泛型？能解决什么问题？"><a href="#什么是泛型？能解决什么问题？" class="headerlink" title="什么是泛型？能解决什么问题？"></a>什么是泛型？能解决什么问题？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// T stands for &quot;Type&quot;</span></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      <span class="built_in">this</span>.t = t; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型的本质是参数化类型，即将所操作数据类型指定为参数。实现数据类型的任意化。</p>
<p>在Java1.5之前（泛型 是JDK5中引入的一个新特性），在集合中存储对象时通过对类型Object的引用实现参数的任意化，需要在使用前进行强制类型转换。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。<br>泛型的好处在于：</p>
<ul>
<li>提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</li>
<li>消除了代码中许多的强制类型转换，增强了代码的可读性。</li>
</ul>
<h2 id="说一下Java泛型工作机制？什么是类型擦除？"><a href="#说一下Java泛型工作机制？什么是类型擦除？" class="headerlink" title="说一下Java泛型工作机制？什么是类型擦除？"></a>说一下Java泛型工作机制？什么是类型擦除？</h2><p>泛型是通过类型擦除来实现的。<br>类型擦除是编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List在运行时仅用一个List来表示。<br>这是因为不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从Java泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。<br>这样做的目的，是确保能和Java 5之前的版本进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> <span class="title class_">List</span>&lt;String&gt;();</span><br><span class="line">    		List&lt;Double&gt; l2 = <span class="keyword">new</span> <span class="title class_">List</span>&lt;Double&gt;();</span><br><span class="line">    		System.out.println(l1.getClass() == l2.getClass());</span><br><span class="line">    		<span class="comment">// 输出 true</span></span><br><span class="line">    		<span class="comment">// 由于类型擦除，l1.getClass() == l2.getClass() == java.util.List</span></span><br></pre></td></tr></table></figure>

<p><img src="https://mark.cuckooing.cn/pics/pic_f669f7f4.png" alt="pic_f669f7f4.png"></p>
<ol>
<li>优点</li>
</ol>
<ul>
<li>向前兼容性好<br>是确保能和Java 5之前的版本进行兼容</li>
<li>减小运行时负担<br>在Java中，是不存在类似List，List等等这样的类型，真正被加载进方法区存储的只有List类型</li>
</ul>
<ol>
<li>缺点</li>
</ol>
<ul>
<li>基本类型无法作为泛型实参</li>
<li>泛型类型无法用做方法重载<br>类型擦除意味着List和List编译后其类型都是List，也就是属于同个方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(List&lt;Integer&gt; array)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(List&lt;Double&gt; array)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;    <span class="comment">// compile error</span></span><br></pre></td></tr></table></figure>

<ul>
<li>泛型类型无法当做真实类型使用<br>由于类型擦除后像List这样的类型是不存在的，所以也就无法直接当成真实类型使用:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">genericMethod</span><span class="params">(T t)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">T</span> <span class="variable">newInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();              <span class="comment">// compile errror</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> T.class;                    <span class="comment">// compile errror</span></span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();    <span class="comment">// compile errror</span></span><br><span class="line">    <span class="keyword">if</span> (list instance List&lt;Integer&gt;) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;   <span class="comment">// compile errror</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这也是Gson.fromJson需要传入Class的原因</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">fromJson</span><span class="params">(String json, Class&lt;T&gt; classOfT)</span> </span><br><span class="line">          <span class="keyword">throws</span> JsonSyntaxException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> fromJson(json, (Type)classOfT);</span><br><span class="line">    <span class="keyword">return</span> Primitives.wrap(classOfT).cast(object);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态方法无法引用类泛型参数<br>类的泛型参数只有在类实例化的时候才知道，而静态方法的执行不需要有类的示例存在，所以静态方法无法引用类泛型参数：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;T&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T <span class="title function_">max</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型类型会带来类型强转的运行时开销</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">Array</span>&lt;&gt;();</span><br><span class="line">  strList.add(<span class="string">&quot;Hallo&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> strList.get(<span class="number">0</span>);	<span class="comment">// 返回Object，compile errror</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> （String）strList.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><ol>
<li>泛型类和泛型接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Container</span>&lt;K, V&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Container</span><span class="params">(K k, V v)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        key = k;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getkey</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用Container类时，只需要指定K，V的具体类型即可，从而创建出逻辑上不同的Container实例，用来存放不同的数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     Container&lt;String,String&gt;  c1=<span class="keyword">new</span> <span class="title class_">Container</span>&lt;String ,String&gt;(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">     Container&lt;String,Integer&gt; c2=<span class="keyword">new</span> <span class="title class_">Container</span>&lt;String,Integer&gt;(<span class="string">&quot;age&quot;</span>,<span class="number">22</span>);</span><br><span class="line">     Container&lt;Double,Double&gt;  c3=<span class="keyword">new</span> <span class="title class_">Container</span>&lt;&gt;(<span class="number">1.1</span>,<span class="number">1.3</span>);	<span class="comment">// 泛型的“菱形”语法：Java允许在构造器后不需要带完成的泛型信息，只要给出一对尖括号（&lt;&gt;）即可，Java可以推断尖括号里应该是什么泛型信息。</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>泛型的方法<br>所谓泛型方法，就是在声明方法时定义一个或多个类型形参。 泛型方法的用法格式如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">修饰符&lt;T, S&gt; 返回值类型 方法名（形参列表）｛</span><br><span class="line">   方法体</span><br><span class="line">｝</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">fun</span><span class="params">(T t)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 可以接收任意类型的数据  </span></span><br><span class="line">   <span class="keyword">return</span> t ;     <span class="comment">// 直接把参数返回  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo26</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">    <span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>() ; <span class="comment">// 实例化Demo对象  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> d.fun(<span class="string">&quot;汤姆&quot;</span>) ; <span class="comment">// 传递字符串  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> d.fun(<span class="number">30</span>) ;  <span class="comment">// 传递数字，自动装箱  </span></span><br><span class="line">    System.out.println(str) ; <span class="comment">// 输出内容  </span></span><br><span class="line">    System.out.println(i) ;  <span class="comment">// 输出内容  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>泛型构造器<br>正如泛型方法允许在方法签名中声明类型形参一样，Java也允许在构造器签名中声明类型形参，这样就产生了所谓的泛型构造器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Person(T t) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 隐式推断泛型参数</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">22</span>);</span><br><span class="line">        <span class="comment">// 显示指定泛型参数</span></span><br><span class="line">        <span class="keyword">new</span>&lt;String&gt; Person(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是泛型中的限定通配符和非限定通配符？"><a href="#什么是泛型中的限定通配符和非限定通配符？" class="headerlink" title="什么是泛型中的限定通配符和非限定通配符？"></a>什么是泛型中的限定通配符和非限定通配符？</h2><?>表示了非限定通配符，因为<?><p>可以用任意类型来替代。</p>
<p>使用通配符的目的是来限制泛型的类型参数的类型。有两种限定通配符：一种是&lt;? extends T&gt;它通过确保类型必须是T的子类来设定类型的上界，另一种是&lt;? super T&gt;它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。</p>
<table> 
 <tbody> 
  <tr> 
   <td></td> 
   <td colspan="2">限定通配符</td> 
   <td>非限定通配符</td> 
  </tr> 
  <tr></tr> 
  <tr> 
   <td>表示</td> 
   <td>&lt;? extends T&gt;<br>子类型通配符</td> 
   <td>&lt;? super T&gt;<br>父类型通配符</td> 
   <td>&lt;?&gt;</td> 
  </tr> 
  <tr></tr> 
  <tr> 
   <td>功能</td> 
   <td>通过确保类型必须是T的子类来设定类型的上界</td> 
   <td>通过确保类型必须是T的父类来设定类型的下界</td> 
   <td>可以用任意类型来替代</td> 
  </tr> 
  <tr></tr> 
  <tr> 
   <td>举例</td> 
   <td>List&lt;? extends T&gt;可以接受任何继承自T的类型的List<br>例如List&lt;? extends Number&gt;可以接受List&lt; Integer &gt;或List&lt; Float &gt;</td> 
   <td>List&lt;? super T&gt;<br>可以接受任何T的父类构成的List</td> 
   <td></td> 
  </tr> 
  <tr></tr> 
 </tbody> 
</table>






<h1 id="第九章-Java-I-O与NIO"><a href="#第九章-Java-I-O与NIO" class="headerlink" title="第九章 Java I&#x2F;O与NIO"></a>第九章 Java I&#x2F;O与NIO</h1><ul>
<li>Java IO</li>
<li><ul>
<li>字节与字符</li>
<li><ul>
<li>Java 编码格式</li>
</ul>
</li>
<li>File类</li>
<li><ul>
<li>RandomAccessFile</li>
</ul>
</li>
<li>IO流</li>
<li><ul>
<li>IO流 简介</li>
<li>IO流 分类</li>
<li>IO流 四大基类</li>
</ul>
</li>
</ul>
</li>
<li>Java NIO</li>
<li><ul>
<li>NIO 简介</li>
<li>通道与缓冲区</li>
<li>选择器</li>
</ul>
</li>
</ul>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="字节与字符"><a href="#字节与字符" class="headerlink" title="字节与字符"></a>字节与字符</h3><p>在Java中有输入、输出两种IO流，每种输入、输出流又分为字节流和字符流两大类。关于字节，我们在学习8大基本数据类型中都有了解，每个字节(byte)有8bit组成，每种数据类型又几个字节组成等。关于字符，我们可能知道代表一个汉字或者英文字母。<br>但是字节与字符之间的关系是怎样的？<br>Java采用unicode编码，2个字节来表示一个字符，这点与C语言中不同，C语言中采用ASCII，在大多数系统中，一个字符通常占1个字节，但是在0~127整数之间的字符映射，unicode向下兼容ASCII。而Java采用unicode来表示字符，一个中文或英文字符的unicode编码都占2个字节。但如果采用其他编码方式，一个字符占用的字节数则各不相同。可能有点晕，举个例子解释下。<br>例如：Java中的String类是按照unicode进行编码的，当使用String(byte[] bytes, String encoding)构造字符串时，encoding所指的是bytes中的数据是按照那种方式编码的，而不是最后产生的String是什么编码方式，换句话说，是让系统把bytes中的数据由encoding编码方式转换成unicode编码。如果不指明，bytes的编码方式将由jdk根据操作系统决定。<br>getBytes(String charsetName)使用指定的编码方式将此String编码为 byte 序列，并将结果存储到一个新的 byte 数组中。如果不指定将使用操作系统默认的编码方式，我的电脑默认的是GBK编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hel</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;你好hello&quot;</span>;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">byte_len</span> <span class="operator">=</span> str.getBytes().length;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();  </span><br><span class="line">            System.out.println(<span class="string">&quot;字节长度为：&quot;</span> + byte_len);  </span><br><span class="line">        System.out.println(<span class="string">&quot;字符长度为：&quot;</span> + len);  </span><br><span class="line">        System.out.println(<span class="string">&quot;系统默认编码方式：&quot;</span> + System.getProperty(<span class="string">&quot;file.encoding&quot;</span>));  </span><br><span class="line">       &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字节长度为：<span class="number">9</span></span><br><span class="line">字符长度为：<span class="number">7</span></span><br><span class="line">系统默认编码方式：GBK</span><br></pre></td></tr></table></figure>

<p>这是因为：在 GB 2312 编码或 GBK 编码中，一个英文字母字符存储需要1个字节，一个汉字字符存储需要2个字节。 在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。在UTF-16编码中，一个英文字母字符存储需要2个字节，一个汉字字符储存需要3到4个字节（Unicode扩展区的一些汉字存储需要4个字节）。在UTF-32编码中，世界上任何字符的存储都需要4个字节。<br>简单来讲，一个字符表示一个汉字或英文字母，具体字符与字节之间的大小比例视编码情况而定。有时候读取的数据是乱码，就是因为编码方式不一致，需要进行转换，然后再按照unicode进行编码。</p>
<h4 id="Java-编码格式"><a href="#Java-编码格式" class="headerlink" title="Java 编码格式"></a>Java 编码格式</h4><p>计算机中存储信息的最小单元是1byte即8bit，所以能表示的字符范围是 0~255 个，人类要表示的符号太多，无法用一个字节来完全表示，需要一个新的数据结构char来表示这些字符。char与byte之间转换需要编码与解码。<br>编码：字节（Byte &#x3D; 8bit 默认数据的最小单位）与字符（Character &#x3D; 2byte）的转换方式。<br>编码就是把字符转换为字节，而解码是把字节重新组合成字符。<br>如果编码和解码过程使用不同的编码方式那么就出现了乱码。<br>编码规范</p>
<ol>
<li>ASCII<br>ASCII码一共规定了128个字符的编码，用一个字节的低 7 位表示，0<del>31 是控制字符如换行回车删除等；32</del>126 是打印字符，可以通过键盘输入并且能够显示出来。</li>
<li>ISO-8859-1<br>ISO 组织在 ASCII 码基础上又制定了一些列标准用来扩展 ASCII 编码，共有256个字符。</li>
<li>GB2312</li>
<li>GBK<br>中文字符占 2 个字节，英文字符占 1 个字节；</li>
<li>UTF-16<br>中文字符和英文字符都占 2 个字节；</li>
<li>UTF-8<br>UTF-8就是在互联网上使用最广的一种Unicode的实现方式。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。<br>中文字符占 3 个字节，英文字符占 1 个字节；<br>Java中需要编码的场景包括：</li>
<li>I&#x2F;O操作中存在的编码<br>Reader类是Java I&#x2F;O中读字符的父类，InputStream类是读字节的父类，通过InputStreamReader类将字节转换为字符。<br>同理，Writer是写字符的父类，OutputStram类是写字节的父类，通过OutputStreamWriter将字符转换为字节。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File_Stream</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Scanner sca=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//写文件</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入文件名：&quot;</span>);</span><br><span class="line">        String name=sca.next();</span><br><span class="line">        File file=<span class="keyword">new</span> <span class="title class_">File</span>(name+<span class="string">&quot;.txt&quot;</span>);<span class="comment">//文件名        相对路径（项目名根目录下）</span></span><br><span class="line"><span class="comment">//      FileOutputStream fs=new FileOutputStream(file);//如果文件存在 覆盖</span></span><br><span class="line">        FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file,<span class="literal">true</span>);<span class="comment">//true表示追加，如果文件存在 向里面继续添加内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入写入的内容:&quot;</span>);</span><br><span class="line">        String str=sca.next();</span><br><span class="line">        <span class="type">byte</span> bytes[]=str.getBytes();         <span class="comment">//FileOutputStream 是基于字节流  把要写入的信息 保存到字节数组中</span></span><br><span class="line">        fos.write(bytes,<span class="number">0</span>,bytes.length);<span class="comment">//将字节数组中全部内容写到文件中   从0—数组的长度</span></span><br><span class="line">        fos.close();<span class="comment">//关闭流</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件写入成功！&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//读文件</span></span><br><span class="line">        FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="type">byte</span> bt[]=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];<span class="comment">//1KB       每次最多读取的1KB  根据文件大小而定</span></span><br><span class="line">        <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((temp=fis.read(bt))!=-<span class="number">1</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">         <span class="comment">//将数据保存到数组（缓冲区）中 并返回读取的字节数  -1表示读完了</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bt,<span class="number">0</span>,temp));<span class="comment">//输出数组中保存内容 按照每次读取的字节数</span></span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>内存中的编码（String 的 编码方式）<br>Java 中用 String 表示字符串，所以 String 类就提供转换到字节的方法，也支持将字节转换为字符串的构造函数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;这是一段中文字符串&quot;</span>;    </span><br><span class="line"> <span class="type">byte</span>[] b = s.getBytes(<span class="string">&quot;UTF-8&quot;</span>);    <span class="comment">// （字符转字节）将字符串所表示的字符按照charset编码，并以字节方式表示。</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b,<span class="string">&quot;UTF-8&quot;</span>);	<span class="comment">// （字节转字符）将字节数组按照charset编码进行组合识别，最后转换为unicode存储</span></span><br></pre></td></tr></table></figure>

<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>File类是java.io包下代表与平台无关的文件和目录，也就是说，如果希望在程序中操作文件和目录，都可以通过File类来完成。<br>① 构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数File(String pathname)</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;c:\\abc\\1.txt&quot;</span>);</span><br><span class="line"><span class="comment">//File(String parent,String child)</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;c:\\abc&quot;</span>,<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line"><span class="comment">//File(File parent,String child)</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;c:&quot;</span>+File.separator+<span class="string">&quot;abc&quot;</span>);<span class="comment">//separator 跨平台分隔符</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">File</span>(f3,<span class="string">&quot;3.txt&quot;</span>);</span><br><span class="line">System.out.println(f1);<span class="comment">//c:\abc\1.txt</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>路径分隔符： windows： “&#x2F;” “” 都可以 linux&#x2F;unix： “&#x2F;”<br>注意:如果windows选择用”“做分割符的话,那么请记得替换成””,因为Java中”“代表转义字符<br>所以推荐都使用”&#x2F;“，也可以直接使用代码File.separator，表示跨平台分隔符。<br>路径：</p>
<ul>
<li>相对路径：<br>.&#x2F;表示当前路径（默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性user.dir 指定，通常是 Java 虚拟机的调用目录。）<br>…&#x2F;表示上一级路径</li>
<li>绝对路径：<br>绝对路径名是完整的路径名，不需要任何其他信息就可以定位自身表示的文件</li>
</ul>
</blockquote>
<p>② 创建与删除方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果文件存在返回false，否则返回true并且创建文件 </span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//创建一个File对象所对应的目录，成功返回true，否则false。且File对象必须为路径而不是文件。只会创建最后一级目录，如果上级目录不存在就抛异常。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//创建一个File对象所对应的目录，成功返回true，否则false。且File对象必须为路径而不是文件。创建多级目录，创建路径中所有不存在的目录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span>    ;</span><br><span class="line"><span class="comment">//如果文件存在返回true并且删除文件，否则返回false</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//在虚拟机终止时，删除File对象所表示的文件或目录。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteOnExit</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>③ 判断方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">canExecute</span><span class="params">()</span>    ;<span class="comment">//判断文件是否可执行</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">()</span>;<span class="comment">//判断文件是否可读</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">()</span>;<span class="comment">//判断文件是否可写</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;<span class="comment">//判断文件是否存在</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span>;<span class="comment">//判断是否是目录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>;<span class="comment">//判断是否是文件</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isHidden</span><span class="params">()</span>;<span class="comment">//判断是否是隐藏文件或隐藏目录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isAbsolute</span><span class="params">()</span>;<span class="comment">//判断是否是绝对路径 文件不存在也能判断</span></span><br></pre></td></tr></table></figure>

<p>③获取方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getName</span><span class="params">()</span>;<span class="comment">//返回文件或者是目录的名称</span></span><br><span class="line">String <span class="title function_">getPath</span><span class="params">()</span>;<span class="comment">//返回路径</span></span><br><span class="line">String <span class="title function_">getAbsolutePath</span><span class="params">()</span>;<span class="comment">//返回绝对路径</span></span><br><span class="line">String <span class="title function_">getParent</span><span class="params">()</span>;<span class="comment">//返回父目录，如果没有父目录则返回null</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span>;<span class="comment">//返回最后一次修改的时间</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">length</span><span class="params">()</span>;<span class="comment">//返回文件的长度</span></span><br><span class="line">File[] listRoots();<span class="comment">// 列出所有的根目录（Window中就是所有系统的盘符）</span></span><br><span class="line">String[] list() ;<span class="comment">//返回一个字符串数组，给定路径下的文件或目录名称字符串</span></span><br><span class="line">String[] list(FilenameFilter filter);<span class="comment">//返回满足过滤器要求的一个字符串数组</span></span><br><span class="line">File[]  listFiles();<span class="comment">//返回一个文件对象数组，给定路径下文件或目录</span></span><br><span class="line">File[] listFiles(FilenameFilter filter);<span class="comment">//返回满足过滤器要求的一个文件对象数组</span></span><br></pre></td></tr></table></figure>

<p>其中包含了一个重要的接口FileNameFilter，该接口是个文件过滤器，包含了一个accept(File dir,String name)方法，该方法依次对指定File的所有子目录或者文件进行迭代，按照指定条件，进行过滤，过滤出满足条件的所有文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件过滤</span></span><br><span class="line">        File[] files = file.listFiles(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File file, String filename)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">return</span> filename.endsWith(<span class="string">&quot;.mp3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>file目录下的所有子文件如果满足后缀是.mp3的条件的文件都会被过滤出来。</p>
<h4 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h4><ul>
<li>简介</li>
</ul>
<p>RandomAccessFile既可以读取文件内容，也可以向文件输出数据。同时，RandomAccessFile支持“随机访问”的方式，程序快可以直接跳转到文件的任意地方来读写数据。<br>由于RandomAccessFile可以自由访问文件的任意位置，所以如果需要访问文件的部分内容，而不是把文件从头读到尾，使用RandomAccessFile将是更好的选择。<br>与OutputStream、Writer等输出流不同的是，RandomAccessFile允许自由定义文件记录指针，RandomAccessFile可以不从开始的地方开始输出，因此RandomAccessFile可以向已存在的文件后追加内容。如果程序需要向已存在的文件后追加内容，则应该使用RandomAccessFile。</p>
<p>RandomAccessFile的方法虽然多，但它有一个最大的局限，就是只能读写文件，不能读写其他IO节点。<br>RandomAccessFile的一个重要使用场景就是网络请求中的多线程下载及断点续传。</p>
<ul>
<li>方法</li>
</ul>
<ol>
<li>RandomAccessFile的构造函数<br>RandomAccessFile类有两个构造函数，其实这两个构造函数基本相同，只不过是指定文件的形式不同——一个需要使用String参数来指定文件名，一个使用File参数来指定文件本身。除此之外，创建RandomAccessFile对象时还需要指定一个mode参数，该参数指定RandomAccessFile的访问模式，一共有4种模式。</li>
</ol>
<blockquote>
<p>“r”: 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。<br>“rw”: 打开以便读取和写入。<br>“rws”: 打开以便读取和写入。相对于 “rw”，“rws” 还要求对“文件的内容”或“元数据”的每个更新都同步写入到基础存储设备。<br>“rwd” : 打开以便读取和写入，相对于 “rw”，“rwd” 还要求对“文件的内容”的每个更新都同步写入到基础存储设备。</p>
</blockquote>
<ol>
<li>RandomAccessFile的重要方法<br>RandomAccessFile既可以读文件，也可以写文件，所以类似于InputStream的read()方法，以及类似于OutputStream的write()方法，RandomAccessFile都具备。除此之外，RandomAccessFile具备两个特有的方法，来支持其随机访问的特性。<br>RandomAccessFile对象包含了一个记录指针，用以标识当前读写处的位置，当程序新创建一个RandomAccessFile对象时，该对象的文件指针记录位于文件头（也就是0处），当读&#x2F;写了n个字节后，文件记录指针将会后移n个字节。除此之外，RandomAccessFile还可以自由移动该记录指针。下面就是RandomAccessFile具有的两个特殊方法，来操作记录指针，实现随机访问：</li>
</ol>
<blockquote>
<p>long getFilePointer( )：返回文件记录指针的当前位置<br>void seek(long pos)：将文件指针定位到pos位置</p>
</blockquote>
<ul>
<li>使用</li>
</ul>
<p>利用RandomAccessFile实现文件的多线程下载，即多线程下载一个文件时，将文件分成几块，每块用不同的线程进行下载。下面是一个利用多线程在写文件时的例子，其中预先分配文件所需要的空间，然后在所分配的空间中进行分块，然后写入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 测试利用多线程进行文件的写操作 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 预分配文件所占的磁盘空间，磁盘中会创建一个指定大小的文件  </span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;D://abc.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);  </span><br><span class="line">        raf.setLength(<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">// 预分配 1M 的文件空间  </span></span><br><span class="line">        raf.close();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所要写入的文件内容  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;第一个字符串&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;第二个字符串&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;第三个字符串&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;第四个字符串&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;第五个字符串&quot;</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用多线程同时写入一个文件  </span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileWriteThread</span>(<span class="number">1024</span>*<span class="number">1</span>,s1.getBytes()).start(); <span class="comment">// 从文件的1024字节之后开始写入数据  </span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileWriteThread</span>(<span class="number">1024</span>*<span class="number">2</span>,s2.getBytes()).start(); <span class="comment">// 从文件的2048字节之后开始写入数据  </span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileWriteThread</span>(<span class="number">1024</span>*<span class="number">3</span>,s3.getBytes()).start(); <span class="comment">// 从文件的3072字节之后开始写入数据  </span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileWriteThread</span>(<span class="number">1024</span>*<span class="number">4</span>,s4.getBytes()).start(); <span class="comment">// 从文件的4096字节之后开始写入数据  </span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileWriteThread</span>(<span class="number">1024</span>*<span class="number">5</span>,s5.getBytes()).start(); <span class="comment">// 从文件的5120字节之后开始写入数据  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用线程在文件的指定位置写入指定数据  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FileWriteThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> skip;  </span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] content;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FileWriteThread</span><span class="params">(<span class="type">int</span> skip,<span class="type">byte</span>[] content)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">            <span class="built_in">this</span>.skip = skip;  </span><br><span class="line">            <span class="built_in">this</span>.content = content;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">            <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                raf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;D://abc.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);  </span><br><span class="line">                raf.seek(skip);  </span><br><span class="line">                raf.write(content);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                    raf.close();  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当RandomAccessFile向指定文件中插入内容时，将会覆盖掉原有内容。如果不想覆盖掉，则需要将原有内容先读取出来，然后先把插入内容插入后再把原有内容追加到插入内容后。</p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h4 id="IO流-简介"><a href="#IO流-简介" class="headerlink" title="IO流 简介"></a>IO流 简介</h4><p>Java的IO流是实现输入&#x2F;输出的基础，它可以方便地实现数据的输入&#x2F;输出操作，在Java中把不同的输入&#x2F;输出源抽象表述为”流”。流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。<br>流有输入和输出，输入时是流从数据源流向程序。输出时是流从程序传向数据源，而数据源可以是内存，文件，网络或程序等。</p>
<h4 id="IO流-分类"><a href="#IO流-分类" class="headerlink" title="IO流 分类"></a>IO流 分类</h4><ol>
<li>输入流和输出流</li>
</ol>
<p>根据数据流向不同分为：输入流和输出流。<br>输入流：程序从数据源中读取数据。<br>输出流：程序向数据源中写入数据。<br>如下如所示：对程序而言，向右的箭头，表示输入，向左的箭头，表示输出。<br><img src="https://mark.cuckooing.cn/pics/pic_1b9d2b1a.png" alt="pic_1b9d2b1a.png"><br>2. 字节流和字符流</p>
<p>字节流和字符流和用法几乎完全一样，区别在于字节流和字符流所操作的数据单元不同。<br>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。字节流和字符流的区别：<br>（1）读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。<br>（2）处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。<br>只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。</p>
<ol>
<li>节点流和处理流</li>
</ol>
<p>按照流的角色来分，可以分为节点流和处理流。<br>可以从&#x2F;向一个特定的IO设备（如磁盘、网络）读&#x2F;写数据的流，称为节点流，节点流也被成为低级流。<br>处理流是对一个已存在的流进行连接或封装，通过封装后的流来实现数据读&#x2F;写功能，处理流也被称为高级流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点流，直接传入的参数是IO设备</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"><span class="comment">//处理流，直接传入的参数是流对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br></pre></td></tr></table></figure>

<p><img src="https://mark.cuckooing.cn/pics/pic_fff37b23.png" alt="pic_fff37b23.png"><br>当使用处理流进行输入&#x2F;输出时，程序并不会直接连接到实际的数据源，没有和实际的输入&#x2F;输出节点连接。使用处理流的一个明显好处是，只要使用相同的处理流，程序就可以采用完全相同的输入&#x2F;输出代码来访问不同的数据源，随着处理流所包装节点流的变化，程序实际所访问的数据源也相应地发生变化。<br>实际上，Java使用处理流来包装节点流是一种典型的装饰器设计模式，通过使用处理流来包装不同的节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入&#x2F;输出功能。</p>
<h4 id="IO流-四大基类"><a href="#IO流-四大基类" class="headerlink" title="IO流 四大基类"></a>IO流 四大基类</h4><p>根据流的流向以及操作的数据单元不同，将流分为了四种类型，每种类型对应一种抽象基类。这四种抽象基类分别为：InputStream,Reader,OutputStream以及Writer。四种基类下，对应不同的实现类，具有不同的特性。在这些实现类中，又可以分为节点流和处理流。下面就是整个由着四大基类支撑下，整个IO流的框架图。<br><img src="https://mark.cuckooing.cn/pics/pic_ff5b6489.png" alt="pic_ff5b6489.png"><br>InputStream,Reader,OutputStream以及Writer，这四大抽象基类，本身并不能创建实例来执行输入&#x2F;输出，但它们将成为所有输入&#x2F;输出流的模版，所以它们的方法是所有输入&#x2F;输出流都可以使用的方法。类似于集合中的Collection接口。</p>
<ol>
<li>InputStream<br>InputStream 是所有的输入字节流的父类，它是一个抽象类，主要包含三个方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取一个字节并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> ； </span><br><span class="line"><span class="comment">//读取一系列字节并存储到一个数组buffer，返回实际读取的字节数，如果读取前已到输入流的末尾返回-1。 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span> ； </span><br><span class="line"><span class="comment">//读取length个字节并存储到一个字节数组buffer，从off位置开始存,最多len， 返回实际读取的字节数，如果读取前以到输入流的末尾返回-1。 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> off, <span class="type">int</span> len)</span> ；</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取f盘下该文件f://hell/test.txt</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;f://hello//test.txt&quot;</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//一次读取一个字节</span></span><br><span class="line">        <span class="keyword">while</span> ((i = inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.print((<span class="type">char</span>) i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭IO流</span></span><br><span class="line">        inputStream.close();</span><br></pre></td></tr></table></figure>

<ol>
<li>Reader<br>Reader 是所有的输入字符流的父类，它是一个抽象类，主要包含三个方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取一个字符并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> ； </span><br><span class="line"><span class="comment">//读取一系列字符并存储到一个数组buffer，返回实际读取的字符数，如果读取前已到输入流的末尾返回-1。 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf)</span> ； </span><br><span class="line"><span class="comment">//读取length个字符,并存储到一个数组buffer，从off位置开始存,最多读取len，返回实际读取的字符数，如果读取前以到输入流的末尾返回-1。 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> off, <span class="type">int</span> len)</span></span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认编码        </span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.print((<span class="type">char</span>) len);</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br></pre></td></tr></table></figure>

<p>对比InputStream和Reader所提供的方法，就不难发现两个基类的功能基本一样的，只不过读取的数据单元不同。<br>在执行完流操作后，要调用close()方法来关系输入流，因为程序里打开的IO资源不属于内存资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。</p>
<ol>
<li>OutputStream<br>OutputStream 是所有的输出字节流的父类，它是一个抽象类，主要包含如下四个方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向输出流中写入一个字节数据,该字节数据为参数b的低8位。 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> ; </span><br><span class="line"><span class="comment">//将一个字节类型的数组中的数据写入输出流。 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span>; </span><br><span class="line"><span class="comment">//将一个字节类型的数组中的从指定位置（off）开始的,len个字节写入到输出流。 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span>; </span><br><span class="line"><span class="comment">//将输出流中缓冲的数据全部写出到目的地。 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;ABCD&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 关闭IO流</span></span><br><span class="line">        outputStream.close();</span><br></pre></td></tr></table></figure>

<ol>
<li>Writer<br>Writer 是所有的输出字符流的父类，它是一个抽象类,主要包含如下六个方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向输出流中写入一个字符数据,该字节数据为参数b的低16位。 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span>; </span><br><span class="line"><span class="comment">//将一个字符类型的数组中的数据写入输出流， </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf)</span> </span><br><span class="line"><span class="comment">//将一个字符类型的数组中的从指定位置（offset）开始的,length个字符写入到输出流。 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> offset, <span class="type">int</span> length)</span>; </span><br><span class="line"><span class="comment">//将一个字符串中的字符写入到输出流。 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String string)</span>; </span><br><span class="line"><span class="comment">//将一个字符串从offset开始的length个字符写入到输出流。 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String string, <span class="type">int</span> offset, <span class="type">int</span> length)</span>; </span><br><span class="line"><span class="comment">//将输出流中缓冲的数据全部写出到目的地。 </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        writer.write(<span class="string">&quot;ABCD&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 关闭IO流</span></span><br><span class="line">        writer.close();</span><br></pre></td></tr></table></figure>

<p>可以看出，Writer比OutputStream多出两个方法，主要是支持写入字符和字符串类型的数据。<br>使用Java的IO流执行输出时，不要忘记关闭输出流，关闭输出流除了可以保证流的物理资源被回收之外，还能将输出流缓冲区的数据flush到物理节点里（因为在执行close()方法之前，自动执行输出流的flush()方法）</p>
<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h3 id="NIO-简介"><a href="#NIO-简介" class="headerlink" title="NIO 简介"></a>NIO 简介</h3><p>新的输入&#x2F;输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I&#x2F;O 的不足，提供了高速的、面向块的 I&#x2F;O。<br>NIO 与普通 I&#x2F;O 的区别主要有以下两点：</p>
<ul>
<li>NIO 是非阻塞的；<br>当一个read操作发生时，它会经历两个阶段：<br>1 等待数据准备 (Waiting for the data to be ready)<br>2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)<br>blocking IO的特点就是在IO执行的两个阶段都被block了。<br>non-blocking IO的特点是当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。所以，用户进程其实是需要不断的主动询问kernel数据好了没有。</li>
<li>NIO 面向块，I&#x2F;O 面向流。<br>I&#x2F;O 与 NIO 最重要的区别是数据打包和传输的方式，I&#x2F;O 以流的方式处理数据，而 NIO 以块的方式处理数据。按块处理数据比按流处理数据要快得多。但是面向块的 I&#x2F;O 缺少一些面向流的 I&#x2F;O 所具有的优雅性和简单性。</li>
</ul>
<h3 id="通道与缓冲区"><a href="#通道与缓冲区" class="headerlink" title="通道与缓冲区"></a>通道与缓冲区</h3><ol>
<li>通道<br>通道 Channel 是对原 I&#x2F;O 包中的流的模拟，可以通过它读取和写入数据。</li>
</ol>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p>通道包括以下类型：</p>
<ul>
<li>FileChannel：从文件中读写数据；</li>
<li>DatagramChannel：通过 UDP 读写网络中数据；</li>
<li>SocketChannel：通过 TCP 读写网络中数据；</li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<ol>
<li>缓冲区</li>
</ol>
<p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读&#x2F;写进程。</p>
<p>缓冲区包括以下类型：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<p>缓冲区状态变量包括：</p>
<ul>
<li>capacity：最大容量；</li>
<li>position：当前已经读写的字节数；</li>
<li>limit：还可以读写的字节数。</li>
</ul>
<p>状态变量的改变过程举例：</p>
<p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit &#x3D; capacity &#x3D; 8。capacity 变量不会改变，下面的讨论会忽略它。</p>
<p><img src="https://mark.cuckooing.cn/pics/pic_0acfd191.png" alt="pic_0acfd191.png"></p>
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</p>
<p><img src="https://mark.cuckooing.cn/pics/pic_b2bb651f.png" alt="pic_b2bb651f.png"></p>
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<p><img src="https://mark.cuckooing.cn/pics/pic_f31342fc.png" alt="pic_f31342fc.png"></p>
<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<p><img src="https://mark.cuckooing.cn/pics/pic_7701dba0.png" alt="pic_7701dba0.png"></p>
<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<p><img src="https://mark.cuckooing.cn/pics/pic_13fdec05.png" alt="pic_13fdec05.png"></p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ol>
<li>简介<br>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</li>
</ol>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p>
<p>应该注意的是，只有Socket Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p>
<p><img src="https://mark.cuckooing.cn/pics/pic_743e8810.png" alt="pic_743e8810.png"></p>
<ol>
<li>原理<br>IO multiplexing —— 整体 blocking 局部 non-blocking<br>当用户进程调用了select，那么整个进程会被block，而同时，kernel通过不断轮询，“监视”所有select负责的所有kernel(socket)，当任何一个kernel(socket)中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<br>使用IO multiplexing性能不一定比使用multi-threading + blocking IO效率高，使用select的优势在于它可以同时处理多个connection。<br>在IO multiplexing Model中，实际中，对于每一个socket channel，一般都设置成为non-blocking，但是，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket channel IO给block。</li>
<li>使用</li>
</ol>
<ul>
<li>创建选择器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure>

<ul>
<li>将通道注册到选择器上</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>它们在 SelectionKey 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<ul>
<li>监听事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> selector.select();</span><br></pre></td></tr></table></figure>

<p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>
<ul>
<li>获取到达的事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件循环</li>
</ul>
<p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>套接字 NIO 实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> ssChannel.socket();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">ssChannel1</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这个新连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> buffer.limit();</span><br><span class="line">            <span class="type">char</span>[] dst = <span class="keyword">new</span> <span class="title class_">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                dst[i] = (<span class="type">char</span>) buffer.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="第十章-多线程"><a href="#第十章-多线程" class="headerlink" title="第十章 多线程"></a>第十章 多线程</h1><ul>
<li>线程状态 &amp; 转换</li>
<li>创建线程 3 种方式</li>
<li><ul>
<li>实现 Runnable 接口</li>
<li>实现 Callable 接口</li>
<li>继承 Thread 类</li>
</ul>
</li>
<li>互斥</li>
<li><ul>
<li>Synchronized 类（JVM）</li>
<li>ReentrantLock 类（JUC）</li>
</ul>
</li>
<li>协作</li>
<li><ul>
<li>join()</li>
<li>wait() 、notify()、 notifyAll()（结合synchronized）</li>
<li>await() 、signal()、 signalAll()（结合Lock）</li>
<li>生产者&#x2F;消费者 模式实现</li>
</ul>
</li>
<li>JUC</li>
<li><ul>
<li>AQS</li>
<li><ul>
<li>Semaphore</li>
<li>CountDownLatch</li>
<li>CyclicBarrier</li>
</ul>
</li>
<li>其他组件</li>
<li><ul>
<li>FutureTask</li>
<li>ForkJoin</li>
<li>Executor &amp;&amp; ThreadPoolExecutor</li>
</ul>
</li>
</ul>
</li>
<li>Java 内存模型</li>
<li><ul>
<li>内存模型 &amp; 特性</li>
<li>Volatile</li>
</ul>
</li>
<li>线程安全</li>
<li><ul>
<li>不可变</li>
<li>互斥同步（锁）</li>
<li>非阻塞同步（CAS）</li>
<li><ul>
<li><ol>
<li>CAS</li>
</ol>
</li>
<li><ol start="2">
<li>AtomicInteger</li>
</ol>
</li>
</ul>
</li>
<li>无同步方案</li>
<li><ul>
<li><ol>
<li>线程本地存储（Thread Local Storage）</li>
</ol>
</li>
<li><ol start="2">
<li>可重入代码（Reentrant Code）</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>并发集合</li>
<li><ul>
<li>BlockingQueue（JUC）</li>
<li>ConcurrentHashMap</li>
</ul>
</li>
<li>多线程开发良好的实践</li>
<li>实例 —— 多线程断点续传</li>
</ul>
<h2 id="线程状态-转换"><a href="#线程状态-转换" class="headerlink" title="线程状态 &amp; 转换"></a>线程状态 &amp; 转换</h2><p><img src="https://mark.cuckooing.cn/pics/pic_5394a242.png" alt="pic_5394a242.png"></p>
<ol>
<li>新建（New）<br>创建后尚未启动。</li>
<li>可运行（Runnable）<br>可能正在运行，也可能正在等待 CPU 时间片。包含了操作系统线程状态中的 Running 和 Ready。</li>
<li>阻塞（Blocked）<br>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</li>
<li>无限期等待（Waiting）<br>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</li>
</ol>
<table> 
 <thead> 
  <tr> 
   <th>进入方法</th> 
   <th>退出方法</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>没有设置 Timeout 参数的 Object.wait() 方法</td> 
   <td>Object.notify() / Object.notifyAll()</td> 
  </tr> 
  <tr> 
   <td>没有设置 Timeout 参数的 Thread.join() 方法</td> 
   <td>被调用的线程执行完毕</td> 
  </tr> 
 </tbody> 
</table>

<ol>
<li>限期等待（Timed Waiting）<br>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。<br>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。<br>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。<br>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。<br>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</li>
</ol>
<table> 
 <thead> 
  <tr> 
   <th>进入方法</th> 
   <th>退出方法</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>Thread.sleep() 方法</td> 
   <td>时间结束</td> 
  </tr> 
  <tr> 
   <td>设置了 Timeout 参数的 Object.wait() 方法</td> 
   <td>时间结束 / Object.notify() / Object.notifyAll()</td> 
  </tr> 
  <tr> 
   <td>设置了 Timeout 参数的 Thread.join() 方法</td> 
   <td>时间结束 / 被调用的线程执行完毕</td> 
  </tr> 
 </tbody> 
</table>

<ol>
<li>死亡（Terminated）<br>可以是线程结束任务之后自己结束，或者产生了异常而结束。</li>
</ol>
<blockquote>
<p>控制线程方法：</p>
<ul>
<li>Thread.start()：创建了新的线程，在新的线程中执行</li>
<li>Thread.run()：在主线程中执行该方法，和调用普通方法一样</li>
</ul>
</blockquote>
<h2 id="创建线程-3-种方式"><a href="#创建线程-3-种方式" class="headerlink" title="创建线程 3 种方式"></a>创建线程 3 种方式</h2><ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>
<h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><p>需要实现 run() 方法。<br>通过 Thread 调用 start() 方法来启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">MyRunnable</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h3><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());	<span class="comment">// FutureTask.get()方法可以得到子线程执行结束后的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。<br>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现接口 VS 继承 Thread<br>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ul>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><h3 id="Synchronized-类（JVM）"><a href="#Synchronized-类（JVM）" class="headerlink" title="Synchronized 类（JVM）"></a>Synchronized 类（JVM）</h3><p>synchronized 规定了同一个时刻只允许一条线程可以进入临界区（互斥性），同时还保证了共享变量的内存可见性。此规则决定了持有同一个对象锁的多个同步块只能串行执行。<br>（一）原理<br>synchronized实现同步的基础：Java中每个对象都可以作为锁。当线程试图访问同步代码时，必须先获得对象锁，退出或抛出异常时必须释放锁。<br>Synchronzied实现同步的表现形式分为：代码块同步 和 方法同步。</p>
<p>synchronized 方法实现的本质是通过对对象的监视器（monitor）的获取：<br>任意一个对象都拥有自己的监视器，当同步代码块或方法时，执行方法的线程必须先获得该对象的监视器才能进入同步块或同步方法；没有获取监视器的将会被阻塞，并进入同步队列，状态变为BLOCKED。当获取监视器的线程释放锁后，才回唤醒阻塞在同步队列中的线程，使其尝试对监视器的获取。<br>对象、监视器、同步队列和执行线程间的关系如下图：<br><img src="https://mark.cuckooing.cn/pics/pic_ab9ecded.png" alt="pic_ab9ecded.png"><br>（二）使用</p>
<ol>
<li>对象锁 —— 用于对象实例方法，或者一个对象实例上的</li>
</ol>
<ul>
<li>同步代码块</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     ...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同步方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     ...&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>类锁 —— 用于类的静态方法或者一个类的class对象上的</li>
</ol>
<ul>
<li>同步代码块</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     ...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同步静态方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     ...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock-类（JUC）"><a href="#ReentrantLock-类（JUC）" class="headerlink" title="ReentrantLock 类（JUC）"></a>ReentrantLock 类（JUC）</h3><p>ReentrantLock，一个可重入的互斥锁。<br>（一）Lock 接口<br>Lock，锁对象。用于控制多个线程访问共享资源（互斥 &amp; 协作（如：读写锁））。<br>优点在于拥有锁的获取与释放的可操作性，并且可以中断、超时获取锁等。具有更为强大的同步功能；<br>缺点在于使用时需要显示获取和释放锁，缺少synchronized那样隐式获取和释放锁的便捷性。<br>常用方法：</p>
<table> 
 <thead> 
  <tr> 
   <th>方法</th> 
   <th>解释</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>void lock()</td> 
   <td>执行此方法时，如果锁处于空闲状态，当前线程将获取到锁。相反，如果锁已经被其他线程持有，将阻塞当前线程，直到当前线程获取到锁。</td> 
  </tr> 
  <tr> 
   <td>boolean tryLock()</td> 
   <td>如果锁可用，则获取锁，并立即返回true，否则返回false. 该方法和lock()的区别在于，tryLock()只是"试图"获取锁，如果锁不可用，不会导致当前线程被阻塞，当前线程仍然继续往下执行代码</td> 
  </tr> 
  <tr> 
   <td>void unlock()</td> 
   <td>执行此方法时，当前线程将释放持有的锁. 锁只能由持有者释放，如果线程并不持有锁，却执行该方法，可能导致异常的发生</td> 
  </tr> 
  <tr> 
   <td>Condition newCondition()</td> 
   <td>条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将释放锁</td> 
  </tr> 
 </tbody> 
</table>

<p>（二）可重入锁<br>当一个线程得到一个对象后，再次请求该对象锁时是可以再次得到该对象的锁的。即由于本身已经具有该锁，所以自己可以再次获取该锁。<br>Java里面内置锁(synchronized)和Lock(ReentrantLock)都是可重入的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 即调用method1()方法时，已经获得了锁，此时内部调用method2()方法时,由于本身已经具有该锁，所以可以再次获取。</span></span><br><span class="line"><span class="comment">// synchronized 可重入示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;方法1获得ReentrantTest的锁运行了&quot;</span>);</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;方法1里面调用的方法2重入锁,也正常运行了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>().method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock 可重入示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockTest</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;方法1获得ReentrantLock锁运行了&quot;</span>);</span><br><span class="line">            method2();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;方法1里面调用的方法2重入ReentrantLock锁,也正常运行了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReentrantLockTest</span>().method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（三）公平锁<br>CPU在调度线程的时候是在等待队列里随机挑选一个线程，由于这种随机性所以是无法保证线程先到先得的（synchronized控制的锁就是这种非公平锁）。但这样就会产生饥饿现象，即有些线程（优先级较低的线程）可能永远也无法获取CPU的执行权，优先级高的线程会不断的强制它的资源。那么如何解决饥饿问题呢，这就需要公平锁了。<br>公平锁可以保证线程按照时间的先后顺序执行，避免饥饿现象的产生。但公平锁的效率比较低，因为要实现顺序执行，需要维护一个有序队列。<br>ReentrantLock便是一种公平锁，通过在构造方法中传入true就是公平锁，传入false，就是非公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（四）ReentrantLock 的 使用<br>关于ReentrantLock的使用很简单，只需要显示调用，获得同步锁，释放同步锁即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockExample</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        lock.lock();	<span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">        	<span class="comment">// 操作</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（五）Synchronized &amp; ReentrantLock 比较</p>
<table> 
 <thead> 
  <tr> 
   <th></th> 
   <th>Synchronized</th> 
   <th>ReentrantLock</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>锁的实现</td> 
   <td>JVM</td> 
   <td>JDK</td> 
  </tr> 
  <tr> 
   <td>性能</td> 
   <td></td> 
   <td>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等</td> 
  </tr> 
  <tr> 
   <td>等待可中断</td> 
   <td>不可中断，使用synchronized时，等待的线程会一直等待下去，不能够响应中断</td> 
   <td>可中断，当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</td> 
  </tr> 
  <tr> 
   <td>公平锁</td> 
   <td>非公平</td> 
   <td>默认非公平，可公平，公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁</td> 
  </tr> 
  <tr> 
   <td>异常</td> 
   <td>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生</td> 
   <td>Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁</td> 
  </tr> 
 </tbody> 
</table>

<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。<br>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                a.join();	<span class="comment">// b 线程等待a先执行完毕再接着执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">JoinExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoinExample</span>();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>

<h3 id="wait-、notify-、-notifyAll-（结合synchronized）"><a href="#wait-、notify-、-notifyAll-（结合synchronized）" class="headerlink" title="wait() 、notify()、 notifyAll()（结合synchronized）"></a>wait() 、notify()、 notifyAll()（结合synchronized）</h3><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p>
<ul>
<li>它们都属于 Object 的一部分，而不属于 Thread。</li>
<li>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException（确保调用wait()方法的线程必须拥有锁）</li>
<li>使用 wait() 挂起期时：<br>线程会释放锁，并进入 wait set中，状态为WAITING。</li>
<li>使用notify()唤醒线程时：<br>①如果多个线程在等待，通知对象的wait set中一个线程释放。这种选择是随意的，和具体实现有关。（若使用notifyAll()则通知对象的wait set中所有线程释放）<br>②被唤醒的线程是不能被执行的，需要等到当前线程放弃这个对象的锁，当前线程会在方法执行完毕后释放锁。若线程获取锁则为RUNNABLE状态，否则为BLOCKED状态。</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>方法</th> 
   <th>说明</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>wait()方法</td> 
   <td>让当前线程进入等待，并释放锁</td> 
  </tr> 
  <tr> 
   <td>wait(long)</td> 
   <td>让当前线程进入等待，并释放锁，不过等待时间为long，超过这个时间没有对当前线程进行唤醒，将自动唤醒</td> 
  </tr> 
  <tr> 
   <td>notify()</td> 
   <td>让当前线程通知那些处于等待状态的线程，当前线程执行完毕后释放锁，并从其他线程中唤醒其中一个继续执行</td> 
  </tr> 
  <tr> 
   <td>notifyAll()</td> 
   <td>让当前线程通知那些处于等待状态的线程，当前线程执行完毕后释放锁，将唤醒所有等待状态的线程</td> 
  </tr> 
 </tbody> 
</table>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="type">WaitNotifyExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotifyExample</span>();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<blockquote>
<p>wait() 和 sleep() 的区别</p>
<ul>
<li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li>
<li>wait() 会释放锁，sleep() 不会。</li>
</ul>
</blockquote>
<h3 id="await-、signal-、-signalAll-（结合Lock）"><a href="#await-、signal-、-signalAll-（结合Lock）" class="headerlink" title="await() 、signal()、 signalAll()（结合Lock）"></a>await() 、signal()、 signalAll()（结合Lock）</h3><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待某个条件满足，其它线程运行满足这个条件后，调用 signal() 或 signalAll() 方法唤醒等待的线程。</p>
<ul>
<li>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</li>
<li>使用 Lock 来获取一个 Condition 对象。（需结合Lock使用）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AwaitSignalExample</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="type">AwaitSignalExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignalExample</span>();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<h3 id="生产者-消费者-模式实现"><a href="#生产者-消费者-模式实现" class="headerlink" title="生产者&#x2F;消费者 模式实现"></a>生产者&#x2F;消费者 模式实现</h3><p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; container;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(List&lt;&gt; container)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">this</span>.container = container;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 生产者生产产品</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">synchronized</span>(container)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="keyword">if</span>(container.size &gt;= MAX_CAPACITY)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">				<span class="comment">// 容器已满，停止生产</span></span><br><span class="line">				container.wait();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 模拟1秒生产一个产品</span></span><br><span class="line">			<span class="type">Integer</span> <span class="variable">p</span> <span class="operator">=</span> container.add(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>));</span><br><span class="line">			TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">			container.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">				produce();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     e.printStackTrace();&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; container;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(List&lt;&gt; container)</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">this</span>.container = container;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 消费者消费产品</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">synchronized</span>(container)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="keyword">if</span>(container.isEmpty())&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">				<span class="comment">// 容器为空，停止消费</span></span><br><span class="line">				container.wait();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 模拟1秒消费一个产品</span></span><br><span class="line">			<span class="type">Integer</span> <span class="variable">p</span> <span class="operator">=</span> container.remove(<span class="number">0</span>);</span><br><span class="line">			TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">			container.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">				consume();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     e.printStackTrace();&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerTest</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        List&lt;Integer&gt; container = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(container));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(container));</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么使用notifyAll()唤醒？<br>多个生产者和消费者线程。当全部运行后，生产者线程生产数据后，可能唤醒的同类即生产者线程。此时可能会出现如下情况：所有生产者线程进入等待状态，然后消费者线程消费完数据后，再次唤醒的还是消费者线程，直至所有消费者线程都进入等待状态，此时将进入“假死”。</p>
<p>将notify()或signal()方法改为notifyAll()或signalAll()方法，这样就不怕因为唤醒同类而进入“假死”状态了。</p>
</blockquote>
<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。<br>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。（资源数为10的互斥操作）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">clientCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalRequestCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(clientCount);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    semaphore.acquire();	<span class="comment">// 信号量--</span></span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    semaphore.release();	<span class="comment">// 信号量++</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><h3 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h3><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskExample</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">computeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">otherThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            System.out.println(<span class="string">&quot;other task is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">other task is running...</span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></table></figure>

<h4 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h4><h4 id="Executor-ThreadPoolExecutor"><a href="#Executor-ThreadPoolExecutor" class="headerlink" title="Executor &amp;&amp; ThreadPoolExecutor"></a>Executor &amp;&amp; ThreadPoolExecutor</h4><ul>
<li>Executor 执行器<br>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</li>
</ul>
<p>主要有三种 Executor：</p>
<ul>
<li>CachedThreadPool：一个任务创建一个线程；</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Extecutor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。<br>ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。<br><img src="https://mark.cuckooing.cn/pics/pic_1b3d3d30.png" alt="pic_1b3d3d30.png"></p>
<ul>
<li>ThreadPoolExecutor 线程池<br>[第十章 线程 &#x2F; 进程 通信 —— 线程池 ThreadPoolExecutor][_ _ _ _ _ _ ThreadPoolExecutor]</li>
<li>作用</li>
<li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li>
<li>提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行；</li>
<li>方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率；</li>
<li>更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。</li>
<li>执行流程<br><img src="https://mark.cuckooing.cn/pics/pic_9b512bdf.png" alt="pic_9b512bdf.png"><br>① 如果在线程池中的线程数量没有达到核心的线程数量，这时候就回启动一个核心线程来执行任务。<br>② 如果线程池中的线程数量已经超过核心线程数，这时候任务就会被插入到任务队列中排队等待执行。<br>③ 由于任务队列已满，无法将任务插入到任务队列中。这个时候如果线程池中的线程数量没有达到线程池所设定的最大值，那么这时候就会立即启动一个非核心线程来执行任务。<br>④ 如果线程池中的数量达到了所规定的最大值，那么就会拒绝执行此任务，这时候就会调用RejectedExecutionHandler中的rejectedExecution方法来通知调用者。</li>
<li>四种线程池类<br>Java中四种具有不同功能常见的线程池。他们都是直接或者间接配置ThreadPoolExecutor来实现他们各自的功能。这四种线程池分别是：</li>
</ul>
<ol>
<li>newFixedThreadPool：一种线程数量固定的线程池。</li>
<li>newCachedThreadPool</li>
<li>newScheduledThreadPool</li>
<li>newSingleThreadExecutor</li>
</ol>
<ul>
<li>线程池使用技巧<br>需要针对具体情况而具体处理，不同的任务类别应采用不同规模的线程池，任务类别可划分为CPU密集型任务、IO密集型任务和混合型任务。(N代表CPU个数)</li>
</ul>
<table> 
 <thead> 
  <tr> 
   <th>任务</th> 
   <th>说明</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>CPU密集型任务</td> 
   <td>线程池中线程个数应尽量少，如配置N+1个线程的线程池</td> 
  </tr> 
  <tr> 
   <td>IO密集型任务</td> 
   <td>由于IO操作速度远低于CPU速度，那么在运行这类任务时，CPU绝大多数时间处于空闲状态，那么线程池可以配置尽量多些的线程，以提高CPU利用率，如2*N</td> 
  </tr> 
  <tr> 
   <td>混合型任务</td> 
   <td>可以拆分为CPU密集型任务和IO密集型任务，当这两类任务执行时间相差无几时，通过拆分再执行的吞吐率高于串行执行的吞吐率，但若这两类任务执行时间有数据级的差距，那么没有拆分的意义</td> 
  </tr> 
 </tbody> 
</table>

<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><h3 id="内存模型-特性"><a href="#内存模型-特性" class="headerlink" title="内存模型 &amp; 特性"></a>内存模型 &amp; 特性</h3><p>Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。<br>当数据从主内存复制到工作存储时，必须出现两个动作：<br>第一，由主内存执行的读（read）操作；<br>第二，由工作内存执行的相应的load操作；<br>当数据从工作内存拷贝到主内存时，也出现两个操作：<br>第一，由工作内存执行的存储（store）操作；<br>第二，由主内存执行的相应的写（write）操作<br>每一个操作都是原子的，即执行期间不会被中断。<br><img src="https://mark.cuckooing.cn/pics/pic_a57d793f.png" alt="pic_a57d793f.png"><br>在有些场景下多线程访问程序变量会表现出与程序制定的顺序不一样。因为编译器可以以优化的名义改变每个独立线程的顺序，从而使处理器不按原来的顺序执行线程。一个Java程序在从源代码到最终实际执行的指令序列之间，会经历一系列的重排序过程。<br>对于多线程共享同一内存区域这一情况，使得每个线程不知道其他线程对数据做了怎样的修改（数据修改位于线程的私有内存中，具有不可见性），从而导致执行结果不正确。因此必须要解决这一同步问题。（并发一致性带来的问题：丢失修改、不可重复读、脏数据）<br><img src="https://mark.cuckooing.cn/pics/pic_2f0e2962.png" alt="pic_2f0e2962.png"><br>Java内存模型需要保证三特性：原子性、可见性、有序性。</p>
<ol>
<li>原子性<br>即一个操作或者多个操作，要么全部执行，并且执行的过程不会被任何因素打断，要么就都不执行。Java实现方式包括：</li>
</ol>
<ul>
<li>原子类，如AtomicInteger等</li>
<li>synchronized 互斥锁</li>
</ul>
<ol>
<li>可见性<br>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。Java实现方式包括：</li>
</ol>
<ul>
<li>volatile</li>
<li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li>
</ul>
<ol>
<li>有序性<br>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ol>
<ul>
<li>volatile 关键字：通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</li>
<li>synchronized：保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</li>
</ul>
<h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><ol>
<li>原理<br>对于非volatile变量进行读写时，每个线程先从主存拷贝变量到线程缓存中，执行完操作再保存到主存中。需要进行load&#x2F;save操作。<br>而volatile变量保证每次读写变量都是不经过缓存而是直接从内存读写数据。省去了load&#x2F;save操作。volatile变量不会将对该变量的操作与其他内存操作一起重排序，能及时更新到主存；且因该变量存储在主存上，所以总会返回最新写入的值。</li>
<li>三大特性<br>他能保证：</li>
</ol>
<ul>
<li>可见性<br>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</li>
<li>有序性<br>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</li>
</ul>
<ol>
<li>应用 —— 单例模式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要使用volatile 修饰instance？<br>主要在于instance &#x3D; new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:<br>1.给 instance 分配内存<br>2.调用 Singleton 的构造函数来初始化成员变量<br>3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。<br>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。<br>本质上使用Volatile关键字，可以防止产生指令的重排序问题</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p>
<p>线程安全有以下几种实现方式：</p>
<h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>
<p>不可变的类型：</p>
<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>
</ul>
<p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableExample</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        unmodifiableMap.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.UnsupportedOperationException</span><br><span class="line">    at java.util.Collections$UnmodifiableMap.put(Collections.java:<span class="number">1457</span>)</span><br><span class="line">    at ImmutableExample.main(ImmutableExample.java:<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥同步（锁）"><a href="#互斥同步（锁）" class="headerlink" title="互斥同步（锁）"></a>互斥同步（锁）</h3><p>synchronized 和 ReentrantLock。</p>
<h3 id="非阻塞同步（CAS）"><a href="#非阻塞同步（CAS）" class="headerlink" title="非阻塞同步（CAS）"></a>非阻塞同步（CAS）</h3><p>加锁是一种悲观的策略，它总是认为每次访问共享资源的时候，总会发生冲突，所以宁愿牺牲性能（时间）来保证数据安全。<br>无锁是一种乐观的策略，它假设线程访问共享资源不会发生冲突，所以不需要加锁，因此线程将不断执行，不需要停止。一旦碰到冲突，就重试当前操作直到没有冲突为止。</p>
<p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<h4 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h4><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。<br>无锁的策略使用一种叫做比较交换的技术（CAS Compare And Swap）来鉴别线程冲突，一旦检测到冲突产生，就重试当前操作直到没有冲突为止。<br>硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。<br>核心算法：执行函数：CAS(V，E，N)</p>
<ul>
<li>V表示准备要被更新的变量</li>
<li>E表示我们提供的 期望的值</li>
<li>N表示新值 ，准备更新V的值</li>
</ul>
<p>算法思路：V是共享变量，我们拿着自己准备的这个E，去跟V去比较，如果E &#x3D;&#x3D; V ，说明当前没有其它线程在操作，所以，我们把N 这个值 写入对象的 V 变量中。如果 E ！&#x3D; V ，说明我们准备的这个E，已经过时了，所以我们要重新准备一个最新的E ，去跟V 比较，比较成功后才能更新 V的值为N。<br><img src="https://mark.cuckooing.cn/pics/pic_2574a564.png" alt="pic_2574a564.png"></p>
<h4 id="2-AtomicInteger"><a href="#2-AtomicInteger" class="headerlink" title="2. AtomicInteger"></a>2. AtomicInteger</h4><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p>
<p>以下代码使用了 AtomicInteger 执行了自增的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p>
<p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>
<h4 id="1-线程本地存储（Thread-Local-Storage）"><a href="#1-线程本地存储（Thread-Local-Storage）" class="headerlink" title="1. 线程本地存储（Thread Local Storage）"></a>1. 线程本地存储（Thread Local Storage）</h4><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
<p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>为了理解 ThreadLocal，先看以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample1</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">threadLocal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">threadLocal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            threadLocal1.set(<span class="number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它所对应的底层结构图为：<br><img src="https://mark.cuckooing.cn/pics/pic_cb39e8b6.png" alt="pic_cb39e8b6.png"><br>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get() 方法类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>
<p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p>
<h4 id="2-可重入代码（Reentrant-Code）"><a href="#2-可重入代码（Reentrant-Code）" class="headerlink" title="2. 可重入代码（Reentrant Code）"></a>2. 可重入代码（Reentrant Code）</h4><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>
<h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><h3 id="BlockingQueue（JUC）"><a href="#BlockingQueue（JUC）" class="headerlink" title="BlockingQueue（JUC）"></a>BlockingQueue（JUC）</h3><ol>
<li>BlockingQueue<br>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</li>
</ol>
<ul>
<li>FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li>
<li>优先级队列 ：PriorityBlockingQueue</li>
</ul>
<p>提供了阻塞的 take() 和 put() 方法：</p>
<ul>
<li>take：如果队列为空 take() 将线程阻塞，直到队列中有内容；</li>
<li>put：如果队列为满 put() 将阻塞，直到队列有空闲位置。</li>
</ul>
<p>BlockingQueue虽然比起Queue在操作上提供了更多的支持，但是它在使用有如下的几点:</p>
<ul>
<li>BlockingQueue中是不允许添加null的，该接受在声明的时候就要求所有的实现类在接收到一个null的时候，都应该抛出NullPointerException。</li>
<li>BlockingQueue主要应用于生产者与消费者的模型中，其元素的添加和获取都是极具规律性的。<br>使用 BlockingQueue 实现生产者消费者问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                queue.put(<span class="string">&quot;product&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;produce..&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="type">String</span> <span class="variable">product</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;consume..&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..</span><br></pre></td></tr></table></figure>

<ol>
<li>ArrayBlockingQueue &amp; LinkedBlockingQueue<br>ArrayBlockingQueue由于其底层基于数组，并且在创建时指定存储的大小，在完成后就会立即在内存分配固定大小容量的数组元素，因此其存储通常有限，故其是一个“有界“的阻塞队列；<br>而LinkedBlockingQueue可以由用户指定最大存储容量，也可以无需指定，如果不指定则最大存储容量将是Integer.MAX_VALUE，即可以看作是一个“无界”的阻塞队列，由于其节点的创建都是动态创建，并且在节点出队列后可以被GC所回收，因此其具有灵活的伸缩性。但是由于ArrayBlockingQueue的有界性，因此其能够更好的对于性能进行预测，而LinkedBlockingQueue由于没有限制大小，当任务非常多的时候，不停地向队列中存储，就有可能导致内存溢出的情况发生。<br>其次，ArrayBlockingQueue中在入队列和出队列操作过程中，使用的是同一个lock，所以即使在多核CPU的情况下，其读取和操作的都无法做到并行，而LinkedBlockingQueue的读取和插入操作所使用的锁是两个不同的lock，它们之间的操作互相不受干扰，因此两种操作可以并行完成，故LinkedBlockingQueue的吞吐量要高于ArrayBlockingQueue。</li>
<li>选择LinkedBlockingQueue 的理由</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        下面的代码是Executors创建固定大小线程池的代码，其使用了</span></span><br><span class="line"><span class="comment">        LinkedBlockingQueue来作为任务队列。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>JDK中选用LinkedBlockingQueue作为阻塞队列的原因就在于其无界性。因为线程大小固定的线程池，其线程的数量是不具备伸缩性的，当任务非常繁忙的时候，就势必会导致所有的线程都处于工作状态，如果使用一个有界的阻塞队列来进行处理，那么就非常有可能很快导致队列满的情况发生，从而导致任务无法提交而抛出RejectedExecutionException，而使用无界队列由于其良好的存储容量的伸缩性，可以很好的去缓冲任务繁忙情况下场景，即使任务非常多，也可以进行动态扩容，当任务被处理完成之后，队列中的节点也会被随之被GC回收，非常灵活。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>[Java并发集合 —— ConcurrentHashMap][Java_ _ ConcurrentHashMap]<br>利用CAS+Synchronized来保证并发更新的安全，底层依然采用数组+链表+红黑树的存储结构。<br><img src="https://mark.cuckooing.cn/pics/pic_60251108.png" alt="pic_60251108.png"><br>put操作<br>假设table已经初始化完成，put操作采用CAS+synchronized实现并发插入或更新操作，具体实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        ...省略部分代码</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）使用hash算法，并在table中定位索引位置（n 为table大小）<br>（2）获取table中对应索引的元素f。</p>
<ol>
<li>如果f为null，说明table中这个位置第一次插入元素，利用Unsafe.compareAndSwapObject方法插入Node节点。</li>
</ol>
<ul>
<li>如果CAS成功，说明Node节点已经插入，随后addCount(1L, binCount)方法会检查当前容量是否需要进行扩容。<br>如果CAS失败，说明有其它线程提前插入了节点，自旋重新尝试在这个位置插入节点。</li>
</ul>
<ol>
<li>如果f的hash值为-1，说明当前f是ForwardingNode节点，意味有其它线程正在扩容，则一起进行扩容操作。</li>
<li>其余情况把新的Node节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发。</li>
</ol>
<h2 id="多线程开发良好的实践"><a href="#多线程开发良好的实践" class="headerlink" title="多线程开发良好的实践"></a>多线程开发良好的实践</h2><ul>
<li>给线程起个有意义的名字，这样可以方便找 Bug。</li>
<li>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</li>
<li>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</li>
<li>使用 BlockingQueue 实现生产者消费者问题。</li>
<li>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</li>
<li>使用本地变量和不可变类来保证线程安全。</li>
<li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li>
</ul>
<h2 id="实例-——-多线程断点续传"><a href="#实例-——-多线程断点续传" class="headerlink" title="实例 —— 多线程断点续传"></a>实例 —— 多线程断点续传</h2><p>（一）多线程下载</p>
<ol>
<li>原理<br>多线程断点续传是把整个文件分割成几个部分，每个部分由一条线程执行下载，而每一条下载线程都要实现断点续传功能。多线程下载模型：<br><img src="https://mark.cuckooing.cn/pics/pic_d34a1a08.png" alt="pic_d34a1a08.png"><br>在多线程断点续传下载中，有一点需要特别注意： 由于文件是分成多个部分是被不同的线程的同时下载的，这就需要，每一条线程都分别需要有一个断点记录，和一个线程完成状态的记录；<br><img src="https://mark.cuckooing.cn/pics/pic_0a3c155d.png" alt="pic_0a3c155d.png"><br>只有所有线程的下载状态都处于完成状态时，才能表示文件已经下载完成。<br>多线程下载核心逻辑：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取文件总大小，进行分割，并计算文件的开始位置和结束位置</span><br><span class="line">fileLength = httpURLconnection.getContentLength();</span><br><span class="line">每一条线程下载大小 = fileLength / THREAD_NUM;</span><br></pre></td></tr></table></figure>

<p>（二）多线程断点续传<br>所谓断点续传就是从停止的地方重新下载。</p>
<ul>
<li>断点：线程停止的位置。即，当前线程已经下载完成的数据长度。</li>
<li>续传：从停止的位置重新下载。即，向服务器请求上次线程停止位置之后的数据。</li>
</ul>
<p>实现：每当线程停止时就把已下载的数据长度写入记录文件，当重新下载时，从记录文件读取已经下载了的长度。而这个长度就是所需要的断点。<br>断点续传核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">每次下载前从文件中获取需要的断点</span><br><span class="line">lastPositionStr = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>().readLine(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fileInputStream));</span><br><span class="line">通过设置网络参数，请求服务器从指定的位置开始读取数据。</span><br><span class="line">conn.setRequestProperty(<span class="string">&quot;Range&quot;</span>, <span class="string">&quot;bytes=&quot;</span> + startIndex + <span class="string">&quot;-&quot;</span> + endIndex);</span><br><span class="line">获取到下载数据时，还需要将数据写入文件，而普通发File对象并不提供从指定位置写入数据的功能，这个时候，就需要使用到RandomAccessFile来实现从指定位置给文件写入数据的功能。</span><br><span class="line">raFile.seek(<span class="number">100</span>);</span><br><span class="line">raf.write(buffer,<span class="number">0</span>,length);</span><br></pre></td></tr></table></figure>

<p>（三）多线程断点续传实现<br>MultiDownLoad.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiDownLoad</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1. 定义下载路径</span></span><br><span class="line">	<span class="keyword">static</span> <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;http://127.0.0.1:8080/img/test.jpg&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;<span class="comment">//假设开3个线程</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2. 获取服务器文件的大小，计算每个线程下载的开始位置和结束位置</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(path);</span><br><span class="line">			<span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">			conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>); <span class="comment">// 发送GET请求</span></span><br><span class="line">			conn.setConnectTimeout(<span class="number">5000</span>); <span class="comment">// 设置网络超时时间</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> conn.getResponseCode();</span><br><span class="line">			<span class="keyword">if</span>(code == <span class="number">200</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">				<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> conn.getContentLength(); <span class="comment">// 获取服务器文件的大小</span></span><br><span class="line">				<span class="comment">// 3. 创建一个大小和服务器一样的文件，目的是申请出空间</span></span><br><span class="line">				<span class="comment">// RandomAccessFile 支持随机访问文件的读取和写入</span></span><br><span class="line">				<span class="comment">// 随机访问文件的行为类似存储在文件系统中的一个大型byte数组。存在指向该隐含数组的光标或索引，称为文件索引。</span></span><br><span class="line">				<span class="comment">// seek(long pos) 设置到此文件开头测量到的文件指针偏移量，在该位置发生下一个读取或写入操作</span></span><br><span class="line">				<span class="type">RandomAccessFile</span> <span class="variable">rafAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test_download.jpg&quot;</span>,<span class="string">&quot;rw&quot;</span>); <span class="comment">// 创建文件，用读写方式打开</span></span><br><span class="line">				rafAccessFile.setLength(length);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 3.计算每个线程下载的开始位置和结束位置</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">blockSize</span> <span class="operator">=</span> length/threadCount;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadCount;i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">					<span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> i * blockSize; <span class="comment">// 每个线程下载开始位置</span></span><br><span class="line">					<span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> (i+<span class="number">1</span>)*blockSize;</span><br><span class="line">					<span class="keyword">if</span>(i == threadCount-<span class="number">1</span>) endIndex = length -<span class="number">1</span>;<span class="comment">// 每个线程下载的结束位置（最后一个线程特殊处理）</span></span><br><span class="line">					<span class="comment">// 4.开启线程去服务器下载文件</span></span><br><span class="line">					<span class="type">DownLoadThread</span> <span class="variable">downLoadThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DownLoadThread</span>(i+<span class="number">1</span>,startIndex,endIndex);</span><br><span class="line">					downLoadThread.start();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     e.printStackTrace();&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DownloadThread.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownLoadThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> threadId;	<span class="comment">// 线程I</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> startIndex;	<span class="comment">// 开始位置</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> endIndex;	<span class="comment">// 结束位置</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">DownLoadThread</span><span class="params">( <span class="type">int</span> threadId,<span class="type">int</span> startIndex,<span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="built_in">this</span>.threadId = threadId;</span><br><span class="line">		<span class="built_in">this</span>.startIndex = startIndex;</span><br><span class="line">		<span class="built_in">this</span>.endIndex = endIndex;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义线程去服务器下载文件</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			<span class="type">URL</span> 	<span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(MultiDownLoad.path);</span><br><span class="line">			<span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">			conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>); <span class="comment">// 发送GET请求</span></span><br><span class="line">			conn.setConnectTimeout(<span class="number">5000</span>); <span class="comment">// 设置网络超时时间</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> conn.getResponseCode();</span><br><span class="line">			<span class="comment">// 如果中间被中断，则从上一次下载的位置重新下载</span></span><br><span class="line">			<span class="comment">// 从文件中读取上次下载的位置</span></span><br><span class="line">			<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(threadId+<span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(file.exists() &amp;&amp; file.length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">				<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">				<span class="type">BufferedReader</span> <span class="variable">bufr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis));</span><br><span class="line">				<span class="type">String</span> <span class="variable">lastPositionStr</span> <span class="operator">=</span> bufr.readLine();</span><br><span class="line">				<span class="type">int</span> <span class="variable">lastPosition</span> <span class="operator">=</span> Integer.parseInt(lastPositionStr);</span><br><span class="line">				System.out.println(<span class="string">&quot;当前线程&quot;</span>+threadId+<span class="string">&quot;下载的位置:&quot;</span>+lastPosition);</span><br><span class="line">				<span class="comment">// 更改startIndex位置（加载位置从上一次下载的位置开始）</span></span><br><span class="line">				startIndex = lastPosition;</span><br><span class="line">				fis.close();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// *多线程下载的核心</span></span><br><span class="line">			<span class="comment">// 设置一个请求头Range,告诉服务器每个线程下载的开始位置和结束位置</span></span><br><span class="line">			conn.setRequestProperty(<span class="string">&quot;Range&quot;</span>, <span class="string">&quot;bytes=&quot;</span>+startIndex+<span class="string">&quot;-&quot;</span>+endIndex);</span><br><span class="line">			<span class="keyword">if</span>(code == <span class="number">206</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">				<span class="comment">// 返回值200 请求获取服务器全部资源成功</span></span><br><span class="line">				<span class="comment">// 返回值206 请求部分资源成功</span></span><br><span class="line">				<span class="comment">// 创建随机读写文件对象</span></span><br><span class="line">				<span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test_download.jpg&quot;</span>,<span class="string">&quot;rw&quot;</span>); <span class="comment">// 创建文件，用读写方式打开</span></span><br><span class="line">				<span class="comment">// 每个线程从自己的开始位置开始写</span></span><br><span class="line">				raf.seek(startIndex);</span><br><span class="line">				<span class="comment">// 获取的是文件 [startIndex..endIndex]</span></span><br><span class="line">				<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> conn.getInputStream();</span><br><span class="line">				<span class="comment">// 将数据写入文件中</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">				<span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">				<span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 当前线程下载的大小</span></span><br><span class="line">				<span class="keyword">while</span>((length = in.read(buffer))!=-<span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">					raf.write(buffer,<span class="number">0</span>,length);</span><br><span class="line">					<span class="comment">// * 实现断点续传的核心 </span></span><br><span class="line">					<span class="comment">// 把当前线程下载的位置存起来，下次下载时按照上次下载的位置继续下载</span></span><br><span class="line">					<span class="comment">// 将当前下载位置存入txt文本</span></span><br><span class="line">					total += length;</span><br><span class="line">					<span class="type">int</span> <span class="variable">currentThreadPosition</span> <span class="operator">=</span> startIndex + total;</span><br><span class="line">					<span class="type">RandomAccessFile</span> <span class="variable">raf_position</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(threadId+<span class="string">&quot;.txt&quot;</span>,<span class="string">&quot;rwd&quot;</span>);<span class="comment">// 可直接同步数据到底层硬盘</span></span><br><span class="line">					raf_position.write(String.valueOf(currentThreadPosition).getBytes());</span><br><span class="line">					raf_position.close();</span><br><span class="line">				&#125; </span><br><span class="line">				raf.close(); <span class="comment">// 关闭流 释放资源</span></span><br><span class="line">				System.out.println(<span class="string">&quot;线程&quot;</span> + threadId + <span class="string">&quot;:下载完成&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（三）优雅的实现<br><img src="https://mark.cuckooing.cn/pics/pic_54e2a2b4.png" alt="pic_54e2a2b4.png"><br>IDownloadListener.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.arialyy.frame.http.inf;</span><br><span class="line">    <span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 在这里面编写你的业务逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDownloadListener</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 取消下载</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCancel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下载失败</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFail</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下载预处理,可通过HttpURLConnection获取文件长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPreDownload</span><span class="params">(HttpURLConnection connection)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下载监听</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProgress</span><span class="params">(<span class="type">long</span> currentLocation)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 单一线程的结束位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChildComplete</span><span class="params">(<span class="type">long</span> finishLocation)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 开始</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="type">long</span> startLocation)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 子程恢复下载的位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChildResume</span><span class="params">(<span class="type">long</span> resumeLocation)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 恢复位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">(<span class="type">long</span> resumeLocation)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 停止</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="type">long</span> stopLocation)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下载完成</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该类是下载监听接口<br>DownloadListener.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownloadListener</span> <span class="keyword">implements</span> <span class="title class_">IDownloadListener</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">(<span class="type">long</span> resumeLocation)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCancel</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFail</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPreDownload</span><span class="params">(HttpURLConnection connection)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProgress</span><span class="params">(<span class="type">long</span> currentLocation)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChildComplete</span><span class="params">(<span class="type">long</span> finishLocation)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="type">long</span> startLocation)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChildResume</span><span class="params">(<span class="type">long</span> resumeLocation)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(<span class="type">long</span> stopLocation)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">下载参数实体</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子线程下载信息类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DownloadEntity</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//文件总长度</span></span><br><span class="line">        <span class="type">long</span> fileSize;</span><br><span class="line">        <span class="comment">//下载链接</span></span><br><span class="line">        String downloadUrl;</span><br><span class="line">        <span class="comment">//线程Id</span></span><br><span class="line">        <span class="type">int</span> threadId;</span><br><span class="line">        <span class="comment">//起始下载位置</span></span><br><span class="line">        <span class="type">long</span> startLocation;</span><br><span class="line">        <span class="comment">//结束下载的文章</span></span><br><span class="line">        <span class="type">long</span> endLocation;</span><br><span class="line">        <span class="comment">//下载文件</span></span><br><span class="line">        File tempFile;</span><br><span class="line">        Context context;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DownloadEntity</span><span class="params">(Context context, <span class="type">long</span> fileSize, String downloadUrl, File file, <span class="type">int</span> threadId, <span class="type">long</span> startLocation, <span class="type">long</span> endLocation)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="built_in">this</span>.fileSize = fileSize;</span><br><span class="line">            <span class="built_in">this</span>.downloadUrl = downloadUrl;</span><br><span class="line">            <span class="built_in">this</span>.tempFile = file;</span><br><span class="line">            <span class="built_in">this</span>.threadId = threadId;</span><br><span class="line">            <span class="built_in">this</span>.startLocation = startLocation;</span><br><span class="line">            <span class="built_in">this</span>.endLocation = endLocation;</span><br><span class="line">            <span class="built_in">this</span>.context = context;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该类是下载信息配置类，每一条子线程的下载都需要一个下载实体来配置下载信息。<br>下载任务线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程下载任务类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DownLoadTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;DownLoadTask&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> DownloadEntity dEntity;</span><br><span class="line">        <span class="keyword">private</span> String configFPath;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DownLoadTask</span><span class="params">(DownloadEntity downloadInfo)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="built_in">this</span>.dEntity = downloadInfo;</span><br><span class="line">            configFPath = dEntity.context.getFilesDir().getPath() + <span class="string">&quot;/temp/&quot;</span> + dEntity.tempFile.getName() + <span class="string">&quot;.properties&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                L.d(TAG, <span class="string">&quot;线程_&quot;</span> + dEntity.threadId + <span class="string">&quot;_正在下载【&quot;</span> + <span class="string">&quot;开始位置 : &quot;</span> + dEntity.startLocation + <span class="string">&quot;，结束位置：&quot;</span> + dEntity.endLocation + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(dEntity.downloadUrl);</span><br><span class="line">                <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">                <span class="comment">//在头里面请求下载开始位置和结束位置</span></span><br><span class="line">                conn.setRequestProperty(<span class="string">&quot;Range&quot;</span>, <span class="string">&quot;bytes=&quot;</span> + dEntity.startLocation + <span class="string">&quot;-&quot;</span> + dEntity.endLocation);</span><br><span class="line">                conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">                conn.setRequestProperty(<span class="string">&quot;Charset&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                conn.setConnectTimeout(TIME_OUT);</span><br><span class="line">                conn.setRequestProperty(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.2; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)&quot;</span>);</span><br><span class="line">                conn.setRequestProperty(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/x-shockwave-flash, application/xaml+xml, application/vnd.ms-xpsdocument, application/x-ms-xbap, application/x-ms-application, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*&quot;</span>);</span><br><span class="line">                conn.setReadTimeout(<span class="number">2000</span>);  <span class="comment">//设置读取流的等待时间,必须设置该参数</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> conn.getInputStream();</span><br><span class="line">                <span class="comment">//创建可设置位置的文件</span></span><br><span class="line">                <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(dEntity.tempFile, <span class="string">&quot;rwd&quot;</span>);</span><br><span class="line">                <span class="comment">//设置每条线程写入文件的位置</span></span><br><span class="line">                file.seek(dEntity.startLocation);</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> len;</span><br><span class="line">                <span class="comment">//当前子线程的下载位置</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">currentLocation</span> <span class="operator">=</span> dEntity.startLocation;</span><br><span class="line">                <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">if</span> (isCancel) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        L.d(TAG, <span class="string">&quot;++++++++++ thread_&quot;</span> + dEntity.threadId + <span class="string">&quot;_cancel ++++++++++&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//把下载数据数据写入文件</span></span><br><span class="line">                    file.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                    <span class="keyword">synchronized</span> (DownLoadUtil.<span class="built_in">this</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        mCurrentLocation += len;</span><br><span class="line">                        mListener.onProgress(mCurrentLocation);</span><br><span class="line">                    &#125;</span><br><span class="line">                    currentLocation += len;</span><br><span class="line">                &#125;</span><br><span class="line">                file.close();</span><br><span class="line">                is.close();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isCancel) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">synchronized</span> (DownLoadUtil.<span class="built_in">this</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        mCancelNum++;</span><br><span class="line">                        <span class="keyword">if</span> (mCancelNum == THREAD_NUM) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                            <span class="type">File</span> <span class="variable">configFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(configFPath);</span><br><span class="line">                            <span class="keyword">if</span> (configFile.exists()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                                configFile.delete();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (dEntity.tempFile.exists()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                                dEntity.tempFile.delete();</span><br><span class="line">                            &#125;</span><br><span class="line">                            L.d(TAG, <span class="string">&quot;++++++++++++++++ onCancel +++++++++++++++++&quot;</span>);</span><br><span class="line">                            isDownloading = <span class="literal">false</span>;</span><br><span class="line">                            mListener.onCancel();</span><br><span class="line">                            System.gc();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//停止状态不需要删除记录文件</span></span><br><span class="line">                <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">synchronized</span> (DownLoadUtil.<span class="built_in">this</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        mStopNum++;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> String.valueOf(currentLocation);</span><br><span class="line">                        L.i(TAG, <span class="string">&quot;thread_&quot;</span> + dEntity.threadId + <span class="string">&quot;_stop, stop location ==&gt; &quot;</span> + currentLocation);</span><br><span class="line">                        writeConfig(dEntity.tempFile.getName() + <span class="string">&quot;_record_&quot;</span> + dEntity.threadId, location);</span><br><span class="line">                        <span class="keyword">if</span> (mStopNum == THREAD_NUM) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                            L.d(TAG, <span class="string">&quot;++++++++++++++++ onStop +++++++++++++++++&quot;</span>);</span><br><span class="line">                            isDownloading = <span class="literal">false</span>;</span><br><span class="line">                            mListener.onStop(mCurrentLocation);</span><br><span class="line">                            System.gc();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                L.i(TAG, <span class="string">&quot;线程【&quot;</span> + dEntity.threadId + <span class="string">&quot;】下载完毕&quot;</span>);</span><br><span class="line">                writeConfig(dEntity.tempFile.getName() + <span class="string">&quot;_state_&quot;</span> + dEntity.threadId, <span class="number">1</span> + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                mListener.onChildComplete(dEntity.endLocation);</span><br><span class="line">                mCompleteThreadNum++;</span><br><span class="line">                <span class="keyword">if</span> (mCompleteThreadNum == THREAD_NUM) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    <span class="type">File</span> <span class="variable">configFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(configFPath);</span><br><span class="line">                    <span class="keyword">if</span> (configFile.exists()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        configFile.delete();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mListener.onComplete();</span><br><span class="line">                    isDownloading = <span class="literal">false</span>;</span><br><span class="line">                    System.gc();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                isDownloading = <span class="literal">false</span>;</span><br><span class="line">                mListener.onFail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                FL.e(<span class="built_in">this</span>, <span class="string">&quot;下载失败【&quot;</span> + dEntity.downloadUrl + <span class="string">&quot;】&quot;</span> + FL.getPrintException(e));</span><br><span class="line">                isDownloading = <span class="literal">false</span>;</span><br><span class="line">                mListener.onFail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                FL.e(<span class="built_in">this</span>, <span class="string">&quot;获取流失败&quot;</span> + FL.getPrintException(e));</span><br><span class="line">                isDownloading = <span class="literal">false</span>;</span><br><span class="line">                mListener.onFail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这个是每条下载子线程的下载任务类，子线程通过下载实体对每一条线程进行下载配置，由于在多断点续传的概念里，停止表示的是暂停状态，而恢复表示的是线程从记录的断点重新进行下载，所以，线程处于停止状态时是不能删除记录文件的。<br>下载入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多线程断点续传下载文件，暂停和继续</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context          必须添加该参数，不能使用全局变量的context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> downloadUrl      下载路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath         保存路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> downloadListener 下载进度监听 &#123;<span class="doctag">@link</span> DownloadListener&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(<span class="keyword">final</span> Context context, <span class="meta">@NonNull</span> <span class="keyword">final</span> String downloadUrl, <span class="meta">@NonNull</span> <span class="keyword">final</span> String filePath,</span></span><br><span class="line"><span class="params">                         <span class="meta">@NonNull</span> <span class="keyword">final</span> DownloadListener downloadListener)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        isDownloading = <span class="literal">true</span>;</span><br><span class="line">        mCurrentLocation = <span class="number">0</span>;</span><br><span class="line">        isStop = <span class="literal">false</span>;</span><br><span class="line">        isCancel = <span class="literal">false</span>;</span><br><span class="line">        mCancelNum = <span class="number">0</span>;</span><br><span class="line">        mStopNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">File</span> <span class="variable">dFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        <span class="comment">//读取已完成的线程数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">File</span> <span class="variable">configFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(context.getFilesDir().getPath() + <span class="string">&quot;/temp/&quot;</span> + dFile.getName() + <span class="string">&quot;.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (!configFile.exists()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">      <span class="comment">//记录文件被删除，则重新下载</span></span><br><span class="line">                newTask = <span class="literal">true</span>;</span><br><span class="line">                FileUtil.createFile(configFile.getPath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                newTask = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            mListener.onFail();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        newTask = !dFile.exists();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    mListener = downloadListener;</span><br><span class="line">                    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(downloadUrl);</span><br><span class="line">                    <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">                    conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">                    conn.setRequestProperty(<span class="string">&quot;Charset&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    conn.setConnectTimeout(TIME_OUT);</span><br><span class="line">                    conn.setRequestProperty(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.2; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)&quot;</span>);</span><br><span class="line">                    conn.setRequestProperty(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/x-shockwave-flash, application/xaml+xml, application/vnd.ms-xpsdocument, application/x-ms-xbap, application/x-ms-application, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*&quot;</span>);</span><br><span class="line">                    conn.connect();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> conn.getContentLength();</span><br><span class="line">                    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       <span class="comment">//网络被劫持时会出现这个问题</span></span><br><span class="line">                        mListener.onFail();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> conn.getResponseCode();</span><br><span class="line">                    <span class="keyword">if</span> (code == <span class="number">200</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        <span class="type">int</span> <span class="variable">fileLength</span> <span class="operator">=</span> conn.getContentLength();</span><br><span class="line">                        <span class="comment">//必须建一个文件</span></span><br><span class="line">                        FileUtil.createFile(filePath);</span><br><span class="line">                        <span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(filePath, <span class="string">&quot;rwd&quot;</span>);</span><br><span class="line">                        <span class="comment">//设置文件长度</span></span><br><span class="line">                        file.setLength(fileLength);</span><br><span class="line">                        mListener.onPreDownload(conn);</span><br><span class="line">                        <span class="comment">//分配每条线程的下载区间</span></span><br><span class="line">                        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                        pro = Util.loadConfig(configFile);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">blockSize</span> <span class="operator">=</span> fileLength / THREAD_NUM;</span><br><span class="line">                        SparseArray&lt;Thread&gt; tasks = <span class="keyword">new</span> <span class="title class_">SparseArray</span>&lt;&gt;();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_NUM; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                            <span class="type">long</span> <span class="variable">startL</span> <span class="operator">=</span> i * blockSize, endL = (i + <span class="number">1</span>) * blockSize;</span><br><span class="line">                            <span class="type">Object</span> <span class="variable">state</span> <span class="operator">=</span> pro.getProperty(dFile.getName() + <span class="string">&quot;_state_&quot;</span> + i);</span><br><span class="line">                            <span class="keyword">if</span> (state != <span class="literal">null</span> &amp;&amp; Integer.parseInt(state + <span class="string">&quot;&quot;</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">       <span class="comment">//该线程已经完成</span></span><br><span class="line">                                mCurrentLocation += endL - startL;</span><br><span class="line">                                L.d(TAG, <span class="string">&quot;++++++++++ 线程_&quot;</span> + i + <span class="string">&quot;_已经下载完成 ++++++++++&quot;</span>);</span><br><span class="line">                                mCompleteThreadNum++;</span><br><span class="line">                                <span class="keyword">if</span> (mCompleteThreadNum == THREAD_NUM) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                                    <span class="keyword">if</span> (configFile.exists()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                                        configFile.delete();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    mListener.onComplete();</span><br><span class="line">                                    isDownloading = <span class="literal">false</span>;</span><br><span class="line">                                    System.gc();</span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//分配下载位置</span></span><br><span class="line">                            <span class="type">Object</span> <span class="variable">record</span> <span class="operator">=</span> pro.getProperty(dFile.getName() + <span class="string">&quot;_record_&quot;</span> + i);</span><br><span class="line">                            <span class="keyword">if</span> (!newTask &amp;&amp; record != <span class="literal">null</span> &amp;&amp; Long.parseLong(record + <span class="string">&quot;&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//如果有记录，则恢复下载</span></span><br><span class="line">                                <span class="type">Long</span> <span class="variable">r</span> <span class="operator">=</span> Long.parseLong(record + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                                mCurrentLocation += r - startL;</span><br><span class="line">                                L.d(TAG, <span class="string">&quot;++++++++++ 线程_&quot;</span> + i + <span class="string">&quot;_恢复下载 ++++++++++&quot;</span>);</span><br><span class="line">                                mListener.onChildResume(r);</span><br><span class="line">                                startL = r;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (i == (THREAD_NUM - <span class="number">1</span>)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                                endL = fileLength;<span class="comment">//如果整个文件的大小不为线程个数的整数倍，则最后一个线程的结束位置即为文件的总长度</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="type">DownloadEntity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DownloadEntity</span>(context, fileLength, downloadUrl, dFile, i, startL, endL);</span><br><span class="line">                            <span class="type">DownLoadTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DownLoadTask</span>(entity);</span><br><span class="line">                            tasks.put(i, <span class="keyword">new</span> <span class="title class_">Thread</span>(task));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (mCurrentLocation &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                            mListener.onResume(mCurrentLocation);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                            mListener.onStart(mCurrentLocation);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, count = tasks.size(); i &lt; count; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                            <span class="type">Thread</span> <span class="variable">task</span> <span class="operator">=</span> tasks.get(i);</span><br><span class="line">                            <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                                task.start();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                        FL.e(TAG, <span class="string">&quot;下载失败，返回码：&quot;</span> + code);</span><br><span class="line">                        isDownloading = <span class="literal">false</span>;</span><br><span class="line">                        System.gc();</span><br><span class="line">                        mListener.onFail();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                    FL.e(<span class="built_in">this</span>, <span class="string">&quot;下载失败【downloadUrl:&quot;</span> + downloadUrl + <span class="string">&quot;】\n【filePath:&quot;</span> + filePath + <span class="string">&quot;】&quot;</span> + FL.getPrintException(e));</span><br><span class="line">                    isDownloading = <span class="literal">false</span>;</span><br><span class="line">                    mListener.onFail();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意两点</p>
<ul>
<li>恢复下载时：已下载的文件大小 &#x3D; 该线程的上一次断点的位置 - 该线程起始下载位置；</li>
<li>为了保证下载文件的完整性，只要记录文件不存在就需要重新进行下载；</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.wuleizhenshang.love">无泪真伤</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.wuleizhenshang.love/2025/01/03/java%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/">https://www.wuleizhenshang.love/2025/01/03/java%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.wuleizhenshang.love" target="_blank">Blog-无泪真伤</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2025/01/03/K2M9njOwagHpfIs.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/03/android%E6%8F%90%E9%97%AE200%E9%81%93/" title="Android提问问答"><img class="cover" src="https://s2.loli.net/2025/01/03/tPiv5zLXgsfGWmn.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android提问问答</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/" title="程序员面试金典（Java代码）"><img class="cover" src="https://pic.imgdb.cn/item/67487ddcd0e0a243d4da7860.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">程序员面试金典（Java代码）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/09/16/Leecode%E5%8A%9B%E6%89%A3%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/" title="Leecode面试经典150题"><img class="cover" src="https://s2.loli.net/2024/09/16/JTzk8CZGW7vjXor.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-16</div><div class="title">Leecode面试经典150题</div></div></a></div><div><a href="/2025/01/03/android%E6%8F%90%E9%97%AE200%E9%81%93/" title="Android提问问答"><img class="cover" src="https://s2.loli.net/2025/01/03/tPiv5zLXgsfGWmn.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-03</div><div class="title">Android提问问答</div></div></a></div><div><a href="/2025/01/03/android%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/" title="Android知识秘籍"><img class="cover" src="https://s2.loli.net/2025/01/03/gw4uYQMBloWir5K.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-03</div><div class="title">Android知识秘籍</div></div></a></div><div><a href="/2025/01/25/Leetcode%20CookBook%E7%AE%97%E6%B3%95/" title="Leetcode CookBook算法"><img class="cover" src="https://pic1.imgdb.cn/item/67948944d0e0a243d4f7c0f9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="title">Leetcode CookBook算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/65582252c458853aeff7c6f5.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">无泪真伤</div><div class="author-info__description">找寻自己所爱！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wuleizhenshang"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本人并非什么大佬！写博客纯属个人兴趣，记录一下个人学习经历而已，有错误请见谅！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">第一章 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象三大特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9this%E5%92%8Csuper%E7%9A%84%E8%AE%A4%E8%AF%86%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">对this和super的认识？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">谈谈权限修饰符的特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9java%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3-Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">对java多态的理解 &#x2F;Java中实现多态的机制是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%9F%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%8F%88%E6%98%AF%E5%90%A6%E8%83%BD%E8%A2%AB%E9%87%8D%E5%86%99%E5%91%A2%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2String-%E6%95%B0%E7%BB%84-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">第二章 字符串String &amp; 数组 &amp; 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Java%E4%B8%AD%E7%9A%848%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E5%86%85%E5%AD%98%E4%B8%AD%E5%8D%A0%E6%9C%89%E7%9A%84%E5%AD%97%E8%8A%82-%E5%88%9D%E5%A7%8B%E5%80%BC%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">说说Java中的8大基本类型 &amp; 内存中占有的字节 &amp; 初始值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E9%81%93float%E5%92%8Cdouble%E7%B1%BB%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%83%85%E5%86%B5%E5%90%97%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">知道float和double类型为什么会出现精度丢失的情况吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%B0%81%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">JAVA基本数据类型与封装类型的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%86%E7%AE%B1-%E8%A3%85%E7%AE%B1%EF%BC%8C%E8%83%BD%E7%BB%99%E6%88%91%E4%B8%BE%E6%A0%97%E5%AD%90%E5%90%97%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">什么是拆箱 &amp; 装箱，能给我举栗子吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E8%AF%B4%E8%AF%B4%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%8A%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">能说说多维数组在内存上是怎么存储的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E6%95%B0%E7%BB%84%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85%E8%BF%87%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4%E5%B0%81%E8%A3%85%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">你对数组二次封装过吗？说说封装了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">2.7.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">2.7.1.</span> <span class="toc-text">原理 &amp; 不可变性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-StringBuilder-StringBuffer"><span class="toc-number">2.7.2.</span> <span class="toc-text">String &amp;&amp; StringBuilder &amp;&amp; StringBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8"><span class="toc-number">2.7.3.</span> <span class="toc-text">内存中存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B9%E5%BC%8F-%E6%AF%94%E8%BE%83"><span class="toc-number">2.7.4.</span> <span class="toc-text">字符串拼接方式 &amp; 比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-a-%E2%80%9Ca%E2%80%9D-%E2%80%9Cb%E2%80%9D-%E2%80%9Cc%E2%80%9D-%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.7.5.</span> <span class="toc-text">String a &#x3D; “a”+“b”+“c”;在内存中创建了几个对象？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%89%B9%E6%80%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">3.</span> <span class="toc-text">第三章 Java特性与基本语法(1)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Objct%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">Objct通用方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-equals"><span class="toc-number">3.1.1.</span> <span class="toc-text">Object.equals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-hashCode"><span class="toc-number">3.1.2.</span> <span class="toc-text">Object.hashCode()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-toString"><span class="toc-number">3.1.3.</span> <span class="toc-text">Object.toString()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-clone"><span class="toc-number">3.1.4.</span> <span class="toc-text">Object.clone()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.2.</span> <span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serializable%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.1.</span> <span class="toc-text">Serializable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#transient-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">transient 关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parcelable%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.2.</span> <span class="toc-text">Parcelable接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%BC%82%E5%B8%B8"><span class="toc-number">3.4.</span> <span class="toc-text">Java 异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%BC%82%E5%B8%B8%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.4.1.</span> <span class="toc-text">Java 异常关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">3.4.2.</span> <span class="toc-text">Java 异常体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Java%E5%BC%82%E5%B8%B8"><span class="toc-number">3.4.3.</span> <span class="toc-text">自定义Java异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%89%B9%E6%80%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="toc-number">4.</span> <span class="toc-text">第三章 Java特性与基本语法(2)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">4.1.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-%E5%8A%9F%E8%83%BD-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.1.</span> <span class="toc-text">简介 &amp; 功能 &amp; 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Java%E5%8F%8D%E5%B0%84%E6%9F%A5%E7%9C%8B%E7%B1%BB%E4%BF%A1%E6%81%AF"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">通过Java反射查看类信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Java%E5%8F%8D%E5%B0%84%E7%94%9F%E6%88%90%E5%B9%B6%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">通过Java反射生成并操作对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-%E4%B8%8E-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">4.1.3.</span> <span class="toc-text">Java反射机制 与 动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-%E4%B8%8E-%E6%B3%9B%E5%9E%8B"><span class="toc-number">4.1.4.</span> <span class="toc-text">Java反射机制 与 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.1.5.</span> <span class="toc-text">反射在项目中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%95%88%E7%8E%87%E4%BD%8E-%E5%8E%9F%E5%9B%A0-%E8%A7%A3%E5%86%B3"><span class="toc-number">4.1.6.</span> <span class="toc-text">反射效率低 原因 &amp; 解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%EF%BC%88Annotation%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">注解（Annotation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">4.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.2.</span> <span class="toc-text">工作机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK%E6%B3%A8%E8%A7%A3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.2.3.</span> <span class="toc-text">JDK注解 &#x2F; 自定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.2.4.</span> <span class="toc-text">如何解析注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88IOC%EF%BC%89-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">控制反转（IOC）&#x2F;依赖注入（DI）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ButterKnife%E7%94%A8%E6%B3%95-%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">4.3.1.</span> <span class="toc-text">ButterKnife用法 &amp; 原理？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">第四章 抽象类与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">抽象类&amp;接口？区别？优缺点？适用场景？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-JVM%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">第五章 JVM、垃圾回收（GC）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">Java代码执行流程&#x2F;Java虚拟机工作原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">Java内存结构 &#x2F; 运行时数据区域？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-%E5%92%8C-%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">6.3.</span> <span class="toc-text">对象的创建、内存布局 和 访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">6.3.1.</span> <span class="toc-text">对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">6.3.2.</span> <span class="toc-text">对象的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">6.3.3.</span> <span class="toc-text">对象的访问定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">6.4.</span> <span class="toc-text">类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFclass%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-number">6.4.1.</span> <span class="toc-text">什么是class文件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-1"><span class="toc-number">6.4.2.</span> <span class="toc-text">类加载机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.4.3.</span> <span class="toc-text">类的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.4.4.</span> <span class="toc-text">触发类加载的条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-number">6.4.5.</span> <span class="toc-text">类加载的具体过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">6.4.6.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">6.4.6.1.</span> <span class="toc-text">类加载器分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.4.6.2.</span> <span class="toc-text">双亲委派模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">6.5.</span> <span class="toc-text">垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%BC%9A%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%A4%84%E7%90%86%E6%8E%89%EF%BC%9F"><span class="toc-number">6.5.1.</span> <span class="toc-text">如何判断对象是否会被垃圾回收机制处理掉？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Java%E7%A7%8D%E7%9A%844%E7%A7%8D%E5%BC%95%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="toc-number">6.5.2.</span> <span class="toc-text">说说Java种的4种引用以及用法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">6.5.3.</span> <span class="toc-text">GC回收算法有哪些？优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">6.5.4.</span> <span class="toc-text">GC回收机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91%E7%9A%84%EF%BC%9F"><span class="toc-number">6.5.5.</span> <span class="toc-text">GC是什么时候触发的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9F"><span class="toc-number">6.5.6.</span> <span class="toc-text">垃圾收集器？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95"><span class="toc-number">6.6.</span> <span class="toc-text">面试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.6.1.</span> <span class="toc-text">对象的生命周期?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88static%E5%85%B3%E9%94%AE%E5%AD%97-%E8%B0%88%E8%B0%88static%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%9A%84%EF%BC%9F"><span class="toc-number">6.6.2.</span> <span class="toc-text">谈谈static关键字&#x2F;谈谈static编译运行时的流程，在虚拟机中如何保存的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-Java%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">第六章 Java容器类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">7.1.</span> <span class="toc-text">Java 集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E9%9B%86%E5%90%88%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">7.1.1.</span> <span class="toc-text">Java 集合类继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E9%9B%86%E5%90%88%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.2.</span> <span class="toc-text">Java 集合类简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection-%EF%BC%88Interface%EF%BC%89"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">Collection （Interface）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map-%EF%BC%88Interface%EF%BC%89"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">Map （Interface）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-number">7.2.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">7.2.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">7.2.3.</span> <span class="toc-text">源码解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E3%80%81HashSet%E3%80%81HashTable%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.4.</span> <span class="toc-text">HashMap、HashSet、HashTable区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95-1"><span class="toc-number">7.2.5.</span> <span class="toc-text">面试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">7.3.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">7.3.1.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList"><span class="toc-number">7.3.2.</span> <span class="toc-text">LinkedList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">7.4.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88Java%E9%9B%86%E5%90%88%E4%B8%AD%E9%82%A3%E4%BA%9B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">谈谈Java集合中那些线程安全的集合 &amp; 实现原理？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">第八章 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">8.1.</span> <span class="toc-text">语法糖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">什么是泛型？能解决什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BJava%E6%B3%9B%E5%9E%8B%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">说一下Java泛型工作机制？什么是类型擦除？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.4.</span> <span class="toc-text">泛型的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E9%9D%9E%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">什么是泛型中的限定通配符和非限定通配符？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-Java-I-O%E4%B8%8ENIO"><span class="toc-number">9.</span> <span class="toc-text">第九章 Java I&#x2F;O与NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO"><span class="toc-number">9.1.</span> <span class="toc-text">Java IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E4%B8%8E%E5%AD%97%E7%AC%A6"><span class="toc-number">9.1.1.</span> <span class="toc-text">字节与字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">9.1.1.1.</span> <span class="toc-text">Java 编码格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File%E7%B1%BB"><span class="toc-number">9.1.2.</span> <span class="toc-text">File类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RandomAccessFile"><span class="toc-number">9.1.2.1.</span> <span class="toc-text">RandomAccessFile</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">9.1.3.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%B5%81-%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.3.1.</span> <span class="toc-text">IO流 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%B5%81-%E5%88%86%E7%B1%BB"><span class="toc-number">9.1.3.2.</span> <span class="toc-text">IO流 分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%B5%81-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%B1%BB"><span class="toc-number">9.1.3.3.</span> <span class="toc-text">IO流 四大基类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-NIO"><span class="toc-number">9.2.</span> <span class="toc-text">Java NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-%E7%AE%80%E4%BB%8B"><span class="toc-number">9.2.1.</span> <span class="toc-text">NIO 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">9.2.2.</span> <span class="toc-text">通道与缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">9.2.3.</span> <span class="toc-text">选择器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">第十章 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81-%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.1.</span> <span class="toc-text">线程状态 &amp; 转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B-3-%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">创建线程 3 种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.2.1.</span> <span class="toc-text">实现 Runnable 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-Callable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.2.2.</span> <span class="toc-text">实现 Callable 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB"><span class="toc-number">10.2.3.</span> <span class="toc-text">继承 Thread 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">10.3.</span> <span class="toc-text">互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized-%E7%B1%BB%EF%BC%88JVM%EF%BC%89"><span class="toc-number">10.3.1.</span> <span class="toc-text">Synchronized 类（JVM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-%E7%B1%BB%EF%BC%88JUC%EF%BC%89"><span class="toc-number">10.3.2.</span> <span class="toc-text">ReentrantLock 类（JUC）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E4%BD%9C"><span class="toc-number">10.4.</span> <span class="toc-text">协作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">10.4.1.</span> <span class="toc-text">join()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-%E3%80%81notify-%E3%80%81-notifyAll-%EF%BC%88%E7%BB%93%E5%90%88synchronized%EF%BC%89"><span class="toc-number">10.4.2.</span> <span class="toc-text">wait() 、notify()、 notifyAll()（结合synchronized）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await-%E3%80%81signal-%E3%80%81-signalAll-%EF%BC%88%E7%BB%93%E5%90%88Lock%EF%BC%89"><span class="toc-number">10.4.3.</span> <span class="toc-text">await() 、signal()、 signalAll()（结合Lock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85-%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.4.4.</span> <span class="toc-text">生产者&#x2F;消费者 模式实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC"><span class="toc-number">10.5.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">10.5.1.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore"><span class="toc-number">10.5.1.1.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">10.5.1.2.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">10.5.1.3.</span> <span class="toc-text">CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6"><span class="toc-number">10.5.2.</span> <span class="toc-text">其他组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FutureTask"><span class="toc-number">10.5.2.1.</span> <span class="toc-text">FutureTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ForkJoin"><span class="toc-number">10.5.2.2.</span> <span class="toc-text">ForkJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executor-ThreadPoolExecutor"><span class="toc-number">10.5.2.3.</span> <span class="toc-text">Executor &amp;&amp; ThreadPoolExecutor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.6.</span> <span class="toc-text">Java 内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%89%B9%E6%80%A7"><span class="toc-number">10.6.1.</span> <span class="toc-text">内存模型 &amp; 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volatile"><span class="toc-number">10.6.2.</span> <span class="toc-text">Volatile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">10.7.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">10.7.1.</span> <span class="toc-text">不可变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%EF%BC%88%E9%94%81%EF%BC%89"><span class="toc-number">10.7.2.</span> <span class="toc-text">互斥同步（锁）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%EF%BC%88CAS%EF%BC%89"><span class="toc-number">10.7.3.</span> <span class="toc-text">非阻塞同步（CAS）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-CAS"><span class="toc-number">10.7.3.1.</span> <span class="toc-text">1. CAS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-AtomicInteger"><span class="toc-number">10.7.3.2.</span> <span class="toc-text">2. AtomicInteger</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="toc-number">10.7.4.</span> <span class="toc-text">无同步方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%EF%BC%88Thread-Local-Storage%EF%BC%89"><span class="toc-number">10.7.4.1.</span> <span class="toc-text">1. 线程本地存储（Thread Local Storage）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A3%E7%A0%81%EF%BC%88Reentrant-Code%EF%BC%89"><span class="toc-number">10.7.4.2.</span> <span class="toc-text">2. 可重入代码（Reentrant Code）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88"><span class="toc-number">10.8.</span> <span class="toc-text">并发集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingQueue%EF%BC%88JUC%EF%BC%89"><span class="toc-number">10.8.1.</span> <span class="toc-text">BlockingQueue（JUC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">10.8.2.</span> <span class="toc-text">ConcurrentHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%E8%89%AF%E5%A5%BD%E7%9A%84%E5%AE%9E%E8%B7%B5"><span class="toc-number">10.9.</span> <span class="toc-text">多线程开发良好的实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-%E2%80%94%E2%80%94-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-number">10.10.</span> <span class="toc-text">实例 —— 多线程断点续传</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/05/%E8%87%AA%E5%AE%9A%E4%B9%89View/" title="自定义View"><img src="https://wushangblog.s3.bitiful.net/%E8%87%AA%E5%AE%9A%E4%B9%89View.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自定义View"/></a><div class="content"><a class="title" href="/2025/02/05/%E8%87%AA%E5%AE%9A%E4%B9%89View/" title="自定义View">自定义View</a><time datetime="2025-02-05T06:47:33.000Z" title="发表于 2025-02-05 14:47:33">2025-02-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/25/Leetcode%20CookBook%E7%AE%97%E6%B3%95/" title="Leetcode CookBook算法"><img src="https://pic1.imgdb.cn/item/67948944d0e0a243d4f7c0f9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode CookBook算法"/></a><div class="content"><a class="title" href="/2025/01/25/Leetcode%20CookBook%E7%AE%97%E6%B3%95/" title="Leetcode CookBook算法">Leetcode CookBook算法</a><time datetime="2025-01-25T06:47:33.000Z" title="发表于 2025-01-25 14:47:33">2025-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/03/android%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/" title="Android知识秘籍"><img src="https://s2.loli.net/2025/01/03/gw4uYQMBloWir5K.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android知识秘籍"/></a><div class="content"><a class="title" href="/2025/01/03/android%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/" title="Android知识秘籍">Android知识秘籍</a><time datetime="2025-01-03T12:19:51.000Z" title="发表于 2025-01-03 20:19:51">2025-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/03/android%E6%8F%90%E9%97%AE200%E9%81%93/" title="Android提问问答"><img src="https://s2.loli.net/2025/01/03/tPiv5zLXgsfGWmn.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android提问问答"/></a><div class="content"><a class="title" href="/2025/01/03/android%E6%8F%90%E9%97%AE200%E9%81%93/" title="Android提问问答">Android提问问答</a><time datetime="2025-01-03T12:19:12.000Z" title="发表于 2025-01-03 20:19:12">2025-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/03/java%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/" title="Java知识秘籍"><img src="https://s2.loli.net/2025/01/03/K2M9njOwagHpfIs.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java知识秘籍"/></a><div class="content"><a class="title" href="/2025/01/03/java%E7%9F%A5%E8%AF%86%E7%B2%BE%E5%8D%8E/" title="Java知识秘籍">Java知识秘籍</a><time datetime="2025-01-03T12:18:23.000Z" title="发表于 2025-01-03 20:18:23">2025-01-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By 无泪真伤</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog! --by Wuleizhenshang</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false#  open shake (抖動特效);
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>
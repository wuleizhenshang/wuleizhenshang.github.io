<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法 | Blog-无泪真伤</title><meta name="author" content="无泪真伤"><meta name="copyright" content="无泪真伤"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="算法加油！！！ 递归改写迭代引入队列是递归改写程序常做方法，然后借助循环 12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;&#x2F;递归public boolean isSymmetric(TreeNode root) &#123;    return check(root,root);&#125;">
<meta property="og:type" content="article">
<meta property="og:title" content="算法">
<meta property="og:url" content="https://www.wuleizhenshang.love/2023/11/18/%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Blog-无泪真伤">
<meta property="og:description" content="算法加油！！！ 递归改写迭代引入队列是递归改写程序常做方法，然后借助循环 12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;&#x2F;递归public boolean isSymmetric(TreeNode root) &#123;    return check(root,root);&#125;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/65587081c458853aef16f416.jpg">
<meta property="article:published_time" content="2023-11-18T15:29:30.000Z">
<meta property="article:modified_time" content="2023-11-19T04:58:32.092Z">
<meta property="article:author" content="无泪真伤">
<meta property="article:tag" content="开发常用">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/65587081c458853aef16f416.jpg"><link rel="shortcut icon" href="/img/86634.jpg"><link rel="canonical" href="https://www.wuleizhenshang.love/2023/11/18/%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 无泪真伤","link":"链接: ","source":"来源: Blog-无泪真伤","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-19 12:58:32'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/65582252c458853aeff7c6f5.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/65587081c458853aef16f416.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog-无泪真伤"><span class="site-name">Blog-无泪真伤</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-18T15:29:30.000Z" title="发表于 2023-11-18 23:29:30">2023-11-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-19T04:58:32.092Z" title="更新于 2023-11-19 12:58:32">2023-11-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>90分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>加油！！！</p>
<h3 id="递归改写迭代"><a href="#递归改写迭代" class="headerlink" title="递归改写迭代"></a>递归改写迭代</h3><p>引入队列是递归改写程序常做方法，然后借助循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> check(root,root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left==<span class="literal">null</span>&amp;&amp;right==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left==<span class="literal">null</span>||right==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.val== right.val&amp;&amp;check(left.left,right.right)&amp;&amp;check(left.right,right.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面递归方法改写成迭代，借助队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> check(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode u, TreeNode v)</span> &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    q.offer(u);</span><br><span class="line">    q.offer(v);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        u = q.poll();</span><br><span class="line">        v = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="literal">null</span> &amp;&amp; v == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((u == <span class="literal">null</span> || v == <span class="literal">null</span>) || (u.val != v.val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q.offer(u.left);</span><br><span class="line">        q.offer(v.right);</span><br><span class="line"></span><br><span class="line">        q.offer(u.right);</span><br><span class="line">        q.offer(v.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="分治法（递归）"><a href="#分治法（递归）" class="headerlink" title="分治法（递归）"></a>分治法（递归）</h3><p> <strong>分治法的设计思想</strong>：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>  <strong>分治策略</strong>：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>  如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p>
<p><strong>分治法适用的情况</strong></p>
<p>  分治法所能解决的问题一般具有以下几个特征：</p>
<p>  \1) 该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>  \2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p>
<p>  \3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p>
<p>  \4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；</p>
<p>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p>
<p>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p>
<p>分治法在每一层递归上都有三个步骤：</p>
<p>  step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p>
<p>  step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p>
<p>  step3 合并：将各个子问题的解合并为原问题的解。</p>
<h4 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SuanFa.DiGuiFenZhi.HanNuoTa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HanNuoTa</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        hanoi(n,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,ints);</span><br><span class="line">        System.out.format(<span class="string">&quot;移动%d个盘子总共需要移动%d次盘子&quot;</span>,n,ints[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*一个直接移动到c即可；两个就先把一个移动到b，再把最下面一个移动到c，然后把b上的移动到c即可；</span></span><br><span class="line"><span class="comment">    * 三个怎么办呢，可以想办法把最大的移动到c，再把剩下的移动到最大的上面，那怎么把最大的移动到c呢，</span></span><br><span class="line"><span class="comment">    * 要先把上面的都移动到b，怎么把上面的移动到b呢，</span></span><br><span class="line"><span class="comment">    * 这不就是只有两个的时候的情况吗，这样来看就是递归了*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//a为一开始在的柱子，b为中间柱子，c为最终放在的柱子,n为几个盘子</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> a,<span class="type">char</span> b,<span class="type">char</span> c,<span class="type">int</span>[] ints)</span>&#123;</span><br><span class="line">        <span class="comment">//只有一个就从a直接移动到c</span></span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            move(n,a,c,ints);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//大于1个就把n-1个盘子借助c从a移动到b，之后递归了</span></span><br><span class="line">        hanoi(n-<span class="number">1</span>,a,c,b,ints);</span><br><span class="line">        <span class="comment">//然后把最下面也就是第n个盘子移动到c</span></span><br><span class="line">        move(n,a,c,ints);</span><br><span class="line">        <span class="comment">//之后把b柱子上的盘子借助a柱子移动到c，也是递归</span></span><br><span class="line">        hanoi(n-<span class="number">1</span>,b,a,c,ints);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> a,<span class="type">char</span> c,<span class="type">int</span>[] ints)</span>&#123;</span><br><span class="line">        <span class="comment">//一秒移动一个盘子，要把64个盘子移动完都可以移动到宇宙毁灭了</span></span><br><span class="line"><span class="comment">//        System.out.format(&quot;编号为：%d的盘子正在从%c柱子移动到%c柱子\n&quot;,n,a,c);</span></span><br><span class="line">        ints[<span class="number">0</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h4><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：<em>F</em>(0)&#x3D;0，<em>F</em>(1)&#x3D;1, <em>F</em>(n)&#x3D;<em>F</em>(n - 1)+<em>F</em>(n - 2)（<em>n</em> ≥ 2，<em>n</em> ∈ N*）在现代物理、准晶体结构晶体结构、化学等领域，斐波那契数列都有直接的应用</p>
<ul>
<li><strong>楼梯问题</strong></li>
<li><strong>兔子繁殖问题（不死亡）</strong></li>
<li><strong>兔子繁殖问题（会死亡）</strong></li>
<li><strong>求解质数（基本方法有试除法和筛法，试除法除到根号n就好，规律），这里有斐波那契质数（ 若某Fibonacci数与任何比它小的Fibonacci数互质，那么它就是Fibonacci质数。可以保存到一个数组然后开始一个个推）</strong></li>
</ul>
<p><strong>1. 爬楼梯问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.爬楼梯问题（solve3）</span></span><br><span class="line"><span class="keyword">package</span> LeeCode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span></span><br><span class="line"><span class="comment">每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exercise70</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(solve1(n));</span><br><span class="line">        System.out.println(solve2(n));</span><br><span class="line">        System.out.println(solve3(n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="comment">//斐波那契问题除了爬楼梯还有兔子繁殖问题，满足f(n) = f(n-1) + f(n-2)就是</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//无脑，递归，能一次上3步同理,很耗时，超时，O(2^n),能一次上3步就是3^n</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solve1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//0台阶一步</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1台阶就只有一种情况，爬一步</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2台阶两种情况，一种每次爬1步，一种直接爬2步</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//多于2楼梯的就根据当前选择有不同情况，如爬了1级，那么剩下n-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> solve1(n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//爬了2级,剩下n-2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> solve1(n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> first + second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过分析上4次楼梯有多少情况发现有问题重叠计算了、</span></span><br><span class="line">    <span class="comment">//同斐波那契数列，可以用一个数组存结果，原理也同其实，4阶楼梯上法可以由3阶上楼梯方法推出来，3阶可以由2阶上楼梯方法推出来</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solve2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//这里由于输入的n为1的话新建的数组根本没这么大，直接ints[2]直接错，</span></span><br><span class="line">        <span class="comment">// 可以做个判断或者把数组直接new很大出来，也可以直接new n+3长度就行，让数组最短都有3个格子</span></span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">3</span>];</span><br><span class="line">        ints[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        ints[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        ints[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            ints[i] = ints[i-<span class="number">1</span>] + ints[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面还要建数组根本就不需要，就跟斐波那契一样，根本不需要去建数组，直接3个数轮换就可以求出来</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solve3</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//n3表示第三个数，第三个数是前2个数n1和n2相加，然后把下次要相加的两个数往后移动n2变为n3，n1变为n2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">1</span>, n2 = <span class="number">2</span>, n3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            n3 = n2 + n1;</span><br><span class="line">            n1 = n2;</span><br><span class="line">            n2 = n3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2.兔子繁殖问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.兔子繁殖（会死亡），不死亡同前面其实</span></span><br><span class="line"><span class="keyword">package</span> SuanFa.FeiBoNaQie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*题目</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有一对兔子，从出生后，</span></span><br><span class="line"><span class="comment">第 1、2 月为 幼年期</span></span><br><span class="line"><span class="comment">第 3 月开始，进入了 成年期，每个月都生一对 兔子</span></span><br><span class="line"><span class="comment">小兔子 长到 第3月 后，每个月又生一对兔子</span></span><br><span class="line"><span class="comment">当 一对兔子 在 第5月 时，他们产完仔之后，就会死亡*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitProblemWillDie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Rabbit</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">growUp</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> month)</span>&#123;</span><br><span class="line">        <span class="comment">//用队列很容易理解且比递归快</span></span><br><span class="line">        Queue&lt;Rabbit&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">Rabbit</span>());</span><br><span class="line">        <span class="type">int</span> <span class="variable">monthNow</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (monthNow&lt;month)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span> (count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Rabbit</span> <span class="variable">rabbit</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">                <span class="keyword">switch</span> (rabbit.age)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        rabbit.growUp();</span><br><span class="line">                        queue.add(rabbit);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//一起写就可以</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        rabbit.growUp();</span><br><span class="line">                        queue.add(rabbit);</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="title class_">Rabbit</span>());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//4个月这个月变成5个月会死，并且生一只兔子</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="title class_">Rabbit</span>());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            monthNow++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">RabbitProblemWillDie</span> <span class="variable">dd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RabbitProblemWillDie</span>();</span><br><span class="line">        System.out.println(dd.count(scanner.nextInt()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>3.求解质数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.求解质数</span></span><br><span class="line"><span class="keyword">package</span> SuanFa.FeiBoNaQie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求解质数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(isPrime(num));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">byte</span>[] date = getAllPrime(range);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; date.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (date[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//试除法，优化除到根号n即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">0</span>||num==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i&lt;=Math.sqrt(num); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//筛法,返回一个范围内所有质数</span></span><br><span class="line">    <span class="comment">/*全称：The Sieve of Eratosthens（爱拉托逊斯筛选法），简称为筛法</span></span><br><span class="line"><span class="comment">    筛法就是把每一个质数的倍数去掉 余下的数就是质数</span></span><br><span class="line"><span class="comment">    2 是最小的质数，将 2 的所有倍数去掉，然后找 2 的下一个质数：3 ，将 3 的所有倍数去掉，寻找下一个质数：5 , 去掉 5 的所有倍数…以此类推*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getAllPrime(<span class="type">int</span> range)&#123;</span><br><span class="line">        <span class="type">byte</span>[] date = <span class="keyword">new</span> <span class="title class_">byte</span>[range+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= range ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (date[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; i*j &lt;=range ; j++) &#123;</span><br><span class="line">                    date[i*j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回值为一个byte数组</span></span><br><span class="line">        <span class="comment">//从下标为2的值开始，值为0说明该下标数是质数</span></span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><p><strong>二分搜索算法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//length是数组长度（数组有序，这里是升序，降序自己给一下变化就行），target是要查找的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">BinarySearch</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> length,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (ints[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ints[mid]&gt;target)&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ints[mid]&lt;target)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p><strong>1.冒泡排序</strong></p>
<p><strong>数量少时选择，每轮把最大的数放在数组最后</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序 传入数组长度</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (ints.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//每次把最大的数放在最后一个</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (ints[j] &gt; ints[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                   swap(ints, j, j + <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[left];</span><br><span class="line">       ints[left] = ints[right];</span><br><span class="line">       ints[right] = temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>2.选择排序</strong></p>
<p>选择排序就是每轮把剩余中最小的往前面已经放好的后面放，相对冒泡就是少了频繁交换,每次大循环就交换数组里面的值一次，每次把最小的放前面，用min保存当前循环的最小数值的下标就好，每轮循环min开始置为当前循环的i值就好，因为上一轮把最小的放在这里了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[min] &gt; ints[j]) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(ints, min, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[left];</span><br><span class="line">        ints[left] = ints[right];</span><br><span class="line">        ints[right] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p><strong>3.归并排序(合并排序，基于二分实现)</strong></p>
<p><strong>数多时选择，一直递归把数据一分为二，把两半数据排好后复制到原数组，最小是只有2个数的情况，这时候就相当于有序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序（合并排序） 需要同等大小的复制控件 传入数组的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//不断划分子问题（分治思想）</span></span><br><span class="line">            MergeSort(ints, left, mid, temp);</span><br><span class="line">            MergeSort(ints, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//解决子问题并且把子问题的值从临时数组复制回原数组</span></span><br><span class="line">            Merge(ints, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里的循环条件考虑递归到最小的时候，也就是只有两个数的时候</span></span><br><span class="line">        <span class="comment">//下面是把两个有序数组进行合并</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ints[left] &lt; ints[right]) &#123;</span><br><span class="line">                temp[t++] = ints[left++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = ints[right++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= mid) &#123;</span><br><span class="line">            temp[t++] = ints[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &lt;= end) &#123;</span><br><span class="line">            temp[t++] = ints[right++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//临时数组保存的是当前这个子问题这个小段的正确顺序</span></span><br><span class="line">        <span class="comment">//下面是把临时数组中排好序的数组复制回原数组</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            ints[i] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><em>归并算法求逆序对</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//保存交换次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序借助另一个数组合并的过程,先把两个串按照顺序合并放到临时数组再放回去</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> *ints, <span class="type">int</span> *temp, <span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ints[left] &lt;= ints[right]) &#123;</span><br><span class="line">            <span class="comment">//因为是最小，等会的情况不交换</span></span><br><span class="line">            temp[t++] = ints[left++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[t++] = ints[right++];</span><br><span class="line">            sum+=(mid-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid) &#123;</span><br><span class="line">        temp[t++] = ints[left++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right &lt;= end) &#123;</span><br><span class="line">        temp[t++] = ints[right++];</span><br><span class="line">    &#125;</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; ++i) &#123;</span><br><span class="line">        ints[i] = temp[t++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> *ints, <span class="type">int</span> *temp, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(ints, temp, left, mid);</span><br><span class="line">        mergeSort(ints, temp, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(ints, temp, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> *ints = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> *temp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; ints[i];</span><br><span class="line">    &#125;</span><br><span class="line">    mergeSort(ints, temp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>4.快速排序（双指针递归实现）</strong></p>
<p><strong>数量多时选择，一开始把基准值设为数组第一个值，每轮把基准值放在对的位置并把交换得到的值作为基准值</strong></p>
<p>变形问题：</p>
<p>设计一个平均时间为O(n)的算法，在n(1&lt;&#x3D;n&lt;&#x3D;1000)个无序的整数中找出第k小的数。（因为每轮的right值都会是放在正确位置的值，看right这个是不是对应下标，对可以直接返回了，根本不用全排序完，如果right大了递归左边的那段，小了递归右边半段，因为这时候左边的数都小于right下标的值，右边都大于right下标的值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序(递归) 传入数组的下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">//一开始start&lt;end记得写</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = end, base = ints[left];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="comment">//这两个while都有等于作为判断条件</span></span><br><span class="line">                <span class="comment">//这里之所以写&lt;=base是因为在交换一次不对的数字后没有把left和right直接改变，而是在下次的while中改变</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt;= end &amp;&amp; ints[left] &lt;= base) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; start &amp;&amp; ints[right] &gt;= base) &#123;</span><br><span class="line">                    <span class="comment">//right&gt;start其实可以不用写，因为前面有基准值堵住，不会超出去</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果不是left&lt;right说明序列正确</span></span><br><span class="line">                <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                    swap(ints, left, right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里是遍历基准值后面的数结束了，这时候right在左边，left在右边或者left=right，</span></span><br><span class="line">            <span class="comment">// 这时候把基准值跟小的值交换才对，自己写个数组就明白了，小的值就是right对应的值</span></span><br><span class="line">            swap(ints, start, right);</span><br><span class="line">            <span class="comment">//然后递归已经放置正确的值的左边和右边，也就是right这个值的左边和右边，</span></span><br><span class="line">            <span class="comment">// start衡为数组界限，如果right-1小于这个值不会进行循环，不会越界，right+1同理</span></span><br><span class="line">            QuickSort(ints, start, right - <span class="number">1</span>);</span><br><span class="line">            QuickSort(ints, right + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[left];</span><br><span class="line">        ints[left] = ints[right];</span><br><span class="line">        ints[right] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>5.堆排序</strong></p>
<p><strong>数多时选择，每次都形成大顶堆，也就是数字最大的在父节点，每轮得到最大的放在数组最后并进行交换</strong></p>
<p>首先要了解一下一些关系，下标为i的节点的父节点的下标为（i-1）&#x2F;2,下标为i的节点的左孩子节点的下标为ix2+1,右孩子节点下标为ix2+2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line">	<span class="comment">//方法入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="comment">//建堆,一开始先把堆建好，之后递归就好</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//倒着建堆，根据规律父节点为（n-1）/2,注意这个方法传入的不是下标是长度，n要减多一个1</span></span><br><span class="line">            Heap(ints, length, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span> (i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//最后一个元素和第一个元素交换，就是把最大的数放到最后,swap方法在这个类最后面</span></span><br><span class="line">            swap(ints, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//交换完成最大元素在最后，之后从堆顶开始维护堆，这里容易错，长度改变了</span></span><br><span class="line">            Heap(ints, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> length, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">//维护堆,length为数组长度,i为维护的目标节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//要把最大的那个数放在父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">//假设目前最大的是父节点，根据规律看哪个节点最大就记录它的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lson</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, rson = i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (lson &lt; length &amp;&amp; ints[lson] &gt; ints[largest]) &#123;</span><br><span class="line">            largest = lson;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rson &lt; length &amp;&amp; ints[rson] &gt; ints[largest]) &#123;</span><br><span class="line">            largest = rson;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断最大节点是不是已经在父节点，不是就进行交换，并且要递归调整下面的堆</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(ints, largest, i);</span><br><span class="line">            <span class="comment">//这时候的largest记录的是被交换过来的不是最大的值的父节点的下标，容易出错</span></span><br><span class="line">            Heap(ints, length, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] ints, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[left];</span><br><span class="line">        ints[left] = ints[right];</span><br><span class="line">        ints[right] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>









<h4 id="线性时间选择算法"><a href="#线性时间选择算法" class="headerlink" title="线性时间选择算法"></a>线性时间选择算法</h4><p>如果要要在一个数组中找到最大或者最小的数是可以轻易做到O(n)时间完成的，但如果要寻找中位数或者说寻找第几大的数看起来是非常难在O(n)时间完成的，但事实上从渐近的意义上来看，它们是一样的<strong>（线性时间选择算法是在快排的基础上实现的，也叫快速选择算法）</strong></p>
<p>看了一下b站的视频感觉寻找第几小的数字，貌似自己的思路是正确的，但不知道是不是原版线性时间选择算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计一个平均时间为O(n)的算法，在n(1&lt;=n&lt;=1000)个无序的整数中找出第k小的数。</span></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *ints,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> ints[left];</span><br><span class="line">    ints[left] = ints[right];</span><br><span class="line">    ints[right] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> *ints,<span class="type">int</span> target,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start,right = end,base = ints[left];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;end&amp;&amp;ints[left]&lt;=base)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right&gt;start&amp;&amp;ints[right]&gt;=base)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                swap(ints,left,right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(ints,start,right);</span><br><span class="line">        <span class="comment">//前面都是跟快排一样的，这里不同而已</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里通过下标看中间值也就是right值，right左边比right小，右边比right大，</span></span><br><span class="line">        <span class="comment">//如果要找到第几小的值在right左边就递归左边，反之递归右边</span></span><br><span class="line">        <span class="keyword">if</span>(right==target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;target)&#123;</span><br><span class="line">            solve(ints,target,right+<span class="number">1</span>,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;target)&#123;</span><br><span class="line">            solve(ints,target,start,right-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> length,target;</span><br><span class="line">    cin &gt;&gt; length &gt;&gt; target;</span><br><span class="line">    <span class="type">int</span> *ints = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        cin &gt;&gt; ints[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solve(ints,target-<span class="number">1</span>,<span class="number">0</span>,length-<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ints[target-<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//有n场比赛</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> *ints, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = end, base = ints[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= end &amp;&amp; ints[left] &lt;= base) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; start &amp;&amp; ints[right] &gt;= base) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            swap(ints[left], ints[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(ints[start], ints[right]);</span><br><span class="line">    <span class="keyword">if</span> (right == target - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ints[right];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; target - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSort(ints, start, right - <span class="number">1</span>, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSort(ints, right + <span class="number">1</span>, end, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> *ints = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; ints[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> target;<span class="comment">//目标寻找第target大的值</span></span><br><span class="line">    cin &gt;&gt; target;</span><br><span class="line">    cout &lt;&lt; quickSort(ints, <span class="number">0</span>, n - <span class="number">1</span>, target);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法（greedy algorithm [8] ，又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。</p>
<p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择 。</p>
<p>把求解的问题分成若干个子问题，对每个子问题求解，得到子问题的局部最优解，把子问题的解局部最优解合成原来解问题的一个解。（贪心算法<strong>一般用来解决求最大或最小解</strong>，贪心算法只能确定某些问题的可行性范围，不能保证最佳，因为贪心算法总是从局部出发，并没从整体考虑）</p>
<ul>
<li><p>题目：121，找零问题（注意贪心是不是有最优解）（从大的零钱开始找）</p>
</li>
<li><p>题目:删数问题（给定n位正整数a，去掉其中任意k≤n 个数字后，剩下的数字按原次序排列组成一个新的正整数。对于给定的n位正整数a和正整数 k，设计一个算法找出剩下数字组成的新数最小的删数方案。如果数字最前面有0不输出。）（从头开始，递减段的第一个数字删掉，因为这样会让后面小的数字上来顶替它）</p>
</li>
<li><p>题目：最优分解问题（设 n 是一个正整数。现在要求将 n 分解为若干个互不相同的自然数的和，且使这些自然数的乘积最大。）</p>
</li>
</ul>
<p>（整数的一个性质：若 a + b &#x3D;N(常数)，则| a - b |越小， a * b 越大，<em>因为要使乘积最大，所以要尽量分解为相似大小的数。    分解时，因数从2开始，每次加1，n&#x3D;n-a[i]，保证剩下的数比下一次的数大。    否则<strong>从后往前循环</strong>（从前往后会出现相同数字，拿去10来看就知道了）已经出现的数a[i]，一次加1，知道n&#x3D;0为止。     例如：        分解13        分解为 2 3 4 ，还剩下 4 ，不够继续分解的下一个数”5”，就把 4 依次分配给前面的因子，        分配顺序是 4 &#x3D;&gt; 3 &#x3D;&gt; 2 。所以最终结果为 3 4 6，这就是最大乘积的因子。        （分配顺序为从大到小，如果还剩下，就继续从大到小分配）</em>）</p>
<ul>
<li>在0-1背包的贪心算法模型中把物品质量和价格初始化为double类型最好，不然会因为int类型保存时有误差导致sort排序有时候不对</li>
</ul>
<h4 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h4><p>学校的礼堂每天都会有许多活动，有时间这些活动的计划时间会发生冲突，需要选择出一些活动进行举办。小刘的工作就是安排学校礼堂的活动，每个时间最多安排一个活动。现在小刘有一些活动计划的时间表，他想尽可能的安排更多的活动，请问他该如何安排。</p>
<p><strong>输入格式：</strong></p>
<p>第一行是一个整型数m(m&lt;100)表示共有m组测试数据。<br>每组测试数据的第一行是一个整数n(1&lt;n&lt;10000)表示该测试数据共有n个活动。<br>随后的n行，每行有两个正整数Bi,Ei(0&lt;&#x3D;Bi,Ei&lt;10000),分别表示第i个活动的起始与结束时间（Bi&lt;&#x3D;Ei)</p>
<p><strong>输出格式：</strong></p>
<p>对于每一组输入，输出最多能够安排的活动数量。<br>每组的输出占一行</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">1 10</span><br><span class="line">10 11</span><br><span class="line">3</span><br><span class="line">1 10</span><br><span class="line">9 11</span><br><span class="line">11 20</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>



<p><strong>代码：</strong></p>
<p>贪心选择，最早结束时间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;<span class="comment">//m组测试数据</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//每组数据有n个活动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ac</span> &#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ac ac1, ac ac2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ac1.end &lt; ac2.end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> result, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        ac *p = <span class="keyword">new</span> ac[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; p[j].start &gt;&gt; p[j].end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(p, p + n, cmp);</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j].start &gt;= p[temp].end) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                temp = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            cout &lt;&lt; result;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; endl &lt;&lt; result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="活动安排进阶（需保存状态）"><a href="#活动安排进阶（需保存状态）" class="headerlink" title="活动安排进阶（需保存状态）"></a>活动安排进阶（需保存状态）</h4><ul>
<li><strong>保存状态的这个思想很重要，有些贪心的题目也用得上</strong></li>
</ul>
<p>假设要在足够多的会场里安排一批活动，并希望使用尽可能少的会场。设计一个有效的<br>贪心算法进行安排。（这个问题实际上是著名的图着色问题。若将每一个活动作为图的一个<br>顶点，不相容活动间用边相连。使相邻顶点着有不同颜色的最小着色数，相应于要找的最小<br>会场数。）</p>
<p><strong>输入格式</strong></p>
<p>第一行有 1 个正整数k，表示有 k个待安排的活动。<br>接下来的 k行中，每行有 2个正整数，分别表示 k个待安排的活动开始时间和结束时间。时间<br>以 0 点开始的分钟计。</p>
<p><strong>输出格式</strong></p>
<p>输出最少会场数。</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 23</span><br><span class="line">12 28</span><br><span class="line">25 35</span><br><span class="line">27 80</span><br><span class="line">36 50 </span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>



<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/10/29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//代安排的活动数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ac</span> &#123;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ac ac1, ac ac2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ac1.start &lt; ac2.start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(ac *p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(p, p + n, cmp);</span><br><span class="line">    <span class="type">int</span> *target = <span class="keyword">new</span> <span class="type">int</span>[n]&#123;<span class="number">0</span>&#125;;<span class="comment">//保存当前会场信息</span></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;<span class="comment">//保存开了多少个会场</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">//j从会场0号下标开始遍历到result，如果能安排进去就结束了，如果不能就会到下标result对应会场，表示要新开会场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= result; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == result) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[i].start &gt;= target[j]) &#123;</span><br><span class="line">                target[j] = p[i].end;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ac *p = <span class="keyword">new</span> ac[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; p[i].start &gt;&gt; p[i].end;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(p) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="最优合并问题（借助优先队列）"><a href="#最优合并问题（借助优先队列）" class="headerlink" title="最优合并问题（借助优先队列）"></a>最优合并问题（借助优先队列）</h4><ul>
<li><strong>有时候借助优先队列解决更快和方便</strong></li>
</ul>
<p>给定k 个排好序的序列, 用 2 路合并算法将这k 个序列合并成一个序列。<br>假设所采用的 2 路合并算法合并 2 个长度分别为m和n的序列需要m+n-1 次比较。试设<br>计一个算法确定合并这个序列的最优合并顺序，使所需的总比较次数最少。<br>为了进行比较，还需要确定合并这个序列的最差合并顺序，使所需的总比较次数最多。</p>
<p><strong>输入格式：</strong></p>
<p>第一行有 1 个正整数k，表示有 k个待合并序列。<br>第二行有 k个正整数，表示 k个待合并序列的长度。</p>
<p><strong>输出格式：</strong></p>
<p>输出最多比较次数和最少比较次数。</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5 12 11 2 </span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">78 52</span><br></pre></td></tr></table></figure>



<p><strong>代码：</strong></p>
<p>次数最少的情况就是尽量减少长的序列的比较次数(每次都让短的两个序列先比较)，而最大的情况就是尽量增加长的序列的比较次数(每次都让最长的两个序列比较)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; small, <span class="type">int</span> &amp;small_result,</span></span></span><br><span class="line"><span class="params"><span class="function">           priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; big, <span class="type">int</span> &amp;big_result)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp1, temp2;</span><br><span class="line">    <span class="keyword">while</span> (small.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        temp1 = small.<span class="built_in">top</span>();</span><br><span class="line">        small.<span class="built_in">pop</span>();</span><br><span class="line">        temp2 = small.<span class="built_in">top</span>();</span><br><span class="line">        small.<span class="built_in">pop</span>();</span><br><span class="line">        small_result += (temp1 + temp2 - <span class="number">1</span>);</span><br><span class="line">        small.<span class="built_in">push</span>(temp1 + temp2);</span><br><span class="line">        temp1 = big.<span class="built_in">top</span>();</span><br><span class="line">        big.<span class="built_in">pop</span>();</span><br><span class="line">        temp2 = big.<span class="built_in">top</span>();</span><br><span class="line">        big.<span class="built_in">pop</span>();</span><br><span class="line">        big_result += (temp1 + temp2 - <span class="number">1</span>);</span><br><span class="line">        big.<span class="built_in">push</span>(temp1 + temp2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*次数最少的情况就是尽量减少长的序列的比较次数(每次都让短的两个序列先比较),</span></span><br><span class="line"><span class="comment">    而最大的情况就是尽量增加长的序列的比较次数(每次都让最长的两个序列比较)*/</span></span><br><span class="line">    <span class="type">int</span> k, temp, small_result = <span class="number">0</span>, big_result = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; small;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; big;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        small.<span class="built_in">push</span>(temp);</span><br><span class="line">        big.<span class="built_in">push</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(small, small_result, big, big_result);</span><br><span class="line">    cout &lt;&lt; big_result &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; small_result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>####图最短问题（迪杰斯特拉算法）</p>
<ul>
<li><p><strong>单源最短路径</strong></p>
</li>
<li><p><strong>迪杰斯特拉要求的图的权值要为正数</strong></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/PRML_MAN/article/details/114477814?ops_request_misc=%7B%22request_id%22:%22166826569516782388091019%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166826569516782388091019&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114477814-null-null.142%5Ev63%5Econtrol,201%5Ev3%5Econtrol_2,213%5Ev2%5Et3_esquery_v2&utm_term=%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89&spm=1018.2226.3001.4449">(26条消息) 算法之迪杰斯特拉（dijkstra）非常详细介绍_PRML_MAN的博客-CSDN博客_迪杰斯特拉</a></p>
<p>城市的道路四通八达，我们经常需要查找从某地出发到其他地方的路径，当然我们希望能最快到达。现得到去每个地方需要花费的时间，现请你编写程序，计算从特定地点出发到所有城市之间的最短时间。</p>
<p><strong>输入格式：</strong></p>
<p>输入的第一行给出城市数目N (1≤N≤10)和道路数目M和1（表示有向图）或0（表示无向图）；</p>
<p>接下来的M行对应每个城市间来往所需时间，每行给出3个正整数，分别是两个城市的编号（从1编号到N）和来往两城市间所需时间。最后一行给出一个编号，表示从此编号地点出发。</p>
<p><strong>输出格式：</strong></p>
<p>输出从特定地点出发到达所有城市（按编号1-编号N顺序输出）的距离（用编号1-&gt;编号**: 表示 ），如果无路，请输出no path。每个城市占一行。</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 4 1</span><br><span class="line">1 2 2</span><br><span class="line">1 4 8</span><br><span class="line">3 2 16</span><br><span class="line">3 4 10</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;1:0</span><br><span class="line">1-&gt;2:2</span><br><span class="line">1-&gt;3:no path</span><br><span class="line">1-&gt;4:8</span><br></pre></td></tr></table></figure>

<p><strong>代码</strong></p>
<p>&#x2F;&#x2F;迪杰斯特拉算法,每次寻找图中到某个点最小的距离，更新和这个点相连的且没有被访问过的点，并把这个点置为已访问过，如果要知道具体路径就可以再增加一个数组保存前驱点（这个点最小值出现的时候也就是要刷新这个点的值的时候改变前驱点）,根据目的地一直往前驱找到起始点就是具体路径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/9.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">//邻接矩阵两个点没有相连定义初始化的值</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//城市数目1&lt;=n&lt;=10</span></span><br><span class="line"><span class="type">int</span> m;<span class="comment">//图中路的条数</span></span><br><span class="line"><span class="type">int</span> target;<span class="comment">//一开始指定的点</span></span><br><span class="line"><span class="type">int</span> kind;<span class="comment">//表示图的种类，1表示有向图，0表示无向图，根据这个初始化邻接矩阵</span></span><br><span class="line"><span class="type">int</span> g[<span class="number">11</span>][<span class="number">11</span>];<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> dist[<span class="number">11</span>];<span class="comment">//保存特殊路径长度，一开始初始化为定义的目标点到每个点的距离</span></span><br><span class="line"><span class="type">bool</span> visit[<span class="number">11</span>];<span class="comment">//是否被加进去集合遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        visit[i] = <span class="literal">false</span>;</span><br><span class="line">        dist[i] = g[target][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= n; ++t) &#123;</span><br><span class="line">        <span class="type">int</span> point = <span class="number">-1</span>, min = INF;<span class="comment">//一开始让point为-1，如果在下面的循环中point依然为-1说明dist一开始全保存为INF，就是图所有点都是不相通的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[i] &amp;&amp; dist[i] &lt; min) &#123;</span><br><span class="line">                min = dist[i];</span><br><span class="line">                point = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (point == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[point] = <span class="literal">true</span>;<span class="comment">//加进集合，visit[point]置为true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="comment">//之前遍历过的点就不用遍历了，因为已经保存了目标值到这个点的最小值了</span></span><br><span class="line">            <span class="keyword">if</span> (!visit[i] &amp;&amp; dist[point] + g[point][i] &lt; dist[i]) &#123;</span><br><span class="line">                dist[i] = dist[point] + g[point][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; kind;</span><br><span class="line">    <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; ++j) &#123;</span><br><span class="line">            g[i][j] = INF;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                g[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a][b] = c;</span><br><span class="line">        <span class="keyword">if</span> (kind == <span class="number">0</span>) &#123;</span><br><span class="line">            g[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; target;</span><br><span class="line">    <span class="built_in">Dijkstra</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i] != INF) &#123;</span><br><span class="line">            cout &lt;&lt; target &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; target &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="string">&quot;no path&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="哈希映射"><a href="#哈希映射" class="headerlink" title="哈希映射"></a>哈希映射</h3><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希（Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<p><strong>Example:</strong></p>
<p>现在给出 <strong>n</strong> 个数(a[0],a[1],…,a[n-1])，且每个数的大小都是小于等于 10的10次方 的非负数(0&lt;&#x3D;a[i]&lt;&#x3D;1010)，现需要<strong>统计每个数的出现次数</strong>，并从小到大依次输出，且 <strong>n</strong> 是小于等于 <strong>100</strong> 的正整数(0&lt;n&lt;&#x3D;100)。</p>
<p><strong>基础解决方法：</strong></p>
<p>对于这道题确实可以直接定义一个很长的数组，然后遍历输入的数，出现一次就在对应的下标的数组保存的值加1，这样子可以做到O(n)</p>
<p>的效率，算是优解了，但是这里的数最大为10的10次方，数组定义不了这么长</p>
<p><strong>解决方法（发现问题）</strong></p>
<p>那么就可以构造一个哈希函数通过一个映射关系压缩如此大的一个数组，因为这个数组里面很多值其实很多都是0来着，非常稀疏，例如H*(*k)&#x3D;k  mod m，取模，但是这种可能会出现碰撞冲突，如1%100&#x3D;1，但101%100&#x3D;1</p>
<p><strong>解决问题（解决冲突）</strong></p>
<p>解决碰撞冲突的思路有两个，<strong>其一</strong>是为冲突发生的情况下，设置新的规则来应对，比方说，如果出现冲突，那么就从冲突出现位置顺序往后找，直到找到一个空的位子，填上去；<strong>或者</strong>是隔几个位子跳着跳着找；<strong>又或者</strong>是在冲突出现的位置链接上一条链表，依次记录相同哈希值元素的出现次数。</p>
<p><strong>1. 线性探测法</strong></p>
<p>顾名思义，若出现冲突，则逐个往后或往前搜索，直到找到空的位子。假设现在又出现一个元素 <strong>20</strong> 经哈希函数后得到的映射结果也是位置 <strong>0</strong> ，而发现该位置已被元素 <strong>10</strong> 所占据，那么就可以线性向后查找，直到找到第一个空的位置 <strong>2</strong> ，然后放上去。(若找到了哈希表结尾，则回到开头继续向后查找，由于保证了哈希表的大小一定比元素总个数多，所以能保证每个元素都能找到自己的位置)</p>
<p>但这样有一个弊端就是，此时 <strong>20</strong> 占据了一个本不属于它的位置 <strong>2</strong> ，如若下次来了一个本就映射到位置 <strong>2</strong> 的元素，那么它也只好继续向后探测，换句话说，虽然你解决了一个冲突，但同时又产生了另一个产生冲突的隐患，而且甚至还有可能出现无限冲突的情况。另一方面对于要在表中删除元素的情况，处理起来也不太方便。</p>
<p><strong>2. 链地址法</strong></p>
<p>这种思想是将所有映射到位置 <strong>i</strong> 的元素构建一条链表，并将单链表的头指针存在哈希表的第 <strong>i</strong> 个单元中，这样做的好处是一方面不会出现前面方法的那种解决一个哈希冲突，又带了新冲突隐患的问题，另一方面是在元素的删除上也能很好的处理，只需删除对应节点即可。但缺点也有，就是可能会在某个位置出现一条很长很长的链，增加了时间的开销。</p>
<p><strong>3.再哈希法</strong></p>
<p>这种方式是选取多个哈希函数，若第 <strong>j</strong> 个哈希函数出现了冲突，那么选用第 <strong>j+1</strong> 个哈希函数计算，直至找到不发生冲突的哈希函数。又或者使用同一个哈希函数，以上一轮产生的哈希值作为键值进行再次映射，直至找到可用的位置。</p>
<p>**4. 其他结局冲突方法 **</p>
<p>除了以上这些方法外，还有很多类似的方法，如平方探测法等等</p>
<p><strong>解决问题（设计更好的哈希函数）</strong></p>
<p>这类处理思路都是着重于当冲突发生的时候如何处理，此外，另一种解决冲突的思想便是在冲突发生之前尽可能的减少冲突的发生概率，即设计更好的哈希函数。</p>
<p><strong>1. 使用更大的哈希表</strong></p>
<p>不难想到，一张更大的哈希表能降低冲突发生的概率，以之前的简单哈希函数为例，极端情况是如果把 <strong>m</strong> 取得很大到 <strong>1010</strong> 时，那么显然就不会发生冲突了。一般而言，在经验和习惯上，会将哈希表的大小设置在元素个数的 <strong>1~10</strong> 倍之间，以实现在较小空间冗余的代价上，减小冲突的发生，提高时间效率。</p>
<p><strong>2. 更好的哈希运算</strong></p>
<p>之前提到的最简单的哈希函数，被称为除留余数法，可以说没有对键值 <strong>k</strong> 作任何的处理，直接进行了求余数，而如果我们加上些其它的运算，便能够使得映射更加复杂，以达到更随机的映射效果。例如下面的一阶线性映射：<br>H ( k ) &#x3D; ( a × k + b )  m o d  m ( a , m ∈ Z ) H(k) &#x3D; (a×k + b)\ mod\ m (a,m \in Z)<em>H</em>(<em>k</em>)&#x3D;(<em>a</em>×<em>k</em>+<em>b</em>) <em>m<strong>o</strong>d</em> <em>m</em>(<em>a</em>,<em>m</em>∈<em>Z</em>)从理论上来说， <strong>a</strong>、<strong>b</strong>、<strong>m</strong>取不要太接近2的幂或10的幂的数会更好(同理前面简单取余的哈希函数里的 <strong>m</strong> 也一样)，冲突率更小，有兴趣的可以上网找找相关证明，这里之间简单说一下如果 <strong>m</strong> 取偶数，由于一个偶数对偶数取余结果仍然是偶数，这将导致所有的偶数元素只能映射到偶数位置，显然将会导致分布不均匀，容易出现冲突。<br>再来看看下面的乘法映射。<br>H ( k ) &#x3D; ( A ⋅ k  m o d  2 w )  r s h  ( w − r ) H(k) &#x3D; (A·k\ mod\ 2^w)\ rsh\ (w-r)<em>H</em>(<em>k</em>)&#x3D;(<em>A</em>⋅<em>k</em> <em>m<strong>o</strong>d</em> 2<em>w</em>) <em>r<strong>s</strong>h</em> (<em>w</em>−<em>r</em>)其中 <strong>m&#x3D;2r</strong> ，<strong>w</strong> 表示计算机一个字的长度的bit位数，<strong>A</strong> 为奇数，且 <strong>2(w-r) &lt; A &lt; 2w</strong>(A不能太接近2w-r和2w)， <strong>rsh</strong> 指右移运算。<br>这是一个快速的哈希算法，介于编译器对这些二进制运算的优化，有兴趣的查阅相关资料，这里不做过多说明。</p>
<h3 id="摩尔投票"><a href="#摩尔投票" class="headerlink" title="摩尔投票"></a>摩尔投票</h3><p>摩尔投票法：摩尔投票法的核心思想为<strong>对拼消耗</strong>。首先我们考虑最基本的摩尔投票问题，比如找出一组数字序列中出现次数大于总数一半的数字（并且假设这个数字一定存在）。我们可以直接利用反证法证明这样的数字只可能有一个。</p>
<p><strong>Example:</strong></p>
<p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>当然这题也可以直接sort排序然后因为最多的数超过一半长度，所以排序后中间的数一定是最大的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">majorityElement2</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> nums[<span class="number">0</span>],count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count==<span class="number">0</span>)&#123;</span><br><span class="line">                result = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=result)&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>Example:</strong></p>
<p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">solve</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="literal">null</span>||length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> <span class="number">0</span>,count2 = <span class="number">0</span>,result1 = nums[<span class="number">0</span>],result2 = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="comment">//注意顺序逻辑，因为result1和result2一开始已经赋值了</span></span><br><span class="line">            <span class="keyword">if</span> (num==result1)&#123;</span><br><span class="line">                count1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num==result2)&#123;</span><br><span class="line">                count2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count1==<span class="number">0</span>)&#123;</span><br><span class="line">                result1=num;</span><br><span class="line">                count1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count2==<span class="number">0</span>)&#123;</span><br><span class="line">                result2 = num;</span><br><span class="line">                count2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count1--;</span><br><span class="line">            count2--;</span><br><span class="line">        &#125;</span><br><span class="line">        count1=<span class="number">0</span>;</span><br><span class="line">        count2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result1==nums[i])&#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result2==nums[i])&#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count1&gt;length/<span class="number">3</span>)&#123;</span><br><span class="line">            list.add(result1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count2&gt;length/<span class="number">3</span>)&#123;</span><br><span class="line">            list.add(result2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="双指针技巧"><a href="#双指针技巧" class="headerlink" title="双指针技巧"></a>双指针技巧</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span></span><br><span class="line"><span class="comment">请注意 ，必须在不复制数组的情况下原地对数组进行操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*1、定义两个指针i和k，初始化i = 0，k = 0。</span></span><br><span class="line"><span class="comment">    2、i指针向后移动，遍整个nums数组，如果 nums[i] != 0，也就是说遇到了非0元素，此时我们就将nums[i]元素放置到nums[k]位置</span></span><br><span class="line"><span class="comment">    ，同时k++后一位。</span></span><br><span class="line"><span class="comment">    3、最后将k位置之后的元素都赋值为0。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">moveZeroes1</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[k++]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k&lt;length)&#123;</span><br><span class="line">            nums[k++]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k </span></span><br><span class="line"><span class="comment">，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">你返回所有和为 0 且不重复的三元组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：答案中不可以包含重复的三元组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：nums = [-1,0,1,2,-1,-4]</span></span><br><span class="line"><span class="comment">输出：[[-1,-1,2],[-1,0,1]]</span></span><br><span class="line"><span class="comment">解释：</span></span><br><span class="line"><span class="comment">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span></span><br><span class="line"><span class="comment">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span></span><br><span class="line"><span class="comment">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span></span><br><span class="line"><span class="comment">注意，输出的顺序和三元组的顺序并不重要。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//如果length不大于三不会有三元组</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组用Arrays.sort()排序，List用Collections.sort()排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">//当第一个数大于0，最后一个数为整数且是最大的，中间的数为多少三个数加起来都不会为0</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i=0时存在只有三个0的情况，这种情况满足，右边条件是去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//left为中间加数，i为左边加数，right为右边加数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (total == <span class="number">0</span>) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    list.add(nums[left]);</span><br><span class="line">                    list.add(nums[right]);</span><br><span class="line">                    result.add(list);</span><br><span class="line">                    <span class="comment">//下面两个while和left++，right--都是去重后得到正确的数</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>









<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>####Floyd判圈算法（龟兔赛跑算法）</p>
<ul>
<li><strong>可以在有限<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%8A%B6%E6%80%81%E6%9C%BA&spm=1001.2101.3001.7020">状态机</a>、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。</strong></li>
</ul>
<ol>
<li>判断链表上是否存在环</li>
</ol>
<p>设两个指针<code>t</code>和<code>h</code>已不同步伐（<code>t</code>一步<code>h</code>两步）从起点出发：如果快指针到达了链表尾部，两者都没相遇，则没有环。如果两个指针相遇，则有环。（快2步相当于快的走两圈，慢的走一圈，快的走一圈没有终点就会再走一圈跟慢的相遇）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle1</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>求链表环的起点</li>
</ol>
<p>两个指针相遇，设相遇点为<code>M</code>，让<code>h</code>指针留在<code>M</code>点，<code>t</code>指针回到原点<code>head</code>，两个指针同时已每次一步的步伐前进，再次相遇时即为环的起点。</p>
<ol start="3">
<li>链表环的长度</li>
</ol>
<p>两个指针相遇，设相遇点为<code>M</code>，让<code>h</code>指针留在<code>M</code>点，<code>t</code>指针继续前进，每次一步。再次到达<code>M</code>点时，前进的步数即为环的长度。                        </p>
<h4 id="双指针解决求相交链表问题"><a href="#双指针解决求相交链表问题" class="headerlink" title="双指针解决求相交链表问题"></a>双指针解决求相交链表问题</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/">相交链表 - 相交链表 - 力扣（LeetCode）</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回两个链表相交的节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="翻转链表（逆序输出）"><a href="#翻转链表（逆序输出）" class="headerlink" title="翻转链表（逆序输出）"></a>翻转链表（逆序输出）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无脑list倒序输出即可,借助空间了</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">result</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(result);</span><br><span class="line">            result = result.next;</span><br><span class="line">        &#125;</span><br><span class="line">        result = list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">        head = result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result.next = list.get(i);</span><br><span class="line">            result = result.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意一开始节点的next为第二个节点，倒序后原第一个节点next为null才对</span></span><br><span class="line">        result.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其实完全没必要借助list，可以用一个节点保存前一个，遍历到下一个的时候把next转为上一个（迭代）</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList1</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">now</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> now.next;</span><br><span class="line">            now.next = pre;</span><br><span class="line">            pre = now;</span><br><span class="line">            now = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h4 id="判断是否是回文链表"><a href="#判断是否是回文链表" class="headerlink" title="判断是否是回文链表"></a>判断是否是回文链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先把链表的值全部复制到list判断    </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">now</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(now.val);</span><br><span class="line">            now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Objects.equals(list.get(left), list.get(right))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>









<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>关于树的几个术语：</strong> <strong>节点</strong>，<strong>根节点</strong>，<strong>父节点</strong>，<strong>子节点</strong>，<strong>叶子节点</strong>，<strong>节点的权（节点值）</strong>，<strong>路径（从root找到该节点的路线）</strong>，<strong>层</strong>，<strong>子树</strong>，<strong>树的高度（最大层数）</strong>，<strong>森林（多棵子树构成森林）</strong></p>
<p><strong>二叉树：</strong> 每个节点<strong>最多</strong>只有两个子节点，分为左子节点和右子节点</p>
<p><strong>满二叉树：</strong> 如果一棵二叉树的叶子节点都在最后一层，且节点总数为2^n-1，n为层数</p>
<p><strong>完全二叉树：</strong> 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称这为完全二叉树</p>
<p>**二叉查找树:*<em>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</em>判断一棵二叉树是不是二叉搜索树用递归写法（遍历传参包括当前允许最小值和最大值和当前判断节点，如果不在允许范围就返回false，然后递归左右子树，遍历传参更改范围值即可，递归左子树更改最大值，递归右子树更改最小值，只能说设计很巧妙）。*</p>
<p><strong>关于二叉树代码（有备注）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ShuJuJieGou;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="comment">//创建二叉树</span></span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建需要的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>, <span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>, <span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置节点的关系，二叉树一般是遍历创建，这里是测试就手动创建了，主要看三中遍历</span></span><br><span class="line">        root.setLeft(node1);</span><br><span class="line">        root.setRight(node2);</span><br><span class="line">        node2.setRight(node3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);<span class="comment">//1 2 3 4</span></span><br><span class="line">        binaryTree.preOrder1();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        binaryTree.preOrder2();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历：&quot;</span>);<span class="comment">//2 1 3 4</span></span><br><span class="line">        binaryTree.midOrder1();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        binaryTree.midOrder2();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历：&quot;</span>);<span class="comment">//2 4 3 1</span></span><br><span class="line">        binaryTree.postOrder1();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        binaryTree.postOrder2();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;层次遍历：&quot;</span>);<span class="comment">//1 2 3 4</span></span><br><span class="line">        binaryTree.floorOrder();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;树的深度：&quot;</span>);</span><br><span class="line">        binaryTree.getDeep1();</span><br><span class="line">        binaryTree.getDeep2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="comment">//只要有根节点就可以进行遍历</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个数的root节点是Node类型，带有Node类型的方法，也就是说只要把root确定就可以开始遍历</span></span><br><span class="line">    <span class="comment">/*递归*/</span></span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不为空才调用方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder1();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrder1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不为空才调用方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.midOrder1();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不为空才调用方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder1();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个数的root节点是Node类型，带有Node类型的方法，也就是说只要把root确定就可以开始遍历</span></span><br><span class="line">    <span class="comment">/*递归*/</span></span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不为空才调用方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrder2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不为空才调用方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.midOrder2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不为空才调用方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*层次遍历*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floorOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.floorOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前二叉树为空，不能进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*求树的最大深度*/</span></span><br><span class="line">    <span class="comment">//层次遍历基础上演变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeep1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.root.getDeep1());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归求解子树最大深度加1就是整棵树的最大深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDeep2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.root.getDeep2(<span class="built_in">this</span>.root));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//不构造left和right，让左右节点默认为空,当然也可以构建，这样子就不需要left和right的get和set方法了，都一样其实</span></span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(Node left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(Node right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> + <span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*递归写法*/</span></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//能进这个方法说明这个节点不为空</span></span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrder1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.midOrder1();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.midOrder1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.postOrder1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.postOrder1();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*迭代写法，借助栈*/</span></span><br><span class="line">    <span class="comment">//前序遍历,直接写法虽然简单，但为了统一还是用两个while这种吧，方便记忆，不过感觉都行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder2</span><span class="params">()</span> &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*        stack.push(this);</span></span><br><span class="line"><span class="comment">        while (!stack.empty())&#123;</span></span><br><span class="line"><span class="comment">            Node node = stack.pop();</span></span><br><span class="line"><span class="comment">            System.out.format(&quot;%d %s\n&quot;,node.getId(),node.getName());</span></span><br><span class="line"><span class="comment">            //栈先进后出，为了让左孩子先出来就得让左孩子后入栈</span></span><br><span class="line"><span class="comment">            if (node.right!=null)&#123;</span></span><br><span class="line"><span class="comment">                stack.push(node.right);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if (node.left!=null)&#123;</span></span><br><span class="line"><span class="comment">                stack.push(node.left);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> || !stack.empty()) &#123;</span><br><span class="line">            <span class="comment">//这里输出过的节点要保存在栈中，因为还要回溯回来得到它的右节点，可以先得到它但不输出直接通过它拿到右节点</span></span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.format(<span class="string">&quot;%d %s\n&quot;</span>, node.getId(), node.getName());</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左边输出完了要回溯右边，结束一次循环，换一棵子树</span></span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrder2</span><span class="params">()</span> &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> || !stack.empty()) &#123;</span><br><span class="line">            <span class="comment">//每次都把最左边的节点放在最后</span></span><br><span class="line">            <span class="comment">//节点不为空时，把左子树的所有结点都入栈，因为栈是后进先出的，所以最后一个入栈的一定是当前二叉树左子树的最后一个结点</span></span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            System.out.format(<span class="string">&quot;%d %s\n&quot;</span>, node.getId(), node.getName());</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder2</span><span class="params">()</span> &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//pre代表上一次已经处理完的节点</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> || !stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="literal">null</span> || node.right == pre) &#123;</span><br><span class="line">                <span class="comment">//此时右边树已经处理完，可以输出这个节点了</span></span><br><span class="line">                System.out.format(<span class="string">&quot;%d %s\n&quot;</span>, node.getId(), node.getName());</span><br><span class="line">                pre = node;<span class="comment">//node此时为处理完的节点</span></span><br><span class="line">                node = <span class="literal">null</span>;<span class="comment">//node处理完了要处理其他子树了，把node变成null，去获取栈里面上个节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明这个节点右边有树要处理，把这个节点存起来先，且这个节点没有左树了，因为一开始一路向左，</span></span><br><span class="line">               <span class="comment">//这个节点是一棵树最左边那个</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*层次遍历*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">floorOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            node = queue.poll();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*求树的深度*/</span></span><br><span class="line">    <span class="comment">//在层次遍历的基础上求树的最大深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDeep1</span><span class="params">()</span> &#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//next队列是存放下一层节点的，每存一层count++最后就可以根据count的数值知道树的深度</span></span><br><span class="line">            Queue&lt;Node&gt; next = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//能进入循环说明存当前这层数据的队列不为空，层数+1</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//队列被一直抛出，长度在减少，如果用队列长度判断是否结束会出错，可以一开始作为</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    next.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    next.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                queue = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种求解深度的方法是得到最长的左右子数的深度加1即可，递归实现，深度更快</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDeep2</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//判断传入的这个节点是否为空，为空返回0，不为空继续求这个节点的子树的深度</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(getDeep2(node.left), getDeep2(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历按照层添加节点值到list</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue_now = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue_now.add(root);</span><br><span class="line">            <span class="keyword">while</span> (!queue_now.isEmpty()) &#123;</span><br><span class="line">                Queue&lt;TreeNode&gt; queue_next = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> queue_now.size();</span><br><span class="line">                <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue_now.poll();</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                        queue_next.add(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                        queue_next.add(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    num--;</span><br><span class="line">                &#125;</span><br><span class="line">                queue_now = queue_next;</span><br><span class="line">                result.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="动态规划DP"><a href="#动态规划DP" class="headerlink" title="动态规划DP"></a>动态规划DP</h3><h4 id="首先认识备忘录方法"><a href="#首先认识备忘录方法" class="headerlink" title="首先认识备忘录方法"></a>首先认识备忘录方法</h4><h4 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以多建一个数组用来保存k的位置，也就是断开的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DP_Solve</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从1开始填</span></span><br><span class="line">    <span class="type">int</span> target[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//这里可以一开始初始斜对角为0也可以后面填充的时候再添加0</span></span><br><span class="line"><span class="comment">//    for (int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">//        target[i][i]=0;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                target[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            target[i][j] = target[i][i] + target[i + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[i] * p[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                <span class="type">int</span> temp = target[i][k] + target[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j];</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; target[i][j]) &#123;</span><br><span class="line">                    target[i][j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">DP_Solve</span>(p, n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="最长公共子序列，最长公共子串"><a href="#最长公共子序列，最长公共子串" class="headerlink" title="最长公共子序列，最长公共子串"></a>最长公共子序列，最长公共子串</h4><ul>
<li>子串是连在一起的数字，而子序列是可以断开的</li>
</ul>
<p>​		<code>ababc</code>和<code>cbaab</code>最长公共子串为2，而最长子序列为3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最长子序列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LENGTH = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归公式(target[i][j]表示第一个串长度为i,第二个串长度为j时最长子序列长度),i=1,j=1开始填表</span></span><br><span class="line"><span class="comment"> * 两个串最后一个值相等就相当于看前面n-1个子串最长子串值就是数组的值加1,否则就是第一个串减1长度保存的值或者第二个串减1长度保存的值</span></span><br><span class="line"><span class="comment"> * 当i=0时整一行为0,当j=0时整一列为0,递归先添加边界值,斜边从小到大添加</span></span><br><span class="line"><span class="comment"> * 当string1[i-1]=string2[j-1]时(i和j表示长度),target[i][j]=target[i-1][j-1]+1</span></span><br><span class="line"><span class="comment"> * 否则target[i][j] = max(target[i - 1][j], target[i][j - 1])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DP_Solve</span><span class="params">(string string1, string string2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> target[LENGTH][LENGTH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= string1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= string2.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (string1[i - <span class="number">1</span>] == string2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                target[i][j] = target[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[i][j] = <span class="built_in">max</span>(target[i - <span class="number">1</span>][j], target[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[string1.<span class="built_in">size</span>()][string2.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string string1, string2;</span><br><span class="line">    cin &gt;&gt; string1 &gt;&gt; string2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">DP_Solve</span>(string1, string2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最长子串，可以用来优化前面的最长子序列，空间上更合理</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归公式(target[i][j]表示第一个串下标为i,第二个串下标为j时最长子序列长度),i=0,j=0开始填表</span></span><br><span class="line"><span class="comment"> * 两个串最后一个值相等就相当于看前面n-1个子串最长子串值就是数组的值加1,否则就是0</span></span><br><span class="line"><span class="comment"> * 一开始把整个表初始化为0</span></span><br><span class="line"><span class="comment"> * 当string1[i]=string2[j]且i！=0,j!=0时(i和j表示下标),target[i][j]=target[i-1][j-1]+1</span></span><br><span class="line"><span class="comment"> * 当string1[i]=string2[j]且i和j有0时时(i和j表示下标),target[i][j]=1</span></span><br><span class="line"><span class="comment"> * 否则target[i][j] = 0*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DP_Solve</span><span class="params">(string string1, string string2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length1 = string1.<span class="built_in">size</span>(), length2 = string2.<span class="built_in">size</span>(), max = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> **target = <span class="keyword">new</span> <span class="type">int</span> *[length1];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length1; ++i) &#123;</span><br><span class="line">        target[i] = <span class="keyword">new</span> <span class="type">int</span>[length2]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length1; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length2; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (string1[i] == string2[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) &#123;</span><br><span class="line">                    target[i][j] = target[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    target[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (target[i][j] &gt; max) &#123;</span><br><span class="line">                    max = target[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string string1, string2;</span><br><span class="line">    cin &gt;&gt; string1 &gt;&gt; string2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">DP_Solve</span>(string1, string2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h4><p>给定n(n&lt;&#x3D;100)种物品和一个背包。物品i的重量是wi，价值为vi，背包的容量为C(C&lt;&#x3D;1000)。问:应如何选择装入背包中的物品，使得装入背包中物品的总价值最大? 在选择装入背包的物品时，对每种物品i只有两个选择：装入或不装入。不能将物品i装入多次，也不能只装入部分物品i。</p>
<p>输入格式：</p>
<p>共有n+1行输入： 第一行为n值和c值，表示n件物品和背包容量c； 接下来的n行，每行有两个数据，分别表示第i(1≤i≤n)件物品的重量和价值。</p>
<p>输出格式：</p>
<p>输出装入背包中物品的最大总价值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入格式</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="comment">//输出格式</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//有n种物品</span></span><br><span class="line"><span class="type">int</span> c;<span class="comment">//背包容量为n</span></span><br><span class="line"><span class="type">int</span> w[<span class="number">101</span>];<span class="comment">//物品i的重量</span></span><br><span class="line"><span class="type">int</span> v[<span class="number">101</span>];<span class="comment">//物品i的价值</span></span><br><span class="line"><span class="type">int</span> target[<span class="number">101</span>][<span class="number">1001</span>];<span class="comment">/*</span></span><br><span class="line"><span class="comment">保存当前判断到第i个物品且剩余容量为j时最优值*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*(背包能装时，不能装直接跳过)target[i][j]=max(target[i+1][j],target[i+1][j-w[i]]+v[i]);</span></span><br><span class="line"><span class="comment">当只有一个物品时</span></span><br><span class="line"><span class="comment">target[n][j]=v[n];(还能装的时候)</span></span><br><span class="line"><span class="comment">target[n][j]=0(不能装了)*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DP_Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=c;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[n]&gt;j)&#123;</span><br><span class="line">            target[n][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            target[n][j]=v[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&lt;=j)&#123;</span><br><span class="line">                target[i][j]=<span class="built_in">max</span>(target[i+<span class="number">1</span>][j],target[i+<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                target[i][j]=target[i+<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[<span class="number">1</span>][c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">DP_Solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="图最短路问题（弗洛伊德算法）"><a href="#图最短路问题（弗洛伊德算法）" class="headerlink" title="图最短路问题（弗洛伊德算法）"></a>图最短路问题（弗洛伊德算法）</h4><h3 id="回溯算法Backtrack"><a href="#回溯算法Backtrack" class="headerlink" title="回溯算法Backtrack"></a>回溯算法Backtrack</h3><ul>
<li><p><strong>回溯算法有“通用的解题法”之称，回溯实际上是一种试探算法，这种算法跟暴力搜索最大的不同在于，在回溯算法里，是一步一步地小心翼翼地进行向前试探，会对每一步探测到的情况进行评估，如果当前的情况已经无法满足要求，那么就没有必要继续进行下去，也就是说，它可以帮助我们避免走很多的弯路。</strong></p>
</li>
<li><p><strong>回溯算法的特点在于，当出现非法的情况时，算法可以回退到之前的情景，可以是返回一步，有时候甚至可以返回多步，然后再去尝试别的路径和办法。这也就意味着，想要采用回溯算法，就必须保证，每次都有多种尝试的可能。这种以深度优先方式系统搜索问题的算法称为回溯法，适合解组合数较大的问题</strong></p>
</li>
</ul>
<p><strong>步骤</strong></p>
<ul>
<li><strong>定义解空间</strong></li>
</ul>
<p>​		可以通过一维的向量来保存结果和要试的数</p>
<ul>
<li><strong>试解</strong></li>
</ul>
<p>​		试解的这个过程最主要的是要把这些数组织起来，一般是以<strong>解空间树</strong>这种形式组织起来，对于有n个数这棵树就会有n层，每层的这		个值有加进去结果集和不加进去两中情况并且是在上一层各个节点的情况下继续的，这样就形成了一棵能表示所有组合的一棵满二叉		树，只要以<strong>深度优先遍历</strong>整棵树就能得到所有的组合（这个解空间树是不用以一个数据结构搭建出来的）</p>
<p>​		而仅仅知道解空间树还没有用，还需要避免在搜索结果都过程中<strong>避免无效搜索</strong>，这个过程叫<strong>剪枝</strong>，剪枝有<strong>两种方式</strong>，一种是<strong>约束函数</strong>	  （扩展节点时剪去不满足约束的子树），一种是<strong>限界函数</strong>（剪去得不到最优解的子树）</p>
<p>​	解空间树有<strong>三种典型的解空间树</strong>（三种问题种类）</p>
<p>子集树就是每个物品都去看选择与否组成最优解，而排列树是看n个点按照顺序不同有多少种的排列组合</p>
<pre><code>    1. 子集树（0-1背包问题）
    2. 排列树（旅行售货员）
</code></pre>
<p><strong>递归回溯写法模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Backtrack</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="comment">//t表示当前为第几层(深度)</span></span><br><span class="line">    <span class="comment">//if为递归结束条件(t &gt; n即为叶子节点)</span></span><br><span class="line">    <span class="keyword">if</span>(t &gt; n)&#123;</span><br><span class="line">        <span class="built_in">Output</span>(x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//f(n, t)，g(n, t)分别表示扩展结点的子树的起始编号和终止编号，尝试这些解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">f</span>(n, t); i &lt;= <span class="built_in">g</span>(n, t); i++)&#123;</span><br><span class="line">            x[t] = <span class="built_in">h</span>(i);<span class="comment">//h(i)表示第i个可选值</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Constraint</span>(t) &amp;&amp; <span class="built_in">Bound</span>(t))&#123;</span><br><span class="line">                <span class="comment">//Constraint和Bound分别表示约束函数和限界函数</span></span><br><span class="line">                <span class="built_in">Backtrack</span>(t+<span class="number">1</span>);<span class="comment">//通过全局变量了解当前状态知道遍历到是哪个孩子节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="子集树（0-1背包问题）"><a href="#子集树（0-1背包问题）" class="headerlink" title="子集树（0-1背包问题）"></a>子集树（0-1背包问题）</h4><ul>
<li><strong>数据量小时就可以不剪枝，但数据量大就要剪值了</strong></li>
</ul>
<p><strong>无剪枝，只有约束函数(条件)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">good</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//n件物品</span></span><br><span class="line"><span class="type">int</span> c;<span class="comment">//c为背包容量</span></span><br><span class="line"><span class="type">int</span> max_value = <span class="number">-1</span>;<span class="comment">//最大价值</span></span><br><span class="line"><span class="type">int</span> c_temp = <span class="number">0</span>, v_temp = <span class="number">0</span>;<span class="comment">//存当前装入容量和价值</span></span><br><span class="line">good *goods;<span class="comment">//存货物信息</span></span><br><span class="line"><span class="type">bool</span> *result_max;<span class="comment">//保存最优结果时这个点选不选，当到叶子节点时如果最大值被刷新就要更新这个数组</span></span><br><span class="line"><span class="type">bool</span> *visited;<span class="comment">//保存遍历过程中这个点是否选择</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回溯算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Backtrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//t&gt;n表示走到叶子节点了</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v_temp &gt; max_value) &#123;</span><br><span class="line">            max_value = v_temp;</span><br><span class="line">            <span class="comment">//当最大价值被刷新才复制选择结果到最佳选择情况数组，不然就会到叶子节点就复制了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                result_max[i] = visited[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//else这一块代码也可以用一个循环来弄，n从0到1的循环，visited[t]=0表示不放，处理，visited[t]=1表示放，处理</span></span><br><span class="line">        <span class="comment">//选这个点，判断装进去会不会超，会肯定只能不选了，约束函数(条件)</span></span><br><span class="line">        <span class="keyword">if</span> (goods[t].weight + c_temp &lt;= c) &#123;</span><br><span class="line">            c_temp += goods[t].weight;</span><br><span class="line">            v_temp += goods[t].value;</span><br><span class="line">            visited[t] = <span class="literal">true</span>;<span class="comment">//选了它</span></span><br><span class="line">            <span class="built_in">Backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//下面是递归回来，要回溯把选上的值全部不要了</span></span><br><span class="line">            c_temp -= goods[t].weight;</span><br><span class="line">            v_temp -= goods[t].value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不选这个点,那种就直接跳到下一层就可以了</span></span><br><span class="line">        visited[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">Backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    goods = <span class="keyword">new</span> good[n + <span class="number">1</span>];</span><br><span class="line">    result_max = <span class="keyword">new</span> <span class="type">bool</span>[n + <span class="number">1</span>];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">bool</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//从1号下标开始存东西</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; goods[i].weight &gt;&gt; goods[i].value;</span><br><span class="line">        result_max[i] = <span class="literal">false</span>;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; max_value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result_max[i]) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>有剪枝，约束函数(条件)加限界函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">good</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">double</span> unit_price;<span class="comment">//单位价格</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//n件物品</span></span><br><span class="line"><span class="type">int</span> c;<span class="comment">//c为背包容量</span></span><br><span class="line"><span class="type">int</span> max_value = <span class="number">-1</span>;<span class="comment">//最大价值</span></span><br><span class="line"><span class="type">int</span> c_temp = <span class="number">0</span>, v_temp = <span class="number">0</span>;<span class="comment">//存当前装入容量和价值</span></span><br><span class="line">good *goods;<span class="comment">//存货物信息</span></span><br><span class="line"><span class="type">bool</span> *result_max;<span class="comment">//保存最优结果时这个点选不选，当到叶子节点时如果最大值被刷新就要更新这个数组</span></span><br><span class="line"><span class="type">bool</span> *visited;<span class="comment">//保存遍历过程中这个点是否选择</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序规则，单位价值高的在前面</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(good good1, good good2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> good1.unit_price &gt; good2.unit_price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*限界函数，原理其实也很简单，就在一开始按照跟贪心一样的单位价格进行排序，</span></span><br><span class="line"><span class="comment">把剩下的要处理的点里面把单位价格高的物品装进去背包肯定能得到最高的价值，</span></span><br><span class="line"><span class="comment">虽然题目原本是不允许装一部分物品的，但如果最大可能性都比之前保存的最高价值小那肯定不用处理这棵子树了，处理了也是浪费时间*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Bound</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = c_temp;</span><br><span class="line">    <span class="type">double</span> value = v_temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp + goods[i].weight &lt;= c) &#123;</span><br><span class="line">            temp += goods[i].weight;</span><br><span class="line">            value += goods[i].value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value += (c - temp) * goods[i].unit_price;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; max_value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回溯算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Backtrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//t&gt;n表示走到叶子节点了</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v_temp &gt; max_value) &#123;</span><br><span class="line">            max_value = v_temp;</span><br><span class="line">            <span class="comment">//当最大价值被刷新才复制选择结果到最佳选择情况数组，不然就会到叶子节点就复制了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                result_max[i] = visited[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//else这一块代码也可以用一个循环来弄，n从0到1的循环，visited[t]=0表示不放，处理，visited[t]=1表示放，处理</span></span><br><span class="line">        <span class="comment">//选这个点，判断装进去会不会超，会肯定只能不选了，约束函数(条件)</span></span><br><span class="line">        <span class="keyword">if</span> (goods[t].weight + c_temp &lt;= c) &#123;</span><br><span class="line">            c_temp += goods[t].weight;</span><br><span class="line">            v_temp += goods[t].value;</span><br><span class="line">            visited[t] = <span class="literal">true</span>;<span class="comment">//选了它</span></span><br><span class="line">            <span class="built_in">Backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//下面是递归回来，要回溯把选上的值全部不要了</span></span><br><span class="line">            c_temp -= goods[t].weight;</span><br><span class="line">            v_temp -= goods[t].value;</span><br><span class="line">            visited[t] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不选这个点,那种就直接跳到下一层就可以了,限界函数Bound</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Bound</span>(t + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">Backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    goods = <span class="keyword">new</span> good[n + <span class="number">1</span>];</span><br><span class="line">    result_max = <span class="keyword">new</span> <span class="type">bool</span>[n + <span class="number">1</span>];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">bool</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; goods[i].weight &gt;&gt; goods[i].value;</span><br><span class="line">        goods[i].unit_price = (<span class="type">double</span>) goods[i].value / (<span class="type">double</span>) goods[i].weight;</span><br><span class="line">        result_max[i] = <span class="literal">false</span>;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(goods + <span class="number">1</span>, goods + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="built_in">Backtrack</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; max_value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result_max[i]) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>####排列树（旅行售货员）</p>
<p>某售货员要到若干城市去推销商品，已知各城市之间的路程(或旅费)。他要选定一条从驻地出发，经过每个城市一遍，最后回到驻地的路线，使总的路程（或总旅费）最小。</p>
<p><strong>输入格式:</strong></p>
<p>第一行为城市数n</p>
<p>下面n行n列给出一个完全有向图，如 i 行 j 列表示第 i 个城市到第 j 个城市的距离。</p>
<p><strong>输出格式:</strong></p>
<p>一个数字，表示最短路程长度。</p>
<p><strong>输入样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 2 1</span><br><span class="line">1 0 2</span><br><span class="line">2 1 0</span><br></pre></td></tr></table></figure>

<p><strong>输出样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>理解：</strong></p>
<p>这道题和前面的子集树最明显的不同就是子集树主要是针对某个点的选择与不选，是一颗满二叉树，但这题就不是了，这道题要知道的是n个点的排列组合（这里假设都是从点1出发）</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//城市点的个数</span></span><br><span class="line"><span class="type">int</span> *best;<span class="comment">//记录最短路径的排列</span></span><br><span class="line"><span class="type">int</span> dis_min = <span class="number">0x3f3f3f3f</span>;<span class="comment">//记录最短路径的长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *dis;<span class="comment">//记录遍历过程中保存的节点和路径信息</span></span><br><span class="line"><span class="type">int</span> *vist;<span class="comment">//记录遍历过的信息</span></span><br><span class="line"><span class="type">int</span> dis_temp = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> **g;<span class="comment">//保存图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归到第t层</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) &#123;</span><br><span class="line">        <span class="comment">//注意这里是g[dis[t-1]][1]或者g[dis[n]][1],最后一个点，而不是直接n</span></span><br><span class="line">        <span class="keyword">if</span> (dis_temp + g[dis[t<span class="number">-1</span>]][<span class="number">1</span>] &lt; dis_min) &#123;</span><br><span class="line">            dis_min = dis_temp + g[dis[t<span class="number">-1</span>]][<span class="number">1</span>];<span class="comment">//判断条件和这一句可以写g[dis[n]][1]的，一样的，dis是保存这次遍历的路径信息的，</span></span><br><span class="line">            <span class="comment">// 可以通过dis[t]确认当前添加到点，那么dis[t-1]自然就是上次添加到点了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                best[i] = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代码初始化后都以第一个点为起始点，并把visit[1]置为1了，这个循环是按照题目来的，把每个点都当做第二个点为开始遍历点，</span></span><br><span class="line">    <span class="comment">//遍历到就把visit中对应的点置为1即可，在递归中就不会再查找找过的点，这样子就能遍历完所有的点，最后回溯即可换另一个点进行遍历了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vist[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            vist[i] = <span class="number">1</span>;</span><br><span class="line">            dis[t] = i;</span><br><span class="line">            dis_temp += g[dis[t<span class="number">-1</span>]][i];</span><br><span class="line">            <span class="comment">//约束函数</span></span><br><span class="line">            <span class="keyword">if</span> (dis_temp &lt; dis_min) &#123;</span><br><span class="line">                <span class="built_in">backTrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            vist[i] = <span class="number">0</span>;</span><br><span class="line">            dis_temp -= g[dis[t - <span class="number">1</span>]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    g = <span class="keyword">new</span> <span class="type">int</span> *[n + <span class="number">1</span>];<span class="comment">//从1开始</span></span><br><span class="line">    best = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    dis = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    vist = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        g[i] = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    best[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    vist[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//这个很容易忘记</span></span><br><span class="line">    <span class="built_in">backTrack</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//    for (int i = 1; i &lt;= n; ++i) &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; best[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    cout &lt;&lt; dis_min &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="k叉树（n后问题）"><a href="#k叉树（n后问题）" class="headerlink" title="k叉树（n后问题）"></a>k叉树（n后问题）</h4><p>在n×n格的棋盘上放置彼此不受攻击的n个皇后。按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n后问题等价于在n×n格的棋盘上放置n个皇后，任何2个皇后不放在同一行或同一列或同一斜线上</p>
<p><strong>输入格式:</strong></p>
<p>一个数字n</p>
<p><strong>输出格式:</strong></p>
<p>按照深度优先输出所有可行的解</p>
<p><strong>输入样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p><strong>输出样例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 4 1 3 </span><br><span class="line">3 1 4 2 </span><br></pre></td></tr></table></figure>

<p><strong>理解</strong></p>
<p>对于每一行都可以把棋子放在任何一个地方，这样可以构成一棵n叉树</p>
<p>我们从第一行开始放皇后，每一行只能放一个皇后，这样就不用考虑行会冲突了，而列就可以通过路径数组（result数组）来判断前面有没有放过这一列，斜线的话就可以根据三角形性质，当两个点的横坐标的相差（就是绝对值）和纵坐标相差相等就在一条斜线上来判断（这两个条件构成约束函数），当到达最后一行直接输出路径即可</p>
<p>其实也可以用求排列的思想来实现，行和列都不同，那所有点就是一个排列，最后判断是不是所有点都不在斜线上即可</p>
<p><strong>代码:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/30.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//有几个皇后</span></span><br><span class="line"><span class="type">int</span> *result;<span class="comment">//保存结果，下标从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断本次这一行把这个数字放进能不能成立</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; t; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((result[i] == result[t]) || (<span class="built_in">abs</span>(result[t] - result[i]) == <span class="built_in">abs</span>(t - i))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//n叉树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">//一行一行放的，一行放一个，所以不用考虑有行冲突</span></span><br><span class="line">        result[t] = i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(t)) &#123;</span><br><span class="line">            <span class="built_in">backTrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//result[i]表示第i行放在哪一列</span></span><br><span class="line">    result = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">backTrack</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二维递归回溯（求解数独）"><a href="#二维递归回溯（求解数独）" class="headerlink" title="二维递归回溯（求解数独）"></a>二维递归回溯（求解数独）</h4><ul>
<li><strong>本身也是k叉树，但是比n后问题多一个维度，因为n后问题每次递归其实就是完成一行，递归可以看成是行遍历，而递归中填写这一行是遍历这一行中每个点，可以看成是列遍历，对于每个点就是简单的放与不放皇后（一个循环就可以解决），但数独还要看是填哪个数字</strong></li>
</ul>
<p>返回值为bool类型，因为其实只要得到一个数独的解就可以返回了</p>
<p>终止条件其实也在下面的处理逻辑中给包含了，只有放满才会返回true，否则就返回false，一定会有返回值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断数独填写过程中这个数字能不能填</span></span><br><span class="line"><span class="comment">//line第一行,row第几列</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isWriteAvailable</span><span class="params">(<span class="type">int</span> line, <span class="type">int</span> row, <span class="type">int</span> **target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//同列不能有相同数字，i==line就是同个格子来的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW_NUM; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != line &amp;&amp; target[i][row] == target[line][row]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同行不能有相同数字，j==row就是同个格子来的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= ROW_NUM; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j != row &amp;&amp; target[line][j] == target[line][row]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//规定的九个格子里面数字各不相同,可以找到这个格子所在的块的左上角这个坐标</span></span><br><span class="line">    <span class="comment">//根据这个格子是第几行求出对于九个格子其实点的行坐标</span></span><br><span class="line">    <span class="type">int</span> temp1 = line / <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> temp2 = line % <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> start1;</span><br><span class="line">    <span class="keyword">if</span> (temp2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        start1 = temp1 * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start1 = (temp1 - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据这个格子是第几列求出对于九个格子其实点的列坐标</span></span><br><span class="line">    <span class="type">int</span> temp3 = row / <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> temp4 = row % <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> start2;</span><br><span class="line">    <span class="keyword">if</span> (temp4 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        start2 = temp3 * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start2 = (temp3 - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始判断所在块是否符合,不在目标格子并且周围的数字跟它相同就不能放进去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start1; i &lt; start1 + <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = start2; j &lt; start2 + <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != line &amp;&amp; j != row &amp;&amp; target[i][j] == target[line][row]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面条件都满足就走到这里，返回true即可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求解算法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solveSudoku</span><span class="params">(<span class="type">int</span> **target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两层循环去找哪个格子未填数字就去填这个格子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ROW_NUM; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= ROW_NUM; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//填数字,1到9</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= ROW_NUM; ++k) &#123;</span><br><span class="line">                    target[i][j] = k;<span class="comment">//先填，填完去判断填进去成不成立，成立递归</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isWriteAvailable</span>(i, j, target)) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">solveSudoku</span>(target))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果下一层没有得到结果就要回到这里，那么就找另一个数字去填看能不能成功，如果下一层成功就直接return了，走不到这里</span></span><br><span class="line">                    target[i][j] = <span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有格子能填完直接返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="一些例题（这里是很典型能看出区别的）"><a href="#一些例题（这里是很典型能看出区别的）" class="headerlink" title="一些例题（这里是很典型能看出区别的）"></a>一些例题（这里是很典型能看出区别的）</h4><p><strong>子集合问题（子集树）</strong></p>
<p>设集合S&#x3D;{x1,x2,…,xn}是一个正整数集合，c是一个正整数，子集和问题判定是否存在S的一个子集S1，使S1中的元素之和为c。试设计一个解子集和问题的回溯法，并输出利用回溯法在搜索树（按输入顺序建立）中找到的第一个解。</p>
<p><strong>输入格式:</strong></p>
<p>输入数据第1行有2个正整数n和c，n表示S的大小，c是子集和的目标值。接下来的1行中，有n个正整数，表示集合S中的元素。<br>是子集和的目标值。接下来的1 行中，有n个正整数，表示集合S中的元素。</p>
<p><strong>输出格式:</strong></p>
<p>输出利用回溯法找到的第一个解，以空格分隔，最后一个输出的后面有空格。当问题无解时，输出“No Solution!”。</p>
<p><strong>输入样例:</strong></p>
<p>在这里给出一组输入。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 10</span><br><span class="line">2 2 6 5 4</span><br></pre></td></tr></table></figure>

<p><strong>输出样例:</strong></p>
<p>在这里给出相应的输出。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 2 6 </span><br></pre></td></tr></table></figure>

<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/19.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//集合元素个数</span></span><br><span class="line"><span class="type">int</span> target;<span class="comment">//目标子集合的合</span></span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *ints;<span class="comment">//保存集合</span></span><br><span class="line"><span class="type">bool</span> *result;<span class="comment">//保存结果</span></span><br><span class="line"><span class="type">bool</span> *visited;<span class="comment">//保存递归过程中的状态</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历右子树也就是不选时如果所有值加起来都没有目标值大就没必要递归了，限界函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Bound</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt; n; ++i) &#123;</span><br><span class="line">        sum += ints[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Backtrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp == target) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            result[i] = visited[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//约束函数</span></span><br><span class="line">    <span class="keyword">if</span> (t &lt; n &amp;&amp; !flag &amp;&amp; temp &lt; target) &#123;</span><br><span class="line">        temp += ints[t];</span><br><span class="line">        visited[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">Backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        temp -= ints[t];</span><br><span class="line">        visited[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Bound</span>(t + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">Backtrack</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; target;</span><br><span class="line">    ints = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    result = <span class="keyword">new</span> <span class="type">bool</span>[n];</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">bool</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; ints[i];</span><br><span class="line">        result[i] = <span class="literal">false</span>;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Backtrack</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result[i]) &#123;</span><br><span class="line">                cout &lt;&lt; ints[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No Solution!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>全排列</strong></p>
<p>请编写程序输出前<em>n</em>个正整数的全排列（<em>n</em>&lt;10），并通过9个测试用例（即<em>n</em>从1到9）观察<em>n</em>逐步增大时程序的运行时间。</p>
<p><strong>输入格式:</strong></p>
<p>输入给出正整数<em>n</em>（&lt;10）。</p>
<p><strong>输出格式:</strong></p>
<p>输出1到<em>n</em>的全排列。每种排列占一行，数字间无空格。排列的输出顺序为字典序，即序列<em>a</em>1,<em>a</em>2,⋯,<em>a**n</em>排在序列<em>b</em>1,<em>b</em>2,⋯,<em>b**n</em>之前，如果存在<em>k</em>使得<em>a</em>1&#x3D;<em>b</em>1,⋯,<em>a**k</em>&#x3D;<em>b**k</em> 并且 <em>a**k</em>+1&lt;<em>b**k</em>+1。</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">132</span><br><span class="line">213</span><br><span class="line">231</span><br><span class="line">312</span><br><span class="line">321</span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/11/23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//从1到n全排列</span></span><br><span class="line"><span class="type">int</span> *visited;<span class="comment">//标记是否遍历过，这题就从大到小假设一开始就进入一个点然后递归遍历其他点即可</span></span><br><span class="line"><span class="type">int</span> *temp;<span class="comment">//保存遍历过程结果</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;<span class="comment">//标记要不要输出回车的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历到最后一层，直接输出即可</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是最后一层就是遍历其他点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            temp[t] = i;</span><br><span class="line">            <span class="built_in">backTrack</span>(t + <span class="number">1</span>);</span><br><span class="line">            visited[i] = <span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    temp = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">        temp[<span class="number">1</span>] = i;</span><br><span class="line">        <span class="built_in">backTrack</span>(<span class="number">2</span>);</span><br><span class="line">        visited[i] = <span class="number">0</span>;<span class="comment">//这轮结束把一开始的点改为未访问，下一轮换点为初始点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="回溯法总结"><a href="#回溯法总结" class="headerlink" title="回溯法总结"></a>回溯法总结</h4><ul>
<li><p>求子集：从n个元素的集合S中找出满足某个性质的<strong>子集</strong>。<strong>（每个节点都是可选或者不选的）</strong>其搜索树称为子集树，是典型的二叉树，通常有<code>2^n</code>个叶子节点，遍历时间为O（2^n）</p>
</li>
<li><p>求排列：n个节点的<strong>排列组合</strong>。<strong>（每个节点都包括在内，顺序不同罢了）</strong>其中搜索树称为排列树，通常有<code>n!</code>个叶子节点，因此遍历排列树需要时间为O（n!），这个算法有两种书写方法，还是习惯用visit数组保存遍历过节点信息的方法，<strong>都是从第二层开始遍历</strong></p>
</li>
<li><p>求路径：只需要找到一条路径便可以得到解。设每个状态有k个后继，其搜索树为k叉树，其节点总数为<code>k^(n+1)-1</code>，遍历的时间为O（k^n）,<strong>每层都可以选n个点中的任意一个</strong>，以n后问题来看，其实也可以用求排列的思想来实现，行和列都不同，那所有点就是一个排列，最后判断是不是所有点都不在斜线上即可</p>
</li>
</ul>
<h3 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h3><p>相较于回溯法就是广度优先遍历</p>
<ul>
<li><p><strong>队列式分支限界法</strong></p>
</li>
<li><p><strong>优先队列式分支限界法</strong></p>
</li>
</ul>
<h4 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h4><p><strong>普通队列</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by GTR on 2022/12/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">good</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">double</span> average;</span><br><span class="line">&#125;;<span class="comment">//物品信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp_value;<span class="comment">//当前价值</span></span><br><span class="line">    <span class="type">int</span> remain;<span class="comment">//剩余</span></span><br><span class="line">    <span class="type">int</span> deep;<span class="comment">//层数</span></span><br><span class="line">&#125;;<span class="comment">//扩展节点</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//物品个数</span></span><br><span class="line"><span class="type">int</span> c;<span class="comment">//背包容量</span></span><br><span class="line">good *goods;<span class="comment">//保存物品信息</span></span><br><span class="line"><span class="type">int</span> max_value = <span class="number">0</span>;<span class="comment">//最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sort排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(good good1, good good2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> good1.average &gt; good2.average;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减枝，限界函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bound</span><span class="params">(node *node)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = node-&gt;temp_value;</span><br><span class="line">    <span class="type">int</span> temp = node-&gt;remain;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = node-&gt;deep + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (goods[i].weight &lt;= temp) &#123;</span><br><span class="line">            temp -= goods[i].weight;</span><br><span class="line">            sum += goods[i].value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += goods[i].average * temp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; max_value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分支限界法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(node *head)</span> </span>&#123;</span><br><span class="line">    queue&lt;node *&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node *temp = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        max_value = <span class="built_in">max</span>(max_value, temp-&gt;temp_value);</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;deep &lt; n &amp;&amp; goods[temp-&gt;deep + <span class="number">1</span>].weight &lt;= temp-&gt;remain) &#123;</span><br><span class="line">            node *left_child = <span class="keyword">new</span> node;</span><br><span class="line">            left_child-&gt;deep = temp-&gt;deep + <span class="number">1</span>;</span><br><span class="line">            left_child-&gt;remain = temp-&gt;remain - goods[left_child-&gt;deep].weight;</span><br><span class="line">            left_child-&gt;temp_value = temp-&gt;temp_value + goods[left_child-&gt;deep].value;</span><br><span class="line">            queue.<span class="built_in">push</span>(left_child);</span><br><span class="line">            max_value = <span class="built_in">max</span>(max_value, left_child-&gt;temp_value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;deep &lt; n &amp;&amp; <span class="built_in">bound</span>(temp)) &#123;</span><br><span class="line">            node *right_child = <span class="keyword">new</span> node;</span><br><span class="line">            right_child-&gt;deep = temp-&gt;deep + <span class="number">1</span>;</span><br><span class="line">            right_child-&gt;remain = temp-&gt;remain;</span><br><span class="line">            right_child-&gt;temp_value = temp-&gt;temp_value;</span><br><span class="line">            queue.<span class="built_in">push</span>(right_child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    goods = <span class="keyword">new</span> good[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; goods[i].weight &gt;&gt; goods[i].value;</span><br><span class="line">        goods[i].average = <span class="built_in">double</span>(goods[i].value) / goods[i].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(goods + <span class="number">1</span>, goods + n + <span class="number">1</span>, cmp);</span><br><span class="line">    node *head = <span class="keyword">new</span> node;</span><br><span class="line">    head-&gt;deep = <span class="number">0</span>;</span><br><span class="line">    head-&gt;temp_value = <span class="number">0</span>;</span><br><span class="line">    head-&gt;remain = c;</span><br><span class="line">    <span class="built_in">dfs</span>(head);</span><br><span class="line">    cout &lt;&lt; max_value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="八数码问题八重境界"><a href="#八数码问题八重境界" class="headerlink" title="八数码问题八重境界"></a>八数码问题八重境界</h3><p><strong>境界二（广搜+哈希（康托展开））：</strong></p>
<h3 id="力扣做题遇到技巧总结"><a href="#力扣做题遇到技巧总结" class="headerlink" title="力扣做题遇到技巧总结"></a>力扣做题遇到技巧总结</h3><p>借助前面的数求解当前值，时间为1</p>
<p>338题</p>
<p>如果题目叫尝试空间复杂度为1的话要记录可以借助题目给定范围之外的数字</p>
<p>448题</p>
<h4 id="备注一下"><a href="#备注一下" class="headerlink" title="备注一下"></a>备注一下</h4><p>贪心算法和动态规划有个不同的就是动态规划后面的子问题不会影响前面子问题，但贪心算法就会，比如力扣121很明显最小值会改变并且后面的结果依靠新的最小值，后面的子问题跟前面的就没关系了</p>
<p>11题自己想用贪心写不出来，后面回去看看</p>
<p>79回溯</p>
<p>public <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a> void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</p>
<p>src:源数组;</p>
<p>srcPos:源数组要复制的起始位置;</p>
<p>dest:目的数组;</p>
<p>destPos:目的数组放置的起始位置;</p>
<p>length:复制的长度.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.wuleizhenshang.love">无泪真伤</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.wuleizhenshang.love/2023/11/18/%E7%AE%97%E6%B3%95/">https://www.wuleizhenshang.love/2023/11/18/%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.wuleizhenshang.love" target="_blank">Blog-无泪真伤</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8/">开发常用</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/65587081c458853aef16f416.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/18/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88%E9%80%89%E4%BF%AE%E8%AF%BE%EF%BC%89/" title="自然语言处理（选修课）"><img class="cover" src="https://pic.imgdb.cn/item/65586ff1c458853aef149c7e.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">自然语言处理（选修课）</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/17/GitHub+Hexo+Git/" title="GitHub Pages+Hexo+Git快速搭建个人博客"><img class="cover" src="https://pic.imgdb.cn/item/65597baac458853aef754b7b.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GitHub Pages+Hexo+Git快速搭建个人博客</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/18/maven/" title="Maven的使用"><img class="cover" src="https://pic.imgdb.cn/item/65587027c458853aef156fb1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Maven的使用</div></div></a></div><div><a href="/2024/02/24/Git%EF%BC%88B%E7%AB%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%89/" title="Git（B站学习笔记）"><img class="cover" src="https://pic.imgdb.cn/item/6559956bc458853aefc5409e.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-24</div><div class="title">Git（B站学习笔记）</div></div></a></div><div><a href="/2024/02/24/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Kotlin学习笔记"><img class="cover" src="https://pic.imgdb.cn/item/65d9e5d59f345e8d03230185.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-24</div><div class="title">Kotlin学习笔记</div></div></a></div><div><a href="/2022/02/24/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" title="Android学习笔记"><img class="cover" src="https://pic.imgdb.cn/item/65dd5b1c9f345e8d035100ba.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-24</div><div class="title">Android学习笔记</div></div></a></div><div><a href="/2024/05/19/%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E5%92%8C%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/" title="Android导入项目及环境说明"><img class="cover" src="https://pic.imgdb.cn/item/664a0a9ad9c307b7e97d01c6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-19</div><div class="title">Android导入项目及环境说明</div></div></a></div><div><a href="/2023/11/18/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%80%9F%E6%88%90/" title="神经网络与深度学习速成"><img class="cover" src="https://pic.imgdb.cn/item/6558706bc458853aef16912a.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">神经网络与深度学习速成</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/65582252c458853aeff7c6f5.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">无泪真伤</div><div class="author-info__description">不会爱，不愿爱！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wuleizhenshang"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本人新人一枚！写博客知识记录个人学习经历，有错误请见谅！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%94%B9%E5%86%99%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.1.</span> <span class="toc-text">递归改写迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">分治法（递归）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">汉诺塔问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91"><span class="toc-number">1.2.2.</span> <span class="toc-text">斐波那契</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">二分法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.5.</span> <span class="toc-text">线性时间选择算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.1.</span> <span class="toc-text">活动安排问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E8%BF%9B%E9%98%B6%EF%BC%88%E9%9C%80%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">活动安排进阶（需保存状态）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98%EF%BC%88%E5%80%9F%E5%8A%A9%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">最优合并问题（借助优先队列）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84"><span class="toc-number">1.4.</span> <span class="toc-text">哈希映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8"><span class="toc-number">1.5.</span> <span class="toc-text">摩尔投票</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7"><span class="toc-number">1.6.</span> <span class="toc-text">双指针技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E5%86%B3%E6%B1%82%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.1.</span> <span class="toc-text">双指针解决求相交链表问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E9%80%86%E5%BA%8F%E8%BE%93%E5%87%BA%EF%BC%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">翻转链表（逆序输出）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">判断是否是回文链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.8.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP"><span class="toc-number">1.9.</span> <span class="toc-text">动态规划DP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E8%AE%A4%E8%AF%86%E5%A4%87%E5%BF%98%E5%BD%95%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.1.</span> <span class="toc-text">首先认识备忘录方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.2.</span> <span class="toc-text">矩阵连乘问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%8C%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2"><span class="toc-number">1.9.3.</span> <span class="toc-text">最长公共子序列，最长公共子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.4.</span> <span class="toc-text">0-1背包问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%EF%BC%88%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.9.5.</span> <span class="toc-text">图最短路问题（弗洛伊德算法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95Backtrack"><span class="toc-number">1.10.</span> <span class="toc-text">回溯算法Backtrack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E6%A0%91%EF%BC%880-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">1.10.1.</span> <span class="toc-text">子集树（0-1背包问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#k%E5%8F%89%E6%A0%91%EF%BC%88n%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">1.10.2.</span> <span class="toc-text">k叉树（n后问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%EF%BC%88%E6%B1%82%E8%A7%A3%E6%95%B0%E7%8B%AC%EF%BC%89"><span class="toc-number">1.10.3.</span> <span class="toc-text">二维递归回溯（求解数独）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E4%BE%8B%E9%A2%98%EF%BC%88%E8%BF%99%E9%87%8C%E6%98%AF%E5%BE%88%E5%85%B8%E5%9E%8B%E8%83%BD%E7%9C%8B%E5%87%BA%E5%8C%BA%E5%88%AB%E7%9A%84%EF%BC%89"><span class="toc-number">1.10.4.</span> <span class="toc-text">一些例题（这里是很典型能看出区别的）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.5.</span> <span class="toc-text">回溯法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">分支限界法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85"><span class="toc-number">1.11.1.</span> <span class="toc-text">0-1背包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%E5%85%AB%E9%87%8D%E5%A2%83%E7%95%8C"><span class="toc-number">1.12.</span> <span class="toc-text">八数码问题八重境界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9B%E6%89%A3%E5%81%9A%E9%A2%98%E9%81%87%E5%88%B0%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93"><span class="toc-number">1.13.</span> <span class="toc-text">力扣做题遇到技巧总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8%E4%B8%80%E4%B8%8B"><span class="toc-number">1.13.1.</span> <span class="toc-text">备注一下</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/19/%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E5%92%8C%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/" title="Android导入项目及环境说明"><img src="https://pic.imgdb.cn/item/664a0a9ad9c307b7e97d01c6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android导入项目及环境说明"/></a><div class="content"><a class="title" href="/2024/05/19/%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E5%92%8C%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/" title="Android导入项目及环境说明">Android导入项目及环境说明</a><time datetime="2024-05-19T14:18:00.000Z" title="发表于 2024-05-19 22:18:00">2024-05-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/28/%E5%87%86%E5%A4%87/" title="小白个人Android面试准备"><img src="https://pic.imgdb.cn/item/65df52089f345e8d030edde4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="小白个人Android面试准备"/></a><div class="content"><a class="title" href="/2024/02/28/%E5%87%86%E5%A4%87/" title="小白个人Android面试准备">小白个人Android面试准备</a><time datetime="2024-02-28T15:33:46.000Z" title="发表于 2024-02-28 23:33:46">2024-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/28/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%87%86%E5%A4%87/" title="小白个人面试算法准备"><img src="https://pic.imgdb.cn/item/6602823e9f345e8d03cbcbff.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="小白个人面试算法准备"/></a><div class="content"><a class="title" href="/2024/02/28/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E5%87%86%E5%A4%87/" title="小白个人面试算法准备">小白个人面试算法准备</a><time datetime="2024-02-28T15:33:46.000Z" title="发表于 2024-02-28 23:33:46">2024-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/24/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Kotlin学习笔记"><img src="https://pic.imgdb.cn/item/65d9e5d59f345e8d03230185.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kotlin学习笔记"/></a><div class="content"><a class="title" href="/2024/02/24/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Kotlin学习笔记">Kotlin学习笔记</a><time datetime="2024-02-24T15:29:30.000Z" title="发表于 2024-02-24 23:29:30">2024-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/24/Git%EF%BC%88B%E7%AB%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%89/" title="Git（B站学习笔记）"><img src="https://pic.imgdb.cn/item/6559956bc458853aefc5409e.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git（B站学习笔记）"/></a><div class="content"><a class="title" href="/2024/02/24/Git%EF%BC%88B%E7%AB%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%89/" title="Git（B站学习笔记）">Git（B站学习笔记）</a><time datetime="2024-02-24T12:45:00.000Z" title="发表于 2024-02-24 20:45:00">2024-02-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By 无泪真伤</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog! --by Wuleizhenshang</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false#  open shake (抖動特效);
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>